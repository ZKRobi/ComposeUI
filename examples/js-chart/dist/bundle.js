(function () {
    'use strict';

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    /* *
     *
     *  Namespace
     *
     * */
    /**
     * Shared Highcharts properties.
     * @private
     */
    var Globals;
    (function (Globals) {
        /* *
         *
         *  Constants
         *
         * */
        Globals.SVG_NS = 'http://www.w3.org/2000/svg', Globals.product = 'Highcharts', Globals.version = '11.1.0', Globals.win = (typeof window !== 'undefined' ?
            window :
            {}), // eslint-disable-line node/no-unsupported-features/es-builtins
        Globals.doc = Globals.win.document, Globals.svg = (Globals.doc &&
            Globals.doc.createElementNS &&
            !!Globals.doc.createElementNS(Globals.SVG_NS, 'svg').createSVGRect), Globals.userAgent = (Globals.win.navigator && Globals.win.navigator.userAgent) || '', Globals.isChrome = Globals.userAgent.indexOf('Chrome') !== -1, Globals.isFirefox = Globals.userAgent.indexOf('Firefox') !== -1, Globals.isMS = /(edge|msie|trident)/i.test(Globals.userAgent) && !Globals.win.opera, Globals.isSafari = !Globals.isChrome && Globals.userAgent.indexOf('Safari') !== -1, Globals.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(Globals.userAgent), Globals.isWebKit = Globals.userAgent.indexOf('AppleWebKit') !== -1, Globals.deg2rad = Math.PI * 2 / 360, Globals.hasBidiBug = (Globals.isFirefox &&
            parseInt(Globals.userAgent.split('Firefox/')[1], 10) < 4 // issue #38
        ), Globals.hasTouch = !!Globals.win.TouchEvent, Globals.marginNames = [
            'plotTop',
            'marginRight',
            'marginBottom',
            'plotLeft'
        ], Globals.noop = function () { }, Globals.supportsPassiveEvents = (function () {
            // Checks whether the browser supports passive events, (#11353).
            let supportsPassive = false;
            // Object.defineProperty doesn't work on IE as well as passive
            // events - instead of using polyfill, we can exclude IE totally.
            if (!Globals.isMS) {
                const opts = Object.defineProperty({}, 'passive', {
                    get: function () {
                        supportsPassive = true;
                    }
                });
                if (Globals.win.addEventListener && Globals.win.removeEventListener) {
                    Globals.win.addEventListener('testPassive', Globals.noop, opts);
                    Globals.win.removeEventListener('testPassive', Globals.noop, opts);
                }
            }
            return supportsPassive;
        }());
        /**
         * An array containing the current chart objects in the page. A chart's
         * position in the array is preserved throughout the page's lifetime. When
         * a chart is destroyed, the array item becomes `undefined`.
         *
         * @name Highcharts.charts
         * @type {Array<Highcharts.Chart|undefined>}
         */
        Globals.charts = [];
        /**
         * A hook for defining additional date format specifiers. New
         * specifiers are defined as key-value pairs by using the
         * specifier as key, and a function which takes the timestamp as
         * value. This function returns the formatted portion of the
         * date.
         *
         * @sample highcharts/global/dateformats/
         *         Adding support for week number
         *
         * @name Highcharts.dateFormats
         * @type {Record<string, Highcharts.TimeFormatCallbackFunction>}
         */
        Globals.dateFormats = {};
        /**
         * @private
         * @deprecated
         * @todo Use only `Core/Series/SeriesRegistry.seriesTypes`
         */
        Globals.seriesTypes = {};
        /**
         * @private
         */
        Globals.symbolSizes = {};
        /* *
         *
         *  Properties
         *
         * */
        // eslint-disable-next-line prefer-const
        Globals.chartCount = 0;
    })(Globals || (Globals = {}));
    /* *
     *
     *  Default Export
     *
     * */
    var H = Globals;

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { charts: charts$2, doc: doc$4, win: win$8 } = H;
    /* *
     *
     *  Functions
     *
     * */
    /**
     * Provide error messages for debugging, with links to online explanation. This
     * function can be overridden to provide custom error handling.
     *
     * @sample highcharts/chart/highcharts-error/
     *         Custom error handler
     *
     * @function Highcharts.error
     *
     * @param {number|string} code
     *        The error code. See
     *        [errors.xml](https://github.com/highcharts/highcharts/blob/master/errors/errors.xml)
     *        for available codes. If it is a string, the error message is printed
     *        directly in the console.
     *
     * @param {boolean} [stop=false]
     *        Whether to throw an error or just log a warning in the console.
     *
     * @param {Highcharts.Chart} [chart]
     *        Reference to the chart that causes the error. Used in 'debugger'
     *        module to display errors directly on the chart.
     *        Important note: This argument is undefined for errors that lack
     *        access to the Chart instance. In such case, the error will be
     *        displayed on the last created chart.
     *
     * @param {Highcharts.Dictionary<string>} [params]
     *        Additional parameters for the generated message.
     *
     * @return {void}
     */
    function error$5(code, stop, chart, params) {
        const severity = stop ? 'Highcharts error' : 'Highcharts warning';
        if (code === 32) {
            code = `${severity}: Deprecated member`;
        }
        const isCode = isNumber$d(code);
        let message = isCode ?
            `${severity} #${code}: www.highcharts.com/errors/${code}/` :
            code.toString();
        const defaultHandler = function () {
            if (stop) {
                throw new Error(message);
            }
            // else ...
            if (win$8.console &&
                error$5.messages.indexOf(message) === -1 // prevent console flooting
            ) {
                console.warn(message); // eslint-disable-line no-console
            }
        };
        if (typeof params !== 'undefined') {
            let additionalMessages = '';
            if (isCode) {
                message += '?';
            }
            objectEach$d(params, function (value, key) {
                additionalMessages += `\n - ${key}: ${value}`;
                if (isCode) {
                    message += encodeURI(key) + '=' + encodeURI(value);
                }
            });
            message += additionalMessages;
        }
        fireEvent$8(H, 'displayError', { chart, code, message, params }, defaultHandler);
        error$5.messages.push(message);
    }
    (function (error) {
        error.messages = [];
    })(error$5 || (error$5 = {}));
    /* eslint-disable valid-jsdoc */
    /**
     * Utility function to deep merge two or more objects and return a third object.
     * If the first argument is true, the contents of the second object is copied
     * into the first object. The merge function can also be used with a single
     * object argument to create a deep copy of an object.
     *
     * @function Highcharts.merge<T>
     *
     * @param {boolean} extend
     *        Whether to extend the left-side object (a) or return a whole new
     *        object.
     *
     * @param {T|undefined} a
     *        The first object to extend. When only this is given, the function
     *        returns a deep copy.
     *
     * @param {...Array<object|undefined>} [n]
     *        An object to merge into the previous one.
     *
     * @return {T}
     *         The merged object. If the first argument is true, the return is the
     *         same as the second argument.
     */ /**
    * Utility function to deep merge two or more objects and return a third object.
    * The merge function can also be used with a single object argument to create a
    * deep copy of an object.
    *
    * @function Highcharts.merge<T>
    *
    * @param {T|undefined} a
    *        The first object to extend. When only this is given, the function
    *        returns a deep copy.
    *
    * @param {...Array<object|undefined>} [n]
    *        An object to merge into the previous one.
    *
    * @return {T}
    *         The merged object. If the first argument is true, the return is the
    *         same as the second argument.
    */
    function merge$f() {
        /* eslint-enable valid-jsdoc */
        let i, args = arguments, ret = {};
        const doCopy = function (copy, original) {
            // An object is replacing a primitive
            if (typeof copy !== 'object') {
                copy = {};
            }
            objectEach$d(original, function (value, key) {
                // Prototype pollution (#14883)
                if (key === '__proto__' || key === 'constructor') {
                    return;
                }
                // Copy the contents of objects, but not arrays or DOM nodes
                if (isObject$7(value, true) &&
                    !isClass(value) &&
                    !isDOMElement(value)) {
                    copy[key] = doCopy(copy[key] || {}, value);
                    // Primitives and arrays are copied over directly
                }
                else {
                    copy[key] = original[key];
                }
            });
            return copy;
        };
        // If first argument is true, copy into the existing object. Used in
        // setOptions.
        if (args[0] === true) {
            ret = args[1];
            args = Array.prototype.slice.call(args, 2);
        }
        // For each argument, extend the return
        const len = args.length;
        for (i = 0; i < len; i++) {
            ret = doCopy(ret, args[i]);
        }
        return ret;
    }
    /**
     * Constrain a value to within a lower and upper threshold.
     *
     * @private
     * @param {number} value The initial value
     * @param {number} min The lower threshold
     * @param {number} max The upper threshold
     * @return {number} Returns a number value within min and max.
     */
    function clamp$4(value, min, max) {
        return value > min ? value < max ? value : max : min;
    }
    // eslint-disable-next-line valid-jsdoc
    /**
     * Return the deep difference between two objects. It can either return the new
     * properties, or optionally return the old values of new properties.
     * @private
     */
    function diffObjects$2(newer, older, keepOlder, collectionsWithUpdate) {
        const ret = {};
        /**
         * Recurse over a set of options and its current values, and store the
         * current values in the ret object.
         */
        function diff(newer, older, ret, depth) {
            const keeper = keepOlder ? older : newer;
            objectEach$d(newer, function (newerVal, key) {
                if (!depth &&
                    collectionsWithUpdate &&
                    collectionsWithUpdate.indexOf(key) > -1 &&
                    older[key]) {
                    newerVal = splat$5(newerVal);
                    ret[key] = [];
                    // Iterate over collections like series, xAxis or yAxis and map
                    // the items by index.
                    for (let i = 0; i < Math.max(newerVal.length, older[key].length); i++) {
                        // Item exists in current data (#6347)
                        if (older[key][i]) {
                            // If the item is missing from the new data, we need to
                            // save the whole config structure. Like when
                            // responsively updating from a dual axis layout to a
                            // single axis and back (#13544).
                            if (newerVal[i] === void 0) {
                                ret[key][i] = older[key][i];
                                // Otherwise, proceed
                            }
                            else {
                                ret[key][i] = {};
                                diff(newerVal[i], older[key][i], ret[key][i], depth + 1);
                            }
                        }
                    }
                }
                else if (isObject$7(newerVal, true) &&
                    !newerVal.nodeType // #10044
                ) {
                    ret[key] = isArray$9(newerVal) ? [] : {};
                    diff(newerVal, older[key] || {}, ret[key], depth + 1);
                    // Delete empty nested objects
                    if (Object.keys(ret[key]).length === 0 &&
                        // Except colorAxis which is a special case where the empty
                        // object means it is enabled. Which is unfortunate and we
                        // should try to find a better way.
                        !(key === 'colorAxis' && depth === 0)) {
                        delete ret[key];
                    }
                }
                else if (newer[key] !== older[key] ||
                    // If the newer key is explicitly undefined, keep it (#10525)
                    (key in newer && !(key in older))) {
                    ret[key] = keeper[key];
                }
            });
        }
        diff(newer, older, ret, 0);
        return ret;
    }
    /**
     * Shortcut for parseInt
     *
     * @private
     * @function Highcharts.pInt
     *
     * @param {*} s
     *        any
     *
     * @param {number} [mag]
     *        Magnitude
     *
     * @return {number}
     *         number
     */
    function pInt$5(s, mag) {
        return parseInt(s, mag || 10);
    }
    /**
     * Utility function to check for string type.
     *
     * @function Highcharts.isString
     *
     * @param {*} s
     *        The item to check.
     *
     * @return {boolean}
     *         True if the argument is a string.
     */
    function isString$8(s) {
        return typeof s === 'string';
    }
    /**
     * Utility function to check if an item is an array.
     *
     * @function Highcharts.isArray
     *
     * @param {*} obj
     *        The item to check.
     *
     * @return {boolean}
     *         True if the argument is an array.
     */
    function isArray$9(obj) {
        const str = Object.prototype.toString.call(obj);
        return str === '[object Array]' || str === '[object Array Iterator]';
    }
    /**
     * Utility function to check if an item is of type object.
     *
     * @function Highcharts.isObject
     *
     * @param {*} obj
     *        The item to check.
     *
     * @param {boolean} [strict=false]
     *        Also checks that the object is not an array.
     *
     * @return {boolean}
     *         True if the argument is an object.
     */
    function isObject$7(obj, strict) {
        return (!!obj &&
            typeof obj === 'object' &&
            (!strict || !isArray$9(obj))); // eslint-disable-line @typescript-eslint/no-explicit-any
    }
    /**
     * Utility function to check if an Object is a HTML Element.
     *
     * @function Highcharts.isDOMElement
     *
     * @param {*} obj
     *        The item to check.
     *
     * @return {boolean}
     *         True if the argument is a HTML Element.
     */
    function isDOMElement(obj) {
        return isObject$7(obj) && typeof obj.nodeType === 'number';
    }
    /**
     * Utility function to check if an Object is a class.
     *
     * @function Highcharts.isClass
     *
     * @param {object|undefined} obj
     *        The item to check.
     *
     * @return {boolean}
     *         True if the argument is a class.
     */
    function isClass(obj) {
        const c = obj && obj.constructor;
        return !!(isObject$7(obj, true) &&
            !isDOMElement(obj) &&
            (c && c.name && c.name !== 'Object'));
    }
    /**
     * Utility function to check if an item is a number and it is finite (not NaN,
     * Infinity or -Infinity).
     *
     * @function Highcharts.isNumber
     *
     * @param {*} n
     *        The item to check.
     *
     * @return {boolean}
     *         True if the item is a finite number
     */
    function isNumber$d(n) {
        return typeof n === 'number' && !isNaN(n) && n < Infinity && n > -Infinity;
    }
    /**
     * Remove the last occurence of an item from an array.
     *
     * @function Highcharts.erase
     *
     * @param {Array<*>} arr
     *        The array.
     *
     * @param {*} item
     *        The item to remove.
     *
     * @return {void}
     */
    function erase$5(arr, item) {
        let i = arr.length;
        while (i--) {
            if (arr[i] === item) {
                arr.splice(i, 1);
                break;
            }
        }
    }
    /**
     * Insert a series or an axis in a collection with other items, either the
     * chart series or yAxis series or axis collections, in the correct order
     * according to the index option and whether it is internal. Used internally
     * when adding series and axes.
     *
     * @private
     * @function Highcharts.Chart#insertItem
     * @param  {Highcharts.Series|Highcharts.Axis} item
     *         The item to insert
     * @param  {Array<Highcharts.Series>|Array<Highcharts.Axis>} collection
     *         A collection of items, like `chart.series` or `xAxis.series`.
     * @return {number} The index of the series in the collection.
     */
    function insertItem$2(item, collection) {
        const indexOption = item.options.index, length = collection.length;
        let i;
        for (
        // Internal item (navigator) should always be pushed to the end
        i = item.options.isInternal ? length : 0; i < length + 1; i++) {
            if (
            // No index option, reached the end of the collection,
            // equivalent to pushing
            !collection[i] ||
                // Handle index option, the element to insert has lower index
                (isNumber$d(indexOption) &&
                    indexOption < pick$f(collection[i].options.index, collection[i]._i)) ||
                // Insert the new item before other internal items
                // (navigator)
                collection[i].options.isInternal) {
                collection.splice(i, 0, item);
                break;
            }
        }
        return i;
    }
    /**
     * Adds an item to an array, if it is not present in the array.
     *
     * @function Highcharts.pushUnique
     *
     * @param {Array<unknown>} array
     * The array to add the item to.
     *
     * @param {unknown} item
     * The item to add.
     *
     * @return {boolean}
     * Returns true, if the item was not present and has been added.
     */
    function pushUnique(array, item) {
        return array.indexOf(item) < 0 && !!array.push(item);
    }
    /**
     * Check if an object is null or undefined.
     *
     * @function Highcharts.defined
     *
     * @param {*} obj
     *        The object to check.
     *
     * @return {boolean}
     *         False if the object is null or undefined, otherwise true.
     */
    function defined$c(obj) {
        return typeof obj !== 'undefined' && obj !== null;
    }
    /**
     * Set or get an attribute or an object of attributes.
     *
     * To use as a setter, pass a key and a value, or let the second argument be a
     * collection of keys and values. When using a collection, passing a value of
     * `null` or `undefined` will remove the attribute.
     *
     * To use as a getter, pass only a string as the second argument.
     *
     * @function Highcharts.attr
     *
     * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} elem
     *        The DOM element to receive the attribute(s).
     *
     * @param {string|Highcharts.HTMLAttributes|Highcharts.SVGAttributes} [keyOrAttribs]
     *        The property or an object of key-value pairs.
     *
     * @param {number|string} [value]
     *        The value if a single property is set.
     *
     * @return {string|null|undefined}
     *         When used as a getter, return the value.
     */
    function attr$5(elem, keyOrAttribs, value) {
        const isGetter = isString$8(keyOrAttribs) && !defined$c(value);
        let ret;
        const attrSingle = (value, key) => {
            // Set the value
            if (defined$c(value)) {
                elem.setAttribute(key, value);
                // Get the value
            }
            else if (isGetter) {
                ret = elem.getAttribute(key);
                // IE7 and below cannot get class through getAttribute (#7850)
                if (!ret && key === 'class') {
                    ret = elem.getAttribute(key + 'Name');
                }
                // Remove the value
            }
            else {
                elem.removeAttribute(key);
            }
        };
        // If keyOrAttribs is a string
        if (isString$8(keyOrAttribs)) {
            attrSingle(value, keyOrAttribs);
            // Else if keyOrAttribs is defined, it is a hash of key/value pairs
        }
        else {
            objectEach$d(keyOrAttribs, attrSingle);
        }
        return ret;
    }
    /**
     * Check if an element is an array, and if not, make it into an array.
     *
     * @function Highcharts.splat
     *
     * @param {*} obj
     *        The object to splat.
     *
     * @return {Array}
     *         The produced or original array.
     */
    function splat$5(obj) {
        return isArray$9(obj) ? obj : [obj];
    }
    /**
     * Set a timeout if the delay is given, otherwise perform the function
     * synchronously.
     *
     * @function Highcharts.syncTimeout
     *
     * @param {Function} fn
     *        The function callback.
     *
     * @param {number} delay
     *        Delay in milliseconds.
     *
     * @param {*} [context]
     *        An optional context to send to the function callback.
     *
     * @return {number}
     *         An identifier for the timeout that can later be cleared with
     *         Highcharts.clearTimeout. Returns -1 if there is no timeout.
     */
    function syncTimeout$5(fn, delay, context) {
        if (delay > 0) {
            return setTimeout(fn, delay, context);
        }
        fn.call(0, context);
        return -1;
    }
    /**
     * Internal clear timeout. The function checks that the `id` was not removed
     * (e.g. by `chart.destroy()`). For the details see
     * [issue #7901](https://github.com/highcharts/highcharts/issues/7901).
     *
     * @function Highcharts.clearTimeout
     *
     * @param {number|undefined} id
     * Id of a timeout.
     */
    function internalClearTimeout(id) {
        if (defined$c(id)) {
            clearTimeout(id);
        }
    }
    /* eslint-disable valid-jsdoc */
    /**
     * Utility function to extend an object with the members of another.
     *
     * @function Highcharts.extend<T>
     *
     * @param {T|undefined} a
     *        The object to be extended.
     *
     * @param {Partial<T>} b
     *        The object to add to the first one.
     *
     * @return {T}
     *         Object a, the original object.
     */
    function extend$d(a, b) {
        /* eslint-enable valid-jsdoc */
        let n;
        if (!a) {
            a = {};
        }
        for (n in b) { // eslint-disable-line guard-for-in
            a[n] = b[n];
        }
        return a;
    }
    /* eslint-disable valid-jsdoc */
    /**
     * Return the first value that is not null or undefined.
     *
     * @function Highcharts.pick<T>
     *
     * @param {...Array<T|null|undefined>} items
     *        Variable number of arguments to inspect.
     *
     * @return {T}
     *         The value of the first argument that is not null or undefined.
     */
    function pick$f() {
        const args = arguments;
        const length = args.length;
        for (let i = 0; i < length; i++) {
            const arg = args[i];
            if (typeof arg !== 'undefined' && arg !== null) {
                return arg;
            }
        }
    }
    /**
     * Set CSS on a given element.
     *
     * @function Highcharts.css
     *
     * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} el
     *        An HTML DOM element.
     *
     * @param {Highcharts.CSSObject} styles
     *        Style object with camel case property names.
     *
     * @return {void}
     */
    function css$4(el, styles) {
        if (H.isMS && !H.svg) { // #2686
            if (styles && defined$c(styles.opacity)) {
                styles.filter = `alpha(opacity=${styles.opacity * 100})`;
            }
        }
        extend$d(el.style, styles);
    }
    /**
     * Utility function to create an HTML element with attributes and styles.
     *
     * @function Highcharts.createElement
     *
     * @param {string} tag
     *        The HTML tag.
     *
     * @param {Highcharts.HTMLAttributes} [attribs]
     *        Attributes as an object of key-value pairs.
     *
     * @param {Highcharts.CSSObject} [styles]
     *        Styles as an object of key-value pairs.
     *
     * @param {Highcharts.HTMLDOMElement} [parent]
     *        The parent HTML object.
     *
     * @param {boolean} [nopad=false]
     *        If true, remove all padding, border and margin.
     *
     * @return {Highcharts.HTMLDOMElement}
     *         The created DOM element.
     */
    function createElement$4(tag, attribs, styles, parent, nopad) {
        const el = doc$4.createElement(tag);
        if (attribs) {
            extend$d(el, attribs);
        }
        if (nopad) {
            css$4(el, { padding: '0', border: 'none', margin: '0' });
        }
        if (styles) {
            css$4(el, styles);
        }
        if (parent) {
            parent.appendChild(el);
        }
        return el;
    }
    // eslint-disable-next-line valid-jsdoc
    /**
     * Extend a prototyped class by new members.
     *
     * @deprecated
     * @function Highcharts.extendClass<T>
     *
     * @param {Highcharts.Class<T>} parent
     *        The parent prototype to inherit.
     *
     * @param {Highcharts.Dictionary<*>} members
     *        A collection of prototype members to add or override compared to the
     *        parent prototype.
     *
     * @return {Highcharts.Class<T>}
     *         A new prototype.
     */
    function extendClass$1(parent, members) {
        const obj = (function () { });
        obj.prototype = new parent(); // eslint-disable-line new-cap
        extend$d(obj.prototype, members);
        return obj;
    }
    /**
     * Left-pad a string to a given length by adding a character repetitively.
     *
     * @function Highcharts.pad
     *
     * @param {number} number
     *        The input string or number.
     *
     * @param {number} [length]
     *        The desired string length.
     *
     * @param {string} [padder=0]
     *        The character to pad with.
     *
     * @return {string}
     *         The padded string.
     */
    function pad$1(number, length, padder) {
        return new Array((length || 2) +
            1 -
            String(number)
                .replace('-', '')
                .length).join(padder || '0') + number;
    }
    /**
     * Return a length based on either the integer value, or a percentage of a base.
     *
     * @function Highcharts.relativeLength
     *
     * @param {Highcharts.RelativeSize} value
     *        A percentage string or a number.
     *
     * @param {number} base
     *        The full length that represents 100%.
     *
     * @param {number} [offset=0]
     *        A pixel offset to apply for percentage values. Used internally in
     *        axis positioning.
     *
     * @return {number}
     *         The computed length.
     */
    function relativeLength$3(value, base, offset) {
        return (/%$/).test(value) ?
            (base * parseFloat(value) / 100) + (offset || 0) :
            parseFloat(value);
    }
    /**
     * Wrap a method with extended functionality, preserving the original function.
     *
     * @function Highcharts.wrap
     *
     * @param {*} obj
     *        The context object that the method belongs to. In real cases, this is
     *        often a prototype.
     *
     * @param {string} method
     *        The name of the method to extend.
     *
     * @param {Highcharts.WrapProceedFunction} func
     *        A wrapper function callback. This function is called with the same
     *        arguments as the original function, except that the original function
     *        is unshifted and passed as the first argument.
     */
    function wrap(obj, method, func) {
        const proceed = obj[method];
        obj[method] = function () {
            const outerArgs = arguments, scope = this;
            return func.apply(this, [
                function () {
                    return proceed.apply(scope, arguments.length ? arguments : outerArgs);
                }
            ].concat([].slice.call(arguments)));
        };
    }
    /**
     * Get the magnitude of a number.
     *
     * @function Highcharts.getMagnitude
     *
     * @param {number} num
     *        The number.
     *
     * @return {number}
     *         The magnitude, where 1-9 are magnitude 1, 10-99 magnitude 2 etc.
     */
    function getMagnitude(num) {
        return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));
    }
    /**
     * Take an interval and normalize it to multiples of round numbers.
     *
     * @deprecated
     * @function Highcharts.normalizeTickInterval
     *
     * @param {number} interval
     *        The raw, un-rounded interval.
     *
     * @param {Array<*>} [multiples]
     *        Allowed multiples.
     *
     * @param {number} [magnitude]
     *        The magnitude of the number.
     *
     * @param {boolean} [allowDecimals]
     *        Whether to allow decimals.
     *
     * @param {boolean} [hasTickAmount]
     *        If it has tickAmount, avoid landing on tick intervals lower than
     *        original.
     *
     * @return {number}
     *         The normalized interval.
     *
     * @todo
     * Move this function to the Axis prototype. It is here only for historical
     * reasons.
     */
    function normalizeTickInterval$1(interval, multiples, magnitude, allowDecimals, hasTickAmount) {
        let i, retInterval = interval;
        // round to a tenfold of 1, 2, 2.5 or 5
        magnitude = pick$f(magnitude, getMagnitude(interval));
        const normalized = interval / magnitude;
        // multiples for a linear scale
        if (!multiples) {
            multiples = hasTickAmount ?
                // Finer grained ticks when the tick amount is hard set, including
                // when alignTicks is true on multiple axes (#4580).
                [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] :
                // Else, let ticks fall on rounder numbers
                [1, 2, 2.5, 5, 10];
            // the allowDecimals option
            if (allowDecimals === false) {
                if (magnitude === 1) {
                    multiples = multiples.filter(function (num) {
                        return num % 1 === 0;
                    });
                }
                else if (magnitude <= 0.1) {
                    multiples = [1 / magnitude];
                }
            }
        }
        // normalize the interval to the nearest multiple
        for (i = 0; i < multiples.length; i++) {
            retInterval = multiples[i];
            // only allow tick amounts smaller than natural
            if ((hasTickAmount &&
                retInterval * magnitude >= interval) ||
                (!hasTickAmount &&
                    (normalized <=
                        (multiples[i] +
                            (multiples[i + 1] || multiples[i])) / 2))) {
                break;
            }
        }
        // Multiply back to the correct magnitude. Correct floats to appropriate
        // precision (#6085).
        retInterval = correctFloat$3(retInterval * magnitude, -Math.round(Math.log(0.001) / Math.LN10));
        return retInterval;
    }
    /**
     * Sort an object array and keep the order of equal items. The ECMAScript
     * standard does not specify the behaviour when items are equal.
     *
     * @function Highcharts.stableSort
     *
     * @param {Array<*>} arr
     *        The array to sort.
     *
     * @param {Function} sortFunction
     *        The function to sort it with, like with regular Array.prototype.sort.
     */
    function stableSort(arr, sortFunction) {
        // @todo It seems like Chrome since v70 sorts in a stable way internally,
        // plus all other browsers do it, so over time we may be able to remove this
        // function
        const length = arr.length;
        let sortValue, i;
        // Add index to each item
        for (i = 0; i < length; i++) {
            arr[i].safeI = i; // stable sort index
        }
        arr.sort(function (a, b) {
            sortValue = sortFunction(a, b);
            return sortValue === 0 ? a.safeI - b.safeI : sortValue;
        });
        // Remove index from items
        for (i = 0; i < length; i++) {
            delete arr[i].safeI; // stable sort index
        }
    }
    /**
     * Non-recursive method to find the lowest member of an array. `Math.min` raises
     * a maximum call stack size exceeded error in Chrome when trying to apply more
     * than 150.000 points. This method is slightly slower, but safe.
     *
     * @function Highcharts.arrayMin
     *
     * @param {Array<*>} data
     *        An array of numbers.
     *
     * @return {number}
     *         The lowest number.
     */
    function arrayMin$2(data) {
        let i = data.length, min = data[0];
        while (i--) {
            if (data[i] < min) {
                min = data[i];
            }
        }
        return min;
    }
    /**
     * Non-recursive method to find the lowest member of an array. `Math.max` raises
     * a maximum call stack size exceeded error in Chrome when trying to apply more
     * than 150.000 points. This method is slightly slower, but safe.
     *
     * @function Highcharts.arrayMax
     *
     * @param {Array<*>} data
     *        An array of numbers.
     *
     * @return {number}
     *         The highest number.
     */
    function arrayMax$2(data) {
        let i = data.length, max = data[0];
        while (i--) {
            if (data[i] > max) {
                max = data[i];
            }
        }
        return max;
    }
    /**
     * Utility method that destroys any SVGElement instances that are properties on
     * the given object. It loops all properties and invokes destroy if there is a
     * destroy method. The property is then delete.
     *
     * @function Highcharts.destroyObjectProperties
     *
     * @param {*} obj
     *        The object to destroy properties on.
     *
     * @param {*} [except]
     *        Exception, do not destroy this property, only delete it.
     */
    function destroyObjectProperties$3(obj, except) {
        objectEach$d(obj, function (val, n) {
            // If the object is non-null and destroy is defined
            if (val && val !== except && val.destroy) {
                // Invoke the destroy
                val.destroy();
            }
            // Delete the property from the object.
            delete obj[n];
        });
    }
    /**
     * Discard a HTML element
     *
     * @function Highcharts.discardElement
     *
     * @param {Highcharts.HTMLDOMElement} element
     *        The HTML node to discard.
     */
    function discardElement$1(element) {
        if (element && element.parentElement) {
            element.parentElement.removeChild(element);
        }
    }
    /**
     * Fix JS round off float errors.
     *
     * @function Highcharts.correctFloat
     *
     * @param {number} num
     *        A float number to fix.
     *
     * @param {number} [prec=14]
     *        The precision.
     *
     * @return {number}
     *         The corrected float number.
     */
    function correctFloat$3(num, prec) {
        // When the number is higher than 1e14 use the number (#16275)
        return num > 1e14 ? num : parseFloat(num.toPrecision(prec || 14));
    }
    /**
     * The time unit lookup
     *
     * @ignore
     */
    const timeUnits$1 = {
        millisecond: 1,
        second: 1000,
        minute: 60000,
        hour: 3600000,
        day: 24 * 3600000,
        week: 7 * 24 * 3600000,
        month: 28 * 24 * 3600000,
        year: 364 * 24 * 3600000
    };
    /**
     * Easing definition
     *
     * @private
     * @function Math.easeInOutSine
     *
     * @param {number} pos
     *        Current position, ranging from 0 to 1.
     *
     * @return {number}
     *         Ease result
     */
    Math.easeInOutSine = function (pos) {
        return -0.5 * (Math.cos(Math.PI * pos) - 1);
    };
    /**
     * Find the closest distance between two values of a two-dimensional array
     * @private
     * @function Highcharts.getClosestDistance
     *
     * @param {Array<Array<number>>} arrays
     *          An array of arrays of numbers
     *
     * @return {number | undefined}
     *          The closest distance between values
     */
    function getClosestDistance$2(arrays, onError) {
        const allowNegative = !onError;
        let closest, loopLength, distance, i;
        arrays.forEach((xData) => {
            if (xData.length > 1) {
                loopLength = xData.length - 1;
                for (i = loopLength; i > 0; i--) {
                    distance = xData[i] - xData[i - 1];
                    if (distance < 0 && !allowNegative) {
                        onError === null || onError === void 0 ? void 0 : onError();
                        // Only one call
                        onError = void 0;
                    }
                    else if (distance && (typeof closest === 'undefined' || distance < closest)) {
                        closest = distance;
                    }
                }
            }
        });
        return closest;
    }
    /**
     * Returns the value of a property path on a given object.
     *
     * @private
     * @function getNestedProperty
     *
     * @param {string} path
     * Path to the property, for example `custom.myValue`.
     *
     * @param {unknown} obj
     * Instance containing the property on the specific path.
     *
     * @return {unknown}
     * The unknown property value.
     */
    function getNestedProperty$3(path, parent) {
        const pathElements = path.split('.');
        while (pathElements.length && defined$c(parent)) {
            const pathElement = pathElements.shift();
            // Filter on the key
            if (typeof pathElement === 'undefined' ||
                pathElement === '__proto__') {
                return; // undefined
            }
            if (pathElement === 'this') {
                let thisProp;
                if (isObject$7(parent)) {
                    thisProp = parent['@this'];
                }
                return thisProp !== null && thisProp !== void 0 ? thisProp : parent;
            }
            const child = parent[pathElement];
            // Filter on the child
            if (!defined$c(child) ||
                typeof child === 'function' ||
                typeof child.nodeType === 'number' ||
                child === win$8) {
                return; // undefined
            }
            // Else, proceed
            parent = child;
        }
        return parent;
    }
    /**
     * Get the computed CSS value for given element and property, only for numerical
     * properties. For width and height, the dimension of the inner box (excluding
     * padding) is returned. Used for fitting the chart within the container.
     *
     * @function Highcharts.getStyle
     *
     * @param {Highcharts.HTMLDOMElement} el
     * An HTML element.
     *
     * @param {string} prop
     * The property name.
     *
     * @param {boolean} [toInt=true]
     * Parse to integer.
     *
     * @return {number|string|undefined}
     * The style value.
     */
    function getStyle$2(el, prop, toInt) {
        let style;
        // For width and height, return the actual inner pixel size (#4913)
        if (prop === 'width') {
            let offsetWidth = Math.min(el.offsetWidth, el.scrollWidth);
            // In flex boxes, we need to use getBoundingClientRect and floor it,
            // because scrollWidth doesn't support subpixel precision (#6427) ...
            const boundingClientRectWidth = el.getBoundingClientRect &&
                el.getBoundingClientRect().width;
            // ...unless if the containing div or its parents are transform-scaled
            // down, in which case the boundingClientRect can't be used as it is
            // also scaled down (#9871, #10498).
            if (boundingClientRectWidth < offsetWidth &&
                boundingClientRectWidth >= offsetWidth - 1) {
                offsetWidth = Math.floor(boundingClientRectWidth);
            }
            return Math.max(0, // #8377
            (offsetWidth -
                (getStyle$2(el, 'padding-left', true) || 0) -
                (getStyle$2(el, 'padding-right', true) || 0)));
        }
        if (prop === 'height') {
            return Math.max(0, // #8377
            (Math.min(el.offsetHeight, el.scrollHeight) -
                (getStyle$2(el, 'padding-top', true) || 0) -
                (getStyle$2(el, 'padding-bottom', true) || 0)));
        }
        // Otherwise, get the computed style
        const css = win$8.getComputedStyle(el, void 0); // eslint-disable-line no-undefined
        if (css) {
            style = css.getPropertyValue(prop);
            if (pick$f(toInt, prop !== 'opacity')) {
                style = pInt$5(style);
            }
        }
        return style;
    }
    /**
     * Search for an item in an array.
     *
     * @function Highcharts.inArray
     *
     * @deprecated
     *
     * @param {*} item
     *        The item to search for.
     *
     * @param {Array<*>} arr
     *        The array or node collection to search in.
     *
     * @param {number} [fromIndex=0]
     *        The index to start searching from.
     *
     * @return {number}
     *         The index within the array, or -1 if not found.
     */
    function inArray(item, arr, fromIndex) {
        error$5(32, false, void 0, { 'Highcharts.inArray': 'use Array.indexOf' });
        return arr.indexOf(item, fromIndex);
    }
    /**
     * Return the value of the first element in the array that satisfies the
     * provided testing function.
     *
     * @function Highcharts.find<T>
     *
     * @param {Array<T>} arr
     *        The array to test.
     *
     * @param {Function} callback
     *        The callback function. The function receives the item as the first
     *        argument. Return `true` if this item satisfies the condition.
     *
     * @return {T|undefined}
     *         The value of the element.
     */
    const find$2 = Array.prototype.find ?
        function (arr, callback) {
            return arr.find(callback);
        } :
        // Legacy implementation. PhantomJS, IE <= 11 etc. #7223.
        function (arr, callback) {
            let i;
            const length = arr.length;
            for (i = 0; i < length; i++) {
                if (callback(arr[i], i)) { // eslint-disable-line node/callback-return
                    return arr[i];
                }
            }
        };
    /**
     * Returns an array of a given object's own properties.
     *
     * @function Highcharts.keys
     * @deprecated
     *
     * @param {*} obj
     *        The object of which the properties are to be returned.
     *
     * @return {Array<string>}
     *         An array of strings that represents all the properties.
     */
    function keys(obj) {
        error$5(32, false, void 0, { 'Highcharts.keys': 'use Object.keys' });
        return Object.keys(obj);
    }
    /**
     * Get the element's offset position, corrected for `overflow: auto`.
     *
     * @function Highcharts.offset
     *
     * @param {global.Element} el
     *        The DOM element.
     *
     * @return {Highcharts.OffsetObject}
     *         An object containing `left` and `top` properties for the position in
     *         the page.
     */
    function offset(el) {
        const docElem = doc$4.documentElement, box = (el.parentElement || el.parentNode) ?
            el.getBoundingClientRect() :
            { top: 0, left: 0, width: 0, height: 0 };
        return {
            top: box.top + (win$8.pageYOffset || docElem.scrollTop) -
                (docElem.clientTop || 0),
            left: box.left + (win$8.pageXOffset || docElem.scrollLeft) -
                (docElem.clientLeft || 0),
            width: box.width,
            height: box.height
        };
    }
    /* eslint-disable valid-jsdoc */
    /**
     * Iterate over object key pairs in an object.
     *
     * @function Highcharts.objectEach<T>
     *
     * @param {*} obj
     *        The object to iterate over.
     *
     * @param {Highcharts.ObjectEachCallbackFunction<T>} fn
     *        The iterator callback. It passes three arguments:
     *        * value - The property value.
     *        * key - The property key.
     *        * obj - The object that objectEach is being applied to.
     *
     * @param {T} [ctx]
     *        The context.
     */
    function objectEach$d(obj, fn, ctx) {
        /* eslint-enable valid-jsdoc */
        for (const key in obj) {
            if (Object.hasOwnProperty.call(obj, key)) {
                fn.call(ctx || obj[key], obj[key], key, obj);
            }
        }
    }
    /**
     * Iterate over an array.
     *
     * @deprecated
     * @function Highcharts.each
     *
     * @param {Array<*>} arr
     *        The array to iterate over.
     *
     * @param {Function} fn
     *        The iterator callback. It passes three arguments:
     *        - `item`: The array item.
     *        - `index`: The item's index in the array.
     *        - `arr`: The array that each is being applied to.
     *
     * @param {*} [ctx]
     *        The context.
     *
     * @return {void}
     */
    /**
     * Filter an array by a callback.
     *
     * @deprecated
     * @function Highcharts.grep
     *
     * @param {Array<*>} arr
     *        The array to filter.
     *
     * @param {Function} callback
     *        The callback function. The function receives the item as the first
     *        argument. Return `true` if the item is to be preserved.
     *
     * @return {Array<*>}
     *         A new, filtered array.
     */
    /**
     * Map an array by a callback.
     *
     * @deprecated
     * @function Highcharts.map
     *
     * @param {Array<*>} arr
     *        The array to map.
     *
     * @param {Function} fn
     *        The callback function. Return the new value for the new array.
     *
     * @return {Array<*>}
     *         A new array item with modified items.
     */
    /**
     * Reduce an array to a single value.
     *
     * @deprecated
     * @function Highcharts.reduce
     *
     * @param {Array<*>} arr
     *        The array to reduce.
     *
     * @param {Function} fn
     *        The callback function. Return the reduced value. Receives 4
     *        arguments: Accumulated/reduced value, current value, current array
     *        index, and the array.
     *
     * @param {*} initialValue
     *        The initial value of the accumulator.
     *
     * @return {*}
     *         The reduced value.
     */
    /**
     * Test whether at least one element in the array passes the test implemented by
     * the provided function.
     *
     * @deprecated
     * @function Highcharts.some
     *
     * @param {Array<*>} arr
     *        The array to test
     *
     * @param {Function} fn
     *        The function to run on each item. Return truty to pass the test.
     *        Receives arguments `currentValue`, `index` and `array`.
     *
     * @param {*} ctx
     *        The context.
     *
     * @return {boolean}
     */
    objectEach$d({
        map: 'map',
        each: 'forEach',
        grep: 'filter',
        reduce: 'reduce',
        some: 'some'
    }, function (val, key) {
        H[key] = function (arr) {
            error$5(32, false, void 0, { [`Highcharts.${key}`]: `use Array.${val}` });
            return Array.prototype[val].apply(arr, [].slice.call(arguments, 1));
        };
    });
    /* eslint-disable valid-jsdoc */
    /**
     * Add an event listener.
     *
     * @function Highcharts.addEvent<T>
     *
     * @param {Highcharts.Class<T>|T} el
     *        The element or object to add a listener to. It can be a
     *        {@link HTMLDOMElement}, an {@link SVGElement} or any other object.
     *
     * @param {string} type
     *        The event type.
     *
     * @param {Highcharts.EventCallbackFunction<T>|Function} fn
     *        The function callback to execute when the event is fired.
     *
     * @param {Highcharts.EventOptionsObject} [options]
     *        Options for adding the event.
     *
     * @return {Function}
     *         A callback function to remove the added event.
     */
    function addEvent$6(el, type, fn, options = {}) {
        /* eslint-enable valid-jsdoc */
        // Add hcEvents to either the prototype (in case we're running addEvent on a
        // class) or the instance. If hasOwnProperty('hcEvents') is false, it is
        // inherited down the prototype chain, in which case we need to set the
        // property on this instance (which may itself be a prototype).
        const owner = typeof el === 'function' && el.prototype || el;
        if (!Object.hasOwnProperty.call(owner, 'hcEvents')) {
            owner.hcEvents = {};
        }
        const events = owner.hcEvents;
        // Allow click events added to points, otherwise they will be prevented by
        // the TouchPointer.pinch function after a pinch zoom operation (#7091).
        if (H.Point && // without H a dependency loop occurs
            el instanceof H.Point &&
            el.series &&
            el.series.chart) {
            el.series.chart.runTrackerClick = true;
        }
        // Handle DOM events
        // If the browser supports passive events, add it to improve performance
        // on touch events (#11353).
        const addEventListener = el.addEventListener;
        if (addEventListener) {
            addEventListener.call(el, type, fn, H.supportsPassiveEvents ? {
                passive: options.passive === void 0 ?
                    type.indexOf('touch') !== -1 : options.passive,
                capture: false
            } : false);
        }
        if (!events[type]) {
            events[type] = [];
        }
        const eventObject = {
            fn,
            order: typeof options.order === 'number' ? options.order : Infinity
        };
        events[type].push(eventObject);
        // Order the calls
        events[type].sort((a, b) => a.order - b.order);
        // Return a function that can be called to remove this event.
        return function () {
            removeEvent$6(el, type, fn);
        };
    }
    /* eslint-disable valid-jsdoc */
    /**
     * Remove an event that was added with {@link Highcharts#addEvent}.
     *
     * @function Highcharts.removeEvent<T>
     *
     * @param {Highcharts.Class<T>|T} el
     *        The element to remove events on.
     *
     * @param {string} [type]
     *        The type of events to remove. If undefined, all events are removed
     *        from the element.
     *
     * @param {Highcharts.EventCallbackFunction<T>} [fn]
     *        The specific callback to remove. If undefined, all events that match
     *        the element and optionally the type are removed.
     *
     * @return {void}
     */
    function removeEvent$6(el, type, fn) {
        /* eslint-enable valid-jsdoc */
        /**
         * @private
         */
        function removeOneEvent(type, fn) {
            const removeEventListener = el.removeEventListener;
            if (removeEventListener) {
                removeEventListener.call(el, type, fn, false);
            }
        }
        /**
         * @private
         */
        function removeAllEvents(eventCollection) {
            let types, len;
            if (!el.nodeName) {
                return; // break on non-DOM events
            }
            if (type) {
                types = {};
                types[type] = true;
            }
            else {
                types = eventCollection;
            }
            objectEach$d(types, function (_val, n) {
                if (eventCollection[n]) {
                    len = eventCollection[n].length;
                    while (len--) {
                        removeOneEvent(n, eventCollection[n][len].fn);
                    }
                }
            });
        }
        const owner = typeof el === 'function' && el.prototype || el;
        if (Object.hasOwnProperty.call(owner, 'hcEvents')) {
            const events = owner.hcEvents;
            if (type) {
                const typeEvents = (events[type] || []);
                if (fn) {
                    events[type] = typeEvents.filter(function (obj) {
                        return fn !== obj.fn;
                    });
                    removeOneEvent(type, fn);
                }
                else {
                    removeAllEvents(events);
                    events[type] = [];
                }
            }
            else {
                removeAllEvents(events);
                delete owner.hcEvents;
            }
        }
    }
    /* eslint-disable valid-jsdoc */
    /**
     * Fire an event that was registered with {@link Highcharts#addEvent}.
     *
     * @function Highcharts.fireEvent<T>
     *
     * @param {T} el
     *        The object to fire the event on. It can be a {@link HTMLDOMElement},
     *        an {@link SVGElement} or any other object.
     *
     * @param {string} type
     *        The type of event.
     *
     * @param {Highcharts.Dictionary<*>|Event} [eventArguments]
     *        Custom event arguments that are passed on as an argument to the event
     *        handler.
     *
     * @param {Highcharts.EventCallbackFunction<T>|Function} [defaultFunction]
     *        The default function to execute if the other listeners haven't
     *        returned false.
     *
     * @return {void}
     */
    function fireEvent$8(el, type, eventArguments, defaultFunction) {
        /* eslint-enable valid-jsdoc */
        let e;
        eventArguments = eventArguments || {};
        if (doc$4.createEvent &&
            (el.dispatchEvent ||
                (el.fireEvent &&
                    // Enable firing events on Highcharts instance.
                    el !== H))) {
            e = doc$4.createEvent('Events');
            e.initEvent(type, true, true);
            eventArguments = extend$d(e, eventArguments);
            if (el.dispatchEvent) {
                el.dispatchEvent(eventArguments);
            }
            else {
                el.fireEvent(type, eventArguments);
            }
        }
        else if (el.hcEvents) {
            if (!eventArguments.target) {
                // We're running a custom event
                extend$d(eventArguments, {
                    // Attach a simple preventDefault function to skip
                    // default handler if called. The built-in
                    // defaultPrevented property is not overwritable (#5112)
                    preventDefault: function () {
                        eventArguments.defaultPrevented = true;
                    },
                    // Setting target to native events fails with clicking
                    // the zoom-out button in Chrome.
                    target: el,
                    // If the type is not set, we're running a custom event
                    // (#2297). If it is set, we're running a browser event.
                    type: type
                });
            }
            const events = [];
            let object = el;
            let multilevel = false;
            // Recurse up the inheritance chain and collect hcEvents set as own
            // objects on the prototypes.
            while (object.hcEvents) {
                if (Object.hasOwnProperty.call(object, 'hcEvents') &&
                    object.hcEvents[type]) {
                    if (events.length) {
                        multilevel = true;
                    }
                    events.unshift.apply(events, object.hcEvents[type]);
                }
                object = Object.getPrototypeOf(object);
            }
            // For performance reasons, only sort the event handlers in case we are
            // dealing with multiple levels in the prototype chain. Otherwise, the
            // events are already sorted in the addEvent function.
            if (multilevel) {
                // Order the calls
                events.sort((a, b) => a.order - b.order);
            }
            // Call the collected event handlers
            events.forEach((obj) => {
                // If the event handler returns false, prevent the default handler
                // from executing
                if (obj.fn.call(el, eventArguments) === false) {
                    eventArguments.preventDefault();
                }
            });
        }
        // Run the default if not prevented
        if (defaultFunction && !eventArguments.defaultPrevented) {
            defaultFunction.call(el, eventArguments);
        }
    }
    let serialMode;
    /**
     * Get a unique key for using in internal element id's and pointers. The key is
     * composed of a random hash specific to this Highcharts instance, and a
     * counter.
     *
     * @example
     * let id = uniqueKey(); // => 'highcharts-x45f6hp-0'
     *
     * @function Highcharts.uniqueKey
     *
     * @return {string}
     * A unique key.
     */
    const uniqueKey$4 = (function () {
        const hash = Math.random().toString(36).substring(2, 9) + '-';
        let id = 0;
        return function () {
            return 'highcharts-' + (serialMode ? '' : hash) + id++;
        };
    }());
    /**
     * Activates a serial mode for element IDs provided by
     * {@link Highcharts.uniqueKey}. This mode can be used in automated tests, where
     * a simple comparison of two rendered SVG graphics is needed.
     *
     * **Note:** This is only for testing purposes and will break functionality in
     * webpages with multiple charts.
     *
     * @example
     * if (
     *   process &&
     *   process.env.NODE_ENV === 'development'
     * ) {
     *   Highcharts.useSerialIds(true);
     * }
     *
     * @function Highcharts.useSerialIds
     *
     * @param {boolean} [mode]
     * Changes the state of serial mode.
     *
     * @return {boolean|undefined}
     * State of the serial mode.
     */
    function useSerialIds(mode) {
        return (serialMode = pick$f(mode, serialMode));
    }
    function isFunction$4(obj) {
        return typeof obj === 'function';
    }
    // Register Highcharts as a plugin in jQuery
    if (win$8.jQuery) {
        /**
         * Highcharts-extended JQuery.
         *
         * @external JQuery
         */
        /**
         * Helper function to return the chart of the current JQuery selector
         * element.
         *
         * @function external:JQuery#highcharts
         *
         * @return {Highcharts.Chart}
         *         The chart that is linked to the JQuery selector element.
         */ /**
        * Factory function to create a chart in the current JQuery selector
        * element.
        *
        * @function external:JQuery#highcharts
        *
        * @param {'Chart'|'Map'|'StockChart'|string} [className]
        *        Name of the factory class in the Highcharts namespace.
        *
        * @param {Highcharts.Options} [options]
        *        The chart options structure.
        *
        * @param {Highcharts.ChartCallbackFunction} [callback]
        *        Function to run when the chart has loaded and and all external
        *        images are loaded. Defining a
        *        [chart.events.load](https://api.highcharts.com/highcharts/chart.events.load)
        *        handler is equivalent.
        *
        * @return {JQuery}
        *         The current JQuery selector.
        */
        win$8.jQuery.fn.highcharts = function () {
            const args = [].slice.call(arguments);
            if (this[0]) { // this[0] is the renderTo div
                // Create the chart
                if (args[0]) {
                    new H[ // eslint-disable-line computed-property-spacing, no-new
                    // Constructor defaults to Chart
                    isString$8(args[0]) ? args.shift() : 'Chart'](this[0], args[0], args[1]);
                    return this;
                }
                // When called without parameters or with the return argument,
                // return an existing chart
                return charts$2[attr$5(this[0], 'data-highcharts-chart')];
            }
        };
    }
    /* *
     *
     *  Default Export
     *
     * */
    // TODO use named exports when supported.
    const Utilities = {
        addEvent: addEvent$6,
        arrayMax: arrayMax$2,
        arrayMin: arrayMin$2,
        attr: attr$5,
        clamp: clamp$4,
        clearTimeout: internalClearTimeout,
        correctFloat: correctFloat$3,
        createElement: createElement$4,
        css: css$4,
        defined: defined$c,
        destroyObjectProperties: destroyObjectProperties$3,
        diffObjects: diffObjects$2,
        discardElement: discardElement$1,
        erase: erase$5,
        error: error$5,
        extend: extend$d,
        extendClass: extendClass$1,
        find: find$2,
        fireEvent: fireEvent$8,
        getClosestDistance: getClosestDistance$2,
        getMagnitude,
        getNestedProperty: getNestedProperty$3,
        getStyle: getStyle$2,
        inArray,
        insertItem: insertItem$2,
        isArray: isArray$9,
        isClass,
        isDOMElement,
        isFunction: isFunction$4,
        isNumber: isNumber$d,
        isObject: isObject$7,
        isString: isString$8,
        keys,
        merge: merge$f,
        normalizeTickInterval: normalizeTickInterval$1,
        objectEach: objectEach$d,
        offset,
        pad: pad$1,
        pick: pick$f,
        pInt: pInt$5,
        pushUnique,
        relativeLength: relativeLength$3,
        removeEvent: removeEvent$6,
        splat: splat$5,
        stableSort,
        syncTimeout: syncTimeout$5,
        timeUnits: timeUnits$1,
        uniqueKey: uniqueKey$4,
        useSerialIds,
        wrap
    };

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { isNumber: isNumber$c, merge: merge$e, pInt: pInt$4 } = Utilities;
    /* *
     *
     *  Class
     *
     * */
    /* eslint-disable valid-jsdoc */
    /**
     * Handle color operations. Some object methods are chainable.
     *
     * @class
     * @name Highcharts.Color
     *
     * @param {Highcharts.ColorType} input
     * The input color in either rbga or hex format
     */
    class Color {
        /* *
         *
         *  Static Functions
         *
         * */
        /**
         * Creates a color instance out of a color string or object.
         *
         * @function Highcharts.Color.parse
         *
         * @param {Highcharts.ColorType} [input]
         * The input color in either rbga or hex format.
         *
         * @return {Highcharts.Color}
         * Color instance.
         */
        static parse(input) {
            return input ? new Color(input) : Color.None;
        }
        /* *
         *
         *  Constructor
         *
         * */
        constructor(input) {
            this.rgba = [NaN, NaN, NaN, NaN];
            this.input = input;
            const GlobalColor = H.Color;
            // Backwards compatibility, allow class overwrite
            if (GlobalColor && GlobalColor !== Color) {
                return new GlobalColor(input);
            }
            this.init(input);
        }
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Parse the input color to rgba array
         *
         * @private
         * @function Highcharts.Color#init
         *
         * @param {Highcharts.ColorType} input
         * The input color in either rbga or hex format
         */
        init(input) {
            let result, rgba, i, parser;
            // Gradients
            if (typeof input === 'object' &&
                typeof input.stops !== 'undefined') {
                this.stops = input.stops.map((stop) => new Color(stop[1]));
                // Solid colors
            }
            else if (typeof input === 'string') {
                this.input = input = (Color.names[input.toLowerCase()] || input);
                // Bitmasking as input[0] is not working for legacy IE.
                if (input.charAt(0) === '#') {
                    const len = input.length, col = parseInt(input.substr(1), 16);
                    // Handle long-form, e.g. #AABBCC
                    if (len === 7) {
                        rgba = [
                            (col & 0xFF0000) >> 16,
                            (col & 0xFF00) >> 8,
                            (col & 0xFF),
                            1
                        ];
                        // Handle short-form, e.g. #ABC
                        // In short form, the value is assumed to be the same
                        // for both nibbles for each component. e.g. #ABC = #AABBCC
                    }
                    else if (len === 4) {
                        rgba = [
                            (((col & 0xF00) >> 4) |
                                (col & 0xF00) >> 8),
                            (((col & 0xF0) >> 4) |
                                (col & 0xF0)),
                            ((col & 0xF) << 4) | (col & 0xF),
                            1
                        ];
                    }
                }
                // Otherwise, check regex parsers
                if (!rgba) {
                    i = Color.parsers.length;
                    while (i-- && !rgba) {
                        parser = Color.parsers[i];
                        result = parser.regex.exec(input);
                        if (result) {
                            rgba = parser.parse(result);
                        }
                    }
                }
            }
            if (rgba) {
                this.rgba = rgba;
            }
        }
        /**
         * Return the color or gradient stops in the specified format
         *
         * @function Highcharts.Color#get
         *
         * @param {string} [format]
         * Possible values are 'a', 'rgb', 'rgba' (default).
         *
         * @return {Highcharts.ColorType}
         * This color as a string or gradient stops.
         */
        get(format) {
            const input = this.input, rgba = this.rgba;
            if (typeof input === 'object' &&
                typeof this.stops !== 'undefined') {
                const ret = merge$e(input);
                ret.stops = [].slice.call(ret.stops);
                this.stops.forEach((stop, i) => {
                    ret.stops[i] = [
                        ret.stops[i][0],
                        stop.get(format)
                    ];
                });
                return ret;
            }
            // it's NaN if gradient colors on a column chart
            if (rgba && isNumber$c(rgba[0])) {
                if (format === 'rgb' || (!format && rgba[3] === 1)) {
                    return 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
                }
                if (format === 'a') {
                    return `${rgba[3]}`;
                }
                return 'rgba(' + rgba.join(',') + ')';
            }
            return input;
        }
        /**
         * Brighten the color instance.
         *
         * @function Highcharts.Color#brighten
         *
         * @param {number} alpha
         * The alpha value.
         *
         * @return {Highcharts.Color}
         * This color with modifications.
         */
        brighten(alpha) {
            const rgba = this.rgba;
            if (this.stops) {
                this.stops.forEach(function (stop) {
                    stop.brighten(alpha);
                });
            }
            else if (isNumber$c(alpha) && alpha !== 0) {
                for (let i = 0; i < 3; i++) {
                    rgba[i] += pInt$4(alpha * 255);
                    if (rgba[i] < 0) {
                        rgba[i] = 0;
                    }
                    if (rgba[i] > 255) {
                        rgba[i] = 255;
                    }
                }
            }
            return this;
        }
        /**
         * Set the color's opacity to a given alpha value.
         *
         * @function Highcharts.Color#setOpacity
         *
         * @param {number} alpha
         *        Opacity between 0 and 1.
         *
         * @return {Highcharts.Color}
         *         Color with modifications.
         */
        setOpacity(alpha) {
            this.rgba[3] = alpha;
            return this;
        }
        /**
         * Return an intermediate color between two colors.
         *
         * @function Highcharts.Color#tweenTo
         *
         * @param {Highcharts.Color} to
         * The color object to tween to.
         *
         * @param {number} pos
         * The intermediate position, where 0 is the from color (current color
         * item), and 1 is the `to` color.
         *
         * @return {Highcharts.ColorType}
         * The intermediate color in rgba notation, or unsupported type.
         */
        tweenTo(to, pos) {
            const fromRgba = this.rgba, toRgba = to.rgba;
            // Unsupported color, return to-color (#3920, #7034)
            if (!isNumber$c(fromRgba[0]) || !isNumber$c(toRgba[0])) {
                return to.input || 'none';
            }
            // Check for has alpha, because rgba colors perform worse due to
            // lack of support in WebKit.
            const hasAlpha = (toRgba[3] !== 1 || fromRgba[3] !== 1);
            return (hasAlpha ? 'rgba(' : 'rgb(') +
                Math.round(toRgba[0] + (fromRgba[0] - toRgba[0]) * (1 - pos)) +
                ',' +
                Math.round(toRgba[1] + (fromRgba[1] - toRgba[1]) * (1 - pos)) +
                ',' +
                Math.round(toRgba[2] + (fromRgba[2] - toRgba[2]) * (1 - pos)) +
                (hasAlpha ?
                    (',' +
                        (toRgba[3] + (fromRgba[3] - toRgba[3]) * (1 - pos))) :
                    '') +
                ')';
        }
    }
    /* *
     *
     *  Static Properties
     *
     * */
    /**
     * Collection of named colors. Can be extended from the outside by adding
     * colors to Highcharts.Color.names.
     * @private
     */
    Color.names = {
        white: '#ffffff',
        black: '#000000'
    };
    /**
     * Collection of parsers. This can be extended from the outside by pushing
     * parsers to `Color.parsers`.
     */
    Color.parsers = [{
            // RGBA color
            // eslint-disable-next-line max-len
            regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
            parse: function (result) {
                return [
                    pInt$4(result[1]),
                    pInt$4(result[2]),
                    pInt$4(result[3]),
                    parseFloat(result[4], 10)
                ];
            }
        }, {
            // RGB color
            regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
            parse: function (result) {
                return [pInt$4(result[1]), pInt$4(result[2]), pInt$4(result[3]), 1];
            }
        }];
    // Must be last static member for init cycle
    Color.None = new Color('');

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { parse: color$1 } = Color;
    const { win: win$7 } = H;
    const { isNumber: isNumber$b, objectEach: objectEach$c } = Utilities;
    /* eslint-disable no-invalid-this, valid-jsdoc */
    /* *
     *
     *  Class
     *
     * */
    /**
     * An animator object used internally. One instance applies to one property
     * (attribute or style prop) on one element. Animation is always initiated
     * through {@link SVGElement#animate}.
     *
     * @example
     * let rect = renderer.rect(0, 0, 10, 10).add();
     * rect.animate({ width: 100 });
     *
     * @private
     * @class
     * @name Highcharts.Fx
     *
     * @param {Highcharts.HTMLDOMElement|Highcharts.SVGElement} elem
     * The element to animate.
     *
     * @param {Partial<Highcharts.AnimationOptionsObject>} options
     * Animation options.
     *
     * @param {string} prop
     * The single attribute or CSS property to animate.
     */
    class Fx {
        /* *
         *
         *  Constructors
         *
         * */
        constructor(elem, options, prop) {
            this.pos = NaN;
            this.options = options;
            this.elem = elem;
            this.prop = prop;
        }
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Set the current step of a path definition on SVGElement.
         *
         * @function Highcharts.Fx#dSetter
         *
         */
        dSetter() {
            const paths = this.paths, start = paths && paths[0], end = paths && paths[1], now = this.now || 0;
            let path = [];
            // Land on the final path without adjustment points appended in the ends
            if (now === 1 || !start || !end) {
                path = this.toD || [];
            }
            else if (start.length === end.length && now < 1) {
                for (let i = 0; i < end.length; i++) {
                    // Tween between the start segment and the end segment. Start
                    // with a copy of the end segment and tween the appropriate
                    // numerics
                    const startSeg = start[i];
                    const endSeg = end[i];
                    const tweenSeg = [];
                    for (let j = 0; j < endSeg.length; j++) {
                        const startItem = startSeg[j];
                        const endItem = endSeg[j];
                        // Tween numbers
                        if (isNumber$b(startItem) &&
                            isNumber$b(endItem) &&
                            // Arc boolean flags
                            !(endSeg[0] === 'A' && (j === 4 || j === 5))) {
                            tweenSeg[j] = startItem + now * (endItem - startItem);
                            // Strings, take directly from the end segment
                        }
                        else {
                            tweenSeg[j] = endItem;
                        }
                    }
                    path.push(tweenSeg);
                }
                // If animation is finished or length not matching, land on right value
            }
            else {
                path = end;
            }
            this.elem.attr('d', path, void 0, true);
        }
        /**
         * Update the element with the current animation step.
         *
         * @function Highcharts.Fx#update
         *
         */
        update() {
            const elem = this.elem, prop = this.prop, // if destroyed, it is null
            now = this.now, step = this.options.step;
            // Animation setter defined from outside
            if (this[prop + 'Setter']) {
                this[prop + 'Setter']();
                // Other animations on SVGElement
            }
            else if (elem.attr) {
                if (elem.element) {
                    elem.attr(prop, now, null, true);
                }
                // HTML styles, raw HTML content like container size
            }
            else {
                elem.style[prop] = now + this.unit;
            }
            if (step) {
                step.call(elem, now, this);
            }
        }
        /**
         * Run an animation.
         *
         * @function Highcharts.Fx#run
         *
         * @param {number} from
         *        The current value, value to start from.
         *
         * @param {number} to
         *        The end value, value to land on.
         *
         * @param {string} unit
         *        The property unit, for example `px`.
         *
         */
        run(from, to, unit) {
            const self = this, options = self.options, timer = function (gotoEnd) {
                return timer.stopped ? false : self.step(gotoEnd);
            }, requestAnimationFrame = win$7.requestAnimationFrame ||
                function (step) {
                    setTimeout(step, 13);
                }, step = function () {
                for (let i = 0; i < Fx.timers.length; i++) {
                    if (!Fx.timers[i]()) {
                        Fx.timers.splice(i--, 1);
                    }
                }
                if (Fx.timers.length) {
                    requestAnimationFrame(step);
                }
            };
            if (from === to && !this.elem['forceAnimate:' + this.prop]) {
                delete options.curAnim[this.prop];
                if (options.complete &&
                    Object.keys(options.curAnim).length === 0) {
                    options.complete.call(this.elem);
                }
            }
            else { // #7166
                this.startTime = +new Date();
                this.start = from;
                this.end = to;
                this.unit = unit;
                this.now = this.start;
                this.pos = 0;
                timer.elem = this.elem;
                timer.prop = this.prop;
                if (timer() && Fx.timers.push(timer) === 1) {
                    requestAnimationFrame(step);
                }
            }
        }
        /**
         * Run a single step in the animation.
         *
         * @function Highcharts.Fx#step
         *
         * @param {boolean} [gotoEnd]
         *        Whether to go to the endpoint of the animation after abort.
         *
         * @return {boolean}
         *         Returns `true` if animation continues.
         */
        step(gotoEnd) {
            const t = +new Date(), options = this.options, elem = this.elem, complete = options.complete, duration = options.duration, curAnim = options.curAnim;
            let ret, done;
            if ((elem.attr) && !elem.element) { // #2616, element is destroyed
                ret = false;
            }
            else if (gotoEnd || t >= duration + this.startTime) {
                this.now = this.end;
                this.pos = 1;
                this.update();
                curAnim[this.prop] = true;
                done = true;
                objectEach$c(curAnim, function (val) {
                    if (val !== true) {
                        done = false;
                    }
                });
                if (done && complete) {
                    complete.call(elem);
                }
                ret = false;
            }
            else {
                this.pos = options.easing((t - this.startTime) / duration);
                this.now = this.start + ((this.end -
                    this.start) * this.pos);
                this.update();
                ret = true;
            }
            return ret;
        }
        /**
         * Prepare start and end values so that the path can be animated one to one.
         *
         * @function Highcharts.Fx#initPath
         *
         * @param {Highcharts.SVGElement} elem
         *        The SVGElement item.
         *
         * @param {Highcharts.SVGPathArray|undefined} fromD
         *        Starting path definition.
         *
         * @param {Highcharts.SVGPathArray} toD
         *        Ending path definition.
         *
         * @return {Array<Highcharts.SVGPathArray,Highcharts.SVGPathArray>}
         *         An array containing start and end paths in array form so that
         *         they can be animated in parallel.
         */
        initPath(elem, fromD, toD) {
            const startX = elem.startX, endX = elem.endX, end = toD.slice(), // copy
            isArea = elem.isArea, positionFactor = isArea ? 2 : 1;
            let shift, fullLength, i, reverse, start = fromD && fromD.slice(); // copy
            if (!start) {
                return [end, end];
            }
            /**
             * If shifting points, prepend a dummy point to the end path.
             * @private
             */
            function prepend(arr, other) {
                while (arr.length < fullLength) {
                    // Move to, line to or curve to?
                    const moveSegment = arr[0], otherSegment = other[fullLength - arr.length];
                    if (otherSegment && moveSegment[0] === 'M') {
                        if (otherSegment[0] === 'C') {
                            arr[0] = [
                                'C',
                                moveSegment[1],
                                moveSegment[2],
                                moveSegment[1],
                                moveSegment[2],
                                moveSegment[1],
                                moveSegment[2]
                            ];
                        }
                        else {
                            arr[0] = ['L', moveSegment[1], moveSegment[2]];
                        }
                    }
                    // Prepend a copy of the first point
                    arr.unshift(moveSegment);
                    // For areas, the bottom path goes back again to the left, so we
                    // need to append a copy of the last point.
                    if (isArea) {
                        const z = arr.pop();
                        arr.push(arr[arr.length - 1], z); // append point and the Z
                    }
                }
            }
            /**
             * Copy and append last point until the length matches the end length.
             * @private
             */
            function append(arr, other) {
                while (arr.length < fullLength) {
                    // Pull out the slice that is going to be appended or inserted.
                    // In a line graph, the positionFactor is 1, and the last point
                    // is sliced out. In an area graph, the positionFactor is 2,
                    // causing the middle two points to be sliced out, since an area
                    // path starts at left, follows the upper path then turns and
                    // follows the bottom back.
                    const segmentToAdd = arr[Math.floor(arr.length / positionFactor) - 1].slice();
                    // Disable the first control point of curve segments
                    if (segmentToAdd[0] === 'C') {
                        segmentToAdd[1] = segmentToAdd[5];
                        segmentToAdd[2] = segmentToAdd[6];
                    }
                    if (!isArea) {
                        arr.push(segmentToAdd);
                    }
                    else {
                        const lowerSegmentToAdd = arr[Math.floor(arr.length / positionFactor)].slice();
                        arr.splice(arr.length / 2, 0, segmentToAdd, lowerSegmentToAdd);
                    }
                }
            }
            // For sideways animation, find out how much we need to shift to get the
            // start path Xs to match the end path Xs.
            if (startX && endX && endX.length) {
                for (i = 0; i < startX.length; i++) {
                    // Moving left, new points coming in on right
                    if (startX[i] === endX[0]) {
                        shift = i;
                        break;
                        // Moving right
                    }
                    else if (startX[0] ===
                        endX[endX.length - startX.length + i]) {
                        shift = i;
                        reverse = true;
                        break;
                        // Fixed from the right side, "scaling" left
                    }
                    else if (startX[startX.length - 1] ===
                        endX[endX.length - startX.length + i]) {
                        shift = startX.length - i;
                        break;
                    }
                }
                if (typeof shift === 'undefined') {
                    start = [];
                }
            }
            if (start.length && isNumber$b(shift)) {
                // The common target length for the start and end array, where both
                // arrays are padded in opposite ends
                fullLength = end.length + shift * positionFactor;
                if (!reverse) {
                    prepend(end, start);
                    append(start);
                }
                else {
                    prepend(start, end);
                    append(end);
                }
            }
            return [start, end];
        }
        /**
         * Handle animation of the color attributes directly.
         *
         * @function Highcharts.Fx#fillSetter
         *
         */
        fillSetter() {
            Fx.prototype.strokeSetter.apply(this, arguments);
        }
        /**
         * Handle animation of the color attributes directly.
         *
         * @function Highcharts.Fx#strokeSetter
         *
         */
        strokeSetter() {
            this.elem.attr(this.prop, color$1(this.start).tweenTo(color$1(this.end), this.pos), void 0, true);
        }
    }
    /* *
     *
     *  Static Properties
     *
     * */
    Fx.timers = [];

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { defined: defined$b, getStyle: getStyle$1, isArray: isArray$8, isNumber: isNumber$a, isObject: isObject$6, merge: merge$d, objectEach: objectEach$b, pick: pick$e } = Utilities;
    /* *
     *
     *  Functions
     *
     * */
    /**
     * Set the global animation to either a given value, or fall back to the given
     * chart's animation option.
     *
     * @function Highcharts.setAnimation
     *
     * @param {boolean|Partial<Highcharts.AnimationOptionsObject>|undefined} animation
     *        The animation object.
     *
     * @param {Highcharts.Chart} chart
     *        The chart instance.
     *
     * @todo
     * This function always relates to a chart, and sets a property on the renderer,
     * so it should be moved to the SVGRenderer.
     */
    function setAnimation$2(animation, chart) {
        chart.renderer.globalAnimation = pick$e(animation, chart.options.chart.animation, true);
    }
    /**
     * Get the animation in object form, where a disabled animation is always
     * returned as `{ duration: 0 }`.
     *
     * @function Highcharts.animObject
     *
     * @param {boolean|Highcharts.AnimationOptionsObject} [animation=0]
     *        An animation setting. Can be an object with duration, complete and
     *        easing properties, or a boolean to enable or disable.
     *
     * @return {Highcharts.AnimationOptionsObject}
     *         An object with at least a duration property.
     */
    function animObject$6(animation) {
        return isObject$6(animation) ?
            merge$d({ duration: 500, defer: 0 }, animation) :
            { duration: animation ? 500 : 0, defer: 0 };
    }
    /**
     * Get the defer as a number value from series animation options.
     *
     * @function Highcharts.getDeferredAnimation
     *
     * @param {Highcharts.Chart} chart
     *        The chart instance.
     *
     * @param {boolean|Highcharts.AnimationOptionsObject} animation
     *        An animation setting. Can be an object with duration, complete and
     *        easing properties, or a boolean to enable or disable.
     *
     * @param {Highcharts.Series} [series]
     *        Series to defer animation.
     *
     * @return {number}
     *        The numeric value.
     */
    function getDeferredAnimation(chart, animation, series) {
        const labelAnimation = animObject$6(animation), s = series ? [series] : chart.series;
        let defer = 0, duration = 0;
        s.forEach((series) => {
            const seriesAnim = animObject$6(series.options.animation);
            defer = animation && defined$b(animation.defer) ?
                labelAnimation.defer :
                Math.max(defer, seriesAnim.duration + seriesAnim.defer);
            duration = Math.min(labelAnimation.duration, seriesAnim.duration);
        });
        // Disable defer for exporting
        if (chart.renderer.forExport) {
            defer = 0;
        }
        const anim = {
            defer: Math.max(0, defer - duration),
            duration: Math.min(defer, duration)
        };
        return anim;
    }
    /**
     * The global animate method, which uses Fx to create individual animators.
     *
     * @function Highcharts.animate
     *
     * @param {Highcharts.HTMLDOMElement|Highcharts.SVGElement} el
     *        The element to animate.
     *
     * @param {Highcharts.CSSObject|Highcharts.SVGAttributes} params
     *        An object containing key-value pairs of the properties to animate.
     *        Supports numeric as pixel-based CSS properties for HTML objects and
     *        attributes for SVGElements.
     *
     * @param {Partial<Highcharts.AnimationOptionsObject>} [opt]
     *        Animation options.
     *
     * @return {void}
     */
    function animate$2(el, params, opt) {
        let start, unit = '', end, fx, args;
        if (!isObject$6(opt)) { // Number or undefined/null
            args = arguments;
            opt = {
                duration: args[2],
                easing: args[3],
                complete: args[4]
            };
        }
        if (!isNumber$a(opt.duration)) {
            opt.duration = 400;
        }
        opt.easing = typeof opt.easing === 'function' ?
            opt.easing :
            (Math[opt.easing] || Math.easeInOutSine);
        opt.curAnim = merge$d(params);
        objectEach$b(params, function (val, prop) {
            // Stop current running animation of this property
            stop$1(el, prop);
            fx = new Fx(el, opt, prop);
            end = void 0;
            if (prop === 'd' && isArray$8(params.d)) {
                fx.paths = fx.initPath(el, el.pathArray, params.d);
                fx.toD = params.d;
                start = 0;
                end = 1;
            }
            else if (el.attr) {
                start = el.attr(prop);
            }
            else {
                start = parseFloat(getStyle$1(el, prop)) || 0;
                if (prop !== 'opacity') {
                    unit = 'px';
                }
            }
            if (!end) {
                end = val;
            }
            if (typeof end === 'string' && end.match('px')) {
                end = end.replace(/px/g, ''); // #4351
            }
            fx.run(start, end, unit);
        });
    }
    /**
     * Stop running animation.
     *
     * @function Highcharts.stop
     *
     * @param {Highcharts.SVGElement} el
     *        The SVGElement to stop animation on.
     *
     * @param {string} [prop]
     *        The property to stop animating. If given, the stop method will stop a
     *        single property from animating, while others continue.
     *
     * @return {void}
     *
     * @todo
     * A possible extension to this would be to stop a single property, when
     * we want to continue animating others. Then assign the prop to the timer
     * in the Fx.run method, and check for the prop here. This would be an
     * improvement in all cases where we stop the animation from .attr. Instead of
     * stopping everything, we can just stop the actual attributes we're setting.
     */
    function stop$1(el, prop) {
        let i = Fx.timers.length;
        // Remove timers related to this element (#4519)
        while (i--) {
            if (Fx.timers[i].elem === el && (!prop || prop === Fx.timers[i].prop)) {
                Fx.timers[i].stopped = true; // #4667
            }
        }
    }
    const animationExports = {
        animate: animate$2,
        animObject: animObject$6,
        getDeferredAnimation,
        setAnimation: setAnimation$2,
        stop: stop$1
    };

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    /* *
     *
     *  Namespace
     *
     * */
    var AxisDefaults;
    (function (AxisDefaults) {
        /* *
         *
         *  Constants
         *
         * */
        /**
         * The X axis or category axis. Normally this is the horizontal axis,
         * though if the chart is inverted this is the vertical axis. In case of
         * multiple axes, the xAxis node is an array of configuration objects.
         *
         * See the [Axis class](/class-reference/Highcharts.Axis) for programmatic
         * access to the axis.
         *
         * @productdesc {highmaps}
         * In Highmaps, the axis is hidden, but it is used behind the scenes to
         * control features like zooming and panning. Zooming is in effect the same
         * as setting the extremes of one of the exes.
         *
         * @type         {*|Array<*>}
         * @optionparent xAxis
         */
        AxisDefaults.defaultXAxisOptions = {
            /**
             * When using multiple axis, the ticks of two or more opposite axes
             * will automatically be aligned by adding ticks to the axis or axes
             * with the least ticks, as if `tickAmount` were specified.
             *
             * This can be prevented by setting `alignTicks` to false. If the grid
             * lines look messy, it's a good idea to hide them for the secondary
             * axis by setting `gridLineWidth` to 0.
             *
             * If `startOnTick` or `endOnTick` in an Axis options are set to false,
             * then the `alignTicks ` will be disabled for the Axis.
             *
             * Disabled for logarithmic axes.
             *
             * @product   highcharts highstock gantt
             */
            alignTicks: true,
            /**
             * Whether to allow decimals in this axis' ticks. When counting
             * integers, like persons or hits on a web page, decimals should
             * be avoided in the labels. By default, decimals are allowed on small
             * scale axes.
             *
             * @see [minTickInterval](#xAxis.minTickInterval)
             *
             * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-true/
             *         True by default
             * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-false/
             *         False
             *
             * @type      {boolean|undefined}
             * @default   undefined
             * @since     2.0
             */
            allowDecimals: void 0,
            /**
             * When using an alternate grid color, a band is painted across the
             * plot area between every other grid line.
             *
             * @sample {highcharts} highcharts/yaxis/alternategridcolor/
             *         Alternate grid color on the Y axis
             * @sample {highstock} stock/xaxis/alternategridcolor/
             *         Alternate grid color on the Y axis
             *
             * @type      {Highcharts.ColorType}
             * @apioption xAxis.alternateGridColor
             */
            /**
             * An array defining breaks in the axis, the sections defined will be
             * left out and all the points shifted closer to each other.
             *
             * @productdesc {highcharts}
             * Requires that the broken-axis.js module is loaded.
             *
             * @sample {highcharts} highcharts/axisbreak/break-simple/
             *         Simple break
             * @sample {highcharts|highstock} highcharts/axisbreak/break-visualized/
             *         Advanced with callback
             * @sample {highstock} stock/demo/intraday-breaks/
             *         Break on nights and weekends
             *
             * @type      {Array<*>}
             * @since     4.1.0
             * @product   highcharts highstock gantt
             * @apioption xAxis.breaks
             */
            /**
             * A number indicating how much space should be left between the start
             * and the end of the break. The break size is given in axis units,
             * so for instance on a `datetime` axis, a break size of 3600000 would
             * indicate the equivalent of an hour.
             *
             * @type      {number}
             * @default   0
             * @since     4.1.0
             * @product   highcharts highstock gantt
             * @apioption xAxis.breaks.breakSize
             */
            /**
             * The point where the break starts.
             *
             * @type      {number}
             * @since     4.1.0
             * @product   highcharts highstock gantt
             * @apioption xAxis.breaks.from
             */
            /**
             * Defines an interval after which the break appears again. By default
             * the breaks do not repeat.
             *
             * @type      {number}
             * @default   0
             * @since     4.1.0
             * @product   highcharts highstock gantt
             * @apioption xAxis.breaks.repeat
             */
            /**
             * The point where the break ends.
             *
             * @type      {number}
             * @since     4.1.0
             * @product   highcharts highstock gantt
             * @apioption xAxis.breaks.to
             */
            /**
             * If categories are present for the xAxis, names are used instead of
             * numbers for that axis.
             *
             * Since Highcharts 3.0, categories can also
             * be extracted by giving each point a [name](#series.data) and setting
             * axis [type](#xAxis.type) to `category`. However, if you have multiple
             * series, best practice remains defining the `categories` array.
             *
             * Example: `categories: ['Apples', 'Bananas', 'Oranges']`
             *
             * @sample {highcharts} highcharts/demo/line-labels/
             *         With
             * @sample {highcharts} highcharts/xaxis/categories/
             *         Without
             *
             * @type      {Array<string>}
             * @product   highcharts gantt
             * @apioption xAxis.categories
             */
            /**
             * The highest allowed value for automatically computed axis extremes.
             *
             * @see [floor](#xAxis.floor)
             *
             * @sample {highcharts|highstock} highcharts/yaxis/floor-ceiling/
             *         Floor and ceiling
             *
             * @type       {number}
             * @since      4.0
             * @product    highcharts highstock gantt
             * @apioption  xAxis.ceiling
             */
            /**
             * A class name that opens for styling the axis by CSS, especially in
             * Highcharts styled mode. The class name is applied to group elements
             * for the grid, axis elements and labels.
             *
             * @sample {highcharts|highstock|highmaps} highcharts/css/axis/
             *         Multiple axes with separate styling
             *
             * @type      {string}
             * @since     5.0.0
             * @apioption xAxis.className
             */
            /**
             * Configure a crosshair that follows either the mouse pointer or the
             * hovered point.
             *
             * In styled mode, the crosshairs are styled in the
             * `.highcharts-crosshair`, `.highcharts-crosshair-thin` or
             * `.highcharts-xaxis-category` classes.
             *
             * @productdesc {highstock}
             * In Highcharts stock, by default, the crosshair is enabled on the
             * X axis and disabled on the Y axis.
             *
             * @sample {highcharts} highcharts/xaxis/crosshair-both/
             *         Crosshair on both axes
             * @sample {highstock} stock/xaxis/crosshairs-xy/
             *         Crosshair on both axes, with y axis label
             * @sample {highmaps} highcharts/xaxis/crosshair-both/
             *         Crosshair on both axes
             *
             * @declare   Highcharts.AxisCrosshairOptions
             * @type      {boolean|*}
             * @default   false
             * @since     4.1
             * @apioption xAxis.crosshair
             */
            /**
             * The value on a perpendicular axis where this axis should cross. This
             * is typically used on mathematical plots where the axes cross at 0.
             * When `crossing` is set, space will not be reserved at the sides of
             * the chart for axis labels and title, so those may be clipped. In this
             * case it is better to place the axes without the `crossing` option.
             *
             * @type      {number}
             * @sample    highcharts/xaxis/crossing
             *            Function plot with axes crossing at 0
             * @since 11.0.1
             * @apioption xAxis.crossing
             */
            /**
             * A class name for the crosshair, especially as a hook for styling.
             *
             * @type      {string}
             * @since     5.0.0
             * @apioption xAxis.crosshair.className
             */
            /**
             * The color of the crosshair. Defaults to `#cccccc` for numeric and
             * datetime axes, and `rgba(204,214,235,0.25)` for category axes, where
             * the crosshair by default highlights the whole category.
             *
             * @sample {highcharts|highstock|highmaps} highcharts/xaxis/crosshair-customized/
             *         Customized crosshairs
             *
             * @type      {Highcharts.ColorType}
             * @default   #cccccc
             * @since     4.1
             * @apioption xAxis.crosshair.color
             */
            /**
             * The dash style for the crosshair. See
             * [plotOptions.series.dashStyle](#plotOptions.series.dashStyle)
             * for possible values.
             *
             * @sample {highcharts|highmaps} highcharts/xaxis/crosshair-dotted/
             *         Dotted crosshair
             * @sample {highstock} stock/xaxis/crosshair-dashed/
             *         Dashed X axis crosshair
             *
             * @type      {Highcharts.DashStyleValue}
             * @default   Solid
             * @since     4.1
             * @apioption xAxis.crosshair.dashStyle
             */
            /**
             * A label on the axis next to the crosshair.
             *
             * In styled mode, the label is styled with the
             * `.highcharts-crosshair-label` class.
             *
             * @sample {highstock} stock/xaxis/crosshair-label/
             *         Crosshair labels
             * @sample {highstock} highcharts/css/crosshair-label/
             *         Style mode
             *
             * @declare   Highcharts.AxisCrosshairLabelOptions
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label
             */
            /**
             * Alignment of the label compared to the axis. Defaults to `"left"` for
             * right-side axes, `"right"` for left-side axes and `"center"` for
             * horizontal axes.
             *
             * @type      {Highcharts.AlignValue}
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label.align
             */
            /**
             * The background color for the label. Defaults to the related series
             * color, or `#666666` if that is not available.
             *
             * @type      {Highcharts.ColorType}
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label.backgroundColor
             */
            /**
             * The border color for the crosshair label
             *
             * @type      {Highcharts.ColorType}
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label.borderColor
             */
            /**
             * The border corner radius of the crosshair label.
             *
             * @type      {number}
             * @default   3
             * @since     2.1.10
             * @product   highstock
             * @apioption xAxis.crosshair.label.borderRadius
             */
            /**
             * The border width for the crosshair label.
             *
             * @type      {number}
             * @default   0
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label.borderWidth
             */
            /**
             * Flag to enable crosshair's label.
             *
             * @sample {highstock} stock/xaxis/crosshairs-xy/
             *         Enabled label for yAxis' crosshair
             *
             * @type      {boolean}
             * @default   false
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label.enabled
             */
            /**
             * A format string for the crosshair label. Defaults to `{value}` for
             * numeric axes and `{value:%b %d, %Y}` for datetime axes.
             *
             * @type      {string}
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label.format
             */
            /**
             * Formatter function for the label text.
             *
             * @type      {Highcharts.XAxisCrosshairLabelFormatterCallbackFunction}
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label.formatter
             */
            /**
             * Padding inside the crosshair label.
             *
             * @type      {number}
             * @default   8
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label.padding
             */
            /**
             * The shape to use for the label box.
             *
             * @type      {string}
             * @default   callout
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label.shape
             */
            /**
             * Text styles for the crosshair label.
             *
             * @type      {Highcharts.CSSObject}
             * @default   {"color": "white", "fontWeight": "normal", "fontSize": "11px", "textAlign": "center"}
             * @since     2.1
             * @product   highstock
             * @apioption xAxis.crosshair.label.style
             */
            /**
             * Whether the crosshair should snap to the point or follow the pointer
             * independent of points.
             *
             * @sample {highcharts|highstock} highcharts/xaxis/crosshair-snap-false/
             *         True by default
             * @sample {highmaps} maps/demo/latlon-advanced/
             *         Snap is false
             *
             * @type      {boolean}
             * @default   true
             * @since     4.1
             * @apioption xAxis.crosshair.snap
             */
            /**
             * The pixel width of the crosshair. Defaults to 1 for numeric or
             * datetime axes, and for one category width for category axes.
             *
             * @sample {highcharts} highcharts/xaxis/crosshair-customized/
             *         Customized crosshairs
             * @sample {highstock} highcharts/xaxis/crosshair-customized/
             *         Customized crosshairs
             * @sample {highmaps} highcharts/xaxis/crosshair-customized/
             *         Customized crosshairs
             *
             * @type      {number}
             * @default   1
             * @since     4.1
             * @apioption xAxis.crosshair.width
             */
            /**
             * The Z index of the crosshair. Higher Z indices allow drawing the
             * crosshair on top of the series or behind the grid lines.
             *
             * @type      {number}
             * @default   2
             * @since     4.1
             * @apioption xAxis.crosshair.zIndex
             */
            /**
             * Whether to pan axis. If `chart.panning` is enabled, the option
             * allows to disable panning on an individual axis.
             */
            panningEnabled: true,
            /**
             * The Z index for the axis group.
             */
            zIndex: 2,
            /**
             * Whether to zoom axis. If `chart.zoomType` is set, the option allows
             * to disable zooming on an individual axis.
             *
             * @sample {highcharts} highcharts/xaxis/zoomenabled/
             *         Zoom enabled is false
             */
            zoomEnabled: true,
            /**
             * For a datetime axis, the scale will automatically adjust to the
             * appropriate unit. This member gives the default string
             * representations used for each unit. For intermediate values,
             * different units may be used, for example the `day` unit can be used
             * on midnight and `hour` unit be used for intermediate values on the
             * same axis.
             *
             * For an overview of the replacement codes, see
             * [dateFormat](/class-reference/Highcharts.Time#dateFormat).
             *
             * Defaults to:
             * ```js
             * {
             *     millisecond: '%H:%M:%S.%L',
             *     second: '%H:%M:%S',
             *     minute: '%H:%M',
             *     hour: '%H:%M',
             *     day: '%e. %b',
             *     week: '%e. %b',
             *     month: '%b \'%y',
             *     year: '%Y'
             * }
             * ```
             *
             * @sample {highcharts} highcharts/xaxis/datetimelabelformats/
             *         Different day format on X axis
             * @sample {highstock} stock/xaxis/datetimelabelformats/
             *         More information in x axis labels
             *
             * @declare Highcharts.AxisDateTimeLabelFormatsOptions
             * @product highcharts highstock gantt
             */
            dateTimeLabelFormats: {
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                millisecond: {
                    main: '%H:%M:%S.%L',
                    range: false
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                second: {
                    main: '%H:%M:%S',
                    range: false
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                minute: {
                    main: '%H:%M',
                    range: false
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                hour: {
                    main: '%H:%M',
                    range: false
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                day: {
                    main: '%e %b'
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                week: {
                    main: '%e %b'
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                month: {
                    main: '%b \'%y'
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                year: {
                    main: '%Y'
                }
            },
            /**
             * Whether to force the axis to end on a tick. Use this option with
             * the `maxPadding` option to control the axis end.
             *
             * @productdesc {highstock}
             * In Highcharts Stock, `endOnTick` is always `false` when the navigator
             * is enabled, to prevent jumpy scrolling.
             *
             * @sample {highcharts} highcharts/yaxis/endontick/
             *         True by default
             * @sample {highcharts} highcharts/yaxis/endontick-false/
             *         False
             * @sample {highstock} stock/demo/basic-line/
             *         True by default
             * @sample {highstock} stock/xaxis/endontick/
             *         False
             *
             * @since 1.2.0
             */
            endOnTick: false,
            /**
             * Event handlers for the axis.
             *
             * @type      {*}
             * @apioption xAxis.events
             */
            /**
             * An event fired after the breaks have rendered.
             *
             * @see [breaks](#xAxis.breaks)
             *
             * @sample {highcharts} highcharts/axisbreak/break-event/
             *         AfterBreak Event
             *
             * @type      {Highcharts.AxisEventCallbackFunction}
             * @since     4.1.0
             * @product   highcharts gantt
             * @apioption xAxis.events.afterBreaks
             */
            /**
             * As opposed to the `setExtremes` event, this event fires after the
             * final min and max values are computed and corrected for `minRange`.
             *
             * Fires when the minimum and maximum is set for the axis, either by
             * calling the `.setExtremes()` method or by selecting an area in the
             * chart. One parameter, `event`, is passed to the function, containing
             * common event information.
             *
             * The new user set minimum and maximum values can be found by
             * `event.min` and `event.max`. These reflect the axis minimum and
             * maximum in axis values. The actual data extremes are found in
             * `event.dataMin` and `event.dataMax`.
             *
             * @type      {Highcharts.AxisSetExtremesEventCallbackFunction}
             * @since     2.3
             * @context   Highcharts.Axis
             * @apioption xAxis.events.afterSetExtremes
             */
            /**
             * An event fired when a break from this axis occurs on a point.
             *
             * @see [breaks](#xAxis.breaks)
             *
             * @sample {highcharts} highcharts/axisbreak/break-visualized/
             *         Visualization of a Break
             *
             * @type      {Highcharts.AxisPointBreakEventCallbackFunction}
             * @since     4.1.0
             * @product   highcharts gantt
             * @context   Highcharts.Axis
             * @apioption xAxis.events.pointBreak
             */
            /**
             * An event fired when a point falls inside a break from this axis.
             *
             * @type      {Highcharts.AxisPointBreakEventCallbackFunction}
             * @product   highcharts highstock gantt
             * @context   Highcharts.Axis
             * @apioption xAxis.events.pointInBreak
             */
            /**
             * Fires when the minimum and maximum is set for the axis, either by
             * calling the `.setExtremes()` method or by selecting an area in the
             * chart. One parameter, `event`, is passed to the function,
             * containing common event information.
             *
             * The new user set minimum and maximum values can be found by
             * `event.min` and `event.max`. These reflect the axis minimum and
             * maximum in data values. When an axis is zoomed all the way out from
             * the "Reset zoom" button, `event.min` and `event.max` are null, and
             * the new extremes are set based on `this.dataMin` and `this.dataMax`.
             *
             * @sample {highstock} stock/xaxis/events-setextremes/
             *         Log new extremes on x axis
             *
             * @type      {Highcharts.AxisSetExtremesEventCallbackFunction}
             * @since     1.2.0
             * @context   Highcharts.Axis
             * @apioption xAxis.events.setExtremes
             */
            /**
             * The lowest allowed value for automatically computed axis extremes.
             *
             * @see [ceiling](#yAxis.ceiling)
             *
             * @sample {highcharts} highcharts/yaxis/floor-ceiling/
             *         Floor and ceiling
             * @sample {highstock} stock/demo/lazy-loading/
             *         Prevent negative stock price on Y axis
             *
             * @type      {number}
             * @since     4.0
             * @product   highcharts highstock gantt
             * @apioption xAxis.floor
             */
            /**
             * The dash or dot style of the grid lines. For possible values, see
             * [this demonstration](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-dashstyle-all/).
             *
             * @sample {highcharts} highcharts/yaxis/gridlinedashstyle/
             *         Long dashes
             * @sample {highstock} stock/xaxis/gridlinedashstyle/
             *         Long dashes
             *
             * @type      {Highcharts.DashStyleValue}
             * @since     1.2
             */
            gridLineDashStyle: 'Solid',
            /**
             * The Z index of the grid lines.
             *
             * @sample {highcharts|highstock} highcharts/xaxis/gridzindex/
             *         A Z index of 4 renders the grid above the graph
             *
             * @product   highcharts highstock gantt
             */
            gridZIndex: 1,
            /**
             * An id for the axis. This can be used after render time to get
             * a pointer to the axis object through `chart.get()`.
             *
             * @sample {highcharts} highcharts/xaxis/id/
             *         Get the object
             * @sample {highstock} stock/xaxis/id/
             *         Get the object
             *
             * @type      {string}
             * @since     1.2.0
             * @apioption xAxis.id
             */
            /**
             * The axis labels show the number or category for each tick.
             *
             * Since v8.0.0: Labels are animated in categorized x-axis with
             * updating data if `tickInterval` and `step` is set to 1.
             *
             * @productdesc {highmaps}
             * X and Y axis labels are by default disabled in Highmaps, but the
             * functionality is inherited from Highcharts and used on `colorAxis`,
             * and can be enabled on X and Y axes too.
             */
            labels: {
                /**
                 * What part of the string the given position is anchored to.
                 * If `left`, the left side of the string is at the axis position.
                 * Can be one of `"left"`, `"center"` or `"right"`. Defaults to
                 * an intelligent guess based on which side of the chart the axis
                 * is on and the rotation of the label.
                 *
                 * @see [reserveSpace](#xAxis.labels.reserveSpace)
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-align-left/
                 *         Left
                 * @sample {highcharts} highcharts/xaxis/labels-align-right/
                 *         Right
                 * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/
                 *         Left-aligned labels on a vertical category axis
                 *
                 * @type      {Highcharts.AlignValue}
                 * @apioption xAxis.labels.align
                 */
                /**
                 * Whether to allow the axis labels to overlap. When false,
                 * overlapping labels are hidden.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-allowoverlap-true/
                 *         X axis labels overlap enabled
                 *
                 * @type      {boolean}
                 * @default   false
                 * @apioption xAxis.labels.allowOverlap
                 */
                /**
                 * For horizontal axes, the allowed degrees of label rotation
                 * to prevent overlapping labels. If there is enough space,
                 * labels are not rotated. As the chart gets narrower, it
                 * will start rotating the labels -45 degrees, then remove
                 * every second label and try again with rotations 0 and -45 etc.
                 * Set it to `undefined` to disable rotation, which will
                 * cause the labels to word-wrap if possible. Defaults to `[-45]``
                 * on bottom and top axes, `undefined` on left and right axes.
                 *
                 * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-default/
                 *         Default auto rotation of 0 or -45
                 * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-0-90/
                 *         Custom graded auto rotation
                 *
                 * @type      {Array<number>}
                 * @default   undefined
                 * @since     4.1.0
                 * @product   highcharts highstock gantt
                 * @apioption xAxis.labels.autoRotation
                 */
                autoRotation: void 0,
                /**
                 * When each category width is more than this many pixels, we don't
                 * apply auto rotation. Instead, we lay out the axis label with word
                 * wrap. A lower limit makes sense when the label contains multiple
                 * short words that don't extend the available horizontal space for
                 * each label.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-autorotationlimit/
                 *         Lower limit
                 *
                 * @since     4.1.5
                 * @product   highcharts gantt
                 */
                autoRotationLimit: 80,
                /**
                 * The label's pixel distance from the perimeter of the plot area.
                 * On cartesian charts, this is overridden if the `labels.y` setting
                 * is set.
                 *
                 * @sample {highcharts} highcharts/yaxis/labels-distance/
                 *         Polar chart, labels centered under the arc
                 *
                 * @type      {number}
                 * @product   highcharts gantt
                 */
                distance: 15,
                /**
                 * Enable or disable the axis labels.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-enabled/
                 *         X axis labels disabled
                 * @sample {highstock} stock/xaxis/labels-enabled/
                 *         X axis labels disabled
                 *
                 */
                enabled: true,
                /**
                 * A format string for the axis label. The context is available as
                 * format string variables. For example, you can use `{text}` to
                 * insert the default formatted text. The recommended way of adding
                 * units for the label is using `text`, for example `{text} km`.
                 *
                 * To add custom numeric or datetime formatting, use `{value}` with
                 * formatting, for example `{value:.1f}` or `{value:%Y-%m-%d}`.
                 *
                 * See
                 * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
                 * for more examples of formatting.
                 *
                 * The default value is not specified due to the dynamic
                 * nature of the default implementation.
                 *
                 * @sample {highcharts|highstock} highcharts/yaxis/labels-format/
                 *         Add units to Y axis label
                 * @sample {highcharts} highcharts/xaxis/labels-format-linked/
                 *         Linked category names
                 * @sample {highcharts} highcharts/xaxis/labels-format-custom/
                 *         Custom number format
                 *
                 * @type      {string}
                 * @since     3.0
                 * @apioption xAxis.labels.format
                 */
                /**
                 * Callback JavaScript function to format the label. The value
                 * is given by `this.value`. Additional properties for `this` are
                 * `axis`, `chart`, `isFirst`, `isLast` and `text` which holds the
                 * value of the default formatter.
                 *
                 * Defaults to a built in function returning a formatted string
                 * depending on whether the axis is `category`, `datetime`,
                 * `numeric` or other.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-formatter-linked/
                 *         Linked category names
                 * @sample {highcharts} highcharts/xaxis/labels-formatter-extended/
                 *         Modified numeric labels
                 * @sample {highstock} stock/xaxis/labels-formatter/
                 *         Added units on Y axis
                 *
                 * @type      {Highcharts.AxisLabelsFormatterCallbackFunction}
                 * @apioption xAxis.labels.formatter
                 */
                /**
                 * The number of pixels to indent the labels per level in a treegrid
                 * axis.
                 *
                 * @sample gantt/treegrid-axis/demo
                 *         Indentation 10px by default.
                 * @sample gantt/treegrid-axis/indentation-0px
                 *         Indentation set to 0px.
                 *
                 * @product gantt
                 */
                indentation: 10,
                /**
                 * Horizontal axis only. When `staggerLines` is not set,
                 * `maxStaggerLines` defines how many lines the axis is allowed to
                 * add to automatically avoid overlapping X labels. Set to `1` to
                 * disable overlap detection.
                 *
                 * @deprecated
                 * @type      {number}
                 * @default   5
                 * @since     1.3.3
                 * @apioption xAxis.labels.maxStaggerLines
                 */
                /**
                 * How to handle overflowing labels on horizontal axis. If set to
                 * `"allow"`, it will not be aligned at all. By default it
                 * `"justify"` labels inside the chart area. If there is room to
                 * move it, it will be aligned to the edge, else it will be removed.
                 *
                 * @since      2.2.5
                 * @validvalue ["allow", "justify"]
                 */
                overflow: 'justify',
                /**
                 * The pixel padding for axis labels, to ensure white space between
                 * them.
                 *
                 * @product   highcharts gantt
                 */
                padding: 5,
                /**
                 * Whether to reserve space for the labels. By default, space is
                 * reserved for the labels in these cases:
                 *
                 * * On all horizontal axes.
                 * * On vertical axes if `label.align` is `right` on a left-side
                 * axis or `left` on a right-side axis.
                 * * On vertical axes if `label.align` is `center`.
                 *
                 * This can be turned off when for example the labels are rendered
                 * inside the plot area instead of outside.
                 *
                 * @see [labels.align](#xAxis.labels.align)
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-reservespace/
                 *         No reserved space, labels inside plot
                 * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/
                 *         Left-aligned labels on a vertical category axis
                 *
                 * @type      {boolean}
                 * @since     4.1.10
                 * @product   highcharts highstock gantt
                 * @apioption xAxis.labels.reserveSpace
                 */
                reserveSpace: void 0,
                /**
                 * Rotation of the labels in degrees. When `undefined`, the
                 * `autoRotation` option takes precedence.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-rotation/
                 *         X axis labels rotated 90°
                 *
                 * @type      {number}
                 * @default   0
                 * @apioption xAxis.labels.rotation
                 */
                rotation: void 0,
                /**
                 * Horizontal axes only. The number of lines to spread the labels
                 * over to make room or tighter labels. 0 disables staggering.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-staggerlines/
                 *         Show labels over two lines
                 * @sample {highstock} stock/xaxis/labels-staggerlines/
                 *         Show labels over two lines
                 *
                 * @since     2.1
                 */
                staggerLines: 0,
                /**
                 * To show only every _n_'th label on the axis, set the step to _n_.
                 * Setting the step to 2 shows every other label.
                 *
                 * By default, when 0, the step is calculated automatically to avoid
                 * overlap. To prevent this, set it to 1\. This usually only
                 * happens on a category axis, and is often a sign that you have
                 * chosen the wrong axis type.
                 *
                 * Read more at
                 * [Axis docs](https://www.highcharts.com/docs/chart-concepts/axes)
                 * => What axis should I use?
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-step/
                 *         Showing only every other axis label on a categorized
                 *         x-axis
                 * @sample {highcharts} highcharts/xaxis/labels-step-auto/
                 *         Auto steps on a category axis
                 *
                 * @since     2.1
                 */
                step: 0,
                /**
                 * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
                 * to render the labels.
                 */
                useHTML: false,
                /**
                 * The x position offset of all labels relative to the tick
                 * positions on the axis. Overrides the `labels.distance` option.
                 *
                 * @type      {number}
                 * @apioption xAxis.labels.x
                 */
                /**
                 * The y position offset of all labels relative to the tick
                 * positions on the axis. Overrides the `labels.distance` option.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-x/
                 *         X axis labels placed on grid lines
                 *
                 * @type      {number}
                 * @apioption xAxis.labels.y
                 */
                /**
                 * The Z index for the axis labels.
                 */
                zIndex: 7,
                /**
                 * CSS styles for the label. Use `whiteSpace: 'nowrap'` to prevent
                 * wrapping of category labels. Use `textOverflow: 'none'` to
                 * prevent ellipsis (dots).
                 *
                 * In styled mode, the labels are styled with the
                 * `.highcharts-axis-labels` class.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-style/
                 *         Red X axis labels
                 *
                 * @type      {Highcharts.CSSObject}
                 */
                style: {
                    /** @internal */
                    color: "#333333" /* Palette.neutralColor80 */,
                    /** @internal */
                    cursor: 'default',
                    /** @internal */
                    fontSize: '0.8em'
                }
            },
            /**
             * The left position as the horizontal axis. If it's a number, it is
             * interpreted as pixel position relative to the chart.
             *
             * Since Highcharts v5.0.13: If it's a percentage string, it is
             * interpreted as percentages of the plot width, offset from plot area
             * left.
             *
             * @sample {highcharts} highcharts/xaxis/axis-position-properties
             *         Different axis position properties
             *
             * @type      {number|string}
             * @product   highcharts highstock
             * @apioption xAxis.left
             */
            /**
             * The top position as the vertical axis. If it's a number, it is
             * interpreted as pixel position relative to the chart.
             *
             * Since Highcharts 2: If it's a percentage string, it is interpreted
             * as percentages of the plot height, offset from plot area top.
             *
             * @sample {highcharts} highcharts/xaxis/axis-position-properties
             *         Different axis position properties
             *
             * @type      {number|string}
             * @product   highcharts highstock
             * @apioption xAxis.top
             */
            /**
             * Index of another axis that this axis is linked to. When an axis is
             * linked to a master axis, it will take the same extremes as
             * the master, but as assigned by min or max or by setExtremes.
             * It can be used to show additional info, or to ease reading the
             * chart by duplicating the scales.
             *
             * @sample {highcharts} highcharts/xaxis/linkedto/
             *         Different string formats of the same date
             * @sample {highcharts} highcharts/yaxis/linkedto/
             *         Y values on both sides
             *
             * @type      {number}
             * @since     2.0.2
             * @product   highcharts highstock gantt
             * @apioption xAxis.linkedTo
             */
            /**
             * The maximum value of the axis. If `null`, the max value is
             * automatically calculated.
             *
             * If the [endOnTick](#yAxis.endOnTick) option is true, the `max` value
             * might be rounded up.
             *
             * If a [tickAmount](#yAxis.tickAmount) is set, the axis may be extended
             * beyond the set max in order to reach the given number of ticks. The
             * same may happen in a chart with multiple axes, determined by [chart.
             * alignTicks](#chart), where a `tickAmount` is applied internally.
             *
             * @sample {highcharts} highcharts/yaxis/max-200/
             *         Y axis max of 200
             * @sample {highcharts} highcharts/yaxis/max-logarithmic/
             *         Y axis max on logarithmic axis
             * @sample {highstock} stock/xaxis/min-max/
             *         Fixed min and max on X axis
             *
             * @type      {number|null}
             * @apioption xAxis.max
             */
            /**
             * Padding of the max value relative to the length of the axis. A
             * padding of 0.05 will make a 100px axis 5px longer. This is useful
             * when you don't want the highest data value to appear on the edge
             * of the plot area. When the axis' `max` option is set or a max extreme
             * is set using `axis.setExtremes()`, the maxPadding will be ignored.
             *
             * @productdesc {highstock}
             * For an [ordinal](#xAxis.ordinal) axis, `minPadding` and `maxPadding`
             * are ignored. Use [overscroll](#xAxis.overscroll) instead.
             *
             * @sample {highcharts} highcharts/yaxis/maxpadding/
             *         Max padding of 0.25 on y axis
             * @sample {highstock} stock/xaxis/minpadding-maxpadding/
             *         Greater min- and maxPadding
             * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
             *         Add some padding
             *
             * @default   {highcharts} 0.01
             * @default   {highstock|highmaps} 0
             * @since     1.2.0
             */
            maxPadding: 0.01,
            /**
             * Deprecated. Use `minRange` instead.
             *
             * @deprecated
             * @type      {number}
             * @product   highcharts highstock
             * @apioption xAxis.maxZoom
             */
            /**
             * The minimum value of the axis. If `null` the min value is
             * automatically calculated.
             *
             * If the [startOnTick](#yAxis.startOnTick) option is true (default),
             * the `min` value might be rounded down.
             *
             * The automatically calculated minimum value is also affected by
             * [floor](#yAxis.floor), [softMin](#yAxis.softMin),
             * [minPadding](#yAxis.minPadding), [minRange](#yAxis.minRange)
             * as well as [series.threshold](#plotOptions.series.threshold)
             * and [series.softThreshold](#plotOptions.series.softThreshold).
             *
             * @sample {highcharts} highcharts/yaxis/min-startontick-false/
             *         -50 with startOnTick to false
             * @sample {highcharts} highcharts/yaxis/min-startontick-true/
             *         -50 with startOnTick true by default
             * @sample {highstock} stock/xaxis/min-max/
             *         Set min and max on X axis
             *
             * @type      {number|null}
             * @apioption xAxis.min
             */
            /**
             * The dash or dot style of the minor grid lines. For possible values,
             * see [this demonstration](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-dashstyle-all/).
             *
             * @sample {highcharts} highcharts/yaxis/minorgridlinedashstyle/
             *         Long dashes on minor grid lines
             * @sample {highstock} stock/xaxis/minorgridlinedashstyle/
             *         Long dashes on minor grid lines
             *
             * @type      {Highcharts.DashStyleValue}
             * @since     1.2
             */
            minorGridLineDashStyle: 'Solid',
            /**
             * Specific tick interval in axis units for the minor ticks. On a linear
             * axis, if `"auto"`, the minor tick interval is calculated as a fifth
             * of the tickInterval. If `null` or `undefined`, minor ticks are not
             * shown.
             *
             * On logarithmic axes, the unit is the power of the value. For example,
             * setting the minorTickInterval to 1 puts one tick on each of 0.1, 1,
             * 10, 100 etc. Setting the minorTickInterval to 0.1 produces 9 ticks
             * between 1 and 10, 10 and 100 etc.
             *
             * If user settings dictate minor ticks to become too dense, they don't
             * make sense, and will be ignored to prevent performance problems.
             *
             * @sample {highcharts} highcharts/yaxis/minortickinterval-null/
             *         Null by default
             * @sample {highcharts} highcharts/yaxis/minortickinterval-5/
             *         5 units
             * @sample {highcharts} highcharts/yaxis/minortickinterval-log-auto/
             *         "auto"
             * @sample {highcharts} highcharts/yaxis/minortickinterval-log/
             *         0.1
             * @sample {highstock} stock/demo/basic-line/
             *         Null by default
             * @sample {highstock} stock/xaxis/minortickinterval-auto/
             *         "auto"
             *
             * @type      {number|string|null}
             * @apioption xAxis.minorTickInterval
             */
            /**
             * The pixel length of the minor tick marks.
             *
             * @sample {highcharts} highcharts/yaxis/minorticklength/
             *         10px on Y axis
             * @sample {highstock} stock/xaxis/minorticks/
             *         10px on Y axis
             */
            minorTickLength: 2,
            /**
             * The position of the minor tick marks relative to the axis line.
             *  Can be one of `inside` and `outside`.
             *
             * @sample {highcharts} highcharts/yaxis/minortickposition-outside/
             *         Outside by default
             * @sample {highcharts} highcharts/yaxis/minortickposition-inside/
             *         Inside
             * @sample {highstock} stock/xaxis/minorticks/
             *         Inside
             *
             * @validvalue ["inside", "outside"]
             */
            minorTickPosition: 'outside',
            /**
             * Enable or disable minor ticks. The interval between the minor ticks
             * can be controlled either by the
             * [minorTicksPerMajor](#xAxis.minorTicksPerMajor) setting, or as an
             * absolute [minorTickInterval](#xAxis.minorTickInterval) value.
             *
             * On a logarithmic axis, minor ticks are laid out based on a best
             * guess, attempting to enter an approximate number of minor ticks
             * between each major tick based on
             * [minorTicksPerMajor](#xAxis.minorTicksPerMajor).
             *
             * Prior to v6.0.0, ticks were enabled in auto layout by setting
             * `minorTickInterval` to `"auto"`.
             *
             * @productdesc {highcharts} On axes using
             * [categories](#xAxis.categories), minor ticks are not supported.
             *
             * @sample {highcharts} highcharts/yaxis/minorticks-true/ Enabled on
             *         linear Y axis
             *
             * @type      {boolean}
             * @default   false
             * @since     6.0.0
             * @apioption xAxis.minorTicks
             */
            /**
             * The number of minor ticks per major tick. Works for `linear`,
             * `logarithmic` and `datetime` axes.
             *
             * @sample {highcharts} highcharts/yaxis/minortickspermajor/
             *         2 minor ticks per major tick on Y axis
             *
             * @type {number}
             */
            minorTicksPerMajor: 5,
            /**
             * The pixel width of the minor tick mark.
             *
             * @sample {highcharts} highcharts/yaxis/minortickwidth/
             *         3px width
             * @sample {highstock} stock/xaxis/minorticks/
             *         1px width
             *
             * @type      {number}
             * @default   0
             * @apioption xAxis.minorTickWidth
             */
            /**
             * Padding of the min value relative to the length of the axis. A
             * padding of 0.05 will make a 100px axis 5px longer. This is useful
             * when you don't want the lowest data value to appear on the edge
             * of the plot area. When the axis' `min` option is set or a min extreme
             * is set using `axis.setExtremes()`, the minPadding will be ignored.
             *
             * @productdesc {highstock}
             * For an [ordinal](#xAxis.ordinal) axis, `minPadding` and `maxPadding`
             * are ignored. Use [overscroll](#xAxis.overscroll) instead.
             *
             * @sample {highcharts} highcharts/yaxis/minpadding/
             *         Min padding of 0.2
             * @sample {highstock} stock/xaxis/minpadding-maxpadding/
             *         Greater min- and maxPadding
             * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
             *         Add some padding
             *
             * @default    {highcharts} 0.01
             * @default    {highstock|highmaps} 0
             * @since      1.2.0
             * @product    highcharts highstock gantt
             */
            minPadding: 0.01,
            /**
             * The minimum range to display on this axis. The entire axis will not
             * be allowed to span over a smaller interval than this. For example,
             * for a datetime axis the main unit is milliseconds. If minRange is
             * set to 3600000, you can't zoom in more than to one hour.
             *
             * The default minRange for the x axis is five times the smallest
             * interval between any of the data points.
             *
             * On a logarithmic axis, the unit for the minimum range is the power.
             * So a minRange of 1 means that the axis can be zoomed to 10-100,
             * 100-1000, 1000-10000 etc.
             *
             * **Note**: The `minPadding`, `maxPadding`, `startOnTick` and
             * `endOnTick` settings also affect how the extremes of the axis
             * are computed.
             *
             * @sample {highcharts} highcharts/xaxis/minrange/
             *         Minimum range of 5
             * @sample {highstock} stock/xaxis/minrange/
             *         Max zoom of 6 months overrides user selections
             *
             * @type      {number}
             * @apioption xAxis.minRange
             */
            /**
             * The minimum tick interval allowed in axis values. For example on
             * zooming in on an axis with daily data, this can be used to prevent
             * the axis from showing hours. Defaults to the closest distance between
             * two points on the axis.
             *
             * @type      {number}
             * @since     2.3.0
             * @apioption xAxis.minTickInterval
             */
            /**
             * The distance in pixels from the plot area to the axis line.
             * A positive offset moves the axis with it's line, labels and ticks
             * away from the plot area. This is typically used when two or more
             * axes are displayed on the same side of the plot. With multiple
             * axes the offset is dynamically adjusted to avoid collision, this
             * can be overridden by setting offset explicitly.
             *
             * @sample {highcharts} highcharts/yaxis/offset/
             *         Y axis offset of 70
             * @sample {highcharts} highcharts/yaxis/offset-centered/
             *         Axes positioned in the center of the plot
             * @sample {highstock} stock/xaxis/offset/
             *         Y axis offset by 70 px
             *
             * @type {number}
             */
            offset: void 0,
            /**
             * Whether to display the axis on the opposite side of the normal. The
             * normal is on the left side for vertical axes and bottom for
             * horizontal, so the opposite sides will be right and top respectively.
             * This is typically used with dual or multiple axes.
             *
             * @sample {highcharts} highcharts/yaxis/opposite/
             *         Secondary Y axis opposite
             * @sample {highstock} stock/xaxis/opposite/
             *         Y axis on left side
             *
             * @default   {highcharts|highstock|highmaps} false
             * @default   {gantt} true
             */
            opposite: false,
            /**
             * In an ordinal axis, the points are equally spaced in the chart
             * regardless of the actual time or x distance between them. This means
             * that missing data periods (e.g. nights or weekends for a stock chart)
             * will not take up space in the chart.
             * Having `ordinal: false` will show any gaps created by the `gapSize`
             * setting proportionate to their duration.
             *
             * In stock charts the X axis is ordinal by default, unless
             * the boost module is used and at least one of the series' data length
             * exceeds the [boostThreshold](#series.line.boostThreshold).
             *
             * For an ordinal axis, `minPadding` and `maxPadding` are ignored. Use
             * [overscroll](#xAxis.overscroll) instead.
             *
             * @sample {highstock} stock/xaxis/ordinal-true/
             *         True by default
             * @sample {highstock} stock/xaxis/ordinal-false/
             *         False
             *
             * @see [overscroll](#xAxis.overscroll)
             *
             * @type      {boolean}
             * @default   true
             * @since     1.1
             * @product   highstock
             * @apioption xAxis.ordinal
             */
            /**
             * Additional range on the right side of the xAxis. Works similar to
             * `xAxis.maxPadding`, but value is set in milliseconds. Can be set for
             * both main `xAxis` and the navigator's `xAxis`.
             *
             * @sample {highstock} stock/xaxis/overscroll/
             *         One minute overscroll with live data
             *
             * @type      {number}
             * @default   0
             * @since     6.0.0
             * @product   highstock
             * @apioption xAxis.overscroll
             */
            /**
             * Refers to the index in the [panes](#panes) array. Used for circular
             * gauges and polar charts. When the option is not set then first pane
             * will be used.
             *
             * @sample highcharts/demo/gauge-vu-meter
             *         Two gauges with different center
             *
             * @type      {number}
             * @product   highcharts
             * @apioption xAxis.pane
             */
            /**
             * The zoomed range to display when only defining one or none of `min`
             * or `max`. For example, to show the latest month, a range of one month
             * can be set.
             *
             * @sample {highstock} stock/xaxis/range/
             *         Setting a zoomed range when the rangeSelector is disabled
             *
             * @type      {number}
             * @product   highstock
             * @apioption xAxis.range
             */
            /**
             * Whether to reverse the axis so that the highest number is closest
             * to the origin. If the chart is inverted, the x axis is reversed by
             * default.
             *
             * @sample {highcharts} highcharts/yaxis/reversed/
             *         Reversed Y axis
             * @sample {highstock} stock/xaxis/reversed/
             *         Reversed Y axis
             *
             * @type      {boolean}
             * @default   undefined
             * @apioption xAxis.reversed
             */
            reversed: void 0,
            /**
             * This option determines how stacks should be ordered within a group.
             * For example reversed xAxis also reverses stacks, so first series
             * comes last in a group. To keep order like for non-reversed xAxis
             * enable this option.
             *
             * @sample {highcharts} highcharts/xaxis/reversedstacks/
             *         Reversed stacks comparison
             * @sample {highstock} highcharts/xaxis/reversedstacks/
             *         Reversed stacks comparison
             *
             * @since     6.1.1
             * @product   highcharts highstock
             */
            reversedStacks: false,
            /**
             * An optional scrollbar to display on the X axis in response to
             * limiting the minimum and maximum of the axis values.
             *
             * In styled mode, all the presentational options for the scrollbar are
             * replaced by the classes `.highcharts-scrollbar-thumb`,
             * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,
             * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.
             *
             * @sample {highstock} stock/yaxis/heatmap-scrollbars/
             *         Heatmap with both scrollbars
             *
             * @extends   scrollbar
             * @since     4.2.6
             * @product   highstock
             * @apioption xAxis.scrollbar
             */
            /**
             * Whether to show the axis line and title when the axis has no data.
             *
             * @sample {highcharts} highcharts/yaxis/showempty/
             *         When clicking the legend to hide series, one axis preserves
             *         line and title, the other doesn't
             * @sample {highstock} highcharts/yaxis/showempty/
             *         When clicking the legend to hide series, one axis preserves
             *         line and title, the other doesn't
             *
             * @since     1.1
             */
            showEmpty: true,
            /**
             * Whether to show the first tick label.
             *
             * @sample {highcharts} highcharts/xaxis/showfirstlabel-false/
             *         Set to false on X axis
             * @sample {highstock} stock/xaxis/showfirstlabel/
             *         Labels below plot lines on Y axis
             */
            showFirstLabel: true,
            /**
             * Whether to show the last tick label. Defaults to `true` on cartesian
             * charts, and `false` on polar charts.
             *
             * @sample {highcharts} highcharts/xaxis/showlastlabel-true/
             *         Set to true on X axis
             * @sample {highstock} stock/xaxis/showfirstlabel/
             *         Labels below plot lines on Y axis
             *
             * @type    {boolean}
             * @default undefined
             * @product highcharts highstock gantt
             */
            showLastLabel: true,
            /**
             * A soft maximum for the axis. If the series data maximum is less than
             * this, the axis will stay at this maximum, but if the series data
             * maximum is higher, the axis will flex to show all data.
             *
             * @sample highcharts/yaxis/softmin-softmax/
             *         Soft min and max
             *
             * @type      {number}
             * @since     5.0.1
             * @product   highcharts highstock gantt
             * @apioption xAxis.softMax
             */
            /**
             * A soft minimum for the axis. If the series data minimum is greater
             * than this, the axis will stay at this minimum, but if the series
             * data minimum is lower, the axis will flex to show all data.
             *
             * @sample highcharts/yaxis/softmin-softmax/
             *         Soft min and max
             *
             * @type      {number}
             * @since     5.0.1
             * @product   highcharts highstock gantt
             * @apioption xAxis.softMin
             */
            /**
             * For datetime axes, this decides where to put the tick between weeks.
             *  0 = Sunday, 1 = Monday.
             *
             * @sample {highcharts} highcharts/xaxis/startofweek-monday/
             *         Monday by default
             * @sample {highcharts} highcharts/xaxis/startofweek-sunday/
             *         Sunday
             * @sample {highstock} stock/xaxis/startofweek-1
             *         Monday by default
             * @sample {highstock} stock/xaxis/startofweek-0
             *         Sunday
             *
             * @product highcharts highstock gantt
             */
            startOfWeek: 1,
            /**
             * Whether to force the axis to start on a tick. Use this option with
             * the `minPadding` option to control the axis start.
             *
             * @productdesc {highstock}
             * In Highcharts Stock, `startOnTick` is always `false` when
             * the navigator is enabled, to prevent jumpy scrolling.
             *
             * @sample {highcharts} highcharts/xaxis/startontick-false/
             *         False by default
             * @sample {highcharts} highcharts/xaxis/startontick-true/
             *         True
             *
             * @since 1.2.0
             */
            startOnTick: false,
            /**
             * The amount of ticks to draw on the axis. This opens up for aligning
             * the ticks of multiple charts or panes within a chart. This option
             * overrides the `tickPixelInterval` option.
             *
             * This option only has an effect on linear axes. Datetime, logarithmic
             * or category axes are not affected.
             *
             * @sample {highcharts} highcharts/yaxis/tickamount/
             *         8 ticks on Y axis
             * @sample {highstock} highcharts/yaxis/tickamount/
             *         8 ticks on Y axis
             *
             * @type      {number}
             * @since     4.1.0
             * @product   highcharts highstock gantt
             * @apioption xAxis.tickAmount
             */
            /**
             * The interval of the tick marks in axis units. When `undefined`, the
             * tick interval is computed to approximately follow the
             * [tickPixelInterval](#xAxis.tickPixelInterval) on linear and datetime
             * axes. On categorized axes, a `undefined` tickInterval will default to
             * 1, one category. Note that datetime axes are based on milliseconds,
             * so for example an interval of one day is expressed as
             * `24 * 3600 * 1000`.
             *
             * On logarithmic axes, the tickInterval is based on powers, so a
             * tickInterval of 1 means one tick on each of 0.1, 1, 10, 100 etc. A
             * tickInterval of 2 means a tick of 0.1, 10, 1000 etc. A tickInterval
             * of 0.2 puts a tick on 0.1, 0.2, 0.4, 0.6, 0.8, 1, 2, 4, 6, 8, 10, 20,
             * 40 etc.
             *
             *
             * If the tickInterval is too dense for labels to be drawn, Highcharts
             * may remove ticks.
             *
             * If the chart has multiple axes, the [alignTicks](#chart.alignTicks)
             * option may interfere with the `tickInterval` setting.
             *
             * @see [tickPixelInterval](#xAxis.tickPixelInterval)
             * @see [tickPositions](#xAxis.tickPositions)
             * @see [tickPositioner](#xAxis.tickPositioner)
             *
             * @sample {highcharts} highcharts/xaxis/tickinterval-5/
             *         Tick interval of 5 on a linear axis
             * @sample {highstock} stock/xaxis/tickinterval/
             *         Tick interval of 0.01 on Y axis
             *
             * @type      {number}
             * @apioption xAxis.tickInterval
             */
            /**
             * The pixel length of the main tick marks.
             *
             * @sample {highcharts} highcharts/xaxis/ticklength/
             *         20 px tick length on the X axis
             * @sample {highstock} stock/xaxis/ticks/
             *         Formatted ticks on X axis
             */
            tickLength: 10,
            /**
             * If tickInterval is `null` this option sets the approximate pixel
             * interval of the tick marks. Not applicable to categorized axis.
             *
             * The tick interval is also influenced by the [minTickInterval](
             * #xAxis.minTickInterval) option, that, by default prevents ticks from
             * being denser than the data points.
             *
             * @see [tickInterval](#xAxis.tickInterval)
             * @see [tickPositioner](#xAxis.tickPositioner)
             * @see [tickPositions](#xAxis.tickPositions)
             *
             * @sample {highcharts} highcharts/xaxis/tickpixelinterval-50/
             *         50 px on X axis
             * @sample {highstock} stock/xaxis/tickpixelinterval/
             *         200 px on X axis
             */
            tickPixelInterval: 100,
            /**
             * For categorized axes only. If `on` the tick mark is placed in the
             * center of the category, if `between` the tick mark is placed between
             * categories. The default is `between` if the `tickInterval` is 1, else
             * `on`.
             *
             * @sample {highcharts} highcharts/xaxis/tickmarkplacement-between/
             *         "between" by default
             * @sample {highcharts} highcharts/xaxis/tickmarkplacement-on/
             *         "on"
             *
             * @product    highcharts gantt
             * @validvalue ["on", "between"]
             */
            tickmarkPlacement: 'between',
            /**
             * The position of the major tick marks relative to the axis line.
             * Can be one of `inside` and `outside`.
             *
             * @sample {highcharts} highcharts/xaxis/tickposition-outside/
             *         "outside" by default
             * @sample {highcharts} highcharts/xaxis/tickposition-inside/
             *         "inside"
             * @sample {highstock} stock/xaxis/ticks/
             *         Formatted ticks on X axis
             *
             * @validvalue ["inside", "outside"]
             */
            tickPosition: 'outside',
            /**
             * A callback function returning array defining where the ticks are
             * laid out on the axis. This overrides the default behaviour of
             * [tickPixelInterval](#xAxis.tickPixelInterval) and [tickInterval](
             * #xAxis.tickInterval). The automatic tick positions are accessible
             * through `this.tickPositions` and can be modified by the callback.
             *
             * @see [tickPositions](#xAxis.tickPositions)
             *
             * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/
             *         Demo of tickPositions and tickPositioner
             * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/
             *         Demo of tickPositions and tickPositioner
             *
             * @type      {Highcharts.AxisTickPositionerCallbackFunction}
             * @apioption xAxis.tickPositioner
             */
            /**
             * An array defining where the ticks are laid out on the axis. This
             * overrides the default behaviour of [tickPixelInterval](
             * #xAxis.tickPixelInterval) and [tickInterval](#xAxis.tickInterval).
             *
             * @see [tickPositioner](#xAxis.tickPositioner)
             *
             * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/
             *         Demo of tickPositions and tickPositioner
             * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/
             *         Demo of tickPositions and tickPositioner
             *
             * @type      {Array<number>}
             * @apioption xAxis.tickPositions
             */
            /**
             * The pixel width of the major tick marks. Defaults to 0 on category
             * axes, otherwise 1.
             *
             * In styled mode, the stroke width is given in the `.highcharts-tick`
             * class, but in order for the element to be generated on category axes,
             * the option must be explicitly set to 1.
             *
             * @sample {highcharts} highcharts/xaxis/tickwidth/
             *         10 px width
             * @sample {highcharts} highcharts/css/axis-grid/
             *         Styled mode
             * @sample {highstock} stock/xaxis/ticks/
             *         Formatted ticks on X axis
             * @sample {highstock} highcharts/css/axis-grid/
             *         Styled mode
             *
             * @type      {undefined|number}
             * @default   {highstock} 1
             * @default   {highmaps} 0
             * @apioption xAxis.tickWidth
             */
            /**
             * The axis title, showing next to the axis line.
             *
             * @productdesc {highmaps}
             * In Highmaps, the axis is hidden by default, but adding an axis title
             * is still possible. X axis and Y axis titles will appear at the bottom
             * and left by default.
             */
            title: {
                /**
                 * Alignment of the title relative to the axis values. Possible
                 * values are "low", "middle" or "high".
                 *
                 * @sample {highcharts} highcharts/xaxis/title-align-low/
                 *         "low"
                 * @sample {highcharts} highcharts/xaxis/title-align-center/
                 *         "middle" by default
                 * @sample {highcharts} highcharts/xaxis/title-align-high/
                 *         "high"
                 * @sample {highcharts} highcharts/yaxis/title-offset/
                 *         Place the Y axis title on top of the axis
                 * @sample {highstock} stock/xaxis/title-align/
                 *         Aligned to "high" value
                 *
                 * @type {Highcharts.AxisTitleAlignValue}
                 */
                align: 'middle',
                /**
                 * Deprecated. Set the `text` to `undefined` to disable the title.
                 *
                 * @deprecated
                 * @type      {boolean}
                 * @product   highcharts
                 * @apioption xAxis.title.enabled
                 */
                /**
                 * The pixel distance between the axis labels or line and the title.
                 * Defaults to 0 for horizontal axes, 10 for vertical
                 *
                 * @sample {highcharts} highcharts/xaxis/title-margin/
                 *         Y axis title margin of 60
                 *
                 * @type      {number}
                 * @apioption xAxis.title.margin
                 */
                /**
                 * The distance of the axis title from the axis line. By default,
                 * this distance is computed from the offset width of the labels,
                 * the labels' distance from the axis and the title's margin.
                 * However when the offset option is set, it overrides all this.
                 *
                 * @sample {highcharts} highcharts/yaxis/title-offset/
                 *         Place the axis title on top of the axis
                 * @sample {highstock} highcharts/yaxis/title-offset/
                 *         Place the axis title on top of the Y axis
                 *
                 * @type      {number}
                 * @since     2.2.0
                 * @apioption xAxis.title.offset
                 */
                /**
                 * Whether to reserve space for the title when laying out the axis.
                 *
                 * @type      {boolean}
                 * @default   true
                 * @since     5.0.11
                 * @product   highcharts highstock gantt
                 * @apioption xAxis.title.reserveSpace
                 */
                /**
                 * The rotation of the text in degrees. 0 is horizontal, 270 is
                 * vertical reading from bottom to top.
                 *
                 * @sample {highcharts} highcharts/yaxis/title-offset/
                 *         Horizontal
                 */
                rotation: 0,
                /**
                 * The actual text of the axis title. It can contain basic HTML tags
                 * like `b`, `i` and `span` with style.
                 *
                 * @sample {highcharts} highcharts/xaxis/title-text/
                 *         Custom HTML
                 * @sample {highstock} stock/xaxis/title-text/
                 *         Titles for both axes
                 *
                 * @type      {string|null}
                 * @apioption xAxis.title.text
                 */
                /**
                 * Alignment of the text, can be `"left"`, `"right"` or `"center"`.
                 * Default alignment depends on the
                 * [title.align](xAxis.title.align):
                 *
                 * Horizontal axes:
                 * - for `align` = `"low"`, `textAlign` is set to `left`
                 * - for `align` = `"middle"`, `textAlign` is set to `center`
                 * - for `align` = `"high"`, `textAlign` is set to `right`
                 *
                 * Vertical axes:
                 * - for `align` = `"low"` and `opposite` = `true`, `textAlign` is
                 *   set to `right`
                 * - for `align` = `"low"` and `opposite` = `false`, `textAlign` is
                 *   set to `left`
                 * - for `align` = `"middle"`, `textAlign` is set to `center`
                 * - for `align` = `"high"` and `opposite` = `true` `textAlign` is
                 *   set to `left`
                 * - for `align` = `"high"` and `opposite` = `false` `textAlign` is
                 *   set to `right`
                 *
                 * @type      {Highcharts.AlignValue}
                 * @apioption xAxis.title.textAlign
                 */
                /**
                 * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
                 * to render the axis title.
                 *
                 * @product   highcharts highstock gantt
                 */
                useHTML: false,
                /**
                 * Horizontal pixel offset of the title position.
                 *
                 * @since     4.1.6
                 * @product   highcharts highstock gantt
                 */
                x: 0,
                /**
                 * Vertical pixel offset of the title position.
                 *
                 * @product   highcharts highstock gantt
                 */
                y: 0,
                /**
                 * CSS styles for the title. If the title text is longer than the
                 * axis length, it will wrap to multiple lines by default. This can
                 * be customized by setting `textOverflow: 'ellipsis'`, by
                 * setting a specific `width` or by setting `whiteSpace: 'nowrap'`.
                 *
                 * In styled mode, the stroke width is given in the
                 * `.highcharts-axis-title` class.
                 *
                 * @sample {highcharts} highcharts/xaxis/title-style/
                 *         Red
                 * @sample {highcharts} highcharts/css/axis/
                 *         Styled mode
                 *
                 * @type    {Highcharts.CSSObject}
                 */
                style: {
                    /** @internal */
                    color: "#666666" /* Palette.neutralColor60 */,
                    /** @internal */
                    fontSize: '0.8em'
                }
            },
            /**
             * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`
             * or `category`. In a datetime axis, the numbers are given in
             * milliseconds, and tick marks are placed on appropriate values like
             * full hours or days. In a category axis, the
             * [point names](#series.line.data.name) of the chart's series are used
             * for categories, if not a [categories](#xAxis.categories) array is
             * defined.
             *
             * @sample {highcharts} highcharts/xaxis/type-linear/
             *         Linear
             * @sample {highcharts} highcharts/yaxis/type-log/
             *         Logarithmic
             * @sample {highcharts} highcharts/yaxis/type-log-minorgrid/
             *         Logarithmic with minor grid lines
             * @sample {highcharts} highcharts/xaxis/type-log-both/
             *         Logarithmic on two axes
             * @sample {highcharts} highcharts/yaxis/type-log-negative/
             *         Logarithmic with extension to emulate negative values
             *
             * @type    {Highcharts.AxisTypeValue}
             * @product highcharts gantt
             */
            type: 'linear',
            /**
             * If there are multiple axes on the same side of the chart, the pixel
             * margin between the axes. Defaults to 0 on vertical axes, 15 on
             * horizontal axes.
             *
             * @type      {number}
             * @since     7.0.3
             * @apioption xAxis.margin
             */
            /**
             * Applies only when the axis `type` is `category`. When `uniqueNames`
             * is true, points are placed on the X axis according to their names.
             * If the same point name is repeated in the same or another series,
             * the point is placed on the same X position as other points of the
             * same name. When `uniqueNames` is false, the points are laid out in
             * increasing X positions regardless of their names, and the X axis
             * category will take the name of the last point in each position.
             *
             * @sample {highcharts} highcharts/xaxis/uniquenames-true/
             *         True by default
             * @sample {highcharts} highcharts/xaxis/uniquenames-false/
             *         False
             *
             * @since     4.2.7
             * @product   highcharts gantt
             */
            uniqueNames: true,
            /**
             * Datetime axis only. An array determining what time intervals the
             * ticks are allowed to fall on. Each array item is an array where the
             * first value is the time unit and the second value another array of
             * allowed multiples.
             *
             * Defaults to:
             * ```js
             * units: [[
             *     'millisecond', // unit name
             *     [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
             * ], [
             *     'second',
             *     [1, 2, 5, 10, 15, 30]
             * ], [
             *     'minute',
             *     [1, 2, 5, 10, 15, 30]
             * ], [
             *     'hour',
             *     [1, 2, 3, 4, 6, 8, 12]
             * ], [
             *     'day',
             *     [1, 2]
             * ], [
             *     'week',
             *     [1, 2]
             * ], [
             *     'month',
             *     [1, 2, 3, 4, 6]
             * ], [
             *     'year',
             *     null
             * ]]
             * ```
             *
             * @sample {highcharts} highcharts/xaxis/units/
             *         Axis units demonstrated
             *
             * @type      {Array<Array<string,(Array<number>|null)>>}
             * @product   highcharts highstock gantt
             * @apioption xAxis.units
             */
            /**
             * Whether axis, including axis title, line, ticks and labels, should
             * be visible.
             *
             * @since     4.1.9
             * @product   highcharts highstock gantt
             */
            visible: true,
            /**
             * Color of the minor, secondary grid lines.
             *
             * In styled mode, the stroke width is given in the
             * `.highcharts-minor-grid-line` class.
             *
             * @sample {highcharts} highcharts/yaxis/minorgridlinecolor/
             *         Bright grey lines from Y axis
             * @sample {highcharts|highstock} highcharts/css/axis-grid/
             *         Styled mode
             * @sample {highstock} stock/xaxis/minorgridlinecolor/
             *         Bright grey lines from Y axis
             *
             * @type    {Highcharts.ColorType}
             * @default #f2f2f2
             */
            minorGridLineColor: "#f2f2f2" /* Palette.neutralColor5 */,
            /**
             * Width of the minor, secondary grid lines.
             *
             * In styled mode, the stroke width is given in the
             * `.highcharts-grid-line` class.
             *
             * @sample {highcharts} highcharts/yaxis/minorgridlinewidth/
             *         2px lines from Y axis
             * @sample {highcharts|highstock} highcharts/css/axis-grid/
             *         Styled mode
             * @sample {highstock} stock/xaxis/minorgridlinewidth/
             *         2px lines from Y axis
             */
            minorGridLineWidth: 1,
            /**
             * Color for the minor tick marks.
             *
             * @sample {highcharts} highcharts/yaxis/minortickcolor/
             *         Black tick marks on Y axis
             * @sample {highstock} stock/xaxis/minorticks/
             *         Black tick marks on Y axis
             *
             * @type    {Highcharts.ColorType}
             * @default #999999
             */
            minorTickColor: "#999999" /* Palette.neutralColor40 */,
            /**
             * The color of the line marking the axis itself.
             *
             * In styled mode, the line stroke is given in the
             * `.highcharts-axis-line` or `.highcharts-xaxis-line` class.
             *
             * @sample {highcharts} highcharts/yaxis/linecolor/
             *         A red line on Y axis
             * @sample {highcharts|highstock} highcharts/css/axis/
             *         Axes in styled mode
             * @sample {highstock} stock/xaxis/linecolor/
             *         A red line on X axis
             *
             * @type    {Highcharts.ColorType}
             */
            lineColor: "#333333" /* Palette.neutralColor80 */,
            /**
             * The width of the line marking the axis itself.
             *
             * In styled mode, the stroke width is given in the
             * `.highcharts-axis-line` or `.highcharts-xaxis-line` class.
             *
             * @sample {highcharts} highcharts/yaxis/linecolor/
             *         A 1px line on Y axis
             * @sample {highcharts|highstock} highcharts/css/axis/
             *         Axes in styled mode
             * @sample {highstock} stock/xaxis/linewidth/
             *         A 2px line on X axis
             *
             * @default {highcharts|highstock} 1
             * @default {highmaps} 0
             */
            lineWidth: 1,
            /**
             * Color of the grid lines extending the ticks across the plot area.
             *
             * In styled mode, the stroke is given in the `.highcharts-grid-line`
             * class.
             *
             * @productdesc {highmaps}
             * In Highmaps, the grid lines are hidden by default.
             *
             * @sample {highcharts} highcharts/yaxis/gridlinecolor/
             *         Green lines
             * @sample {highcharts|highstock} highcharts/css/axis-grid/
             *         Styled mode
             * @sample {highstock} stock/xaxis/gridlinecolor/
             *         Green lines
             *
             * @type    {Highcharts.ColorType}
             * @default #e6e6e6
             */
            gridLineColor: "#e6e6e6" /* Palette.neutralColor10 */,
            /**
             * The width of the grid lines extending the ticks across the plot area.
             * Defaults to 1 on the Y axis and 0 on the X axis, except for 3d
             * charts.
             *
             * In styled mode, the stroke width is given in the
             * `.highcharts-grid-line` class.
             *
             * @sample {highcharts} highcharts/yaxis/gridlinewidth/
             *         2px lines
             * @sample {highcharts|highstock} highcharts/css/axis-grid/
             *         Styled mode
             * @sample {highstock} stock/xaxis/gridlinewidth/
             *         2px lines
             *
             * @type      {number}
             * @apioption xAxis.gridLineWidth
             */
            gridLineWidth: void 0,
            /**
             * The height as the vertical axis. If it's a number, it is
             * interpreted as pixels.
             *
             * Since Highcharts 2: If it's a percentage string, it is interpreted
             * as percentages of the total plot height.
             *
             * @sample {highcharts} highcharts/xaxis/axis-position-properties
             *         Different axis position properties
             *
             * @type      {number|string}
             * @product   highcharts highstock
             * @apioption xAxis.height
             */
            /**
             * The width as the horizontal axis. If it's a number, it is interpreted
             * as pixels.
             *
             * Since Highcharts v5.0.13: If it's a percentage string, it is
             * interpreted as percentages of the total plot width.
             *
             * @sample {highcharts} highcharts/xaxis/axis-position-properties
             *         Different axis position properties
             *
             * @type      {number|string}
             * @product   highcharts highstock
             * @apioption xAxis.width
             */
            /**
             * Color for the main tick marks.
             *
             * In styled mode, the stroke is given in the `.highcharts-tick`
             * class.
             *
             * @sample {highcharts} highcharts/xaxis/tickcolor/
             *         Red ticks on X axis
             * @sample {highcharts|highstock} highcharts/css/axis-grid/
             *         Styled mode
             * @sample {highstock} stock/xaxis/ticks/
             *         Formatted ticks on X axis
             *
             * @type    {Highcharts.ColorType}
             */
            tickColor: "#333333" /* Palette.neutralColor80 */
            // tickWidth: 1
        };
        /**
         * The Y axis or value axis. Normally this is the vertical axis,
         * though if the chart is inverted this is the horizontal axis.
         * In case of multiple axes, the yAxis node is an array of
         * configuration objects.
         *
         * See [the Axis object](/class-reference/Highcharts.Axis) for programmatic
         * access to the axis.
         *
         * @type         {*|Array<*>}
         * @extends      xAxis
         * @excluding    currentDateIndicator,ordinal,overscroll
         * @optionparent yAxis
         */
        AxisDefaults.defaultYAxisOptions = {
            /**
             * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`,
             * `category` or `treegrid`. Defaults to `treegrid` for Gantt charts,
             * `linear` for other chart types.
             *
             * In a datetime axis, the numbers are given in milliseconds, and tick
             * marks are placed on appropriate values, like full hours or days. In a
             * category or treegrid axis, the [point names](#series.line.data.name)
             * of the chart's series are used for categories, if a
             * [categories](#xAxis.categories) array is not defined.
             *
             * @sample {highcharts} highcharts/yaxis/type-log-minorgrid/
             *         Logarithmic with minor grid lines
             * @sample {highcharts} highcharts/yaxis/type-log-negative/
             *         Logarithmic with extension to emulate negative values
             * @sample {gantt} gantt/treegrid-axis/demo
             *         Treegrid axis
             *
             * @type      {Highcharts.AxisTypeValue}
             * @default   {highcharts} linear
             * @default   {gantt} treegrid
             * @product   highcharts gantt
             * @apioption yAxis.type
             */
            /**
             * The height of the Y axis. If it's a number, it is interpreted as
             * pixels.
             *
             * Since Highcharts 2: If it's a percentage string, it is interpreted as
             * percentages of the total plot height.
             *
             * @see [yAxis.top](#yAxis.top)
             *
             * @sample {highstock} stock/demo/candlestick-and-volume/
             *         Percentage height panes
             *
             * @type      {number|string}
             * @product   highcharts highstock
             * @apioption yAxis.height
             */
            /**
             * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color
             * to represent the maximum value of the Y axis.
             *
             * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/
             *         Min and max colors
             *
             * @type      {Highcharts.ColorType}
             * @default   #003399
             * @since     4.0
             * @product   highcharts
             * @apioption yAxis.maxColor
             */
            /**
             * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color
             * to represent the minimum value of the Y axis.
             *
             * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/
             *         Min and max color
             *
             * @type      {Highcharts.ColorType}
             * @default   #e6ebf5
             * @since     4.0
             * @product   highcharts
             * @apioption yAxis.minColor
             */
            /**
             * Whether to reverse the axis so that the highest number is closest
             * to the origin.
             *
             * @sample {highcharts} highcharts/yaxis/reversed/
             *         Reversed Y axis
             * @sample {highstock} stock/xaxis/reversed/
             *         Reversed Y axis
             *
             * @type      {boolean}
             * @default   {highcharts} false
             * @default   {highstock} false
             * @default   {highmaps} true
             * @default   {gantt} true
             * @apioption yAxis.reversed
             */
            /**
             * If `true`, the first series in a stack will be drawn on top in a
             * positive, non-reversed Y axis. If `false`, the first series is in
             * the base of the stack.
             *
             * @sample {highcharts} highcharts/yaxis/reversedstacks-false/
             *         Non-reversed stacks
             * @sample {highstock} highcharts/yaxis/reversedstacks-false/
             *         Non-reversed stacks
             *
             * @type      {boolean}
             * @default   true
             * @since     3.0.10
             * @product   highcharts highstock
             * @apioption yAxis.reversedStacks
             */
            reversedStacks: true,
            /**
             * Solid gauge series only. Color stops for the solid gauge. Use this
             * in cases where a linear gradient between a `minColor` and `maxColor`
             * is not sufficient. The stops is an array of tuples, where the first
             * item is a float between 0 and 1 assigning the relative position in
             * the gradient, and the second item is the color.
             *
             * For solid gauges, the Y axis also inherits the concept of
             * [data classes](https://api.highcharts.com/highmaps#colorAxis.dataClasses)
             * from the Highmaps color axis.
             *
             * @sample {highcharts} highcharts/demo/gauge-solid/
             *         Gauge with stops
             *
             * @see [minColor](#yAxis.minColor)
             * @see [maxColor](#yAxis.maxColor)
             *
             * @type      {Array<Array<number,Highcharts.ColorType>>}
             * @since     4.0
             * @product   highcharts
             * @apioption yAxis.stops
             */
            /**
             * The pixel width of the major tick marks.
             *
             * @sample {highcharts} highcharts/xaxis/tickwidth/ 10 px width
             * @sample {highstock} stock/xaxis/ticks/ Formatted ticks on X axis
             *
             * @type      {number}
             * @default   0
             * @product   highcharts highstock gantt
             * @apioption yAxis.tickWidth
             */
            /**
             * Whether to force the axis to end on a tick. Use this option with
             * the `maxPadding` option to control the axis end.
             *
             * This option is always disabled, when panning type is
             * either `y` or `xy`.
             *
             * @see [type](#chart.panning.type)
             *
             *
             * @sample {highcharts} highcharts/yaxis/endontick/
             *         True by default
             * @sample {highcharts} highcharts/yaxis/endontick-false/
             *         False
             * @sample {highstock} stock/demo/basic-line/
             *         True by default
             * @sample {highstock} stock/xaxis/endontick/
             *         False for Y axis
             *
             * @since 1.2.0
             */
            endOnTick: true,
            /**
             * Padding of the max value relative to the length of the axis. A
             * padding of 0.05 will make a 100px axis 5px longer. This is useful
             * when you don't want the highest data value to appear on the edge
             * of the plot area. When the axis' `max` option is set or a max extreme
             * is set using `axis.setExtremes()`, the maxPadding will be ignored.
             *
             * Also the `softThreshold` option takes precedence over `maxPadding`,
             * so if the data is tangent to the threshold, `maxPadding` may not
             * apply unless `softThreshold` is set to false.
             *
             * @sample {highcharts} highcharts/yaxis/maxpadding-02/
             *         Max padding of 0.2
             * @sample {highstock} stock/xaxis/minpadding-maxpadding/
             *         Greater min- and maxPadding
             *
             * @since   1.2.0
             * @product highcharts highstock gantt
             */
            maxPadding: 0.05,
            /**
             * Padding of the min value relative to the length of the axis. A
             * padding of 0.05 will make a 100px axis 5px longer. This is useful
             * when you don't want the lowest data value to appear on the edge
             * of the plot area. When the axis' `min` option is set or a max extreme
             * is set using `axis.setExtremes()`, the maxPadding will be ignored.
             *
             * Also the `softThreshold` option takes precedence over `minPadding`,
             * so if the data is tangent to the threshold, `minPadding` may not
             * apply unless `softThreshold` is set to false.
             *
             * @sample {highcharts} highcharts/yaxis/minpadding/
             *         Min padding of 0.2
             * @sample {highstock} stock/xaxis/minpadding-maxpadding/
             *         Greater min- and maxPadding
             *
             * @since   1.2.0
             * @product highcharts highstock gantt
             */
            minPadding: 0.05,
            /**
             * @productdesc {highstock}
             * In Highcharts Stock 1.x, the Y axis was placed
             * on the left side by default.
             *
             * @sample {highcharts} highcharts/yaxis/opposite/
             *         Secondary Y axis opposite
             * @sample {highstock} stock/xaxis/opposite/
             *         Y axis on left side
             *
             * @type      {boolean}
             * @default   {highstock} true
             * @default   {highcharts} false
             * @product   highstock highcharts gantt
             * @apioption yAxis.opposite
             */
            /**
             * @see [tickInterval](#xAxis.tickInterval)
             * @see [tickPositioner](#xAxis.tickPositioner)
             * @see [tickPositions](#xAxis.tickPositions)
             */
            tickPixelInterval: 72,
            /**
             * Whether to show the last tick label.
             *
             * @productdesc {highcharts|gantt}
             * Defaults to `true` on cartesian charts, and `false` on polar charts.
             *
             * @productdesc {highstock}
             * Defaults to `true` for categorized yAxis and `false` for other types
             * of yAxis.
             *
             * @default undefined
             */
            showLastLabel: true,
            /**
             * @extends xAxis.labels
             */
            labels: {
                /**
                 * The label's pixel distance from the perimeter of the plot area.
                 * On cartesian charts, this is overridden if the `labels.y` setting
                 * is set.
                 *
                 * On polar charts, if it's a percentage string, it is interpreted
                 * the same as [series.radius](#plotOptions.gauge.radius), so the
                 * label can be aligned under the gauge's shape.
                 *
                 * @sample {highcharts} highcharts/yaxis/labels-distance/
                 *         Polar chart, labels centered under the arc
                 *
                 * @type      {number|string}
                 * @product   highcharts
                 * @apioption yAxis.labels.distance
                 */
                /**
                 * The y position offset of all labels relative to the tick
                 * positions on the axis. For polar and radial axis consider the use
                 * of the [distance](#yAxis.labels.distance) option.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-x/
                 *         Y axis labels placed on grid lines
                 *
                 * @type      {number}
                 * @default   {highcharts} 3
                 * @default   {highstock} -2
                 * @default   {highmaps} 3
                 * @apioption yAxis.labels.y
                 */
                /**
                 * What part of the string the given position is anchored to. Can
                 * be one of `"left"`, `"center"` or `"right"`. The exact position
                 * also depends on the `labels.x` setting.
                 *
                 * Angular gauges and solid gauges defaults to `"center"`.
                 * Solid gauges with two labels have additional option `"auto"`
                 * for automatic horizontal and vertical alignment.
                 *
                 * @sample {highcharts} highcharts/yaxis/labels-align-left/
                 *         Left
                 * @sample {highcharts} highcharts/series-solidgauge/labels-auto-aligned/
                 *         Solid gauge labels auto aligned
                 *
                 * @type       {Highcharts.AlignValue}
                 * @default    {highstock} right
                 * @apioption  yAxis.labels.align
                 */
                /**
                 * The x position offset of all labels relative to the tick
                 * positions on the axis. Defaults to -15 for left axis, 15 for
                 * right axis.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-x/
                 *         Y axis labels placed on grid lines
                 *
                 * @type {number}
                 */
                x: void 0
            },
            /**
             * @sample {highcharts} highcharts/yaxis/max-200/
             *         Y axis max of 200
             * @sample {highcharts} highcharts/yaxis/max-logarithmic/
             *         Y axis max on logarithmic axis
             * @sample {highstock} stock/yaxis/min-max/
             *         Fixed min and max on Y axis
             *
             * @apioption yAxis.max
             */
            /**
             * @sample {highcharts} highcharts/yaxis/min-startontick-false/
             *         -50 with startOnTick to false
             * @sample {highcharts} highcharts/yaxis/min-startontick-true/
             *         -50 with startOnTick true by default
             * @sample {highstock} stock/yaxis/min-max/
             *         Fixed min and max on Y axis
             *
             * @apioption yAxis.min
             */
            /**
             * An optional scrollbar to display on the Y axis in response to
             * limiting the minimum an maximum of the axis values.
             *
             * In styled mode, all the presentational options for the scrollbar
             * are replaced by the classes `.highcharts-scrollbar-thumb`,
             * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,
             * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.
             *
             * @sample {highstock} stock/yaxis/scrollbar/
             *         Scrollbar on the Y axis
             *
             * @extends   scrollbar
             * @since     4.2.6
             * @product   highstock
             * @excluding height
             * @apioption yAxis.scrollbar
             */
            /**
             * Enable the scrollbar on the Y axis.
             *
             * @sample {highstock} stock/yaxis/scrollbar/
             *         Enabled on Y axis
             *
             * @type      {boolean}
             * @default   false
             * @since     4.2.6
             * @product   highstock
             * @apioption yAxis.scrollbar.enabled
             */
            /**
             * Pixel margin between the scrollbar and the axis elements.
             *
             * @type      {number}
             * @default   10
             * @since     4.2.6
             * @product   highstock
             * @apioption yAxis.scrollbar.margin
             */
            /* eslint-disable highcharts/doclet-apioption-last */
            /**
             * Defines the position of the scrollbar. By default, it is positioned
             * on the opposite of the main axis (right side of the chart).
             * However, in the case of RTL languages could be set to `false`
             * which positions the scrollbar on the left.
             *
             * Works only for vertical axes.
             * This means yAxis in a non-inverted chart and xAxis in the inverted.
             *
             * @sample stock/yaxis/scrollbar-opposite/
             *         A scrollbar not on the opposite side
             *
             * @type      {boolean}
             * @default   true
             * @since 9.3.0
             *
             * @apioption yAxis.scrollbar.opposite
             * @apioption xAxis.scrollbar.opposite
             *
             */
            /* eslint-enable highcharts/doclet-apioption-last */
            /**
             * Whether to show the scrollbar when it is fully zoomed out at max
             * range. Setting it to `false` on the Y axis makes the scrollbar stay
             * hidden until the user zooms in, like common in browsers.
             *
             * @type      {boolean}
             * @default   true
             * @since     4.2.6
             * @product   highstock
             * @apioption yAxis.scrollbar.showFull
             */
            /**
             * The width of a vertical scrollbar or height of a horizontal
             * scrollbar. Defaults to 20 on touch devices.
             *
             * @type      {number}
             * @default   14
             * @since     4.2.6
             * @product   highstock
             * @apioption yAxis.scrollbar.size
             */
            /**
             * Z index of the scrollbar elements.
             *
             * @type      {number}
             * @default   3
             * @since     4.2.6
             * @product   highstock
             * @apioption yAxis.scrollbar.zIndex
             */
            /**
             * A soft maximum for the axis. If the series data maximum is less
             * than this, the axis will stay at this maximum, but if the series
             * data maximum is higher, the axis will flex to show all data.
             *
             * **Note**: The [series.softThreshold](
             * #plotOptions.series.softThreshold) option takes precedence over this
             * option.
             *
             * @sample highcharts/yaxis/softmin-softmax/
             *         Soft min and max
             *
             * @type      {number}
             * @since     5.0.1
             * @product   highcharts highstock gantt
             * @apioption yAxis.softMax
             */
            /**
             * A soft minimum for the axis. If the series data minimum is greater
             * than this, the axis will stay at this minimum, but if the series
             * data minimum is lower, the axis will flex to show all data.
             *
             * **Note**: The [series.softThreshold](
             * #plotOptions.series.softThreshold) option takes precedence over this
             * option.
             *
             * @sample highcharts/yaxis/softmin-softmax/
             *         Soft min and max
             *
             * @type      {number}
             * @since     5.0.1
             * @product   highcharts highstock gantt
             * @apioption yAxis.softMin
             */
            /**
             * Defines the horizontal alignment of the stack total label. Can be one
             * of `"left"`, `"center"` or `"right"`. The default value is calculated
             * at runtime and depends on orientation and whether the stack is
             * positive or negative.
             *
             * @sample {highcharts} highcharts/yaxis/stacklabels-align-left/
             *         Aligned to the left
             * @sample {highcharts} highcharts/yaxis/stacklabels-align-center/
             *         Aligned in center
             * @sample {highcharts} highcharts/yaxis/stacklabels-align-right/
             *         Aligned to the right
             *
             * @type      {Highcharts.AlignValue}
             * @since     2.1.5
             * @product   highcharts
             * @apioption yAxis.stackLabels.align
             */
            /**
             * A format string for the data label. Available variables are the same
             * as for `formatter`.
             *
             * @type      {string}
             * @default   {total}
             * @since     3.0.2
             * @product   highcharts highstock
             * @apioption yAxis.stackLabels.format
             */
            /**
             * Rotation of the labels in degrees.
             *
             * @sample {highcharts} highcharts/yaxis/stacklabels-rotation/
             *         Labels rotated 45°
             *
             * @type      {number}
             * @default   0
             * @since     2.1.5
             * @product   highcharts
             * @apioption yAxis.stackLabels.rotation
             */
            /**
             * The text alignment for the label. While `align` determines where the
             * texts anchor point is placed with regards to the stack, `textAlign`
             * determines how the text is aligned against its anchor point. Possible
             * values are `"left"`, `"center"` and `"right"`. The default value is
             * calculated at runtime and depends on orientation and whether the
             * stack is positive or negative.
             *
             * @sample {highcharts} highcharts/yaxis/stacklabels-textalign-left/
             *         Label in center position but text-aligned left
             *
             * @type      {Highcharts.AlignValue}
             * @since     2.1.5
             * @product   highcharts
             * @apioption yAxis.stackLabels.textAlign
             */
            /**
             * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
             * to render the labels.
             *
             * @type      {boolean}
             * @default   false
             * @since     3.0
             * @product   highcharts highstock
             * @apioption yAxis.stackLabels.useHTML
             */
            /**
             * Defines the vertical alignment of the stack total label. Can be one
             * of `"top"`, `"middle"` or `"bottom"`. The default value is calculated
             * at runtime and depends on orientation and whether the stack is
             * positive or negative.
             *
             * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-top/
             *         Vertically aligned top
             * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-middle/
             *         Vertically aligned middle
             * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-bottom/
             *         Vertically aligned bottom
             *
             * @type      {Highcharts.VerticalAlignValue}
             * @since     2.1.5
             * @product   highcharts
             * @apioption yAxis.stackLabels.verticalAlign
             */
            /**
             * The x position offset of the label relative to the left of the
             * stacked bar. The default value is calculated at runtime and depends
             * on orientation and whether the stack is positive or negative.
             *
             * @sample {highcharts} highcharts/yaxis/stacklabels-x/
             *         Stack total labels with x offset
             *
             * @type      {number}
             * @since     2.1.5
             * @product   highcharts
             * @apioption yAxis.stackLabels.x
             */
            /**
             * The y position offset of the label relative to the tick position
             * on the axis. The default value is calculated at runtime and depends
             * on orientation and whether the stack is positive or negative.
             *
             * @sample {highcharts} highcharts/yaxis/stacklabels-y/
             *         Stack total labels with y offset
             *
             * @type      {number}
             * @since     2.1.5
             * @product   highcharts
             * @apioption yAxis.stackLabels.y
             */
            /**
             * Whether to force the axis to start on a tick. Use this option with
             * the `maxPadding` option to control the axis start.
             *
             * This option is always disabled, when panning type is
             * either `y` or `xy`.
             *
             * @see [type](#chart.panning.type)
             *
             * @sample {highcharts} highcharts/xaxis/startontick-false/
             *         False by default
             * @sample {highcharts} highcharts/xaxis/startontick-true/
             *         True
             * @sample {highstock} stock/xaxis/endontick/
             *         False for Y axis
             *
             * @since   1.2.0
             * @product highcharts highstock gantt
             */
            startOnTick: true,
            title: {
                /**
                 * The pixel distance between the axis labels and the title.
                 * Positive values are outside the axis line, negative are inside.
                 *
                 * @sample {highcharts} highcharts/xaxis/title-margin/
                 *         Y axis title margin of 60
                 *
                 * @type      {number}
                 * @default   40
                 * @apioption yAxis.title.margin
                 */
                /**
                 * The rotation of the text in degrees. 0 is horizontal, 270 is
                 * vertical reading from bottom to top.
                 *
                 * @sample {highcharts} highcharts/yaxis/title-offset/
                 *         Horizontal
                 */
                rotation: 270,
                /**
                 * The actual text of the axis title. Horizontal texts can contain
                 * HTML, but rotated texts are painted using vector techniques and
                 * must be clean text. The Y axis title is disabled by setting the
                 * `text` option to `undefined`.
                 *
                 * @sample {highcharts} highcharts/xaxis/title-text/
                 *         Custom HTML
                 *
                 * @type    {string|null}
                 * @default {highcharts} Values
                 * @default {highstock} undefined
                 * @product highcharts highstock gantt
                 */
                text: 'Values'
            },
            /**
             * The top position of the Y axis. If it's a number, it is interpreted
             * as pixel position relative to the chart.
             *
             * Since Highcharts 2: If it's a percentage string, it is interpreted as
             * percentages of the plot height, offset from plot area top.
             *
             * @see [yAxis.height](#yAxis.height)
             *
             * @sample {highstock} stock/demo/candlestick-and-volume/
             *         Percentage height panes
             *
             * @type      {number|string}
             * @product   highcharts highstock
             * @apioption yAxis.top
             */
            /**
             * The stack labels show the total value for each bar in a stacked
             * column or bar chart. The label will be placed on top of positive
             * columns and below negative columns. In case of an inverted column
             * chart or a bar chart the label is placed to the right of positive
             * bars and to the left of negative bars.
             *
             * @product highcharts
             */
            stackLabels: {
                /**
                 * Enable or disable the initial animation when a series is
                 * displayed for the `stackLabels`. The animation can also be set as
                 * a configuration object. Please note that this option only
                 * applies to the initial animation.
                 * For other animations, see [chart.animation](#chart.animation)
                 * and the animation parameter under the API methods.
                 * The following properties are supported:
                 *
                 * - `defer`: The animation delay time in milliseconds.
                 *
                 * @sample {highcharts} highcharts/plotoptions/animation-defer/
                 *          Animation defer settings
                 * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
                 * @since 8.2.0
                 * @apioption yAxis.stackLabels.animation
                 */
                animation: {},
                /**
                 * The animation delay time in milliseconds.
                 * Set to `0` renders stackLabel immediately.
                 * As `undefined` inherits defer time from the [series.animation.defer](#plotOptions.series.animation.defer).
                 *
                 * @type      {number}
                 * @since 8.2.0
                 * @apioption yAxis.stackLabels.animation.defer
                 */
                /**
                 * Allow the stack labels to overlap.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-allowoverlap-false/
                 *         Default false
                 *
                 * @since   5.0.13
                 * @product highcharts
                 */
                allowOverlap: false,
                /**
                 * The background color or gradient for the stack label.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-box/
                 *          Stack labels box options
                 * @type      {Highcharts.ColorType}
                 * @since 8.1.0
                 * @apioption yAxis.stackLabels.backgroundColor
                 */
                /**
                 * The border color for the stack label. Defaults to `undefined`.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-box/
                 *          Stack labels box options
                 * @type      {Highcharts.ColorType}
                 * @since 8.1.0
                 * @apioption yAxis.stackLabels.borderColor
                 */
                /**
                 * The border radius in pixels for the stack label.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-box/
                 *          Stack labels box options
                 * @type      {number}
                 * @default   0
                 * @since 8.1.0
                 * @apioption yAxis.stackLabels.borderRadius
                 */
                /**
                 * The border width in pixels for the stack label.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-box/
                 *          Stack labels box options
                 * @type      {number}
                 * @default   0
                 * @since 8.1.0
                 * @apioption yAxis.stackLabels.borderWidth
                 */
                /**
                 * Enable or disable the stack total labels.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-enabled/
                 *         Enabled stack total labels
                 * @sample {highcharts} highcharts/yaxis/stacklabels-enabled-waterfall/
                 *         Enabled stack labels in waterfall chart
                 *
                 * @since   2.1.5
                 * @product highcharts
                 */
                enabled: false,
                /**
                 * Whether to hide stack labels that are outside the plot area.
                 * By default, the stack label is moved
                 * inside the plot area according to the
                 * [overflow](/highcharts/#yAxis/stackLabels/overflow)
                 * option.
                 *
                 * @type  {boolean}
                 * @since 7.1.3
                 */
                crop: true,
                /**
                 * How to handle stack total labels that flow outside the plot area.
                 * The default is set to `"justify"`,
                 * which aligns them inside the plot area.
                 * For columns and bars, this means it will be moved inside the bar.
                 * To display stack labels outside the plot area,
                 * set `crop` to `false` and `overflow` to `"allow"`.
                 *
                 * @sample highcharts/yaxis/stacklabels-overflow/
                 *         Stack labels flows outside the plot area.
                 *
                 * @type  {Highcharts.DataLabelsOverflowValue}
                 * @since 7.1.3
                 */
                overflow: 'justify',
                /* eslint-disable valid-jsdoc */
                /**
                 * Callback JavaScript function to format the label. The value is
                 * given by `this.total`.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-formatter/
                 *         Added units to stack total value
                 *
                 * @type    {Highcharts.FormatterCallbackFunction<Highcharts.StackItemObject>}
                 * @since   2.1.5
                 * @product highcharts
                 */
                formatter: function () {
                    const { numberFormatter } = this.axis.chart;
                    /* eslint-enable valid-jsdoc */
                    return numberFormatter(this.total || 0, -1);
                },
                /**
                 * CSS styles for the label.
                 *
                 * In styled mode, the styles are set in the
                 * `.highcharts-stack-label` class.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-style/
                 *         Red stack total labels
                 *
                 * @type    {Highcharts.CSSObject}
                 * @since   2.1.5
                 * @product highcharts
                 */
                style: {
                    /** @internal */
                    color: "#000000" /* Palette.neutralColor100 */,
                    /** @internal */
                    fontSize: '0.7em',
                    /** @internal */
                    fontWeight: 'bold',
                    /** @internal */
                    textOutline: '1px contrast'
                }
            },
            gridLineWidth: 1,
            lineWidth: 0
            // tickWidth: 0
        };
        /**
         * The Z axis or depth axis for 3D plots.
         *
         * See the [Axis class](/class-reference/Highcharts.Axis) for programmatic
         * access to the axis.
         *
         * @sample {highcharts} highcharts/3d/scatter-zaxis-categories/
         *         Z-Axis with Categories
         * @sample {highcharts} highcharts/3d/scatter-zaxis-grid/
         *         Z-Axis with styling
         *
         * @type      {*|Array<*>}
         * @extends   xAxis
         * @since     5.0.0
         * @product   highcharts
         * @excluding breaks, crosshair, height, left, lineColor, lineWidth,
         *            nameToX, showEmpty, top, width
         * @apioption zAxis
         */
        // This variable extends the defaultOptions for left axes.
        AxisDefaults.defaultLeftAxisOptions = {
            title: {
                rotation: 270
            }
        };
        // This variable extends the defaultOptions for right axes.
        AxisDefaults.defaultRightAxisOptions = {
            title: {
                rotation: 90
            }
        };
        // This variable extends the defaultOptions for bottom axes.
        AxisDefaults.defaultBottomAxisOptions = {
            labels: {
                autoRotation: [-45]
                // overflow: undefined,
                // staggerLines: null
            },
            margin: 15,
            title: {
                rotation: 0
            }
        };
        // This variable extends the defaultOptions for top axes.
        AxisDefaults.defaultTopAxisOptions = {
            labels: {
                autoRotation: [-45]
                // overflow: undefined
                // staggerLines: null
            },
            margin: 15,
            title: {
                rotation: 0
            }
        };
    })(AxisDefaults || (AxisDefaults = {}));
    /* *
     *
     *  Default Export
     *
     * */
    var AxisDefaults$1 = AxisDefaults;

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    /* *
     *
     *  API Options
     *
     * */
    /**
     * General options for the chart.
     *
     * @optionparent chart
     */
    const ChartDefaults = {
        /**
         * Default `mapData` for all series, in terms of a GeoJSON or TopoJSON
         * object. If set to a string, it functions as an index into the
         * `Highcharts.maps` array.
         *
         * For picking out individual shapes and geometries to use for each series
         * of the map, see [series.mapData](#series.map.mapData).
         *
         * @sample    maps/demo/geojson
         *            Loading GeoJSON data
         * @sample    maps/chart/topojson
         *            Loading TopoJSON data
         *
         * @type      {string|Array<*>|Highcharts.GeoJSON|Highcharts.TopoJSON}
         * @since     5.0.0
         * @product   highmaps
         * @apioption chart.map
         */
        /**
         * Set lat/lon transformation definitions for the chart. If not defined,
         * these are extracted from the map data.
         *
         * @type      {*}
         * @since     5.0.0
         * @product   highmaps
         * @apioption chart.mapTransforms
         */
        /**
         * When using multiple axes, the ticks of two or more opposite axes
         * will automatically be aligned by adding ticks to the axis or axes
         * with the least ticks, as if `tickAmount` were specified.
         *
         * This can be prevented by setting `alignTicks` to false. If the grid
         * lines look messy, it's a good idea to hide them for the secondary
         * axis by setting `gridLineWidth` to 0.
         *
         * If `startOnTick` or `endOnTick` in the axis options are set to false,
         * then the `alignTicks ` will be disabled for the axis.
         *
         * Disabled for logarithmic axes.
         *
         * @sample {highcharts} highcharts/chart/alignticks-true/
         *         True by default
         * @sample {highcharts} highcharts/chart/alignticks-false/
         *         False
         * @sample {highstock} stock/chart/alignticks-true/
         *         True by default
         * @sample {highstock} stock/chart/alignticks-false/
         *         False
         *
         * @type      {boolean}
         * @default   true
         * @product   highcharts highstock gantt
         * @apioption chart.alignTicks
         */
        /**
         * When using multiple axes, align the thresholds. When this is true, other
         * ticks will also be aligned.
         *
         * Note that for line series and some other series types, the `threshold`
         * option is set to `null` by default. This will in turn cause their y-axis
         * to not have a threshold. In order to avoid that, set the series
         * `threshold` to 0 or another number.
         *
         * If `startOnTick` or `endOnTick` in the axis options are set to false, or
         * if the axis is logarithmic, the threshold will not be aligned.
         *
         * @sample {highcharts} highcharts/chart/alignthresholds/ Set to true
         *
         * @since 10.0.0
         * @product   highcharts highstock gantt
         * @apioption chart.alignThresholds
         */
        alignThresholds: false,
        /**
         * Set the overall animation for all chart updating. Animation can be
         * disabled throughout the chart by setting it to false here. It can
         * be overridden for each individual API method as a function parameter.
         * The only animation not affected by this option is the initial series
         * animation, see [plotOptions.series.animation](
         * #plotOptions.series.animation).
         *
         * The animation can either be set as a boolean or a configuration
         * object. If `true`, it will use the 'swing' jQuery easing and a
         * duration of 500 ms. If used as a configuration object, the following
         * properties are supported:
         *
         * - `defer`: The animation delay time in milliseconds.
         *
         * - `duration`: The duration of the animation in milliseconds.
         *
         * - `easing`: A string reference to an easing function set on the
         *   `Math` object. See
         *   [the easing demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-animation-easing/).
         *
         * When zooming on a series with less than 100 points, the chart redraw
         * will be done with animation, but in case of more data points, it is
         * necessary to set this option to ensure animation on zoom.
         *
         * @sample {highcharts} highcharts/chart/animation-none/
         *         Updating with no animation
         * @sample {highcharts} highcharts/chart/animation-duration/
         *         With a longer duration
         * @sample {highcharts} highcharts/chart/animation-easing/
         *         With a jQuery UI easing
         * @sample {highmaps} maps/chart/animation-none/
         *         Updating with no animation
         * @sample {highmaps} maps/chart/animation-duration/
         *         With a longer duration
         *
         * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
         * @default   true
         * @apioption chart.animation
         */
        /**
         * A CSS class name to apply to the charts container `div`, allowing
         * unique CSS styling for each chart.
         *
         * @type      {string}
         * @apioption chart.className
         */
        /**
         * Event listeners for the chart.
         *
         * @apioption chart.events
         */
        /**
         * Fires when a series is added to the chart after load time, using the
         * `addSeries` method. One parameter, `event`, is passed to the
         * function, containing common event information. Through
         * `event.options` you can access the series options that were passed to
         * the `addSeries` method. Returning false prevents the series from
         * being added.
         *
         * @sample {highcharts} highcharts/chart/events-addseries/
         *         Alert on add series
         * @sample {highstock} stock/chart/events-addseries/
         *         Alert on add series
         *
         * @type      {Highcharts.ChartAddSeriesCallbackFunction}
         * @since     1.2.0
         * @context   Highcharts.Chart
         * @apioption chart.events.addSeries
         */
        /**
         * Fires when clicking on the plot background. One parameter, `event`,
         * is passed to the function, containing common event information.
         *
         * Information on the clicked spot can be found through `event.xAxis`
         * and `event.yAxis`, which are arrays containing the axes of each
         * dimension and each axis' value at the clicked spot. The primary axes
         * are `event.xAxis[0]` and `event.yAxis[0]`. Remember the unit of a
         * datetime axis is milliseconds since 1970-01-01 00:00:00.
         *
         * ```js
         * click: function(e) {
         *     console.log(
         *         Highcharts.dateFormat('%Y-%m-%d %H:%M:%S', e.xAxis[0].value),
         *         e.yAxis[0].value
         *     )
         * }
         * ```
         *
         * @sample {highcharts} highcharts/chart/events-click/
         *         Alert coordinates on click
         * @sample {highcharts} highcharts/chart/events-container/
         *         Alternatively, attach event to container
         * @sample {highstock} stock/chart/events-click/
         *         Alert coordinates on click
         * @sample {highstock} highcharts/chart/events-container/
         *         Alternatively, attach event to container
         * @sample {highmaps} maps/chart/events-click/
         *         Record coordinates on click
         * @sample {highmaps} highcharts/chart/events-container/
         *         Alternatively, attach event to container
         *
         * @type      {Highcharts.ChartClickCallbackFunction}
         * @since     1.2.0
         * @context   Highcharts.Chart
         * @apioption chart.events.click
         */
        /**
         * Fires when the chart is finished loading. Since v4.2.2, it also waits
         * for images to be loaded, for example from point markers. One
         * parameter, `event`, is passed to the function, containing common
         * event information.
         *
         * There is also a second parameter to the chart constructor where a
         * callback function can be passed to be executed on chart.load.
         *
         * @sample {highcharts} highcharts/chart/events-load/
         *         Alert on chart load
         * @sample {highcharts} highcharts/chart/events-render/
         *         Load vs Redraw vs Render
         * @sample {highstock} stock/chart/events-load/
         *         Alert on chart load
         * @sample {highmaps} maps/chart/events-load/
         *         Add series on chart load
         *
         * @type      {Highcharts.ChartLoadCallbackFunction}
         * @context   Highcharts.Chart
         * @apioption chart.events.load
         */
        /**
         * Fires when the chart is redrawn, either after a call to
         * `chart.redraw()` or after an axis, series or point is modified with
         * the `redraw` option set to `true`. One parameter, `event`, is passed
         * to the function, containing common event information.
         *
         * @sample {highcharts} highcharts/chart/events-redraw/
         *         Alert on chart redraw
         * @sample {highcharts} highcharts/chart/events-render/
         *         Load vs Redraw vs Render
         * @sample {highstock} stock/chart/events-redraw/
         *         Alert on chart redraw when adding a series or moving the
         *         zoomed range
         * @sample {highmaps} maps/chart/events-redraw/
         *         Set subtitle on chart redraw
         *
         * @type      {Highcharts.ChartRedrawCallbackFunction}
         * @since     1.2.0
         * @context   Highcharts.Chart
         * @apioption chart.events.redraw
         */
        /**
         * Fires after initial load of the chart (directly after the `load`
         * event), and after each redraw (directly after the `redraw` event).
         *
         * @sample {highcharts} highcharts/chart/events-render/
         *         Load vs Redraw vs Render
         *
         * @type      {Highcharts.ChartRenderCallbackFunction}
         * @since     5.0.7
         * @context   Highcharts.Chart
         * @apioption chart.events.render
         */
        /**
         * Fires when an area of the chart has been selected. Selection is
         * enabled by setting the chart's zoomType. One parameter, `event`, is
         * passed to the function, containing common event information. The
         * default action for the selection event is to zoom the chart to the
         * selected area. It can be prevented by calling
         * `event.preventDefault()` or return false.
         *
         * Information on the selected area can be found through `event.xAxis`
         * and `event.yAxis`, which are arrays containing the axes of each
         * dimension and each axis' min and max values. The primary axes are
         * `event.xAxis[0]` and `event.yAxis[0]`. Remember the unit of a
         * datetime axis is milliseconds since 1970-01-01 00:00:00.
         *
         * ```js
         * selection: function(event) {
         *     // log the min and max of the primary, datetime x-axis
         *     console.log(
         *         Highcharts.dateFormat(
         *             '%Y-%m-%d %H:%M:%S',
         *             event.xAxis[0].min
         *         ),
         *         Highcharts.dateFormat(
         *             '%Y-%m-%d %H:%M:%S',
         *             event.xAxis[0].max
         *         )
         *     );
         *     // log the min and max of the y axis
         *     console.log(event.yAxis[0].min, event.yAxis[0].max);
         * }
         * ```
         *
         * @sample {highcharts} highcharts/chart/events-selection/
         *         Report on selection and reset
         * @sample {highcharts} highcharts/chart/events-selection-points/
         *         Select a range of points through a drag selection
         * @sample {highstock} stock/chart/events-selection/
         *         Report on selection and reset
         * @sample {highstock} highcharts/chart/events-selection-points/
         *         Select a range of points through a drag selection
         *         (Highcharts)
         *
         * @type      {Highcharts.ChartSelectionCallbackFunction}
         * @apioption chart.events.selection
         */
        /**
         * The margin between the outer edge of the chart and the plot area.
         * The numbers in the array designate top, right, bottom and left
         * respectively. Use the options `marginTop`, `marginRight`,
         * `marginBottom` and `marginLeft` for shorthand setting of one option.
         *
         * By default there is no margin. The actual space is dynamically
         * calculated from the offset of axis labels, axis title, title,
         * subtitle and legend in addition to the `spacingTop`, `spacingRight`,
         * `spacingBottom` and `spacingLeft` options.
         *
         * @sample {highcharts} highcharts/chart/margins-zero/
         *         Zero margins
         * @sample {highstock} stock/chart/margin-zero/
         *         Zero margins
         *
         * @type      {number|Array<number>}
         * @apioption chart.margin
         */
        /**
         * The margin between the bottom outer edge of the chart and the plot
         * area. Use this to set a fixed pixel value for the margin as opposed
         * to the default dynamic margin. See also `spacingBottom`.
         *
         * @sample {highcharts} highcharts/chart/marginbottom/
         *         100px bottom margin
         * @sample {highstock} stock/chart/marginbottom/
         *         100px bottom margin
         * @sample {highmaps} maps/chart/margin/
         *         100px margins
         *
         * @type      {number}
         * @since     2.0
         * @apioption chart.marginBottom
         */
        /**
         * The margin between the left outer edge of the chart and the plot
         * area. Use this to set a fixed pixel value for the margin as opposed
         * to the default dynamic margin. See also `spacingLeft`.
         *
         * @sample {highcharts} highcharts/chart/marginleft/
         *         150px left margin
         * @sample {highstock} stock/chart/marginleft/
         *         150px left margin
         * @sample {highmaps} maps/chart/margin/
         *         100px margins
         *
         * @type      {number}
         * @since     2.0
         * @apioption chart.marginLeft
         */
        /**
         * The margin between the right outer edge of the chart and the plot
         * area. Use this to set a fixed pixel value for the margin as opposed
         * to the default dynamic margin. See also `spacingRight`.
         *
         * @sample {highcharts} highcharts/chart/marginright/
         *         100px right margin
         * @sample {highstock} stock/chart/marginright/
         *         100px right margin
         * @sample {highmaps} maps/chart/margin/
         *         100px margins
         *
         * @type      {number}
         * @since     2.0
         * @apioption chart.marginRight
         */
        /**
         * The margin between the top outer edge of the chart and the plot area.
         * Use this to set a fixed pixel value for the margin as opposed to
         * the default dynamic margin. See also `spacingTop`.
         *
         * @sample {highcharts} highcharts/chart/margintop/ 100px top margin
         * @sample {highstock} stock/chart/margintop/
         *         100px top margin
         * @sample {highmaps} maps/chart/margin/
         *         100px margins
         *
         * @type      {number}
         * @since     2.0
         * @apioption chart.marginTop
         */
        /**
         * Callback function to override the default function that formats all
         * the numbers in the chart. Returns a string with the formatted number.
         *
         * @sample highcharts/members/highcharts-numberformat
         *      Arabic digits in Highcharts
         * @type {Highcharts.NumberFormatterCallbackFunction}
         * @since 8.0.0
         * @apioption chart.numberFormatter
         */
        /**
         * Allows setting a key to switch between zooming and panning. Can be
         * one of `alt`, `ctrl`, `meta` (the command key on Mac and Windows
         * key on Windows) or `shift`. The keys are mapped directly to the key
         * properties of the click event argument (`event.altKey`,
         * `event.ctrlKey`, `event.metaKey` and `event.shiftKey`).
         *
         * @type       {string}
         * @since      4.0.3
         * @product    highcharts gantt
         * @validvalue ["alt", "ctrl", "meta", "shift"]
         * @apioption  chart.panKey
         */
        /**
         * Allow panning in a chart. Best used with [panKey](#chart.panKey)
         * to combine zooming and panning.
         *
         * On touch devices, when the [tooltip.followTouchMove](
         * #tooltip.followTouchMove) option is `true` (default), panning
         * requires two fingers. To allow panning with one finger, set
         * `followTouchMove` to `false`.
         *
         * @sample  {highcharts} highcharts/chart/pankey/ Zooming and panning
         * @sample  {highstock} stock/chart/panning/ Zooming and xy panning
         */
        panning: {
            /**
             * Enable or disable chart panning.
             *
             * @type      {boolean}
             * @default   {highcharts} false
             * @default   {highstock|highmaps} true
             */
            enabled: false,
            /**
             * Decides in what dimensions the user can pan the chart. Can be
             * one of `x`, `y`, or `xy`.
             *
             * When this option is set to `y` or `xy`, [yAxis.startOnTick](#yAxis.startOnTick)
             * and [yAxis.endOnTick](#yAxis.endOnTick) are overwritten to `false`.
             *
             * @sample {highcharts} highcharts/chart/panning-type
             *         Zooming and xy panning
             *
             * @declare    Highcharts.OptionsChartPanningTypeValue
             * @type       {string}
             * @validvalue ["x", "y", "xy"]
             * @default    {highcharts|highstock} x
             * @product    highcharts highstock gantt
             */
            type: 'x'
        },
        /**
         * Equivalent to [zoomType](#chart.zoomType), but for multitouch
         * gestures only. By default, the `pinchType` is the same as the
         * `zoomType` setting. However, pinching can be enabled separately in
         * some cases, for example in stock charts where a mouse drag pans the
         * chart, while pinching is enabled. When [tooltip.followTouchMove](
         * #tooltip.followTouchMove) is true, pinchType only applies to
         * two-finger touches.
         *
         * @type       {string}
         * @default    {highcharts} undefined
         * @default    {highstock} undefined
         * @since      3.0
         * @product    highcharts highstock gantt
         * @deprecated
         * @validvalue ["x", "y", "xy"]
         * @apioption  chart.pinchType
         */
        /**
         * Whether to apply styled mode. When in styled mode, no presentational
         * attributes or CSS are applied to the chart SVG. Instead, CSS rules
         * are required to style the chart. The default style sheet is
         * available from `https://code.highcharts.com/css/highcharts.css`.
         *
         * [Read more in the docs](https://www.highcharts.com/docs/chart-design-and-style/style-by-css)
         * on what classes and variables are available.
         *
         * @sample highcharts/css/colors
         *         Color theming with CSS
         * @sample highcharts/css/prefers-color-scheme
         *         Dynamic theme based on system settings
         * @type       {boolean}
         * @default    false
         * @since      7.0
         * @apioption  chart.styledMode
         */
        styledMode: false,
        /**
         * The corner radius of the outer chart border.
         *
         * @sample {highcharts} highcharts/chart/borderradius/
         *         20px radius
         * @sample {highstock} stock/chart/border/
         *         10px radius
         * @sample {highmaps} maps/chart/border/
         *         Border options
         *
         */
        borderRadius: 0,
        /**
         * In styled mode, this sets how many colors the class names
         * should rotate between. With ten colors, series (or points) are
         * given class names like `highcharts-color-0`, `highcharts-color-1`
         * [...] `highcharts-color-9`. The equivalent in non-styled mode
         * is to set colors using the [colors](#colors) setting.
         *
         * @since      5.0.0
         */
        colorCount: 10,
        /**
         * By default, (because of memory and performance reasons) the chart does
         * not copy the data but keeps it as a reference. In some cases, this might
         * result in mutating the original data source. In order to prevent that,
         * set that property to false. Please note that changing that might decrease
         * performance, especially with bigger sets of data.
         *
         * @type       {boolean}
         * @since 10.1.0
         */
        allowMutatingData: true,
        /**
         * If true, the axes will scale to the remaining visible series once
         * one series is hidden. If false, hiding and showing a series will
         * not affect the axes or the other series. For stacks, once one series
         * within the stack is hidden, the rest of the stack will close in
         * around it even if the axis is not affected.
         *
         * @sample {highcharts} highcharts/chart/ignorehiddenseries-true/
         *         True by default
         * @sample {highcharts} highcharts/chart/ignorehiddenseries-false/
         *         False
         * @sample {highcharts} highcharts/chart/ignorehiddenseries-true-stacked/
         *         True with stack
         * @sample {highstock} stock/chart/ignorehiddenseries-true/
         *         True by default
         * @sample {highstock} stock/chart/ignorehiddenseries-false/
         *         False
         *
         * @since   1.2.0
         * @product highcharts highstock gantt
         */
        ignoreHiddenSeries: true,
        /**
         * Whether to invert the axes so that the x axis is vertical and y axis
         * is horizontal. When `true`, the x axis is [reversed](#xAxis.reversed)
         * by default.
         *
         * @productdesc {highcharts}
         * If a bar series is present in the chart, it will be inverted
         * automatically. Inverting the chart doesn't have an effect if there
         * are no cartesian series in the chart, or if the chart is
         * [polar](#chart.polar).
         *
         * @sample {highcharts} highcharts/chart/inverted/
         *         Inverted line
         * @sample {highstock} stock/navigator/inverted/
         *         Inverted stock chart
         *
         * @type      {boolean}
         * @default   false
         * @product   highcharts highstock gantt
         * @apioption chart.inverted
         */
        /**
         * The distance between the outer edge of the chart and the content,
         * like title or legend, or axis title and labels if present. The
         * numbers in the array designate top, right, bottom and left
         * respectively. Use the options spacingTop, spacingRight, spacingBottom
         * and spacingLeft options for shorthand setting of one option.
         *
         * @type    {Array<number>}
         * @see     [chart.margin](#chart.margin)
         * @default [10, 10, 15, 10]
         * @since   3.0.6
         */
        spacing: [10, 10, 15, 10],
        /**
         * The button that appears after a selection zoom, allowing the user
         * to reset zoom.
         *
         * @since      2.2
         * @deprecated 10.2.1
         */
        resetZoomButton: {
            /**
             * What frame the button placement should be related to. Can be
             * either `plotBox` or `spacingBox`.
             *
             * @sample {highcharts} highcharts/chart/resetzoombutton-relativeto/
             *         Relative to the chart
             * @sample {highstock} highcharts/chart/resetzoombutton-relativeto/
             *         Relative to the chart
             *
             * @type      {Highcharts.ButtonRelativeToValue}
             * @default   plot
             * @apioption chart.resetZoomButton.relativeTo
             */
            /**
             * A collection of attributes for the button. The object takes SVG
             * attributes like `fill`, `stroke`, `stroke-width` or `r`, the
             * border radius. The theme also supports `style`, a collection of
             * CSS properties for the text. Equivalent attributes for the hover
             * state are given in `theme.states.hover`.
             *
             * @sample {highcharts} highcharts/chart/resetzoombutton-theme/
             *         Theming the button
             * @sample {highstock} highcharts/chart/resetzoombutton-theme/
             *         Theming the button
             *
             * @type {Highcharts.SVGAttributes}
             */
            theme: {
                /**
                 * @internal
                 */
                zIndex: 6
            },
            /**
             * The position of the button.
             *
             * @sample {highcharts} highcharts/chart/resetzoombutton-position/
             *         Above the plot area
             * @sample {highstock} highcharts/chart/resetzoombutton-position/
             *         Above the plot area
             * @sample {highmaps} highcharts/chart/resetzoombutton-position/
             *         Above the plot area
             *
             * @type {Highcharts.AlignObject}
             */
            position: {
                /**
                 * The horizontal alignment of the button.
                 */
                align: 'right',
                /**
                 * The horizontal offset of the button.
                 */
                x: -10,
                /**
                 * The vertical alignment of the button.
                 *
                 * @type      {Highcharts.VerticalAlignValue}
                 * @default   top
                 * @apioption chart.resetZoomButton.position.verticalAlign
                 */
                /**
                 * The vertical offset of the button.
                 */
                y: 10
            }
        },
        /**
         * The pixel width of the plot area border.
         *
         * @sample {highcharts} highcharts/chart/plotborderwidth/
         *         1px border
         * @sample {highstock} stock/chart/plotborder/
         *         2px border
         * @sample {highmaps} maps/chart/plotborder/
         *         Plot border options
         *
         * @type      {number}
         * @default   0
         * @apioption chart.plotBorderWidth
         */
        /**
         * Whether to apply a drop shadow to the plot area. Requires that
         * plotBackgroundColor be set. The shadow can be an object configuration
         * containing `color`, `offsetX`, `offsetY`, `opacity` and `width`.
         *
         * @sample {highcharts} highcharts/chart/plotshadow/
         *         Plot shadow
         * @sample {highstock} stock/chart/plotshadow/
         *         Plot shadow
         * @sample {highmaps} maps/chart/plotborder/
         *         Plot border options
         *
         * @type      {boolean|Highcharts.ShadowOptionsObject}
         * @default   false
         * @apioption chart.plotShadow
         */
        /**
         * When true, cartesian charts like line, spline, area and column are
         * transformed into the polar coordinate system. This produces _polar
         * charts_, also known as _radar charts_.
         *
         * @sample {highcharts} highcharts/demo/polar/
         *         Polar chart
         * @sample {highcharts} highcharts/demo/polar-wind-rose/
         *         Wind rose, stacked polar column chart
         * @sample {highcharts} highcharts/demo/polar-spider/
         *         Spider web chart
         * @sample {highcharts} highcharts/parallel-coordinates/polar/
         *         Star plot, multivariate data in a polar chart
         *
         * @type      {boolean}
         * @default   false
         * @since     2.3.0
         * @product   highcharts
         * @requires  highcharts-more
         * @apioption chart.polar
         */
        /**
         * Whether to reflow the chart to fit the width of the container div
         * on resizing the window.
         *
         * @sample {highcharts} highcharts/chart/reflow-true/
         *         True by default
         * @sample {highcharts} highcharts/chart/reflow-false/
         *         False
         * @sample {highstock} stock/chart/reflow-true/
         *         True by default
         * @sample {highstock} stock/chart/reflow-false/
         *         False
         * @sample {highmaps} maps/chart/reflow-true/
         *         True by default
         * @sample {highmaps} maps/chart/reflow-false/
         *         False
         *
         * @since     2.1
         */
        reflow: true,
        /**
         * The HTML element where the chart will be rendered. If it is a string,
         * the element by that id is used. The HTML element can also be passed
         * by direct reference, or as the first argument of the chart
         * constructor, in which case the option is not needed.
         *
         * @sample {highcharts} highcharts/chart/reflow-true/
         *         String
         * @sample {highcharts} highcharts/chart/renderto-object/
         *         Object reference
         * @sample {highstock} stock/chart/renderto-string/
         *         String
         * @sample {highstock} stock/chart/renderto-object/
         *         Object reference
         *
         * @type      {string|Highcharts.HTMLDOMElement}
         * @apioption chart.renderTo
         */
        /**
         * The background color of the marker square when selecting (zooming
         * in on) an area of the chart.
         *
         * @see In styled mode, the selection marker fill is set with the
         *      `.highcharts-selection-marker` class.
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @default   rgba(51,92,173,0.25)
         * @since     2.1.7
         * @apioption chart.selectionMarkerFill
         */
        /**
         * Whether to apply a drop shadow to the global series group. This causes
         * all the series to have the same shadow. Contrary to the `series.shadow`
         * option, this prevents items from casting shadows on each other, like for
         * others series in a stack. The shadow can be an object configuration
         * containing `color`, `offsetX`, `offsetY`, `opacity` and `width`.
         *
         * @sample highcharts/chart/seriesgroupshadow/ Shadow
         *
         * @type      {boolean|Highcharts.ShadowOptionsObject}
         * @default   false
         * @apioption chart.shadow
         */
        /**
         * Whether to apply a drop shadow to the outer chart area. Requires
         * that backgroundColor be set. The shadow can be an object
         * configuration containing `color`, `offsetX`, `offsetY`, `opacity` and
         * `width`.
         *
         * @sample {highcharts} highcharts/chart/shadow/
         *         Shadow
         * @sample {highstock} stock/chart/shadow/
         *         Shadow
         * @sample {highmaps} maps/chart/border/
         *         Chart border and shadow
         *
         * @type      {boolean|Highcharts.ShadowOptionsObject}
         * @default   false
         * @apioption chart.shadow
         */
        /**
         * Whether to show the axes initially. This only applies to empty charts
         * where series are added dynamically, as axes are automatically added
         * to cartesian series.
         *
         * @sample {highcharts} highcharts/chart/showaxes-false/
         *         False by default
         * @sample {highcharts} highcharts/chart/showaxes-true/
         *         True
         *
         * @type      {boolean}
         * @since     1.2.5
         * @product   highcharts gantt
         * @apioption chart.showAxes
         */
        /**
         * The space between the bottom edge of the chart and the content (plot
         * area, axis title and labels, title, subtitle or legend in top
         * position).
         *
         * @sample {highcharts} highcharts/chart/spacingbottom/
         *         Spacing bottom set to 100
         * @sample {highstock} stock/chart/spacingbottom/
         *         Spacing bottom set to 100
         * @sample {highmaps} maps/chart/spacing/
         *         Spacing 100 all around
         *
         * @type      {number}
         * @default   15
         * @since     2.1
         * @apioption chart.spacingBottom
         */
        /**
         * The space between the left edge of the chart and the content (plot
         * area, axis title and labels, title, subtitle or legend in top
         * position).
         *
         * @sample {highcharts} highcharts/chart/spacingleft/
         *         Spacing left set to 100
         * @sample {highstock} stock/chart/spacingleft/
         *         Spacing left set to 100
         * @sample {highmaps} maps/chart/spacing/
         *         Spacing 100 all around
         *
         * @type      {number}
         * @default   10
         * @since     2.1
         * @apioption chart.spacingLeft
         */
        /**
         * The space between the right edge of the chart and the content (plot
         * area, axis title and labels, title, subtitle or legend in top
         * position).
         *
         * @sample {highcharts} highcharts/chart/spacingright-100/
         *         Spacing set to 100
         * @sample {highcharts} highcharts/chart/spacingright-legend/
         *         Legend in right position with default spacing
         * @sample {highstock} stock/chart/spacingright/
         *         Spacing set to 100
         * @sample {highmaps} maps/chart/spacing/
         *         Spacing 100 all around
         *
         * @type      {number}
         * @default   10
         * @since     2.1
         * @apioption chart.spacingRight
         */
        /**
         * The space between the top edge of the chart and the content (plot
         * area, axis title and labels, title, subtitle or legend in top
         * position).
         *
         * @sample {highcharts} highcharts/chart/spacingtop-100/
         *         A top spacing of 100
         * @sample {highcharts} highcharts/chart/spacingtop-10/
         *         Floating chart title makes the plot area align to the default
         *         spacingTop of 10.
         * @sample {highstock} stock/chart/spacingtop/
         *         A top spacing of 100
         * @sample {highmaps} maps/chart/spacing/
         *         Spacing 100 all around
         *
         * @type      {number}
         * @default   10
         * @since     2.1
         * @apioption chart.spacingTop
         */
        /**
         * Additional CSS styles to apply inline to the container `div` and the root
         * SVG.
         *
         * Since v11, the root font size is 1rem by default, and all child element
         * are given a relative `em` font size by default. This allows implementers
         * to control all the chart's font sizes by only setting the root level.
         *
         * @see    In styled mode, general chart styles can be set with the
         *         `.highcharts-root` class.
         * @sample {highcharts} highcharts/chart/style-serif-font/
         *         Using a serif type font
         * @sample {highcharts} highcharts/members/relative-font-size/
         *         Relative font sizes
         * @sample {highcharts} highcharts/css/em/
         *         Styled mode with relative font sizes
         * @sample {highstock} stock/chart/style/
         *         Using a serif type font
         * @sample {highmaps} maps/chart/style-serif-font/
         *         Using a serif type font
         *
         * @type      {Highcharts.CSSObject}
         * @default   {"fontFamily": Helvetica, Arial, sans-serif","fontSize":"1rem"}
         * @apioption chart.style
         */
        /**
         * The default series type for the chart. Can be any of the chart types
         * listed under [plotOptions](#plotOptions) and [series](#series) or can
         * be a series provided by an additional module.
         *
         * In TypeScript this option has no effect in sense of typing and
         * instead the `type` option must always be set in the series.
         *
         * @sample {highcharts} highcharts/chart/type-bar/
         *         Bar
         * @sample {highstock} stock/chart/type/
         *         Areaspline
         * @sample {highmaps} maps/chart/type-mapline/
         *         Mapline
         *
         * @type       {string}
         * @default    {highcharts} line
         * @default    {highstock} line
         * @default    {highmaps} map
         * @since      2.1.0
         * @apioption  chart.type
         */
        type: 'line',
        /**
         * Decides in what dimensions the user can zoom by dragging the mouse.
         * Can be one of `x`, `y` or `xy`.
         *
         * @see [panKey](#chart.panKey)
         *
         * @sample {highcharts} highcharts/chart/zoomtype-none/
         *         None by default
         * @sample {highcharts} highcharts/chart/zoomtype-x/
         *         X
         * @sample {highcharts} highcharts/chart/zoomtype-y/
         *         Y
         * @sample {highcharts} highcharts/chart/zoomtype-xy/
         *         Xy
         * @sample {highcharts} highcharts/chart/zoomtype-polar/
         *         Zoom on polar chart
         * @sample {highstock} stock/demo/basic-line/
         *         None by default
         * @sample {highstock} stock/chart/zoomtype-x/
         *         X
         * @sample {highstock} stock/chart/zoomtype-y/
         *         Y
         * @sample {highstock} stock/chart/zoomtype-xy/
         *         Xy
         * @sample {highmaps} maps/chart/zoomtype-xy/
         *         Map with selection zoom
         *
         * @type       {string}
         * @validvalue ["x", "y", "xy"]
         * @deprecated
         * @apioption  chart.zoomType
         */
        /**
         * Enables zooming by a single touch, in combination with
         * [chart.zoomType](#chart.zoomType). When enabled, two-finger pinch
         * will still work as set up by [chart.pinchType](#chart.pinchType).
         * However, `zoomBySingleTouch` will interfere with touch-dragging the
         * chart to read the tooltip. And especially when vertical zooming is
         * enabled, it will make it hard to scroll vertically on the page.
         * @since      9.0.0
         * @sample     highcharts/chart/zoombysingletouch
         *             Zoom by single touch enabled, with buttons to toggle
         * @product    highcharts highstock gantt
         * @deprecated
         */
        /**
         * Chart zooming options.
         * @since 10.2.1
         */
        zooming: {
            /**
             * Equivalent to [type](#chart.zooming.type), but for multitouch
             * gestures only. By default, the `pinchType` is the same as the
             * `type` setting. However, pinching can be enabled separately in
             * some cases, for example in stock charts where a mouse drag pans the
             * chart, while pinching is enabled. When [tooltip.followTouchMove](
             * #tooltip.followTouchMove) is true, pinchType only applies to
             * two-finger touches.
             *
             * @type       {string}
             * @default    {highcharts} undefined
             * @default    {highstock} x
             * @product    highcharts highstock gantt
             * @validvalue ["x", "y", "xy"]
             * @apioption  chart.zooming.pinchType
             */
            /**
             * Decides in what dimensions the user can zoom by dragging the mouse.
             * Can be one of `x`, `y` or `xy`.
             *
             * @declare    Highcharts.OptionsChartZoomingTypeValue
             * @type       {string}
             * @default    {highcharts} undefined
             * @product    highcharts highstock gantt
             * @validvalue ["x", "y", "xy"]
             * @apioption  chart.zooming.type
             */
            /**
             * Set a key to hold when dragging to zoom the chart. This is useful to
             * avoid zooming while moving points. Should be set different than
             * [chart.panKey](#chart.panKey).
             *
             * @type       {string}
             * @default    {highcharts} undefined
             * @validvalue ["alt", "ctrl", "meta", "shift"]
             * @requires   modules/draggable-points
             * @apioption  chart.zooming.key
             */
            /**
             * Enables zooming by a single touch, in combination with
             * [chart.zooming.type](#chart.zooming.type). When enabled, two-finger
             * pinch will still work as set up by [chart.zooming.pinchType]
             * (#chart.zooming.pinchType). However, `singleTouch` will interfere
             * with touch-dragging the chart to read the tooltip. And especially
             * when vertical zooming is enabled, it will make it hard to scroll
             * vertically on the page.
             *
             * @sample  highcharts/chart/zoombysingletouch
             *          Zoom by single touch enabled, with buttons to toggle
             *
             * @product highcharts highstock gantt
             */
            singleTouch: false,
            /**
             * The button that appears after a selection zoom, allowing the user
             * to reset zoom.
             */
            resetButton: {
                /**
                 * What frame the button placement should be related to. Can be
                 * either `plotBox` or `spacingBox`.
                 *
                 * @sample {highcharts} highcharts/chart/resetzoombutton-relativeto/
                 *         Relative to the chart
                 * @sample {highstock} highcharts/chart/resetzoombutton-relativeto/
                 *         Relative to the chart
                 *
                 * @type      {Highcharts.ButtonRelativeToValue}
                 * @default   plot
                 * @apioption chart.zooming.resetButton.relativeTo
                 */
                /**
                 * A collection of attributes for the button. The object takes SVG
                 * attributes like `fill`, `stroke`, `stroke-width` or `r`, the
                 * border radius. The theme also supports `style`, a collection of
                 * CSS properties for the text. Equivalent attributes for the hover
                 * state are given in `theme.states.hover`.
                 *
                 * @sample {highcharts} highcharts/chart/resetzoombutton-theme/
                 *         Theming the button
                 * @sample {highstock} highcharts/chart/resetzoombutton-theme/
                 *         Theming the button
                 *
                 * @type  {Highcharts.SVGAttributes}
                 * @since 10.2.1
                 */
                theme: {
                    /** @internal */
                    zIndex: 6
                },
                /**
                 * The position of the button.
                 *
                 * @sample {highcharts} highcharts/chart/resetzoombutton-position/
                 *         Above the plot area
                 * @sample {highstock} highcharts/chart/resetzoombutton-position/
                 *         Above the plot area
                 * @sample {highmaps} highcharts/chart/resetzoombutton-position/
                 *         Above the plot area
                 *
                 * @type  {Highcharts.AlignObject}
                 * @since 10.2.1
                 */
                position: {
                    /**
                     * The horizontal alignment of the button.
                     */
                    align: 'right',
                    /**
                     * The horizontal offset of the button.
                     */
                    x: -10,
                    /**
                     * The vertical alignment of the button.
                     *
                     * @type       {Highcharts.VerticalAlignValue}
                     * @default    top
                     * @apioption  chart.zooming.resetButton.position.verticalAlign
                     */
                    /**
                     * The vertical offset of the button.
                     */
                    y: 10
                }
            }
        },
        /**
         * An explicit width for the chart. By default (when `null`) the width
         * is calculated from the offset width of the containing element.
         *
         * @sample {highcharts} highcharts/chart/width/
         *         800px wide
         * @sample {highstock} stock/chart/width/
         *         800px wide
         * @sample {highmaps} maps/chart/size/
         *         Chart with explicit size
         *
         * @type {null|number|string}
         */
        width: null,
        /**
         * An explicit height for the chart. If a _number_, the height is
         * given in pixels. If given a _percentage string_ (for example
         * `'56%'`), the height is given as the percentage of the actual chart
         * width. This allows for preserving the aspect ratio across responsive
         * sizes.
         *
         * By default (when `null`) the height is calculated from the offset
         * height of the containing element, or 400 pixels if the containing
         * element's height is 0.
         *
         * @sample {highcharts} highcharts/chart/height/
         *         500px height
         * @sample {highstock} stock/chart/height/
         *         300px height
         * @sample {highmaps} maps/chart/size/
         *         Chart with explicit size
         * @sample highcharts/chart/height-percent/
         *         Highcharts with percentage height
         *
         * @type {null|number|string}
         */
        height: null,
        /**
         * The color of the outer chart border.
         *
         * @see In styled mode, the stroke is set with the
         *      `.highcharts-background` class.
         *
         * @sample {highcharts} highcharts/chart/bordercolor/
         *         Brown border
         * @sample {highstock} stock/chart/border/
         *         Brown border
         * @sample {highmaps} maps/chart/border/
         *         Border options
         *
         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         */
        borderColor: "#334eff" /* Palette.highlightColor80 */,
        /**
         * The pixel width of the outer chart border.
         *
         * @see In styled mode, the stroke is set with the
         *      `.highcharts-background` class.
         *
         * @sample {highcharts} highcharts/chart/borderwidth/
         *         5px border
         * @sample {highstock} stock/chart/border/
         *         2px border
         * @sample {highmaps} maps/chart/border/
         *         Border options
         *
         * @type      {number}
         * @default   0
         * @apioption chart.borderWidth
         */
        /**
         * The background color or gradient for the outer chart area.
         *
         * @see In styled mode, the background is set with the
         *      `.highcharts-background` class.
         *
         * @sample {highcharts} highcharts/chart/backgroundcolor-color/
         *         Color
         * @sample {highcharts} highcharts/chart/backgroundcolor-gradient/
         *         Gradient
         * @sample {highstock} stock/chart/backgroundcolor-color/
         *         Color
         * @sample {highstock} stock/chart/backgroundcolor-gradient/
         *         Gradient
         * @sample {highmaps} maps/chart/backgroundcolor-color/
         *         Color
         * @sample {highmaps} maps/chart/backgroundcolor-gradient/
         *         Gradient
         *
         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         */
        backgroundColor: "#ffffff" /* Palette.backgroundColor */,
        /**
         * The background color or gradient for the plot area.
         *
         * @see In styled mode, the plot background is set with the
         *      `.highcharts-plot-background` class.
         *
         * @sample {highcharts} highcharts/chart/plotbackgroundcolor-color/
         *         Color
         * @sample {highcharts} highcharts/chart/plotbackgroundcolor-gradient/
         *         Gradient
         * @sample {highstock} stock/chart/plotbackgroundcolor-color/
         *         Color
         * @sample {highstock} stock/chart/plotbackgroundcolor-gradient/
         *         Gradient
         * @sample {highmaps} maps/chart/plotbackgroundcolor-color/
         *         Color
         * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
         *         Gradient
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @apioption chart.plotBackgroundColor
         */
        /**
         * The URL for an image to use as the plot background. To set an image
         * as the background for the entire chart, set a CSS background image
         * to the container element. Note that for the image to be applied to
         * exported charts, its URL needs to be accessible by the export server.
         *
         * @see In styled mode, a plot background image can be set with the
         *      `.highcharts-plot-background` class and a [custom pattern](
         *      https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns).
         *
         * @sample {highcharts} highcharts/chart/plotbackgroundimage/
         *         Skies
         * @sample {highstock} stock/chart/plotbackgroundimage/
         *         Skies
         *
         * @type      {string}
         * @apioption chart.plotBackgroundImage
         */
        /**
         * The color of the inner chart or plot area border.
         *
         * @see In styled mode, a plot border stroke can be set with the
         *      `.highcharts-plot-border` class.
         *
         * @sample {highcharts} highcharts/chart/plotbordercolor/
         *         Blue border
         * @sample {highstock} stock/chart/plotborder/
         *         Blue border
         * @sample {highmaps} maps/chart/plotborder/
         *         Plot border options
         *
         * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         */
        plotBorderColor: "#cccccc" /* Palette.neutralColor20 */
    };

    /**
     * Series palettes for Highcharts. Series colors are defined in highcharts.css.
     * **Do not edit this file!** This file is generated using the 'gulp palette' task.
     */
    const SeriesPalettes = {
        /**
         * Colors for data series and points
         */
        colors: [
            '#2caffe',
            '#544fc5',
            '#00e272',
            '#fe6a35',
            '#6b8abc',
            '#d568fb',
            '#2ee0ca',
            '#fa4b42',
            '#feb56a',
            '#91e8e1'
        ]
    };

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { win: win$6 } = H;
    const { defined: defined$a, error: error$4, extend: extend$c, isObject: isObject$5, merge: merge$c, objectEach: objectEach$a, pad, pick: pick$d, splat: splat$4, timeUnits } = Utilities;
    /* *
     *
     *  Constants
     *
     * */
    const hasNewSafariBug = H.isSafari &&
        win$6.Intl &&
        win$6.Intl.DateTimeFormat.prototype.formatRange;
    // To do: Remove this when we no longer need support for Safari < v14.1
    const hasOldSafariBug = H.isSafari &&
        win$6.Intl &&
        !win$6.Intl.DateTimeFormat.prototype.formatRange;
    /* *
     *
     *  Class
     *
     * */
    /* eslint-disable no-invalid-this, valid-jsdoc */
    /**
     * The Time class. Time settings are applied in general for each page using
     * `Highcharts.setOptions`, or individually for each Chart item through the
     * [time](https://api.highcharts.com/highcharts/time) options set.
     *
     * The Time object is available from {@link Highcharts.Chart#time},
     * which refers to  `Highcharts.time` if no individual time settings are
     * applied.
     *
     * @example
     * // Apply time settings globally
     * Highcharts.setOptions({
     *     time: {
     *         timezone: 'Europe/London'
     *     }
     * });
     *
     * // Apply time settings by instance
     * let chart = Highcharts.chart('container', {
     *     time: {
     *         timezone: 'America/New_York'
     *     },
     *     series: [{
     *         data: [1, 4, 3, 5]
     *     }]
     * });
     *
     * // Use the Time object
     * console.log(
     *        'Current time in New York',
     *        chart.time.dateFormat('%Y-%m-%d %H:%M:%S', Date.now())
     * );
     *
     * @since 6.0.5
     *
     * @class
     * @name Highcharts.Time
     *
     * @param {Highcharts.TimeOptions} [options]
     * Time options as defined in [chart.options.time](/highcharts/time).
     */
    class Time {
        /* *
         *
         *  Constructors
         *
         * */
        constructor(options) {
            /* *
             *
             *  Properties
             *
             * */
            this.options = {};
            this.useUTC = false;
            this.variableTimezone = false;
            this.Date = win$6.Date;
            /**
             * Get the time zone offset based on the current timezone information as
             * set in the global options.
             *
             * @function Highcharts.Time#getTimezoneOffset
             *
             * @param {number} timestamp
             *        The JavaScript timestamp to inspect.
             *
             * @return {number}
             *         The timezone offset in minutes compared to UTC.
             */
            this.getTimezoneOffset = this.timezoneOffsetFunction();
            this.update(options);
        }
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Time units used in `Time.get` and `Time.set`
         *
         * @typedef {"Date"|"Day"|"FullYear"|"Hours"|"Milliseconds"|"Minutes"|"Month"|"Seconds"} Highcharts.TimeUnitValue
         */
        /**
         * Get the value of a date object in given units, and subject to the Time
         * object's current timezone settings. This function corresponds directly to
         * JavaScripts `Date.getXXX / Date.getUTCXXX`, so instead of calling
         * `date.getHours()` or `date.getUTCHours()` we will call
         * `time.get('Hours')`.
         *
         * @function Highcharts.Time#get
         *
         * @param {Highcharts.TimeUnitValue} unit
         * @param {Date} date
         *
         * @return {number}
         *        The given time unit
         */
        get(unit, date) {
            if (this.variableTimezone || this.timezoneOffset) {
                const realMs = date.getTime();
                const ms = realMs - this.getTimezoneOffset(date);
                date.setTime(ms); // Temporary adjust to timezone
                const ret = date['getUTC' + unit]();
                date.setTime(realMs); // Reset
                return ret;
            }
            // UTC time with no timezone handling
            if (this.useUTC) {
                return date['getUTC' + unit]();
            }
            // Else, local time
            return date['get' + unit]();
        }
        /**
         * Set the value of a date object in given units, and subject to the Time
         * object's current timezone settings. This function corresponds directly to
         * JavaScripts `Date.setXXX / Date.setUTCXXX`, so instead of calling
         * `date.setHours(0)` or `date.setUTCHours(0)` we will call
         * `time.set('Hours', 0)`.
         *
         * @function Highcharts.Time#set
         *
         * @param {Highcharts.TimeUnitValue} unit
         * @param {Date} date
         * @param {number} value
         *
         * @return {number}
         *        The epoch milliseconds of the updated date
         */
        set(unit, date, value) {
            // UTC time with timezone handling
            if (this.variableTimezone || this.timezoneOffset) {
                // For lower order time units, just set it directly using UTC
                // time
                if (unit === 'Milliseconds' ||
                    unit === 'Seconds' ||
                    (unit === 'Minutes' &&
                        this.getTimezoneOffset(date) % 3600000 === 0) // #13961
                ) {
                    return date['setUTC' + unit](value);
                }
                // Higher order time units need to take the time zone into
                // account
                // Adjust by timezone
                const offset = this.getTimezoneOffset(date);
                let ms = date.getTime() - offset;
                date.setTime(ms);
                date['setUTC' + unit](value);
                const newOffset = this.getTimezoneOffset(date);
                ms = date.getTime() + newOffset;
                return date.setTime(ms);
            }
            // UTC time with no timezone handling
            if (this.useUTC ||
                // leap calculation in UTC only
                (hasNewSafariBug && unit === 'FullYear')) {
                return date['setUTC' + unit](value);
            }
            // Else, local time
            return date['set' + unit](value);
        }
        /**
         * Update the Time object with current options. It is called internally on
         * initializing Highcharts, after running `Highcharts.setOptions` and on
         * `Chart.update`.
         *
         * @private
         * @function Highcharts.Time#update
         *
         * @param {Highcharts.TimeOptions} [options]
         *
         */
        update(options = {}) {
            const useUTC = pick$d(options.useUTC, true);
            this.options = options = merge$c(true, this.options, options);
            // Allow using a different Date class
            this.Date = options.Date || win$6.Date || Date;
            this.useUTC = useUTC;
            this.timezoneOffset = (useUTC && options.timezoneOffset) || void 0;
            this.getTimezoneOffset = this.timezoneOffsetFunction();
            /*
             * The time object has options allowing for variable time zones, meaning
             * the axis ticks or series data needs to consider this.
             */
            this.variableTimezone = useUTC && !!(options.getTimezoneOffset ||
                options.timezone);
        }
        /**
         * Make a time and returns milliseconds. Interprets the inputs as UTC time,
         * local time or a specific timezone time depending on the current time
         * settings.
         *
         * @function Highcharts.Time#makeTime
         *
         * @param {number} year
         *        The year
         *
         * @param {number} month
         *        The month. Zero-based, so January is 0.
         *
         * @param {number} [date=1]
         *        The day of the month
         *
         * @param {number} [hours=0]
         *        The hour of the day, 0-23.
         *
         * @param {number} [minutes=0]
         *        The minutes
         *
         * @param {number} [seconds=0]
         *        The seconds
         *
         * @return {number}
         *         The time in milliseconds since January 1st 1970.
         */
        makeTime(year, month, date, hours, minutes, seconds) {
            let d, offset, newOffset;
            if (this.useUTC) {
                d = this.Date.UTC.apply(0, arguments);
                offset = this.getTimezoneOffset(d);
                d += offset;
                newOffset = this.getTimezoneOffset(d);
                if (offset !== newOffset) {
                    d += newOffset - offset;
                    // A special case for transitioning from summer time to winter time.
                    // When the clock is set back, the same time is repeated twice, i.e.
                    // 02:30 am is repeated since the clock is set back from 3 am to
                    // 2 am. We need to make the same time as local Date does.
                }
                else if (offset - 36e5 === this.getTimezoneOffset(d - 36e5) &&
                    !hasOldSafariBug) {
                    d -= 36e5;
                }
            }
            else {
                d = new this.Date(year, month, pick$d(date, 1), pick$d(hours, 0), pick$d(minutes, 0), pick$d(seconds, 0)).getTime();
            }
            return d;
        }
        /**
         * Sets the getTimezoneOffset function. If the `timezone` option is set, a
         * default getTimezoneOffset function with that timezone is returned. If
         * a `getTimezoneOffset` option is defined, it is returned. If neither are
         * specified, the function using the `timezoneOffset` option or 0 offset is
         * returned.
         *
         * @private
         * @function Highcharts.Time#timezoneOffsetFunction
         *
         * @return {Function}
         *         A getTimezoneOffset function
         */
        timezoneOffsetFunction() {
            const time = this, options = this.options, getTimezoneOffset = options.getTimezoneOffset, moment = options.moment || win$6.moment;
            if (!this.useUTC) {
                return function (timestamp) {
                    return new Date(timestamp.toString()).getTimezoneOffset() * 60000;
                };
            }
            if (options.timezone) {
                if (!moment) {
                    // getTimezoneOffset-function stays undefined because it depends
                    // on Moment.js
                    error$4(25);
                }
                else {
                    return function (timestamp) {
                        return -moment.tz(timestamp, options.timezone).utcOffset() * 60000;
                    };
                }
            }
            // If not timezone is set, look for the getTimezoneOffset callback
            if (this.useUTC && getTimezoneOffset) {
                return function (timestamp) {
                    return getTimezoneOffset(timestamp.valueOf()) * 60000;
                };
            }
            // Last, use the `timezoneOffset` option if set
            return function () {
                return (time.timezoneOffset || 0) * 60000;
            };
        }
        /**
         * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970)
         * into a human readable date string. The available format keys are listed
         * below. Additional formats can be given in the
         * {@link Highcharts.dateFormats} hook.
         *
         * Supported format keys:
         * - `%a`: Short weekday, like 'Mon'
         * - `%A`: Long weekday, like 'Monday'
         * - `%d`: Two digit day of the month, 01 to 31
         * - `%e`: Day of the month, 1 through 31
         * - `%w`: Day of the week, 0 through 6
         * - `%b`: Short month, like 'Jan'
         * - `%B`: Long month, like 'January'
         * - `%m`: Two digit month number, 01 through 12
         * - `%y`: Two digits year, like 09 for 2009
         * - `%Y`: Four digits year, like 2009
         * - `%H`: Two digits hours in 24h format, 00 through 23
         * - `%k`: Hours in 24h format, 0 through 23
         * - `%I`: Two digits hours in 12h format, 00 through 11
         * - `%l`: Hours in 12h format, 1 through 12
         * - `%M`: Two digits minutes, 00 through 59
         * - `%p`: Upper case AM or PM
         * - `%P`: Lower case AM or PM
         * - `%S`: Two digits seconds, 00 through 59
         * - `%L`: Milliseconds (naming from Ruby)
         *
         * @example
         * const time = new Highcharts.Time();
         * const s = time.dateFormat('%Y-%m-%d %H:%M:%S', Date.UTC(2020, 0, 1));
         * console.log(s); // => 2020-01-01 00:00:00
         *
         * @function Highcharts.Time#dateFormat
         *
         * @param {string} format
         *        The desired format where various time representations are
         *        prefixed with %.
         *
         * @param {number} [timestamp]
         *        The JavaScript timestamp.
         *
         * @param {boolean} [capitalize=false]
         *        Upper case first letter in the return.
         *
         * @return {string}
         *         The formatted date.
         */
        dateFormat(format, timestamp, capitalize) {
            if (!defined$a(timestamp) || isNaN(timestamp)) {
                return (H.defaultOptions.lang &&
                    H.defaultOptions.lang.invalidDate ||
                    '');
            }
            format = pick$d(format, '%Y-%m-%d %H:%M:%S');
            const time = this, date = new this.Date(timestamp), 
            // get the basic time values
            hours = this.get('Hours', date), day = this.get('Day', date), dayOfMonth = this.get('Date', date), month = this.get('Month', date), fullYear = this.get('FullYear', date), lang = H.defaultOptions.lang, langWeekdays = (lang && lang.weekdays), shortWeekdays = (lang && lang.shortWeekdays), 
            // List all format keys. Custom formats can be added from the
            // outside.
            replacements = extend$c({
                // Day
                // Short weekday, like 'Mon'
                a: shortWeekdays ?
                    shortWeekdays[day] :
                    langWeekdays[day].substr(0, 3),
                // Long weekday, like 'Monday'
                A: langWeekdays[day],
                // Two digit day of the month, 01 to 31
                d: pad(dayOfMonth),
                // Day of the month, 1 through 31
                e: pad(dayOfMonth, 2, ' '),
                // Day of the week, 0 through 6
                w: day,
                // Week (none implemented)
                // 'W': weekNumber(),
                // Month
                // Short month, like 'Jan'
                b: lang.shortMonths[month],
                // Long month, like 'January'
                B: lang.months[month],
                // Two digit month number, 01 through 12
                m: pad(month + 1),
                // Month number, 1 through 12 (#8150)
                o: month + 1,
                // Year
                // Two digits year, like 09 for 2009
                y: fullYear.toString().substr(2, 2),
                // Four digits year, like 2009
                Y: fullYear,
                // Time
                // Two digits hours in 24h format, 00 through 23
                H: pad(hours),
                // Hours in 24h format, 0 through 23
                k: hours,
                // Two digits hours in 12h format, 00 through 11
                I: pad((hours % 12) || 12),
                // Hours in 12h format, 1 through 12
                l: (hours % 12) || 12,
                // Two digits minutes, 00 through 59
                M: pad(this.get('Minutes', date)),
                // Upper case AM or PM
                p: hours < 12 ? 'AM' : 'PM',
                // Lower case AM or PM
                P: hours < 12 ? 'am' : 'pm',
                // Two digits seconds, 00 through  59
                S: pad(date.getSeconds()),
                // Milliseconds (naming from Ruby)
                L: pad(Math.floor(timestamp % 1000), 3)
            }, H.dateFormats);
            // Do the replaces
            objectEach$a(replacements, function (val, key) {
                // Regex would do it in one line, but this is faster
                while (format.indexOf('%' + key) !== -1) {
                    format = format.replace('%' + key, typeof val === 'function' ? val.call(time, timestamp) : val);
                }
            });
            // Optionally capitalize the string and return
            return capitalize ?
                (format.substr(0, 1).toUpperCase() +
                    format.substr(1)) :
                format;
        }
        /**
         * Resolve legacy formats of dateTimeLabelFormats (strings and arrays) into
         * an object.
         * @private
         * @param {string|Array<T>|Highcharts.Dictionary<T>} f
         * General format description
         * @return {Highcharts.Dictionary<T>}
         * The object definition
         */
        resolveDTLFormat(f) {
            if (!isObject$5(f, true)) { // check for string or array
                f = splat$4(f);
                return {
                    main: f[0],
                    from: f[1],
                    to: f[2]
                };
            }
            return f;
        }
        /**
         * Return an array with time positions distributed on round time values
         * right and right after min and max. Used in datetime axes as well as for
         * grouping data on a datetime axis.
         *
         * @function Highcharts.Time#getTimeTicks
         *
         * @param {Highcharts.TimeNormalizedObject} normalizedInterval
         *        The interval in axis values (ms) and the count
         *
         * @param {number} [min]
         *        The minimum in axis values
         *
         * @param {number} [max]
         *        The maximum in axis values
         *
         * @param {number} [startOfWeek=1]
         *
         * @return {Highcharts.AxisTickPositionsArray}
         * Time positions
         */
        getTimeTicks(normalizedInterval, min, max, startOfWeek) {
            const time = this, Date = time.Date, tickPositions = [], higherRanks = {}, 
            // When crossing DST, use the max. Resolves #6278.
            minDate = new Date(min), interval = normalizedInterval.unitRange, count = normalizedInterval.count || 1;
            let i, minYear, // used in months and years as a basis for Date.UTC()
            variableDayLength, minDay;
            startOfWeek = pick$d(startOfWeek, 1);
            if (defined$a(min)) { // #1300
                time.set('Milliseconds', minDate, interval >= timeUnits.second ?
                    0 : // #3935
                    count * Math.floor(time.get('Milliseconds', minDate) / count)); // #3652, #3654
                if (interval >= timeUnits.second) { // second
                    time.set('Seconds', minDate, interval >= timeUnits.minute ?
                        0 : // #3935
                        count * Math.floor(time.get('Seconds', minDate) / count));
                }
                if (interval >= timeUnits.minute) { // minute
                    time.set('Minutes', minDate, interval >= timeUnits.hour ?
                        0 :
                        count * Math.floor(time.get('Minutes', minDate) / count));
                }
                if (interval >= timeUnits.hour) { // hour
                    time.set('Hours', minDate, interval >= timeUnits.day ?
                        0 :
                        count * Math.floor(time.get('Hours', minDate) / count));
                }
                if (interval >= timeUnits.day) { // day
                    time.set('Date', minDate, interval >= timeUnits.month ?
                        1 :
                        Math.max(1, count * Math.floor(time.get('Date', minDate) / count)));
                }
                if (interval >= timeUnits.month) { // month
                    time.set('Month', minDate, interval >= timeUnits.year ? 0 :
                        count * Math.floor(time.get('Month', minDate) / count));
                    minYear = time.get('FullYear', minDate);
                }
                if (interval >= timeUnits.year) { // year
                    minYear -= minYear % count;
                    time.set('FullYear', minDate, minYear);
                }
                // week is a special case that runs outside the hierarchy
                if (interval === timeUnits.week) {
                    // get start of current week, independent of count
                    minDay = time.get('Day', minDate);
                    time.set('Date', minDate, (time.get('Date', minDate) -
                        minDay + startOfWeek +
                        // We don't want to skip days that are before
                        // startOfWeek (#7051)
                        (minDay < startOfWeek ? -7 : 0)));
                }
                // Get basics for variable time spans
                minYear = time.get('FullYear', minDate);
                const minMonth = time.get('Month', minDate), minDateDate = time.get('Date', minDate), minHours = time.get('Hours', minDate);
                // Redefine min to the floored/rounded minimum time (#7432)
                min = minDate.getTime();
                // Handle local timezone offset
                if ((time.variableTimezone || !time.useUTC) && defined$a(max)) {
                    // Detect whether we need to take the DST crossover into
                    // consideration. If we're crossing over DST, the day length may
                    // be 23h or 25h and we need to compute the exact clock time for
                    // each tick instead of just adding hours. This comes at a cost,
                    // so first we find out if it is needed (#4951).
                    variableDayLength = (
                    // Long range, assume we're crossing over.
                    max - min > 4 * timeUnits.month ||
                        // Short range, check if min and max are in different time
                        // zones.
                        time.getTimezoneOffset(min) !==
                            time.getTimezoneOffset(max));
                }
                // Iterate and add tick positions at appropriate values
                let t = minDate.getTime();
                i = 1;
                while (t < max) {
                    tickPositions.push(t);
                    // if the interval is years, use Date.UTC to increase years
                    if (interval === timeUnits.year) {
                        t = time.makeTime(minYear + i * count, 0);
                        // if the interval is months, use Date.UTC to increase months
                    }
                    else if (interval === timeUnits.month) {
                        t = time.makeTime(minYear, minMonth + i * count);
                        // if we're using global time, the interval is not fixed as it
                        // jumps one hour at the DST crossover
                    }
                    else if (variableDayLength &&
                        (interval === timeUnits.day || interval === timeUnits.week)) {
                        t = time.makeTime(minYear, minMonth, minDateDate +
                            i * count * (interval === timeUnits.day ? 1 : 7));
                    }
                    else if (variableDayLength &&
                        interval === timeUnits.hour &&
                        count > 1) {
                        // make sure higher ranks are preserved across DST (#6797,
                        // #7621)
                        t = time.makeTime(minYear, minMonth, minDateDate, minHours + i * count);
                        // else, the interval is fixed and we use simple addition
                    }
                    else {
                        t += interval * count;
                    }
                    i++;
                }
                // push the last time
                tickPositions.push(t);
                // Handle higher ranks. Mark new days if the time is on midnight
                // (#950, #1649, #1760, #3349). Use a reasonable dropout threshold
                // to prevent looping over dense data grouping (#6156).
                if (interval <= timeUnits.hour && tickPositions.length < 10000) {
                    tickPositions.forEach(function (t) {
                        if (
                        // Speed optimization, no need to run dateFormat unless
                        // we're on a full or half hour
                        t % 1800000 === 0 &&
                            // Check for local or global midnight
                            time.dateFormat('%H%M%S%L', t) === '000000000') {
                            higherRanks[t] = 'day';
                        }
                    });
                }
            }
            // record information on the chosen unit - for dynamic label formatter
            tickPositions.info = extend$c(normalizedInterval, {
                higherRanks,
                totalRange: interval * count
            });
            return tickPositions;
        }
        /**
         * Get the optimal date format for a point, based on a range.
         *
         * @private
         * @function Highcharts.Time#getDateFormat
         *
         * @param {number} range
         *        The time range
         *
         * @param {number} timestamp
         *        The timestamp of the date
         *
         * @param {number} startOfWeek
         *        An integer representing the first day of the week, where 0 is
         *        Sunday.
         *
         * @param {Highcharts.Dictionary<string>} dateTimeLabelFormats
         *        A map of time units to formats.
         *
         * @return {string}
         *         The optimal date format for a point.
         */
        getDateFormat(range, timestamp, startOfWeek, dateTimeLabelFormats) {
            const dateStr = this.dateFormat('%m-%d %H:%M:%S.%L', timestamp), blank = '01-01 00:00:00.000', strpos = {
                millisecond: 15,
                second: 12,
                minute: 9,
                hour: 6,
                day: 3
            };
            let n = 'millisecond', 
            // for sub-millisecond data, #4223
            lastN = n;
            for (n in timeUnits) { // eslint-disable-line guard-for-in
                // If the range is exactly one week and we're looking at a
                // Sunday/Monday, go for the week format
                if (range === timeUnits.week &&
                    +this.dateFormat('%w', timestamp) === startOfWeek &&
                    dateStr.substr(6) === blank.substr(6)) {
                    n = 'week';
                    break;
                }
                // The first format that is too great for the range
                if (timeUnits[n] > range) {
                    n = lastN;
                    break;
                }
                // If the point is placed every day at 23:59, we need to show
                // the minutes as well. #2637.
                if (strpos[n] &&
                    dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {
                    break;
                }
                // Weeks are outside the hierarchy, only apply them on
                // Mondays/Sundays like in the first condition
                if (n !== 'week') {
                    lastN = n;
                }
            }
            return this.resolveDTLFormat(dateTimeLabelFormats[n]).main;
        }
    }

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { isTouchDevice, svg: svg$3 } = H;
    const { merge: merge$b } = Utilities;
    /* *
     *
     *  API Options
     *
     * */
    /**
     * Global default settings.
     *
     * @name Highcharts.defaultOptions
     * @type {Highcharts.Options}
     */ /**
    * @optionparent
    * @private
    */
    const defaultOptions$6 = {
        /**
         * An array containing the default colors for the chart's series. When
         * all colors are used, new colors are pulled from the start again.
         *
         * Default colors can also be set on a series or series.type basis,
         * see [column.colors](#plotOptions.column.colors),
         * [pie.colors](#plotOptions.pie.colors).
         *
         * In styled mode, the colors option doesn't exist. Instead, colors
         * are defined in CSS and applied either through series or point class
         * names, or through the [chart.colorCount](#chart.colorCount) option.
         *
         * @sample {highcharts} highcharts/chart/colors/
         *         Assign a global color theme
         * @sample highcharts/members/theme-v10/
         *         Latest release styled like version 10
         *
         * @type    {Array<(Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject)>}
         * @default [
         *     "#2caffe",
         *     "#544fc5",
         *     "#00e272",
         *     "#fe6a35",
         *     "#6b8abc",
         *     "#d568fb",
         *     "#2ee0ca",
         *     "#fa4b42",
         *     "#feb56a",
         *     "#91e8e12
         * ]
         */
        colors: SeriesPalettes.colors,
        /**
         * Styled mode only. Configuration object for adding SVG definitions for
         * reusable elements. See [gradients, shadows and
         * patterns](https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns)
         * for more information and code examples.
         *
         * @type      {*}
         * @since     5.0.0
         * @apioption defs
         */
        /**
         * @ignore-option
         */
        symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
        /**
         * The language object is global and it can't be set on each chart
         * initialization. Instead, use `Highcharts.setOptions` to set it before any
         * chart is initialized.
         *
         * ```js
         * Highcharts.setOptions({
         *     lang: {
         *         months: [
         *             'Janvier', 'Février', 'Mars', 'Avril',
         *             'Mai', 'Juin', 'Juillet', 'Août',
         *             'Septembre', 'Octobre', 'Novembre', 'Décembre'
         *         ],
         *         weekdays: [
         *             'Dimanche', 'Lundi', 'Mardi', 'Mercredi',
         *             'Jeudi', 'Vendredi', 'Samedi'
         *         ]
         *     }
         * });
         * ```
         */
        lang: {
            /**
             * The loading text that appears when the chart is set into the loading
             * state following a call to `chart.showLoading`.
             */
            loading: 'Loading...',
            /**
             * An array containing the months names. Corresponds to the `%B` format
             * in `Highcharts.dateFormat()`.
             *
             * @type    {Array<string>}
             * @default ["January", "February", "March", "April", "May", "June",
             *          "July", "August", "September", "October", "November",
             *          "December"]
             */
            months: [
                'January', 'February', 'March', 'April', 'May', 'June', 'July',
                'August', 'September', 'October', 'November', 'December'
            ],
            /**
             * An array containing the months names in abbreviated form. Corresponds
             * to the `%b` format in `Highcharts.dateFormat()`.
             *
             * @type    {Array<string>}
             * @default ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
             *          "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
             */
            shortMonths: [
                'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
                'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
            ],
            /**
             * An array containing the weekday names.
             *
             * @type    {Array<string>}
             * @default ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
             *          "Friday", "Saturday"]
             */
            weekdays: [
                'Sunday', 'Monday', 'Tuesday', 'Wednesday',
                'Thursday', 'Friday', 'Saturday'
            ],
            /**
             * Short week days, starting Sunday. If not specified, Highcharts uses
             * the first three letters of the `lang.weekdays` option.
             *
             * @sample highcharts/lang/shortweekdays/
             *         Finnish two-letter abbreviations
             *
             * @type      {Array<string>}
             * @since     4.2.4
             * @apioption lang.shortWeekdays
             */
            /**
             * What to show in a date field for invalid dates. Defaults to an empty
             * string.
             *
             * @type      {string}
             * @since     4.1.8
             * @product   highcharts highstock
             * @apioption lang.invalidDate
             */
            /**
             * The title appearing on hovering the zoom in button. The text itself
             * defaults to "+" and can be changed in the button options.
             *
             * @type      {string}
             * @default   Zoom in
             * @product   highmaps
             * @apioption lang.zoomIn
             */
            /**
             * The title appearing on hovering the zoom out button. The text itself
             * defaults to "-" and can be changed in the button options.
             *
             * @type      {string}
             * @default   Zoom out
             * @product   highmaps
             * @apioption lang.zoomOut
             */
            /**
             * The default decimal point used in the `Highcharts.numberFormat`
             * method unless otherwise specified in the function arguments.
             *
             * @since 1.2.2
             */
            decimalPoint: '.',
            /**
             * [Metric prefixes](https://en.wikipedia.org/wiki/Metric_prefix) used
             * to shorten high numbers in axis labels. Replacing any of the
             * positions with `null` causes the full number to be written. Setting
             * `numericSymbols` to `null` disables shortening altogether.
             *
             * @sample {highcharts} highcharts/lang/numericsymbols/
             *         Replacing the symbols with text
             * @sample {highstock} highcharts/lang/numericsymbols/
             *         Replacing the symbols with text
             *
             * @type    {Array<string>}
             * @default ["k", "M", "G", "T", "P", "E"]
             * @since   2.3.0
             */
            numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'],
            /**
             * The magnitude of [numericSymbols](#lang.numericSymbol) replacements.
             * Use 10000 for Japanese, Korean and various Chinese locales, which
             * use symbols for 10^4, 10^8 and 10^12.
             *
             * @sample highcharts/lang/numericsymbolmagnitude/
             *         10000 magnitude for Japanese
             *
             * @type      {number}
             * @default   1000
             * @since     5.0.3
             * @apioption lang.numericSymbolMagnitude
             */
            /**
             * The text for the label appearing when a chart is zoomed.
             *
             * @since 1.2.4
             */
            resetZoom: 'Reset zoom',
            /**
             * The tooltip title for the label appearing when a chart is zoomed.
             *
             * @since 1.2.4
             */
            resetZoomTitle: 'Reset zoom level 1:1',
            /**
             * The default thousands separator used in the `Highcharts.numberFormat`
             * method unless otherwise specified in the function arguments. Defaults
             * to a single space character, which is recommended in
             * [ISO 31-0](https://en.wikipedia.org/wiki/ISO_31-0#Numbers) and works
             * across Anglo-American and continental European languages.
             *
             * @default \u0020
             * @since   1.2.2
             */
            thousandsSep: ' '
        },
        /**
         * Global options that don't apply to each chart. These options, like
         * the `lang` options, must be set using the `Highcharts.setOptions`
         * method.
         *
         * ```js
         * Highcharts.setOptions({
         *     global: {
         *         useUTC: false
         *     }
         * });
         * ```
         */
        /**
         * _Canvg rendering for Android 2.x is removed as of Highcharts 5.0\.
         * Use the [libURL](#exporting.libURL) option to configure exporting._
         *
         * The URL to the additional file to lazy load for Android 2.x devices.
         * These devices don't support SVG, so we download a helper file that
         * contains [canvg](https://github.com/canvg/canvg), its dependency
         * rbcolor, and our own CanVG Renderer class. To avoid hotlinking to
         * our site, you can install canvas-tools.js on your own server and
         * change this option accordingly.
         *
         * @deprecated
         *
         * @type      {string}
         * @default   https://code.highcharts.com/{version}/modules/canvas-tools.js
         * @product   highcharts highmaps
         * @apioption global.canvasToolsURL
         */
        /**
         * This option is deprecated since v6.0.5. Instead, use
         * [time.useUTC](#time.useUTC) that supports individual time settings
         * per chart.
         *
         * @deprecated
         *
         * @type      {boolean}
         * @apioption global.useUTC
         */
        /**
         * This option is deprecated since v6.0.5. Instead, use
         * [time.Date](#time.Date) that supports individual time settings
         * per chart.
         *
         * @deprecated
         *
         * @type      {Function}
         * @product   highcharts highstock
         * @apioption global.Date
         */
        /**
         * This option is deprecated since v6.0.5. Instead, use
         * [time.getTimezoneOffset](#time.getTimezoneOffset) that supports
         * individual time settings per chart.
         *
         * @deprecated
         *
         * @type      {Function}
         * @product   highcharts highstock
         * @apioption global.getTimezoneOffset
         */
        /**
         * This option is deprecated since v6.0.5. Instead, use
         * [time.timezone](#time.timezone) that supports individual time
         * settings per chart.
         *
         * @deprecated
         *
         * @type      {string}
         * @product   highcharts highstock
         * @apioption global.timezone
         */
        /**
         * This option is deprecated since v6.0.5. Instead, use
         * [time.timezoneOffset](#time.timezoneOffset) that supports individual
         * time settings per chart.
         *
         * @deprecated
         *
         * @type      {number}
         * @product   highcharts highstock
         * @apioption global.timezoneOffset
         */
        global: {},
        /**
         * Time options that can apply globally or to individual charts. These
         * settings affect how `datetime` axes are laid out, how tooltips are
         * formatted, how series
         * [pointIntervalUnit](#plotOptions.series.pointIntervalUnit) works and how
         * the Highcharts Stock range selector handles time.
         *
         * The common use case is that all charts in the same Highcharts object
         * share the same time settings, in which case the global settings are set
         * using `setOptions`.
         *
         * ```js
         * // Apply time settings globally
         * Highcharts.setOptions({
         *     time: {
         *         timezone: 'Europe/London'
         *     }
         * });
         * // Apply time settings by instance
         * let chart = Highcharts.chart('container', {
         *     time: {
         *         timezone: 'America/New_York'
         *     },
         *     series: [{
         *         data: [1, 4, 3, 5]
         *     }]
         * });
         *
         * // Use the Time object
         * console.log(
         *        'Current time in New York',
         *        chart.time.dateFormat('%Y-%m-%d %H:%M:%S', Date.now())
         * );
         * ```
         *
         * Since v6.0.5, the time options were moved from the `global` obect to the
         * `time` object, and time options can be set on each individual chart.
         *
         * @sample {highcharts|highstock}
         *         highcharts/time/timezone/
         *         Set the timezone globally
         * @sample {highcharts}
         *         highcharts/time/individual/
         *         Set the timezone per chart instance
         * @sample {highstock}
         *         stock/time/individual/
         *         Set the timezone per chart instance
         *
         * @since     6.0.5
         * @optionparent time
         */
        time: {
            /**
             * A custom `Date` class for advanced date handling. For example,
             * [JDate](https://github.com/tahajahangir/jdate) can be hooked in to
             * handle Jalali dates.
             *
             * @type      {*}
             * @since     4.0.4
             * @product   highcharts highstock gantt
             */
            Date: void 0,
            /**
             * A callback to return the time zone offset for a given datetime. It
             * takes the timestamp in terms of milliseconds since January 1 1970,
             * and returns the timezone offset in minutes. This provides a hook
             * for drawing time based charts in specific time zones using their
             * local DST crossover dates, with the help of external libraries.
             *
             * @see [global.timezoneOffset](#global.timezoneOffset)
             *
             * @sample {highcharts|highstock} highcharts/time/gettimezoneoffset/
             *         Use moment.js to draw Oslo time regardless of browser locale
             *
             * @type      {Highcharts.TimezoneOffsetCallbackFunction}
             * @since     4.1.0
             * @product   highcharts highstock gantt
             */
            getTimezoneOffset: void 0,
            /**
             * Requires [moment.js](https://momentjs.com/). If the timezone option
             * is specified, it creates a default
             * [getTimezoneOffset](#time.getTimezoneOffset) function that looks
             * up the specified timezone in moment.js. If moment.js is not included,
             * this throws a Highcharts error in the console, but does not crash the
             * chart.
             *
             * @see [getTimezoneOffset](#time.getTimezoneOffset)
             *
             * @sample {highcharts|highstock} highcharts/time/timezone/
             *         Europe/Oslo
             *
             * @type      {string}
             * @since     5.0.7
             * @product   highcharts highstock gantt
             */
            timezone: void 0,
            /**
             * The timezone offset in minutes. Positive values are west, negative
             * values are east of UTC, as in the ECMAScript
             * [getTimezoneOffset](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset)
             * method. Use this to display UTC based data in a predefined time zone.
             *
             * @see [time.getTimezoneOffset](#time.getTimezoneOffset)
             *
             * @sample {highcharts|highstock} highcharts/time/timezoneoffset/
             *         Timezone offset
             *
             * @since     3.0.8
             * @product   highcharts highstock gantt
             */
            timezoneOffset: 0,
            /**
             * Whether to use UTC time for axis scaling, tickmark placement and
             * time display in `Highcharts.dateFormat`. Advantages of using UTC
             * is that the time displays equally regardless of the user agent's
             * time zone settings. Local time can be used when the data is loaded
             * in real time or when correct Daylight Saving Time transitions are
             * required.
             *
             * @sample {highcharts} highcharts/time/useutc-true/
             *         True by default
             * @sample {highcharts} highcharts/time/useutc-false/
             *         False
             */
            useUTC: true
        },
        chart: ChartDefaults,
        /**
         * The chart's main title.
         *
         * @sample {highmaps} maps/title/title/
         *         Title options demonstrated
         */
        title: {
            /**
             * When the title is floating, the plot area will not move to make space
             * for it.
             *
             * @sample {highcharts} highcharts/chart/zoomtype-none/
             *         False by default
             * @sample {highcharts} highcharts/title/floating/
             *         True - title on top of the plot area
             * @sample {highstock} stock/chart/title-floating/
             *         True - title on top of the plot area
             *
             * @type      {boolean}
             * @default   false
             * @since     2.1
             * @apioption title.floating
             */
            /**
             * Whether to
             * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
             * to render the text.
             *
             * @type      {boolean}
             * @default   false
             * @apioption title.useHTML
             */
            /**
             * The vertical alignment of the title. Can be one of `"top"`,
             * `"middle"` and `"bottom"`. When a value is given, the title behaves
             * as if [floating](#title.floating) were `true`.
             *
             * @sample {highcharts} highcharts/title/verticalalign/
             *         Chart title in bottom right corner
             * @sample {highstock} stock/chart/title-verticalalign/
             *         Chart title in bottom right corner
             *
             * @type      {Highcharts.VerticalAlignValue}
             * @since     2.1
             * @apioption title.verticalAlign
             */
            /**
             * The x position of the title relative to the alignment within
             * `chart.spacingLeft` and `chart.spacingRight`.
             *
             * @sample {highcharts} highcharts/title/align/
             *         Aligned to the plot area (x = 70px = margin left - spacing
             *         left)
             * @sample {highstock} stock/chart/title-align/
             *         Aligned to the plot area (x = 50px = margin left - spacing
             *         left)
             *
             * @type      {number}
             * @default   0
             * @since     2.0
             * @apioption title.x
             */
            /**
             * The y position of the title relative to the alignment within
             * [chart.spacingTop](#chart.spacingTop) and [chart.spacingBottom](
             * #chart.spacingBottom). By default it depends on the font size.
             *
             * @sample {highcharts} highcharts/title/y/
             *         Title inside the plot area
             * @sample {highstock} stock/chart/title-verticalalign/
             *         Chart title in bottom right corner
             *
             * @type      {number}
             * @since     2.0
             * @apioption title.y
             */
            /**
             * CSS styles for the title. Use this for font styling, but use `align`,
             * `x` and `y` for text alignment.
             *
             * In styled mode, the title style is given in the `.highcharts-title`
             * class.
             *
             * @sample {highcharts} highcharts/title/style/
             *         Custom color and weight
             * @sample {highstock} stock/chart/title-style/
             *         Custom color and weight
             * @sample highcharts/css/titles/
             *         Styled mode
             *
             * @type      {Highcharts.CSSObject}
             * @default   {highcharts|highmaps} { "color": "#333333", "fontSize": "18px" }
             * @default   {highstock} { "color": "#333333", "fontSize": "16px" }
             */
            style: {
                color: "#333333" /* Palette.neutralColor80 */,
                fontWeight: 'bold'
            },
            /**
             * The title of the chart. To disable the title, set the `text` to
             * `undefined`.
             *
             * @sample {highcharts} highcharts/title/text/
             *         Custom title
             * @sample {highstock} stock/chart/title-text/
             *         Custom title
             *
             * @default {highcharts|highmaps} Chart title
             * @default {highstock} undefined
             */
            text: 'Chart title',
            /**
             * The horizontal alignment of the title. Can be one of "left", "center"
             * and "right".
             *
             * @sample {highcharts} highcharts/title/align/
             *         Aligned to the plot area (x = 70px = margin left - spacing
             *         left)
             * @sample {highstock} stock/chart/title-align/
             *         Aligned to the plot area (x = 50px = margin left - spacing
             *         left)
             *
             * @type  {Highcharts.AlignValue}
             * @since 2.0
             */
            align: 'center',
            /**
             * The margin between the title and the plot area, or if a subtitle
             * is present, the margin between the subtitle and the plot area.
             *
             * @sample {highcharts} highcharts/title/margin-50/
             *         A chart title margin of 50
             * @sample {highcharts} highcharts/title/margin-subtitle/
             *         The same margin applied with a subtitle
             * @sample {highstock} stock/chart/title-margin/
             *         A chart title margin of 50
             *
             * @since 2.1
             */
            margin: 15,
            /**
             * Adjustment made to the title width, normally to reserve space for
             * the exporting burger menu.
             *
             * @sample highcharts/title/widthadjust/
             *         Wider menu, greater padding
             *
             * @since 4.2.5
             */
            widthAdjust: -44
        },
        /**
         * The chart's subtitle. This can be used both to display a subtitle below
         * the main title, and to display random text anywhere in the chart. The
         * subtitle can be updated after chart initialization through the
         * `Chart.setTitle` method.
         *
         * @sample {highmaps} maps/title/subtitle/
         *         Subtitle options demonstrated
         */
        subtitle: {
            /**
             * When the subtitle is floating, the plot area will not move to make
             * space for it.
             *
             * @sample {highcharts} highcharts/subtitle/floating/
             *         Floating title and subtitle
             * @sample {highstock} stock/chart/subtitle-footnote
             *         Footnote floating at bottom right of plot area
             *
             * @type      {boolean}
             * @default   false
             * @since     2.1
             * @apioption subtitle.floating
             */
            /**
             * CSS styles for the title.
             *
             * In styled mode, the subtitle style is given in the
             * `.highcharts-subtitle` class.
             *
             * @sample {highcharts} highcharts/subtitle/style/
             *         Custom color and weight
             * @sample {highcharts} highcharts/css/titles/
             *         Styled mode
             * @sample {highstock} stock/chart/subtitle-style
             *         Custom color and weight
             * @sample {highstock} highcharts/css/titles/
             *         Styled mode
             * @sample {highmaps} highcharts/css/titles/
             *         Styled mode
             *
             * @type      {Highcharts.CSSObject}
             * @default   {"color": "#666666"}
             * @apioption subtitle.style
             */
            /**
             * Whether to
             * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
             * to render the text.
             *
             * @type      {boolean}
             * @default   false
             * @apioption subtitle.useHTML
             */
            /**
             * The vertical alignment of the title. Can be one of `"top"`,
             * `"middle"` and `"bottom"`. When middle, the subtitle behaves as
             * floating.
             *
             * @sample {highcharts} highcharts/subtitle/verticalalign/
             *         Footnote at the bottom right of plot area
             * @sample {highstock} stock/chart/subtitle-footnote
             *         Footnote at the bottom right of plot area
             *
             * @type      {Highcharts.VerticalAlignValue}
             * @since     2.1
             * @apioption subtitle.verticalAlign
             */
            /**
             * The x position of the subtitle relative to the alignment within
             * `chart.spacingLeft` and `chart.spacingRight`.
             *
             * @sample {highcharts} highcharts/subtitle/align/
             *         Footnote at right of plot area
             * @sample {highstock} stock/chart/subtitle-footnote
             *         Footnote at the bottom right of plot area
             *
             * @type      {number}
             * @default   0
             * @since     2.0
             * @apioption subtitle.x
             */
            /**
             * The y position of the subtitle relative to the alignment within
             * `chart.spacingTop` and `chart.spacingBottom`. By default the subtitle
             * is laid out below the title unless the title is floating.
             *
             * @sample {highcharts} highcharts/subtitle/verticalalign/
             *         Footnote at the bottom right of plot area
             * @sample {highstock} stock/chart/subtitle-footnote
             *         Footnote at the bottom right of plot area
             *
             * @type      {number}
             * @since     2.0
             * @apioption subtitle.y
             */
            /**
             * CSS styles for the title.
             *
             * In styled mode, the subtitle style is given in the
             * `.highcharts-subtitle` class.
             *
             * @sample {highcharts} highcharts/subtitle/style/
             *         Custom color and weight
             * @sample {highcharts} highcharts/css/titles/
             *         Styled mode
             * @sample {highstock} stock/chart/subtitle-style
             *         Custom color and weight
             * @sample {highstock} highcharts/css/titles/
             *         Styled mode
             * @sample {highmaps} highcharts/css/titles/
             *         Styled mode
             *
             * @type      {Highcharts.CSSObject}
             * @default   {"color": "#666666"}
             */
            style: {
                color: "#666666" /* Palette.neutralColor60 */,
                fontSize: '0.8em'
            },
            /**
             * The subtitle of the chart.
             *
             * @sample {highcharts|highstock} highcharts/subtitle/text/
             *         Custom subtitle
             * @sample {highcharts|highstock} highcharts/subtitle/text-formatted/
             *         Formatted and linked text.
             */
            text: '',
            /**
             * The horizontal alignment of the subtitle. Can be one of "left",
             *  "center" and "right".
             *
             * @sample {highcharts} highcharts/subtitle/align/
             *         Footnote at right of plot area
             * @sample {highstock} stock/chart/subtitle-footnote
             *         Footnote at bottom right of plot area
             *
             * @type  {Highcharts.AlignValue}
             * @since 2.0
             */
            align: 'center',
            /**
             * Adjustment made to the subtitle width, normally to reserve space
             * for the exporting burger menu.
             *
             * @see [title.widthAdjust](#title.widthAdjust)
             *
             * @sample highcharts/title/widthadjust/
             *         Wider menu, greater padding
             *
             * @since 4.2.5
             */
            widthAdjust: -44
        },
        /**
         * The chart's caption, which will render below the chart and will be part
         * of exported charts. The caption can be updated after chart initialization
         * through the `Chart.update` or `Chart.caption.update` methods.
         *
         * @sample highcharts/caption/text/
         *         A chart with a caption
         * @since  7.2.0
         */
        caption: {
            /**
             * When the caption is floating, the plot area will not move to make
             * space for it.
             *
             * @type      {boolean}
             * @default   false
             * @apioption caption.floating
             */
            /**
             * The margin between the caption and the plot area.
             */
            margin: 15,
            /**
             * Whether to
             * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
             * to render the text.
             *
             * @type      {boolean}
             * @default   false
             * @apioption caption.useHTML
             */
            /**
             * The x position of the caption relative to the alignment within
             * `chart.spacingLeft` and `chart.spacingRight`.
             *
             * @type      {number}
             * @default   0
             * @apioption caption.x
             */
            /**
             * The y position of the caption relative to the alignment within
             * `chart.spacingTop` and `chart.spacingBottom`.
             *
             * @type      {number}
             * @apioption caption.y
             */
            /**
             * CSS styles for the caption.
             *
             * In styled mode, the caption style is given in the
             * `.highcharts-caption` class.
             *
             * @sample {highcharts} highcharts/css/titles/
             *         Styled mode
             *
             * @type      {Highcharts.CSSObject}
             * @default   {"color": "#666666"}
             */
            style: {
                color: "#666666" /* Palette.neutralColor60 */,
                fontSize: '0.8em'
            },
            /**
             * The caption text of the chart.
             *
             * @sample {highcharts} highcharts/caption/text/
             *         Custom caption
             */
            text: '',
            /**
             * The horizontal alignment of the caption. Can be one of "left",
             *  "center" and "right".
             *
             * @type  {Highcharts.AlignValue}
             */
            align: 'left',
            /**
             * The vertical alignment of the caption. Can be one of `"top"`,
             * `"middle"` and `"bottom"`. When middle, the caption behaves as
             * floating.
             *
             * @type      {Highcharts.VerticalAlignValue}
             */
            verticalAlign: 'bottom'
        },
        /**
         * The plotOptions is a wrapper object for config objects for each series
         * type. The config objects for each series can also be overridden for
         * each series item as given in the series array.
         *
         * Configuration options for the series are given in three levels. Options
         * for all series in a chart are given in the [plotOptions.series](
         * #plotOptions.series) object. Then options for all series of a specific
         * type are given in the plotOptions of that type, for example
         * `plotOptions.line`. Next, options for one single series are given in
         * [the series array](#series).
         */
        plotOptions: {},
        /**
         * The legend is a box containing a symbol and name for each series
         * item or point item in the chart. Each series (or points in case
         * of pie charts) is represented by a symbol and its name in the legend.
         *
         * It is possible to override the symbol creator function and create
         * [custom legend symbols](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/studies/legend-custom-symbol/).
         *
         * @productdesc {highmaps}
         * A Highmaps legend by default contains one legend item per series, but if
         * a `colorAxis` is defined, the axis will be displayed in the legend.
         * Either as a gradient, or as multiple legend items for `dataClasses`.
         */
        legend: {
            /**
             * The background color of the legend.
             *
             * @see In styled mode, the legend background fill can be applied with
             *      the `.highcharts-legend-box` class.
             *
             * @sample {highcharts} highcharts/legend/backgroundcolor/
             *         Yellowish background
             * @sample {highstock} stock/legend/align/
             *         Various legend options
             * @sample {highmaps} maps/legend/border-background/
             *         Border and background options
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @apioption legend.backgroundColor
             */
            /**
             * The width of the drawn border around the legend.
             *
             * @see In styled mode, the legend border stroke width can be applied
             *      with the `.highcharts-legend-box` class.
             *
             * @sample {highcharts} highcharts/legend/borderwidth/
             *         2px border width
             * @sample {highstock} stock/legend/align/
             *         Various legend options
             * @sample {highmaps} maps/legend/border-background/
             *         Border and background options
             *
             * @type      {number}
             * @default   0
             * @apioption legend.borderWidth
             */
            /**
             * Enable or disable the legend. There is also a series-specific option,
             * [showInLegend](#plotOptions.series.showInLegend), that can hide the
             * series from the legend. In some series types this is `false` by
             * default, so it must set to `true` in order to show the legend for the
             * series.
             *
             * @sample {highcharts} highcharts/legend/enabled-false/ Legend disabled
             * @sample {highstock} stock/legend/align/ Various legend options
             * @sample {highmaps} maps/legend/enabled-false/ Legend disabled
             *
             * @default {highstock} false
             * @default {highmaps} true
             * @default {gantt} false
             */
            enabled: true,
            /**
             * The horizontal alignment of the legend box within the chart area.
             * Valid values are `left`, `center` and `right`.
             *
             * In the case that the legend is aligned in a corner position, the
             * `layout` option will determine whether to place it above/below
             * or on the side of the plot area.
             *
             * @sample {highcharts} highcharts/legend/align/
             *         Legend at the right of the chart
             * @sample {highstock} stock/legend/align/
             *         Various legend options
             * @sample {highmaps} maps/legend/alignment/
             *         Legend alignment
             *
             * @type  {Highcharts.AlignValue}
             * @since 2.0
             */
            align: 'center',
            /**
             * If the [layout](legend.layout) is `horizontal` and the legend items
             * span over two lines or more, whether to align the items into vertical
             * columns. Setting this to `false` makes room for more items, but will
             * look more messy.
             *
             * @since 6.1.0
             */
            alignColumns: true,
            /**
             * A CSS class name to apply to the legend group.
             */
            className: 'highcharts-no-tooltip',
            /**
             * When the legend is floating, the plot area ignores it and is allowed
             * to be placed below it.
             *
             * @sample {highcharts} highcharts/legend/floating-false/
             *         False by default
             * @sample {highcharts} highcharts/legend/floating-true/
             *         True
             * @sample {highmaps} maps/legend/alignment/
             *         Floating legend
             *
             * @type      {boolean}
             * @default   false
             * @since     2.1
             * @apioption legend.floating
             */
            /**
             * The layout of the legend items. Can be one of `horizontal` or
             * `vertical` or `proximate`. When `proximate`, the legend items will be
             * placed as close as possible to the graphs they're representing,
             * except in inverted charts or when the legend position doesn't allow
             * it.
             *
             * @sample {highcharts} highcharts/legend/layout-horizontal/
             *         Horizontal by default
             * @sample {highcharts} highcharts/legend/layout-vertical/
             *         Vertical
             * @sample highcharts/legend/layout-proximate
             *         Labels proximate to the data
             * @sample {highstock} stock/legend/layout-horizontal/
             *         Horizontal by default
             * @sample {highmaps} maps/legend/padding-itemmargin/
             *         Vertical with data classes
             * @sample {highmaps} maps/legend/layout-vertical/
             *         Vertical with color axis gradient
             *
             * @validvalue ["horizontal", "vertical", "proximate"]
             */
            layout: 'horizontal',
            /**
             * In a legend with horizontal layout, the itemDistance defines the
             * pixel distance between each item.
             *
             * @sample {highcharts} highcharts/legend/layout-horizontal/
             *         50px item distance
             * @sample {highstock} highcharts/legend/layout-horizontal/
             *         50px item distance
             *
             * @type      {number}
             * @default   {highcharts} 20
             * @default   {highstock} 20
             * @default   {highmaps} 8
             * @since     3.0.3
             * @apioption legend.itemDistance
             */
            /**
             * The pixel bottom margin for each legend item.
             *
             * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
             *         Padding and item margins demonstrated
             * @sample {highmaps} maps/legend/padding-itemmargin/
             *         Padding and item margins demonstrated
             *
             * @since     2.2.0
             */
            itemMarginBottom: 2,
            /**
             * The pixel top margin for each legend item.
             *
             * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
             *         Padding and item margins demonstrated
             * @sample {highmaps} maps/legend/padding-itemmargin/
             *         Padding and item margins demonstrated
             *
             * @since     2.2.0
             */
            itemMarginTop: 2,
            /**
             * The width for each legend item. By default the items are laid out
             * successively. In a [horizontal layout](legend.layout), if the items
             * are laid out across two rows or more, they will be vertically aligned
             * depending on the [legend.alignColumns](legend.alignColumns) option.
             *
             * @sample {highcharts} highcharts/legend/itemwidth-default/
             *         Undefined by default
             * @sample {highcharts} highcharts/legend/itemwidth-80/
             *         80 for aligned legend items
             *
             * @type      {number}
             * @since     2.0
             * @apioption legend.itemWidth
             */
            /**
             * A [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
             * for each legend label. Available variables relates to properties on
             * the series, or the point in case of pies.
             *
             * @type      {string}
             * @default   {name}
             * @since     1.3
             * @apioption legend.labelFormat
             */
            /* eslint-disable valid-jsdoc */
            /**
             * Callback function to format each of the series' labels. The `this`
             * keyword refers to the series object, or the point object in case of
             * pie charts. By default the series or point name is printed.
             *
             * @productdesc {highmaps}
             * In Highmaps the context can also be a data class in case of a
             * `colorAxis`.
             *
             * @sample {highcharts} highcharts/legend/labelformatter/
             *         Add text
             * @sample {highmaps} maps/legend/labelformatter/
             *         Data classes with label formatter
             *
             * @type {Highcharts.FormatterCallbackFunction<Point|Series>}
             */
            labelFormatter: function () {
                /** eslint-enable valid-jsdoc */
                return this.name;
            },
            /**
             * Line height for the legend items. Deprecated as of 2.1\. Instead,
             * the line height for each item can be set using
             * `itemStyle.lineHeight`, and the padding between items using
             * `itemMarginTop` and `itemMarginBottom`.
             *
             * @sample {highcharts} highcharts/legend/lineheight/
             *         Setting padding
             *
             * @deprecated
             *
             * @type      {number}
             * @default   16
             * @since     2.0
             * @product   highcharts gantt
             * @apioption legend.lineHeight
             */
            /**
             * If the plot area sized is calculated automatically and the legend is
             * not floating, the legend margin is the space between the legend and
             * the axis labels or plot area.
             *
             * @sample {highcharts} highcharts/legend/margin-default/
             *         12 pixels by default
             * @sample {highcharts} highcharts/legend/margin-30/
             *         30 pixels
             *
             * @type      {number}
             * @default   12
             * @since     2.1
             * @apioption legend.margin
             */
            /**
             * Maximum pixel height for the legend. When the maximum height is
             * extended, navigation will show.
             *
             * @type      {number}
             * @since     2.3.0
             * @apioption legend.maxHeight
             */
            /**
             * The color of the drawn border around the legend.
             *
             * @see In styled mode, the legend border stroke can be applied with the
             *      `.highcharts-legend-box` class.
             *
             * @sample {highcharts} highcharts/legend/bordercolor/
             *         Brown border
             * @sample {highstock} stock/legend/align/
             *         Various legend options
             * @sample {highmaps} maps/legend/border-background/
             *         Border and background options
             *
             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             */
            borderColor: "#999999" /* Palette.neutralColor40 */,
            /**
             * The border corner radius of the legend.
             *
             * @sample {highcharts} highcharts/legend/borderradius-default/
             *         Square by default
             * @sample {highcharts} highcharts/legend/borderradius-round/
             *         5px rounded
             * @sample {highmaps} maps/legend/border-background/
             *         Border and background options
             */
            borderRadius: 0,
            /**
             * Options for the paging or navigation appearing when the legend is
             * overflown. Navigation works well on screen, but not in static
             * exported images. One way of working around that is to
             * [increase the chart height in
             * export](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/legend/navigation-enabled-false/).
             */
            navigation: {
                /**
                 * How to animate the pages when navigating up or down. A value of
                 * `true` applies the default navigation given in the
                 * `chart.animation` option. Additional options can be given as an
                 * object containing values for easing and duration.
                 *
                 * @sample {highcharts} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 * @sample {highstock} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 *
                 * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
                 * @default   true
                 * @since     2.2.4
                 * @apioption legend.navigation.animation
                 */
                /**
                 * The pixel size of the up and down arrows in the legend paging
                 * navigation.
                 *
                 * @sample {highcharts} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 * @sample {highstock} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 *
                 * @type      {number}
                 * @default   12
                 * @since     2.2.4
                 * @apioption legend.navigation.arrowSize
                 */
                /**
                 * Whether to enable the legend navigation. In most cases, disabling
                 * the navigation results in an unwanted overflow.
                 *
                 * See also the
                 * [adapt chart to legend](https://github.com/highcharts/adapt-chart-to-legend)
                 * plugin for a solution to extend the chart height to make room for
                 * the legend, optionally in exported charts only.
                 *
                 * @type      {boolean}
                 * @default   true
                 * @since     4.2.4
                 * @apioption legend.navigation.enabled
                 */
                /**
                 * Text styles for the legend page navigation.
                 *
                 * @see In styled mode, the navigation items are styled with the
                 *      `.highcharts-legend-navigation` class.
                 *
                 * @sample {highcharts} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 * @sample {highstock} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 *
                 * @type      {Highcharts.CSSObject}
                 * @since     2.2.4
                 * @apioption legend.navigation.style
                 */
                style: {
                    fontSize: '0.8em'
                },
                /**
                 * The color for the active up or down arrow in the legend page
                 * navigation.
                 *
                 * @see In styled mode, the active arrow be styled with the
                 *      `.highcharts-legend-nav-active` class.
                 *
                 * @sample  {highcharts} highcharts/legend/navigation/
                 *          Legend page navigation demonstrated
                 * @sample  {highstock} highcharts/legend/navigation/
                 *          Legend page navigation demonstrated
                 *
                 * @type  {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @since 2.2.4
                 */
                activeColor: "#0022ff" /* Palette.highlightColor100 */,
                /**
                 * The color of the inactive up or down arrow in the legend page
                 * navigation. .
                 *
                 * @see In styled mode, the inactive arrow be styled with the
                 *      `.highcharts-legend-nav-inactive` class.
                 *
                 * @sample {highcharts} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 * @sample {highstock} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 *
                 * @type  {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @since 2.2.4
                 */
                inactiveColor: "#cccccc" /* Palette.neutralColor20 */
            },
            /**
             * The inner padding of the legend box.
             *
             * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
             *         Padding and item margins demonstrated
             * @sample {highmaps} maps/legend/padding-itemmargin/
             *         Padding and item margins demonstrated
             *
             * @type      {number}
             * @default   8
             * @since     2.2.0
             * @apioption legend.padding
             */
            /**
             * Whether to reverse the order of the legend items compared to the
             * order of the series or points as defined in the configuration object.
             *
             * @see [yAxis.reversedStacks](#yAxis.reversedStacks),
             *      [series.legendIndex](#series.legendIndex)
             *
             * @sample {highcharts} highcharts/legend/reversed/
             *         Stacked bar with reversed legend
             *
             * @type      {boolean}
             * @default   false
             * @since     1.2.5
             * @apioption legend.reversed
             */
            /**
             * Whether to show the symbol on the right side of the text rather than
             * the left side. This is common in Arabic and Hebrew.
             *
             * @sample {highcharts} highcharts/legend/rtl/
             *         Symbol to the right
             *
             * @type      {boolean}
             * @default   false
             * @since     2.2
             * @apioption legend.rtl
             */
            /**
             * CSS styles for the legend area. In the 1.x versions the position
             * of the legend area was determined by CSS. In 2.x, the position is
             * determined by properties like `align`, `verticalAlign`, `x` and `y`,
             * but the styles are still parsed for backwards compatibility.
             *
             * @deprecated
             *
             * @type      {Highcharts.CSSObject}
             * @product   highcharts highstock
             * @apioption legend.style
             */
            /**
             * CSS styles for each legend item. Only a subset of CSS is supported,
             * notably those options related to text. The default `textOverflow`
             * property makes long texts truncate. Set it to `undefined` to wrap
             * text instead. A `width` property can be added to control the text
             * width.
             *
             * @see In styled mode, the legend items can be styled with the
             *      `.highcharts-legend-item` class.
             *
             * @sample {highcharts} highcharts/legend/itemstyle/
             *         Bold black text
             * @sample {highmaps} maps/legend/itemstyle/
             *         Item text styles
             *
             * @type    {Highcharts.CSSObject}
             * @default {"color": "#333333", "cursor": "pointer", "fontSize": "0.75em", "fontWeight": "bold", "textOverflow": "ellipsis"}
             */
            itemStyle: {
                /**
                 * @ignore
                 */
                color: "#333333" /* Palette.neutralColor80 */,
                /**
                 * @ignore
                 */
                cursor: 'pointer',
                /**
                 * @ignore
                 */
                fontSize: '0.8em',
                /**
                 * @ignore
                 */
                textDecoration: 'none',
                /**
                 * @ignore
                 */
                textOverflow: 'ellipsis'
            },
            /**
             * CSS styles for each legend item in hover mode. Only a subset of
             * CSS is supported, notably those options related to text. Properties
             * are inherited from `style` unless overridden here.
             *
             * @see In styled mode, the hovered legend items can be styled with
             *      the `.highcharts-legend-item:hover` pesudo-class.
             *
             * @sample {highcharts} highcharts/legend/itemhoverstyle/
             *         Red on hover
             * @sample {highmaps} maps/legend/itemstyle/
             *         Item text styles
             *
             * @type    {Highcharts.CSSObject}
             * @default {"color": "#000000"}
             */
            itemHoverStyle: {
                /**
                 * @ignore
                 */
                color: "#000000" /* Palette.neutralColor100 */
            },
            /**
             * CSS styles for each legend item when the corresponding series or
             * point is hidden. Only a subset of CSS is supported, notably those
             * options related to text. Properties are inherited from `style`
             * unless overridden here.
             *
             * @see In styled mode, the hidden legend items can be styled with
             *      the `.highcharts-legend-item-hidden` class.
             *
             * @sample {highcharts} highcharts/legend/itemhiddenstyle/
             *         Darker gray color
             *
             * @type    {Highcharts.CSSObject}
             * @default {"color": "#cccccc"}
             */
            itemHiddenStyle: {
                /**
                 * @ignore
                 */
                color: "#666666" /* Palette.neutralColor60 */,
                /**
                 * @ignore
                 */
                textDecoration: 'line-through'
            },
            /**
             * Whether to apply a drop shadow to the legend. A `backgroundColor`
             * also needs to be applied for this to take effect. The shadow can be
             * an object configuration containing `color`, `offsetX`, `offsetY`,
             * `opacity` and `width`.
             *
             * @sample {highcharts} highcharts/legend/shadow/
             *         White background and drop shadow
             * @sample {highstock} stock/legend/align/
             *         Various legend options
             * @sample {highmaps} maps/legend/border-background/
             *         Border and background options
             *
             * @type {boolean|Highcharts.CSSObject}
             */
            shadow: false,
            /**
             * Default styling for the checkbox next to a legend item when
             * `showCheckbox` is true.
             *
             * @type {Highcharts.CSSObject}
             * @default {"width": "13px", "height": "13px", "position":"absolute"}
             */
            itemCheckboxStyle: {
                /**
                 * @ignore
                 */
                position: 'absolute',
                /**
                 * @ignore
                 */
                width: '13px',
                /**
                 * @ignore
                 */
                height: '13px'
            },
            // itemWidth: undefined,
            /**
             * When this is true, the legend symbol width will be the same as
             * the symbol height, which in turn defaults to the font size of the
             * legend items.
             *
             * @since 5.0.0
             */
            squareSymbol: true,
            /**
             * The pixel height of the symbol for series types that use a rectangle
             * in the legend. Defaults to the font size of legend items.
             *
             * @productdesc {highmaps}
             * In Highmaps, when the symbol is the gradient of a vertical color
             * axis, the height defaults to 200.
             *
             * @sample {highmaps} maps/legend/layout-vertical-sized/
             *         Sized vertical gradient
             * @sample {highmaps} maps/legend/padding-itemmargin/
             *         No distance between data classes
             *
             * @type      {number}
             * @since     3.0.8
             * @apioption legend.symbolHeight
             */
            /**
             * The border radius of the symbol for series types that use a rectangle
             * in the legend. Defaults to half the `symbolHeight`, effectively
             * creating a circle.
             *
             * For color axis scales, it defaults to 3.
             *
             * @sample {highcharts} highcharts/legend/symbolradius/
             *         Round symbols
             * @sample {highstock} highcharts/legend/symbolradius/
             *         Round symbols
             * @sample {highmaps} highcharts/legend/symbolradius/
             *         Round symbols
             *
             * @type      {number}
             * @since     3.0.8
             * @apioption legend.symbolRadius
             */
            /**
             * The pixel width of the legend item symbol. When the `squareSymbol`
             * option is set, this defaults to the `symbolHeight`, otherwise 16.
             *
             * @productdesc {highmaps}
             * In Highmaps, when the symbol is the gradient of a horizontal color
             * axis, the width defaults to 200.
             *
             * @sample {highcharts} highcharts/legend/symbolwidth/
             *         Greater symbol width and padding
             * @sample {highmaps} maps/legend/padding-itemmargin/
             *         Padding and item margins demonstrated
             * @sample {highmaps} maps/legend/layout-vertical-sized/
             *         Sized vertical gradient
             *
             * @type      {number}
             * @apioption legend.symbolWidth
             */
            /**
             * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
             * to render the legend item texts.
             *
             * Prior to 4.1.7, when using HTML, [legend.navigation](
             * #legend.navigation) was disabled.
             *
             * @type      {boolean}
             * @default   false
             * @apioption legend.useHTML
             */
            /**
             * For a color axis with data classes, how many decimals to render in
             * the legend. The default preserves the decimals of the range numbers.
             *
             * @type      {number}
             * @default   -1
             * @product   highcharts highmaps
             * @apioption legend.valueDecimals
             */
            /**
             * For a color axis with data classes, a suffix for the range numbers in
             * the legend.
             *
             * @type      {string}
             * @default   ''
             * @product   highcharts highmaps
             * @apioption legend.valueSuffix
             */
            /**
             * The width of the legend box. If a number is set, it translates to
             * pixels. Since v7.0.2 it allows setting a percent string of the full
             * chart width, for example `40%`.
             *
             * Defaults to the full chart width for legends below or above the
             * chart, half the chart width for legends to the left and right.
             *
             * @sample {highcharts} highcharts/legend/width/
             *         Aligned to the plot area
             * @sample {highcharts} highcharts/legend/width-percent/
             *         A percent of the chart width
             *
             * @type      {number|string}
             * @since     2.0
             * @apioption legend.width
             */
            /**
             * The pixel padding between the legend item symbol and the legend
             * item text.
             *
             * @sample {highcharts} highcharts/legend/symbolpadding/
             *         Greater symbol width and padding
             */
            symbolPadding: 5,
            /**
             * The vertical alignment of the legend box. Can be one of `top`,
             * `middle` or `bottom`. Vertical position can be further determined
             * by the `y` option.
             *
             * In the case that the legend is aligned in a corner position, the
             * `layout` option will determine whether to place it above/below
             * or on the side of the plot area.
             *
             * When the [layout](#legend.layout) option is `proximate`, the
             * `verticalAlign` option doesn't apply.
             *
             * @sample {highcharts} highcharts/legend/verticalalign/
             *         Legend 100px from the top of the chart
             * @sample {highstock} stock/legend/align/
             *         Various legend options
             * @sample {highmaps} maps/legend/alignment/
             *         Legend alignment
             *
             * @type  {Highcharts.VerticalAlignValue}
             * @since 2.0
             */
            verticalAlign: 'bottom',
            // width: undefined,
            /**
             * The x offset of the legend relative to its horizontal alignment
             * `align` within chart.spacingLeft and chart.spacingRight. Negative
             * x moves it to the left, positive x moves it to the right.
             *
             * @sample {highcharts} highcharts/legend/width/
             *         Aligned to the plot area
             *
             * @since 2.0
             */
            x: 0,
            /**
             * The vertical offset of the legend relative to it's vertical alignment
             * `verticalAlign` within chart.spacingTop and chart.spacingBottom.
             *  Negative y moves it up, positive y moves it down.
             *
             * @sample {highcharts} highcharts/legend/verticalalign/
             *         Legend 100px from the top of the chart
             * @sample {highstock} stock/legend/align/
             *         Various legend options
             * @sample {highmaps} maps/legend/alignment/
             *         Legend alignment
             *
             * @since 2.0
             */
            y: 0,
            /**
             * A title to be added on top of the legend.
             *
             * @sample {highcharts} highcharts/legend/title/
             *         Legend title
             * @sample {highmaps} maps/legend/alignment/
             *         Legend with title
             *
             * @since 3.0
             */
            title: {
                /**
                 * A text or HTML string for the title.
                 *
                 * @type      {string}
                 * @since     3.0
                 * @apioption legend.title.text
                 */
                /**
                 * Generic CSS styles for the legend title.
                 *
                 * @see In styled mode, the legend title is styled with the
                 *      `.highcharts-legend-title` class.
                 *
                 * @type    {Highcharts.CSSObject}
                 * @default {"fontSize": "0.75em", "fontWeight": "bold"}
                 * @since   3.0
                 */
                style: {
                    /**
                     * @ignore
                     */
                    fontSize: '0.8em',
                    /**
                     * @ignore
                     */
                    fontWeight: 'bold'
                }
            }
        },
        /**
         * The loading options control the appearance of the loading screen
         * that covers the plot area on chart operations. This screen only
         * appears after an explicit call to `chart.showLoading()`. It is a
         * utility for developers to communicate to the end user that something
         * is going on, for example while retrieving new data via an XHR connection.
         * The "Loading..." text itself is not part of this configuration
         * object, but part of the `lang` object.
         */
        loading: {
            /**
             * The duration in milliseconds of the fade out effect.
             *
             * @sample highcharts/loading/hideduration/
             *         Fade in and out over a second
             *
             * @type      {number}
             * @default   100
             * @since     1.2.0
             * @apioption loading.hideDuration
             */
            /**
             * The duration in milliseconds of the fade in effect.
             *
             * @sample highcharts/loading/hideduration/
             *         Fade in and out over a second
             *
             * @type      {number}
             * @default   100
             * @since     1.2.0
             * @apioption loading.showDuration
             */
            /**
             * CSS styles for the loading label `span`.
             *
             * @see In styled mode, the loading label is styled with the
             *      `.highcharts-loading-inner` class.
             *
             * @sample {highcharts|highmaps} highcharts/loading/labelstyle/
             *         Vertically centered
             * @sample {highstock} stock/loading/general/
             *         Label styles
             *
             * @type    {Highcharts.CSSObject}
             * @default {"fontWeight": "bold", "position": "relative", "top": "45%"}
             * @since   1.2.0
             */
            labelStyle: {
                /**
                 * @ignore
                 */
                fontWeight: 'bold',
                /**
                 * @ignore
                 */
                position: 'relative',
                /**
                 * @ignore
                 */
                top: '45%'
            },
            /**
             * CSS styles for the loading screen that covers the plot area.
             *
             * In styled mode, the loading label is styled with the
             * `.highcharts-loading` class.
             *
             * @sample  {highcharts|highmaps} highcharts/loading/style/
             *          Gray plot area, white text
             * @sample  {highstock} stock/loading/general/
             *          Gray plot area, white text
             *
             * @type    {Highcharts.CSSObject}
             * @default {"position": "absolute", "backgroundColor": "#ffffff", "opacity": 0.5, "textAlign": "center"}
             * @since   1.2.0
             */
            style: {
                /**
                 * @ignore
                 */
                position: 'absolute',
                /**
                 * @ignore
                 */
                backgroundColor: "#ffffff" /* Palette.backgroundColor */,
                /**
                 * @ignore
                 */
                opacity: 0.5,
                /**
                 * @ignore
                 */
                textAlign: 'center'
            }
        },
        /**
         * Options for the tooltip that appears when the user hovers over a
         * series or point.
         *
         * @declare Highcharts.TooltipOptions
         */
        tooltip: {
            /**
             * The color of the tooltip border. When `undefined`, the border takes
             * the color of the corresponding series or point.
             *
             * @sample {highcharts} highcharts/tooltip/bordercolor-default/
             *         Follow series by default
             * @sample {highcharts} highcharts/tooltip/bordercolor-black/
             *         Black border
             * @sample {highstock} stock/tooltip/general/
             *         Styled tooltip
             * @sample {highmaps} maps/tooltip/background-border/
             *         Background and border demo
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @apioption tooltip.borderColor
             */
            /**
             * A CSS class name to apply to the tooltip's container div,
             * allowing unique CSS styling for each chart.
             *
             * @type      {string}
             * @apioption tooltip.className
             */
            /**
             * Since 4.1, the crosshair definitions are moved to the Axis object
             * in order for a better separation from the tooltip. See
             * [xAxis.crosshair](#xAxis.crosshair).
             *
             * @sample {highcharts} highcharts/tooltip/crosshairs-x/
             *         Enable a crosshair for the x value
             *
             * @deprecated
             *
             * @type      {*}
             * @default   true
             * @apioption tooltip.crosshairs
             */
            /**
             * Distance from point to tooltip in pixels.
             *
             * @type      {number}
             * @default   16
             * @apioption tooltip.distance
             */
            /**
             * Whether the tooltip should follow the mouse as it moves across
             * columns, pie slices and other point types with an extent.
             * By default it behaves this way for pie, polygon, map, sankey
             * and wordcloud series by override in the `plotOptions`
             * for those series types.
             *
             * Does not apply if [split](#tooltip.split) is `true`.
             *
             * For touch moves to behave the same way, [followTouchMove](
             * #tooltip.followTouchMove) must be `true` also.
             *
             * @sample highcharts/tooltip/followpointer/
             *         Tooltip follow pointer comparison
             *
             * @type      {boolean}
             * @default   {highcharts} false
             * @default   {highstock} false
             * @default   {highmaps} true
             * @since     3.0
             * @apioption tooltip.followPointer
             */
            /**
             * Whether the tooltip should update as the finger moves on a touch
             * device. If this is `true` and [chart.panning](#chart.panning) is
             * set,`followTouchMove` will take over one-finger touches, so the user
             * needs to use two fingers for zooming and panning.
             *
             * Note the difference to [followPointer](#tooltip.followPointer) that
             * only defines the _position_ of the tooltip. If `followPointer` is
             * false in for example a column series, the tooltip will show above or
             * below the column, but as `followTouchMove` is true, the tooltip will
             * jump from column to column as the user swipes across the plot area.
             *
             * @type      {boolean}
             * @default   {highcharts} true
             * @default   {highstock} true
             * @default   {highmaps} false
             * @since     3.0.1
             * @apioption tooltip.followTouchMove
             */
            /**
             * A [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
             * for the whole tooltip. When format strings are a requirement, it is
             * usually more convenient to use `headerFormat`, `pointFormat` and
             * `footerFormat`, but the `format` option allows combining them into
             * one setting.
             *
             * The context of the format string is the same as that of the
             * `formatter` callback.
             *
             * @sample {highcharts} highcharts/tooltip/format-shared/
             *         Format for shared tooltip
             *
             * @type      {string}
             * @default   undefined
             * @since 11.1.0
             * @apioption tooltip.format
             */
            /**
             * Callback function to format the text of the tooltip from scratch. In
             * case of single or [shared](#tooltip.shared) tooltips, a string should
             * be returned. In case of [split](#tooltip.split) tooltips, it should
             * return an array where the first item is the header, and subsequent
             * items are mapped to the points. Return `false` to disable tooltip for
             * a specific point on series.
             *
             * A subset of HTML is supported. Unless `useHTML` is true, the HTML of
             * the tooltip is parsed and converted to SVG, therefore this isn't a
             * complete HTML renderer. The following HTML tags are supported: `b`,
             * `br`, `em`, `i`, `span`, `strong`. Spans can be styled with a `style`
             * attribute, but only text-related CSS, that is shared with SVG, is
             * handled.
             *
             * The available data in the formatter differ a bit depending on whether
             * the tooltip is shared or split, or belongs to a single point. In a
             * shared/split tooltip, all properties except `x`, which is common for
             * all points, are kept in an array, `this.points`.
             *
             * Available data are:
             *
             * - **this.percentage (not shared) /**
             *   **this.points[i].percentage (shared)**:
             *   Stacked series and pies only. The point's percentage of the total.
             *
             * - **this.point (not shared) / this.points[i].point (shared)**:
             *   The point object. The point name, if defined, is available through
             *   `this.point.name`.
             *
             * - **this.points**:
             *   In a shared tooltip, this is an array containing all other
             *   properties for each point.
             *
             * - **this.series (not shared) / this.points[i].series (shared)**:
             *   The series object. The series name is available through
             *   `this.series.name`.
             *
             * - **this.total (not shared) / this.points[i].total (shared)**:
             *   Stacked series only. The total value at this point's x value.
             *
             * - **this.x**:
             *   The x value. This property is the same regardless of the tooltip
             *   being shared or not.
             *
             * - **this.y (not shared) / this.points[i].y (shared)**:
             *   The y value.
             *
             * @sample {highcharts} highcharts/tooltip/formatter-simple/
             *         Simple string formatting
             * @sample {highcharts} highcharts/tooltip/formatter-shared/
             *         Formatting with shared tooltip
             * @sample {highcharts|highstock} highcharts/tooltip/formatter-split/
             *         Formatting with split tooltip
             * @sample highcharts/tooltip/formatter-conditional-default/
             *         Extending default formatter
             * @sample {highstock} stock/tooltip/formatter/
             *         Formatting with shared tooltip
             * @sample {highmaps} maps/tooltip/formatter/
             *         String formatting
             *
             * @type      {Highcharts.TooltipFormatterCallbackFunction}
             * @apioption tooltip.formatter
             */
            /**
             * Callback function to format the text of the tooltip for
             * visible null points.
             * Works analogously to [formatter](#tooltip.formatter).
             *
             * @sample highcharts/plotoptions/series-nullformat
             *         Format data label and tooltip for null point.
             *
             * @type      {Highcharts.TooltipFormatterCallbackFunction}
             * @apioption tooltip.nullFormatter
             */
            /**
             * Whether to allow the tooltip to render outside the chart's SVG
             * element box. By default (`false`), the tooltip is rendered within the
             * chart's SVG element, which results in the tooltip being aligned
             * inside the chart area. For small charts, this may result in clipping
             * or overlapping. When `true`, a separate SVG element is created and
             * overlaid on the page, allowing the tooltip to be aligned inside the
             * page itself.
             *
             * Defaults to `true` if `chart.scrollablePlotArea` is activated,
             * otherwise `false`.
             *
             * @sample highcharts/tooltip/outside
             *         Small charts with tooltips outside
             *
             * @type      {boolean|undefined}
             * @default   undefined
             * @since     6.1.1
             * @apioption tooltip.outside
             */
            /**
             * A callback function for formatting the HTML output for a single point
             * in the tooltip. Like the `pointFormat` string, but with more
             * flexibility.
             *
             * @type      {Highcharts.FormatterCallbackFunction<Highcharts.Point>}
             * @since     4.1.0
             * @context   Highcharts.Point
             * @apioption tooltip.pointFormatter
             */
            /**
             * A callback function to place the tooltip in a custom position. The
             * callback receives three parameters: `labelWidth`, `labelHeight` and
             * `point`, where point contains values for `plotX` and `plotY` telling
             * where the reference point is in the plot area. Add `chart.plotLeft`
             * and `chart.plotTop` to get the full coordinates.
             *
             * To find the actual hovered `Point` instance, use
             * `this.chart.hoverPoint`. For shared or split tooltips, all the hover
             * points are available in `this.chart.hoverPoints`.
             *
             * Since v7, when [tooltip.split](#tooltip.split) option is enabled,
             * positioner is called for each of the boxes separately, including
             * xAxis header. xAxis header is not a point, instead `point` argument
             * contains info: `{ plotX: Number, plotY: Number, isHeader: Boolean }`
             *
             * The return should be an object containing x and y values, for example
             * `{ x: 100, y: 100 }`.
             *
             * @sample {highcharts} highcharts/tooltip/positioner/
             *         A fixed tooltip position
             * @sample {highstock} stock/tooltip/positioner/
             *         A fixed tooltip position on top of the chart
             * @sample {highmaps} maps/tooltip/positioner/
             *         A fixed tooltip position
             * @sample {highstock} stock/tooltip/split-positioner/
             *         Split tooltip with fixed positions
             * @sample {highstock} stock/tooltip/positioner-scrollable-plotarea/
             *         Scrollable plot area combined with tooltip positioner
             *
             * @type      {Highcharts.TooltipPositionerCallbackFunction}
             * @since     2.2.4
             * @apioption tooltip.positioner
             */
            /**
             * Split the tooltip into one label per series, with the header close
             * to the axis. This is recommended over [shared](#tooltip.shared)
             * tooltips for charts with multiple line series, generally making them
             * easier to read. This option takes precedence over `tooltip.shared`.
             *
             * Not supported for [polar](#chart.polar) and [inverted](#chart.inverted) charts.
             *
             * @productdesc {highstock} In Highcharts Stock, tooltips are split
             * by default since v6.0.0. Stock charts typically contain
             * multi-dimension points and multiple panes, making split tooltips
             * the preferred layout over
             * the previous `shared` tooltip.
             *
             * @sample highcharts/tooltip/split/
             *         Split tooltip
             * @sample {highcharts|highstock} highcharts/tooltip/formatter-split/
             *         Split tooltip and custom formatter callback
             *
             * @type      {boolean}
             * @default   {highcharts} false
             * @default   {highstock} true
             * @since     5.0.0
             * @product   highcharts highstock
             * @apioption tooltip.split
             */
            /**
             * Prevents the tooltip from switching or closing, when touched or
             * pointed.
             *
             * @sample highcharts/tooltip/stickoncontact/
             *         Tooltip sticks on pointer contact
             *
             * @type      {boolean}
             * @since     8.0.1
             * @apioption tooltip.stickOnContact
             */
            /**
             * Use HTML to render the contents of the tooltip instead of SVG. Using
             * HTML allows advanced formatting like tables and images in the
             * tooltip. It is also recommended for rtl languages as it works around
             * rtl bugs in early Firefox.
             *
             * @sample {highcharts|highstock} highcharts/tooltip/footerformat/
             *         A table for value alignment
             * @sample {highcharts|highstock} highcharts/tooltip/fullhtml/
             *         Full HTML tooltip
             * @sample {highmaps} maps/tooltip/usehtml/
             *         Pure HTML tooltip
             *
             * @type      {boolean}
             * @default   false
             * @since     2.2
             * @apioption tooltip.useHTML
             */
            /**
             * How many decimals to show in each series' y value. This is
             * overridable in each series' tooltip options object. The default is to
             * preserve all decimals.
             *
             * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
             *         Set decimals, prefix and suffix for the value
             * @sample {highmaps} maps/tooltip/valuedecimals/
             *         Set decimals, prefix and suffix for the value
             *
             * @type      {number|undefined}
             * @since     2.2
             * @apioption tooltip.valueDecimals
             */
            /**
             * A string to prepend to each series' y value. Overridable in each
             * series' tooltip options object.
             *
             * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
             *         Set decimals, prefix and suffix for the value
             * @sample {highmaps} maps/tooltip/valuedecimals/
             *         Set decimals, prefix and suffix for the value
             *
             * @type      {string}
             * @since     2.2
             * @apioption tooltip.valuePrefix
             */
            /**
             * A string to append to each series' y value. Overridable in each
             * series' tooltip options object.
             *
             * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
             *         Set decimals, prefix and suffix for the value
             * @sample {highmaps} maps/tooltip/valuedecimals/
             *         Set decimals, prefix and suffix for the value
             *
             * @type      {string}
             * @since     2.2
             * @apioption tooltip.valueSuffix
             */
            /**
             * The format for the date in the tooltip header if the X axis is a
             * datetime axis. The default is a best guess based on the smallest
             * distance between points in the chart.
             *
             * @sample {highcharts} highcharts/tooltip/xdateformat/
             *         A different format
             *
             * @type      {string}
             * @product   highcharts highstock gantt
             * @apioption tooltip.xDateFormat
             */
            /**
             * How many decimals to show for the `point.change`
             * or the `point.cumulativeSum` value when the `series.compare`
             * or the `series.cumulative` option is set.
             * This is overridable in each series' tooltip options object.
             *
             * @type      {number}
             * @default   2
             * @since     1.0.1
             * @product   highstock
             * @apioption tooltip.changeDecimals
             */
            /**
             * Enable or disable the tooltip.
             *
             * @sample {highcharts} highcharts/tooltip/enabled/
             *         Disabled
             * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
             *         Disable tooltip and show values on chart instead
             */
            enabled: true,
            /**
             * Enable or disable animation of the tooltip.
             *
             * @type       {boolean}
             * @default    true
             * @since      2.3.0
             */
            animation: svg$3,
            /**
             * The radius of the rounded border corners.
             *
             * @sample {highcharts} highcharts/tooltip/bordercolor-default/
             *         Default border radius
             * @sample {highcharts} highcharts/tooltip/borderradius-0/
             *         Square borders
             * @sample {highmaps} maps/tooltip/background-border/
             *         Background and border demo
             */
            borderRadius: 3,
            /**
             * For series on datetime axes, the date format in the tooltip's
             * header will by default be guessed based on the closest data points.
             * This member gives the default string representations used for
             * each unit. For an overview of the replacement codes, see
             * [dateFormat](/class-reference/Highcharts.Time#dateFormat).
             *
             * @see [xAxis.dateTimeLabelFormats](#xAxis.dateTimeLabelFormats)
             *
             * @type    {Highcharts.Dictionary<string>}
             * @product highcharts highstock gantt
             */
            dateTimeLabelFormats: {
                /** @internal */
                millisecond: '%A, %e %b, %H:%M:%S.%L',
                /** @internal */
                second: '%A, %e %b, %H:%M:%S',
                /** @internal */
                minute: '%A, %e %b, %H:%M',
                /** @internal */
                hour: '%A, %e %b, %H:%M',
                /** @internal */
                day: '%A, %e %b %Y',
                /** @internal */
                week: 'Week from %A, %e %b %Y',
                /** @internal */
                month: '%B %Y',
                /** @internal */
                year: '%Y'
            },
            /**
             * A string to append to the tooltip format.
             *
             * @sample {highcharts} highcharts/tooltip/footerformat/
             *         A table for value alignment
             * @sample {highmaps} maps/tooltip/format/
             *         Format demo
             *
             * @since 2.2
             */
            footerFormat: '',
            /**
             * The name of a symbol to use for the border around the tooltip
             * header. Applies only when [tooltip.split](#tooltip.split) is
             * enabled.
             *
             * Custom callbacks for symbol path generation can also be added to
             * `Highcharts.SVGRenderer.prototype.symbols` the same way as for
             * [series.marker.symbol](plotOptions.line.marker.symbol).
             *
             * @see [tooltip.shape](#tooltip.shape)
             *
             * @sample {highstock} stock/tooltip/split-positioner/
             *         Different shapes for header and split boxes
             *
             * @type       {Highcharts.TooltipShapeValue}
             * @validvalue ["callout", "square"]
             * @since      7.0
             */
            headerShape: 'callout',
            /**
             * The number of milliseconds to wait until the tooltip is hidden when
             * mouse out from a point or chart.
             *
             * @since 3.0
             */
            hideDelay: 500,
            /**
             * Padding inside the tooltip, in pixels.
             *
             * @since 5.0.0
             */
            padding: 8,
            /**
             * The name of a symbol to use for the border around the tooltip. Can
             * be one of: `"callout"`, `"circle"` or `"rect"`. When
             * [tooltip.split](#tooltip.split)
             * option is enabled, shape is applied to all boxes except header, which
             * is controlled by
             * [tooltip.headerShape](#tooltip.headerShape).
             *
             * Custom callbacks for symbol path generation can also be added to
             * `Highcharts.SVGRenderer.prototype.symbols` the same way as for
             * [series.marker.symbol](plotOptions.line.marker.symbol).
             *
             * @type  {Highcharts.TooltipShapeValue}
             * @since 4.0
             */
            shape: 'callout',
            /**
             * When the tooltip is shared, the entire plot area will capture mouse
             * movement or touch events. Tooltip texts for series types with ordered
             * data (not pie, scatter, flags etc) will be shown in a single bubble.
             * This is recommended for single series charts and for tablet/mobile
             * optimized charts.
             *
             * See also [tooltip.split](#tooltip.split), that is better suited for
             * charts with many series, especially line-type series. The
             * `tooltip.split` option takes precedence over `tooltip.shared`.
             *
             * @sample {highcharts} highcharts/tooltip/shared-false/
             *         False by default
             * @sample {highcharts} highcharts/tooltip/shared-true/
             *         True
             * @sample {highcharts} highcharts/tooltip/shared-x-crosshair/
             *         True with x axis crosshair
             * @sample {highcharts} highcharts/tooltip/shared-true-mixed-types/
             *         True with mixed series types
             *
             * @since   2.1
             * @product highcharts highstock
             */
            shared: false,
            /**
             * Proximity snap for graphs or single points. It defaults to 10 for
             * mouse-powered devices and 25 for touch devices.
             *
             * Note that in most cases the whole plot area captures the mouse
             * movement, and in these cases `tooltip.snap` doesn't make sense. This
             * applies when [stickyTracking](#plotOptions.series.stickyTracking)
             * is `true` (default) and when the tooltip is [shared](#tooltip.shared)
             * or [split](#tooltip.split).
             *
             * @sample {highcharts} highcharts/tooltip/bordercolor-default/
             *         10 px by default
             * @sample {highcharts} highcharts/tooltip/snap-50/
             *         50 px on graph
             *
             * @type    {number}
             * @default 10/25
             * @since   1.2.0
             * @product highcharts highstock
             */
            snap: isTouchDevice ? 25 : 10,
            /**
             * The HTML of the tooltip header line. Variables are enclosed by
             * curly brackets. Available variables are `point.key`, `series.name`,
             * `series.color` and other members from the `point` and `series`
             * objects. The `point.key` variable contains the category name, x
             * value or datetime string depending on the type of axis. For datetime
             * axes, the `point.key` date format can be set using
             * `tooltip.xDateFormat`.
             *
             * @sample {highcharts} highcharts/tooltip/footerformat/
             *         An HTML table in the tooltip
             * @sample {highstock} highcharts/tooltip/footerformat/
             *         An HTML table in the tooltip
             * @sample {highmaps} maps/tooltip/format/
             *         Format demo
             *
             * @type      {string}
             * @apioption tooltip.headerFormat
             */
            headerFormat: '<span style="font-size: 0.8em">{point.key}</span><br/>',
            /**
             * The HTML of the null point's line in the tooltip. Works analogously
             * to [pointFormat](#tooltip.pointFormat).
             *
             * @sample {highcharts} highcharts/plotoptions/series-nullformat
             *         Format data label and tooltip for null point.
             *
             * @type      {string}
             * @apioption tooltip.nullFormat
             */
            /**
             * The HTML of the point's line in the tooltip. Variables are enclosed
             * by curly brackets. Available variables are `point.x`, `point.y`,
             * `series.name` and `series.color` and other properties on the same
             * form. Furthermore, `point.y` can be extended by the
             * `tooltip.valuePrefix` and `tooltip.valueSuffix` variables. This can
             * also be overridden for each series, which makes it a good hook for
             * displaying units.
             *
             * In styled mode, the dot is colored by a class name rather
             * than the point color.
             *
             * @sample {highcharts} highcharts/tooltip/pointformat/
             *         A different point format with value suffix
             * @sample {highcharts|highstock} highcharts/tooltip/pointformat-extra-information/
             *         Show extra information about points in the tooltip
             * @sample {highmaps} maps/tooltip/format/
             *         Format demo
             *
             * @type       {string}
             * @since      2.2
             * @apioption  tooltip.pointFormat
             */
            pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',
            /**
             * The background color or gradient for the tooltip.
             *
             * In styled mode, the stroke width is set in the
             * `.highcharts-tooltip-box` class.
             *
             * @sample {highcharts} highcharts/tooltip/backgroundcolor-solid/
             *         Yellowish background
             * @sample {highcharts} highcharts/tooltip/backgroundcolor-gradient/
             *         Gradient
             * @sample {highcharts} highcharts/css/tooltip-border-background/
             *         Tooltip in styled mode
             * @sample {highstock} stock/tooltip/general/
             *         Custom tooltip
             * @sample {highstock} highcharts/css/tooltip-border-background/
             *         Tooltip in styled mode
             * @sample {highmaps} maps/tooltip/background-border/
             *         Background and border demo
             * @sample {highmaps} highcharts/css/tooltip-border-background/
             *         Tooltip in styled mode
             *
             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             */
            backgroundColor: "#ffffff" /* Palette.backgroundColor */,
            /**
             * The pixel width of the tooltip border. Defaults to 0 for single
             * tooltips and 1 for split tooltips.
             *
             * In styled mode, the stroke width is set in the
             * `.highcharts-tooltip-box` class.
             *
             * @sample {highcharts} highcharts/tooltip/bordercolor-default/
             *         2 pixels
             * @sample {highcharts} highcharts/tooltip/borderwidth/
             *         No border (shadow only)
             * @sample {highcharts} highcharts/css/tooltip-border-background/
             *         Tooltip in styled mode
             * @sample {highstock} stock/tooltip/general/
             *         Custom tooltip
             * @sample {highstock} highcharts/css/tooltip-border-background/
             *         Tooltip in styled mode
             * @sample {highmaps} maps/tooltip/background-border/
             *         Background and border demo
             * @sample {highmaps} highcharts/css/tooltip-border-background/
             *         Tooltip in styled mode
             *
             * @type {number}
             */
            borderWidth: void 0,
            /**
             * Whether to apply a drop shadow to the tooltip.
             *
             * @sample {highcharts} highcharts/tooltip/bordercolor-default/
             *         True by default
             * @sample {highcharts} highcharts/tooltip/shadow/
             *         False
             * @sample {highmaps} maps/tooltip/positioner/
             *         Fixed tooltip position, border and shadow disabled
             *
             * @type {boolean|Highcharts.ShadowOptionsObject}
             */
            shadow: true,
            /**
             * Prevents the tooltip from switching or closing when touched or
             * pointed.
             *
             * @sample highcharts/tooltip/stickoncontact/
             *         Tooltip sticks on pointer contact
             *
             * @since 8.0.1
             */
            stickOnContact: false,
            /**
             * CSS styles for the tooltip. The tooltip can also be styled through
             * the CSS class `.highcharts-tooltip`.
             *
             * Note that the default `pointerEvents` style makes the tooltip ignore
             * mouse events, so in order to use clickable tooltips, this value must
             * be set to `auto`.
             *
             * @sample {highcharts} highcharts/tooltip/style/
             *         Greater padding, bold text
             *
             * @type {Highcharts.CSSObject}
             */
            style: {
                /** @internal */
                color: "#333333" /* Palette.neutralColor80 */,
                /** @internal */
                cursor: 'default',
                /** @internal */
                fontSize: '0.8em'
            },
            /**
             * Use HTML to render the contents of the tooltip instead of SVG. Using
             * HTML allows advanced formatting like tables and images in the
             * tooltip. It is also recommended for rtl languages as it works around
             * rtl bugs in early Firefox.
             *
             * @sample {highcharts|highstock} highcharts/tooltip/footerformat/
             *         A table for value alignment
             * @sample {highcharts|highstock} highcharts/tooltip/fullhtml/
             *         Full HTML tooltip
             * @sample {highmaps} maps/tooltip/usehtml/
             *         Pure HTML tooltip
             *
             * @since 2.2
             */
            useHTML: false
        },
        /**
         * Highchart by default puts a credits label in the lower right corner
         * of the chart. This can be changed using these options.
         */
        credits: {
            /**
             * Credits for map source to be concatenated with conventional credit
             * text. By default this is a format string that collects copyright
             * information from the map if available.
             *
             * @see [mapTextFull](#credits.mapTextFull)
             * @see [text](#credits.text)
             *
             * @type      {string}
             * @default   \u00a9 <a href="{geojson.copyrightUrl}">{geojson.copyrightShort}</a>
             * @since     4.2.2
             * @product   highmaps
             * @apioption credits.mapText
             */
            /**
             * Detailed credits for map source to be displayed on hover of credits
             * text. By default this is a format string that collects copyright
             * information from the map if available.
             *
             * @see [mapText](#credits.mapText)
             * @see [text](#credits.text)
             *
             * @type      {string}
             * @default   {geojson.copyright}
             * @since     4.2.2
             * @product   highmaps
             * @apioption credits.mapTextFull
             */
            /**
             * Whether to show the credits text.
             *
             * @sample {highcharts} highcharts/credits/enabled-false/
             *         Credits disabled
             * @sample {highstock} stock/credits/enabled/
             *         Credits disabled
             * @sample {highmaps} maps/credits/enabled-false/
             *         Credits disabled
             */
            enabled: true,
            /**
             * The URL for the credits label.
             *
             * @sample {highcharts} highcharts/credits/href/
             *         Custom URL and text
             * @sample {highmaps} maps/credits/customized/
             *         Custom URL and text
             */
            href: 'https://www.highcharts.com?credits',
            /**
             * Position configuration for the credits label.
             *
             * @sample {highcharts} highcharts/credits/position-left/
             *         Left aligned
             * @sample {highcharts} highcharts/credits/position-left/
             *         Left aligned
             * @sample {highmaps} maps/credits/customized/
             *         Left aligned
             * @sample {highmaps} maps/credits/customized/
             *         Left aligned
             *
             * @type    {Highcharts.AlignObject}
             * @since   2.1
             */
            position: {
                /** @internal */
                align: 'right',
                /** @internal */
                x: -10,
                /** @internal */
                verticalAlign: 'bottom',
                /** @internal */
                y: -5
            },
            /**
             * CSS styles for the credits label.
             *
             * @see In styled mode, credits styles can be set with the
             *      `.highcharts-credits` class.
             *
             * @type {Highcharts.CSSObject}
             */
            style: {
                /** @internal */
                cursor: 'pointer',
                /** @internal */
                color: "#999999" /* Palette.neutralColor40 */,
                /** @internal */
                fontSize: '0.6em'
            },
            /**
             * The text for the credits label.
             *
             * @productdesc {highmaps}
             * If a map is loaded as GeoJSON, the text defaults to
             * `Highcharts @ {map-credits}`. Otherwise, it defaults to
             * `Highcharts.com`.
             *
             * @sample {highcharts} highcharts/credits/href/
             *         Custom URL and text
             * @sample {highmaps} maps/credits/customized/
             *         Custom URL and text
             */
            text: 'Highcharts.com'
        }
    };
    /* eslint-disable spaced-comment */

    defaultOptions$6.chart.styledMode = false;
    const defaultTime$2 = new Time(defaultOptions$6.time);
    /**
     * Get the updated default options. Until 3.0.7, merely exposing defaultOptions
     * for outside modules wasn't enough because the setOptions method created a new
     * object.
     *
     * @function Highcharts.getOptions
     *
     * @return {Highcharts.Options}
     * Default options.
     */
    function getOptions() {
        return defaultOptions$6;
    }
    /**
     * Merge the default options with custom options and return the new options
     * structure. Commonly used for defining reusable templates.
     *
     * @sample highcharts/global/useutc-false Setting a global option
     * @sample highcharts/members/setoptions Applying a global theme
     *
     * @function Highcharts.setOptions
     *
     * @param {Highcharts.Options} options
     * The new custom chart options.
     *
     * @return {Highcharts.Options}
     * Updated options.
     */
    function setOptions(options) {
        // Copy in the default options
        merge$b(true, defaultOptions$6, options);
        // Update the time object
        if (options.time || options.global) {
            if (H.time) {
                H.time.update(merge$b(defaultOptions$6.global, defaultOptions$6.time, options.global, options.time));
            }
            else {
                /**
                 * Global `Time` object with default options. Since v6.0.5, time
                 * settings can be applied individually for each chart. If no
                 * individual settings apply, this `Time` object is shared by all
                 * instances.
                 *
                 * @name Highcharts.time
                 * @type {Highcharts.Time}
                 */
                H.time = defaultTime$2;
            }
        }
        return defaultOptions$6;
    }
    /* *
     *
     *  Default Export
     *
     * */
    const DefaultOptions = {
        defaultOptions: defaultOptions$6,
        defaultTime: defaultTime$2,
        getOptions,
        setOptions
    };

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { addEvent: addEvent$5, isFunction: isFunction$3, objectEach: objectEach$9, removeEvent: removeEvent$5 } = Utilities;
    /* *
     *
     *  Class Namespace
     *
     * */
    var Foundation;
    (function (Foundation) {
        /* *
         *
         *  Functions
         *
         * */
        /* eslint-disable valid-jsdoc */
        /**
         * Register event options. If an event handler is set on the options, it
         * should be subject to Chart.update, Axis.update and Series.update. This is
         * contrary to general handlers that are set directly using addEvent either
         * on the class or on the instance. #6538, #6943, #10861.
         * @private
         */
        function registerEventOptions(component, options) {
            // A lookup over those events that are added by _options_ (not
            // programmatically). These are updated through .update()
            component.eventOptions = component.eventOptions || {};
            // Register event listeners
            objectEach$9(options.events, function (event, eventType) {
                // If event does not exist, or is changed by the .update()
                // function
                if (component.eventOptions[eventType] !== event) {
                    // Remove existing if set by option
                    if (component.eventOptions[eventType]) {
                        removeEvent$5(component, eventType, component.eventOptions[eventType]);
                        delete component.eventOptions[eventType];
                    }
                    if (isFunction$3(event)) {
                        component.eventOptions[eventType] = event;
                        addEvent$5(component, eventType, event, {
                            order: 0 // #14080 fire those events as firsts
                        });
                    }
                }
            });
        }
        Foundation.registerEventOptions = registerEventOptions;
    })(Foundation || (Foundation = {}));
    /* *
     *
     *  Default Export
     *
     * */
    var Foundation$1 = Foundation;

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { defaultOptions: defaultOptions$5, defaultTime: defaultTime$1 } = DefaultOptions;
    const { extend: extend$b, getNestedProperty: getNestedProperty$2, isArray: isArray$7, isNumber: isNumber$9, isObject: isObject$4, isString: isString$7, pick: pick$c, pInt: pInt$3 } = Utilities;
    const helpers = {
        // Built-in helpers
        add: (a, b) => a + b,
        divide: (a, b) => (b !== 0 ? a / b : ''),
        // eslint-disable-next-line eqeqeq
        eq: (a, b) => a == b,
        each: function (arr) {
            const match = arguments[arguments.length - 1];
            return isArray$7(arr) ?
                arr.map((item, i) => format$1(match.body, extend$b(isObject$4(item) ? item : { '@this': item }, {
                    '@index': i,
                    '@first': i === 0,
                    '@last': i === arr.length - 1
                }))).join('') :
                false;
        },
        ge: (a, b) => a >= b,
        gt: (a, b) => a > b,
        'if': (condition) => !!condition,
        le: (a, b) => a <= b,
        lt: (a, b) => a < b,
        multiply: (a, b) => a * b,
        // eslint-disable-next-line eqeqeq
        ne: (a, b) => a != b,
        subtract: (a, b) => a - b,
        unless: (condition) => !condition
    };
    /* *
     *
     *  Functions
     *
     * */
    /**
     * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970) into a
     * human readable date string. The format is a subset of the formats for PHP's
     * [strftime](https://www.php.net/manual/en/function.strftime.php) function.
     * Additional formats can be given in the {@link Highcharts.dateFormats} hook.
     *
     * Since v6.0.5, all internal dates are formatted through the
     * {@link Highcharts.Chart#time} instance to respect chart-level time settings.
     * The `Highcharts.dateFormat` function only reflects global time settings set
     * with `setOptions`.
     *
     * Supported format keys:
     * - `%a`: Short weekday, like 'Mon'
     * - `%A`: Long weekday, like 'Monday'
     * - `%d`: Two digit day of the month, 01 to 31
     * - `%e`: Day of the month, 1 through 31
     * - `%w`: Day of the week, 0 through 6
     * - `%b`: Short month, like 'Jan'
     * - `%B`: Long month, like 'January'
     * - `%m`: Two digit month number, 01 through 12
     * - `%y`: Two digits year, like 09 for 2009
     * - `%Y`: Four digits year, like 2009
     * - `%H`: Two digits hours in 24h format, 00 through 23
     * - `%k`: Hours in 24h format, 0 through 23
     * - `%I`: Two digits hours in 12h format, 00 through 11
     * - `%l`: Hours in 12h format, 1 through 12
     * - `%M`: Two digits minutes, 00 through 59
     * - `%p`: Upper case AM or PM
     * - `%P`: Lower case AM or PM
     * - `%S`: Two digits seconds, 00 through 59
     * - `%L`: Milliseconds (naming from Ruby)
     *
     * @function Highcharts.dateFormat
     *
     * @param {string} format
     *        The desired format where various time representations are prefixed
     *        with `%`.
     *
     * @param {number} timestamp
     *        The JavaScript timestamp.
     *
     * @param {boolean} [capitalize=false]
     *        Upper case first letter in the return.
     *
     * @return {string}
     *         The formatted date.
     */
    function dateFormat(format, timestamp, capitalize) {
        return defaultTime$1.dateFormat(format, timestamp, capitalize);
    }
    /**
     * Format a string according to a subset of the rules of Python's String.format
     * method.
     *
     * @example
     * let s = Highcharts.format(
     *     'The {color} fox was {len:.2f} feet long',
     *     { color: 'red', len: Math.PI }
     * );
     * // => The red fox was 3.14 feet long
     *
     * @function Highcharts.format
     *
     * @param {string} str
     *        The string to format.
     *
     * @param {Record<string, *>} ctx
     *        The context, a collection of key-value pairs where each key is
     *        replaced by its value.
     *
     * @param {Highcharts.Chart} [chart]
     *        A `Chart` instance used to get numberFormatter and time.
     *
     * @return {string}
     *         The formatted string.
     */
    function format$1(str = '', ctx, chart) {
        const regex = /\{([a-zA-Z0-9\:\.\,;\-\/<>%_@"'= #\(\)]+)\}/g, 
        // The sub expression regex is the same as the top expression regex,
        // but except parens and block helpers (#), and surrounded by parens
        // instead of curly brackets.
        subRegex = /\(([a-zA-Z0-9\:\.\,;\-\/<>%_@"'= ]+)\)/g, matches = [], floatRegex = /f$/, decRegex = /\.([0-9])/, lang = defaultOptions$5.lang, time = chart && chart.time || defaultTime$1, numberFormatter = chart && chart.numberFormatter || numberFormat$1;
        /*
         * Get a literal or variable value inside a template expression. May be
         * extended with other types like string or null if needed, but keep it
         * small for now.
         */
        const resolveProperty = (key = '') => {
            let n;
            // Literals
            if (key === 'true') {
                return true;
            }
            if (key === 'false') {
                return false;
            }
            if ((n = Number(key)).toString() === key) {
                return n;
            }
            // Variables and constants
            return getNestedProperty$2(key, ctx);
        };
        let match, currentMatch, depth = 0, hasSub;
        // Parse and create tree
        while ((match = regex.exec(str)) !== null) {
            // When a sub expression is found, it is evaluated first, and the
            // results recursively evaluated until no subexpression exists.
            const subMatch = subRegex.exec(match[1]);
            if (subMatch) {
                match = subMatch;
                hasSub = true;
            }
            if (!currentMatch || !currentMatch.isBlock) {
                currentMatch = {
                    ctx,
                    expression: match[1],
                    find: match[0],
                    isBlock: match[1].charAt(0) === '#',
                    start: match.index,
                    startInner: match.index + match[0].length,
                    length: match[0].length
                };
            }
            // Identify helpers
            const fn = match[1].split(' ')[0].replace('#', '');
            if (helpers[fn]) {
                // Block helper, only 0 level is handled
                if (currentMatch.isBlock && fn === currentMatch.fn) {
                    depth++;
                }
                if (!currentMatch.fn) {
                    currentMatch.fn = fn;
                }
            }
            // Closing a block helper
            const startingElseSection = match[1] === 'else';
            if (currentMatch.isBlock &&
                currentMatch.fn && (match[1] === `/${currentMatch.fn}` ||
                startingElseSection)) {
                if (!depth) { // === 0
                    const start = currentMatch.startInner, body = str.substr(start, match.index - start);
                    // Either closing without an else section, or when encountering
                    // an else section
                    if (currentMatch.body === void 0) {
                        currentMatch.body = body;
                        currentMatch.startInner = match.index + match[0].length;
                        // The body exists already, so this is the else section
                    }
                    else {
                        currentMatch.elseBody = body;
                    }
                    currentMatch.find += body + match[0];
                    if (!startingElseSection) {
                        matches.push(currentMatch);
                        currentMatch = void 0;
                    }
                }
                else if (!startingElseSection) {
                    depth--;
                }
                // Common expression
            }
            else if (!currentMatch.isBlock) {
                matches.push(currentMatch);
            }
            // Evaluate sub-matches one by one to prevent orphaned block closers
            if (subMatch && !(currentMatch === null || currentMatch === void 0 ? void 0 : currentMatch.isBlock)) {
                break;
            }
        }
        // Execute
        matches.forEach((match) => {
            const { body, elseBody, expression, fn } = match;
            let replacement, i;
            // Helper function
            if (fn) {
                // Pass the helpers the amount of arguments defined by the function,
                // then the match as the last argument.
                const args = [match], parts = expression.split(' ');
                i = helpers[fn].length;
                while (i--) {
                    args.unshift(resolveProperty(parts[i + 1]));
                }
                replacement = helpers[fn].apply(ctx, args);
                // Block helpers may return true or false. They may also return a
                // string, like the `each` helper.
                if (match.isBlock && typeof replacement === 'boolean') {
                    replacement = format$1(replacement ? body : elseBody, ctx);
                }
                // Simple variable replacement
            }
            else {
                const valueAndFormat = expression.split(':');
                replacement = resolveProperty(valueAndFormat.shift() || '');
                // Format the replacement
                if (valueAndFormat.length && typeof replacement === 'number') {
                    const segment = valueAndFormat.join(':');
                    if (floatRegex.test(segment)) { // float
                        const decimals = parseInt((segment.match(decRegex) || ['', '-1'])[1], 10);
                        if (replacement !== null) {
                            replacement = numberFormatter(replacement, decimals, lang.decimalPoint, segment.indexOf(',') > -1 ? lang.thousandsSep : '');
                        }
                    }
                    else {
                        replacement = time.dateFormat(segment, replacement);
                    }
                }
            }
            str = str.replace(match.find, pick$c(replacement, ''));
        });
        return hasSub ? format$1(str, ctx, chart) : str;
    }
    /**
     * Format a number and return a string based on input settings.
     *
     * @sample highcharts/members/highcharts-numberformat/
     *         Custom number format
     *
     * @function Highcharts.numberFormat
     *
     * @param {number} number
     *        The input number to format.
     *
     * @param {number} decimals
     *        The amount of decimals. A value of -1 preserves the amount in the
     *        input number.
     *
     * @param {string} [decimalPoint]
     *        The decimal point, defaults to the one given in the lang options, or
     *        a dot.
     *
     * @param {string} [thousandsSep]
     *        The thousands separator, defaults to the one given in the lang
     *        options, or a space character.
     *
     * @return {string}
     *         The formatted number.
     */
    function numberFormat$1(number, decimals, decimalPoint, thousandsSep) {
        number = +number || 0;
        decimals = +decimals;
        let ret, fractionDigits;
        const lang = defaultOptions$5.lang, origDec = (number.toString().split('.')[1] || '').split('e')[0].length, exponent = number.toString().split('e'), firstDecimals = decimals;
        if (decimals === -1) {
            // Preserve decimals. Not huge numbers (#3793).
            decimals = Math.min(origDec, 20);
        }
        else if (!isNumber$9(decimals)) {
            decimals = 2;
        }
        else if (decimals && exponent[1] && exponent[1] < 0) {
            // Expose decimals from exponential notation (#7042)
            fractionDigits = decimals + +exponent[1];
            if (fractionDigits >= 0) {
                // remove too small part of the number while keeping the notation
                exponent[0] = (+exponent[0]).toExponential(fractionDigits)
                    .split('e')[0];
                decimals = fractionDigits;
            }
            else {
                // fractionDigits < 0
                exponent[0] = exponent[0].split('.')[0] || 0;
                if (decimals < 20) {
                    // use number instead of exponential notation (#7405)
                    number = (exponent[0] * Math.pow(10, exponent[1]))
                        .toFixed(decimals);
                }
                else {
                    // or zero
                    number = 0;
                }
                exponent[1] = 0;
            }
        }
        // Add another decimal to avoid rounding errors of float numbers. (#4573)
        // Then use toFixed to handle rounding.
        const roundedNumber = (Math.abs(exponent[1] ? exponent[0] : number) +
            Math.pow(10, -Math.max(decimals, origDec) - 1)).toFixed(decimals);
        // A string containing the positive integer component of the number
        const strinteger = String(pInt$3(roundedNumber));
        // Leftover after grouping into thousands. Can be 0, 1 or 2.
        const thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;
        // Language
        decimalPoint = pick$c(decimalPoint, lang.decimalPoint);
        thousandsSep = pick$c(thousandsSep, lang.thousandsSep);
        // Start building the return
        ret = number < 0 ? '-' : '';
        // Add the leftover after grouping into thousands. For example, in the
        // number 42 000 000, this line adds 42.
        ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : '';
        if (+exponent[1] < 0 && !firstDecimals) {
            ret = '0';
        }
        else {
            // Add the remaining thousands groups, joined by the thousands separator
            ret += strinteger
                .substr(thousands)
                .replace(/(\d{3})(?=\d)/g, '$1' + thousandsSep);
        }
        // Add the decimal point and the decimal component
        if (decimals) {
            // Get the decimal component
            ret += decimalPoint + roundedNumber.slice(-decimals);
        }
        if (exponent[1] && +ret !== 0) {
            ret += 'e' + exponent[1];
        }
        return ret;
    }
    /* *
     *
     *  Default Export
     *
     * */
    const Templating = {
        dateFormat,
        format: format$1,
        helpers,
        numberFormat: numberFormat$1
    };

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { deg2rad: deg2rad$3 } = H;
    const { clamp: clamp$3, correctFloat: correctFloat$2, defined: defined$9, destroyObjectProperties: destroyObjectProperties$2, extend: extend$a, fireEvent: fireEvent$7, isNumber: isNumber$8, merge: merge$a, objectEach: objectEach$8, pick: pick$b } = Utilities;
    /* *
     *
     *  Class
     *
     * */
    /* eslint-disable no-invalid-this, valid-jsdoc */
    /**
     * The Tick class.
     *
     * @class
     * @name Highcharts.Tick
     *
     * @param {Highcharts.Axis} axis
     * The axis of the tick.
     *
     * @param {number} pos
     * The position of the tick on the axis in terms of axis values.
     *
     * @param {string} [type]
     * The type of tick, either 'minor' or an empty string
     *
     * @param {boolean} [noLabel=false]
     * Whether to disable the label or not. Defaults to false.
     *
     * @param {Object} [parameters]
     * Optional parameters for the tick.
     */
    class Tick {
        /* *
         *
         *  Constructors
         *
         * */
        constructor(axis, pos, type, noLabel, parameters) {
            this.isNew = true;
            this.isNewLabel = true;
            /**
             * The related axis of the tick.
             * @name Highcharts.Tick#axis
             * @type {Highcharts.Axis}
             */
            this.axis = axis;
            /**
             * The logical position of the tick on the axis in terms of axis values.
             * @name Highcharts.Tick#pos
             * @type {number}
             */
            this.pos = pos;
            /**
             * The tick type, which can be `"minor"`, or an empty string.
             * @name Highcharts.Tick#type
             * @type {string}
             */
            this.type = type || '';
            this.parameters = parameters || {};
            /**
             * The mark offset of the tick on the axis. Usually `undefined`, numeric
             * for grid axes.
             * @name Highcharts.Tick#tickmarkOffset
             * @type {number|undefined}
             */
            this.tickmarkOffset = this.parameters.tickmarkOffset;
            this.options = this.parameters.options;
            fireEvent$7(this, 'init');
            if (!type && !noLabel) {
                this.addLabel();
            }
        }
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Write the tick label.
         *
         * @private
         * @function Highcharts.Tick#addLabel
         */
        addLabel() {
            const tick = this, axis = tick.axis, options = axis.options, chart = axis.chart, categories = axis.categories, log = axis.logarithmic, names = axis.names, pos = tick.pos, labelOptions = pick$b(tick.options && tick.options.labels, options.labels), tickPositions = axis.tickPositions, isFirst = pos === tickPositions[0], isLast = pos === tickPositions[tickPositions.length - 1], animateLabels = (!labelOptions.step || labelOptions.step === 1) &&
                axis.tickInterval === 1, tickPositionInfo = tickPositions.info;
            let label = tick.label, dateTimeLabelFormat, dateTimeLabelFormats, i;
            // The context value
            let value = this.parameters.category || (categories ?
                pick$b(categories[pos], names[pos], pos) :
                pos);
            if (log && isNumber$8(value)) {
                value = correctFloat$2(log.lin2log(value));
            }
            // Set the datetime label format. If a higher rank is set for this
            // position, use that. If not, use the general format.
            if (axis.dateTime) {
                if (tickPositionInfo) {
                    dateTimeLabelFormats = chart.time.resolveDTLFormat(options.dateTimeLabelFormats[(!options.grid &&
                        tickPositionInfo.higherRanks[pos]) ||
                        tickPositionInfo.unitName]);
                    dateTimeLabelFormat = dateTimeLabelFormats.main;
                }
                else if (isNumber$8(value)) { // #1441
                    dateTimeLabelFormat = axis.dateTime.getXDateFormat(value, options.dateTimeLabelFormats ||
                        {});
                }
            }
            // set properties for access in render method
            /**
             * True if the tick is the first one on the axis.
             * @name Highcharts.Tick#isFirst
             * @readonly
             * @type {boolean|undefined}
             */
            tick.isFirst = isFirst;
            /**
             * True if the tick is the last one on the axis.
             * @name Highcharts.Tick#isLast
             * @readonly
             * @type {boolean|undefined}
             */
            tick.isLast = isLast;
            // Get the string
            const ctx = {
                axis,
                chart,
                dateTimeLabelFormat: dateTimeLabelFormat,
                isFirst,
                isLast,
                pos,
                tick: tick,
                tickPositionInfo,
                value
            };
            // Fire an event that allows modifying the context for use in
            // `labels.format` and `labels.formatter`.
            fireEvent$7(this, 'labelFormat', ctx);
            // Label formatting. When `labels.format` is given, we first run the
            // defaultFormatter and append the result to the context as `text`.
            // Handy for adding prefix or suffix while keeping default number
            // formatting.
            const labelFormatter = (ctx) => {
                if (labelOptions.formatter) {
                    return labelOptions.formatter.call(ctx, ctx);
                }
                if (labelOptions.format) {
                    ctx.text = axis.defaultLabelFormatter.call(ctx, ctx);
                    return Templating.format(labelOptions.format, ctx, chart);
                }
                return axis.defaultLabelFormatter.call(ctx, ctx);
            };
            const str = labelFormatter.call(ctx, ctx);
            // Set up conditional formatting based on the format list if existing.
            const list = dateTimeLabelFormats && dateTimeLabelFormats.list;
            if (list) {
                tick.shortenLabel = function () {
                    for (i = 0; i < list.length; i++) {
                        extend$a(ctx, { dateTimeLabelFormat: list[i] });
                        label.attr({
                            text: labelFormatter.call(ctx, ctx)
                        });
                        if (label.getBBox().width <
                            axis.getSlotWidth(tick) - 2 *
                                labelOptions.padding) {
                            return;
                        }
                    }
                    label.attr({
                        text: ''
                    });
                };
            }
            else {
                // #15692
                tick.shortenLabel = void 0;
            }
            // Call only after first render
            if (animateLabels && axis._addedPlotLB) {
                tick.moveLabel(str, labelOptions);
            }
            // First call
            if (!defined$9(label) && !tick.movedLabel) {
                /**
                 * The rendered text label of the tick.
                 * @name Highcharts.Tick#label
                 * @type {Highcharts.SVGElement|undefined}
                 */
                tick.label = label = tick.createLabel({ x: 0, y: 0 }, str, labelOptions);
                // Base value to detect change for new calls to getBBox
                tick.rotation = 0;
                // update
            }
            else if (label && label.textStr !== str && !animateLabels) {
                // When resetting text, also reset the width if dynamically set
                // (#8809)
                if (label.textWidth &&
                    !labelOptions.style.width &&
                    !label.styles.width) {
                    label.css({ width: null });
                }
                label.attr({ text: str });
                label.textPxLength = label.getBBox().width;
            }
        }
        /**
         * Render and return the label of the tick.
         *
         * @private
         * @function Highcharts.Tick#createLabel
         */
        createLabel(xy, str, labelOptions) {
            const axis = this.axis, chart = axis.chart, label = defined$9(str) && labelOptions.enabled ?
                chart.renderer
                    .text(str, xy.x, xy.y, labelOptions.useHTML)
                    .add(axis.labelGroup) :
                null;
            // Un-rotated length
            if (label) {
                // Without position absolute, IE export sometimes is wrong
                if (!chart.styledMode) {
                    label.css(merge$a(labelOptions.style));
                }
                label.textPxLength = label.getBBox().width;
            }
            return label;
        }
        /**
         * Destructor for the tick prototype
         *
         * @private
         * @function Highcharts.Tick#destroy
         */
        destroy() {
            destroyObjectProperties$2(this, this.axis);
        }
        /**
         * Gets the x and y positions for ticks in terms of pixels.
         *
         * @private
         * @function Highcharts.Tick#getPosition
         *
         * @param {boolean} horiz
         * Whether the tick is on an horizontal axis or not.
         *
         * @param {number} tickPos
         * Position of the tick.
         *
         * @param {number} tickmarkOffset
         * Tickmark offset for all ticks.
         *
         * @param {boolean} [old]
         * Whether the axis has changed or not.
         *
         * @return {Highcharts.PositionObject}
         * The tick position.
         *
         * @emits Highcharts.Tick#event:afterGetPosition
         */
        getPosition(horiz, tickPos, tickmarkOffset, old) {
            const axis = this.axis, chart = axis.chart, cHeight = (old && chart.oldChartHeight) || chart.chartHeight, pos = {
                x: horiz ?
                    correctFloat$2(axis.translate(tickPos + tickmarkOffset, void 0, void 0, old) +
                        axis.transB) :
                    (axis.left +
                        axis.offset +
                        (axis.opposite ?
                            (((old && chart.oldChartWidth) ||
                                chart.chartWidth) -
                                axis.right -
                                axis.left) :
                            0)),
                y: horiz ?
                    (cHeight -
                        axis.bottom +
                        axis.offset -
                        (axis.opposite ? axis.height : 0)) :
                    correctFloat$2(cHeight -
                        axis.translate(tickPos + tickmarkOffset, void 0, void 0, old) -
                        axis.transB)
            };
            // Chrome workaround for #10516
            pos.y = clamp$3(pos.y, -1e5, 1e5);
            fireEvent$7(this, 'afterGetPosition', { pos: pos });
            return pos;
        }
        /**
         * Get the x, y position of the tick label
         * @private
         */
        getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
            const axis = this.axis, transA = axis.transA, reversed = ( // #7911
            axis.isLinked && axis.linkedParent ?
                axis.linkedParent.reversed :
                axis.reversed), staggerLines = axis.staggerLines, rotCorr = axis.tickRotCorr || { x: 0, y: 0 }, 
            // Adjust for label alignment if we use reserveSpace: true (#5286)
            labelOffsetCorrection = (!horiz && !axis.reserveSpaceDefault ?
                -axis.labelOffset * (axis.labelAlign === 'center' ? 0.5 : 1) :
                0), distance = labelOptions.distance, pos = {};
            let yOffset, line;
            if (axis.side === 0) {
                yOffset = label.rotation ? -distance : -label.getBBox().height;
            }
            else if (axis.side === 2) {
                yOffset = rotCorr.y + distance;
            }
            else {
                // #3140, #3140
                yOffset = Math.cos(label.rotation * deg2rad$3) *
                    (rotCorr.y - label.getBBox(false, 0).height / 2);
            }
            if (defined$9(labelOptions.y)) {
                yOffset = axis.side === 0 && axis.horiz ?
                    labelOptions.y + yOffset :
                    labelOptions.y;
            }
            x = x +
                pick$b(labelOptions.x, [0, 1, 0, -1][axis.side] * distance) +
                labelOffsetCorrection +
                rotCorr.x -
                (tickmarkOffset && horiz ?
                    tickmarkOffset * transA * (reversed ? -1 : 1) :
                    0);
            y = y + yOffset - (tickmarkOffset && !horiz ?
                tickmarkOffset * transA * (reversed ? 1 : -1) : 0);
            // Correct for staggered labels
            if (staggerLines) {
                line = (index / (step || 1) % staggerLines);
                if (axis.opposite) {
                    line = staggerLines - line - 1;
                }
                y += line * (axis.labelOffset / staggerLines);
            }
            pos.x = x;
            pos.y = Math.round(y);
            fireEvent$7(this, 'afterGetLabelPosition', { pos: pos, tickmarkOffset: tickmarkOffset, index: index });
            return pos;
        }
        /**
         * Get the offset height or width of the label
         *
         * @private
         * @function Highcharts.Tick#getLabelSize
         */
        getLabelSize() {
            return this.label ?
                this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :
                0;
        }
        /**
         * Extendible method to return the path of the marker
         * @private
         */
        getMarkPath(x, y, tickLength, tickWidth, horiz, renderer) {
            return renderer.crispLine([[
                    'M',
                    x,
                    y
                ], [
                    'L',
                    x + (horiz ? 0 : -tickLength),
                    y + (horiz ? tickLength : 0)
                ]], tickWidth);
        }
        /**
         * Handle the label overflow by adjusting the labels to the left and right
         * edge, or hide them if they collide into the neighbour label.
         *
         * @private
         * @function Highcharts.Tick#handleOverflow
         */
        handleOverflow(xy) {
            const tick = this, axis = this.axis, labelOptions = axis.options.labels, pxPos = xy.x, chartWidth = axis.chart.chartWidth, spacing = axis.chart.spacing, leftBound = pick$b(axis.labelLeft, Math.min(axis.pos, spacing[3])), rightBound = pick$b(axis.labelRight, Math.max(!axis.isRadial ? axis.pos + axis.len : 0, chartWidth - spacing[1])), label = this.label, rotation = this.rotation, factor = {
                left: 0,
                center: 0.5,
                right: 1
            }[axis.labelAlign || label.attr('align')], labelWidth = label.getBBox().width, slotWidth = axis.getSlotWidth(tick), xCorrection = factor, css = {};
            let modifiedSlotWidth = slotWidth, goRight = 1, leftPos, rightPos, textWidth;
            // Check if the label overshoots the chart spacing box. If it does, move
            // it. If it now overshoots the slotWidth, add ellipsis.
            if (!rotation && labelOptions.overflow === 'justify') {
                leftPos = pxPos - factor * labelWidth;
                rightPos = pxPos + (1 - factor) * labelWidth;
                if (leftPos < leftBound) {
                    modifiedSlotWidth =
                        xy.x + modifiedSlotWidth * (1 - factor) - leftBound;
                }
                else if (rightPos > rightBound) {
                    modifiedSlotWidth =
                        rightBound - xy.x + modifiedSlotWidth * factor;
                    goRight = -1;
                }
                modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth); // #4177
                if (modifiedSlotWidth < slotWidth && axis.labelAlign === 'center') {
                    xy.x += (goRight *
                        (slotWidth -
                            modifiedSlotWidth -
                            xCorrection * (slotWidth - Math.min(labelWidth, modifiedSlotWidth))));
                }
                // If the label width exceeds the available space, set a text width
                // to be picked up below. Also, if a width has been set before, we
                // need to set a new one because the reported labelWidth will be
                // limited by the box (#3938).
                if (labelWidth > modifiedSlotWidth ||
                    (axis.autoRotation && (label.styles || {}).width)) {
                    textWidth = modifiedSlotWidth;
                }
                // Add ellipsis to prevent rotated labels to be clipped against the edge
                // of the chart
            }
            else if (rotation < 0 &&
                pxPos - factor * labelWidth < leftBound) {
                textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad$3) - leftBound);
            }
            else if (rotation > 0 &&
                pxPos + factor * labelWidth > rightBound) {
                textWidth = Math.round((chartWidth - pxPos) /
                    Math.cos(rotation * deg2rad$3));
            }
            if (textWidth) {
                if (tick.shortenLabel) {
                    tick.shortenLabel();
                }
                else {
                    css.width = Math.floor(textWidth) + 'px';
                    if (!(labelOptions.style || {}).textOverflow) {
                        css.textOverflow = 'ellipsis';
                    }
                    label.css(css);
                }
            }
        }
        /**
         * Try to replace the label if the same one already exists.
         *
         * @private
         * @function Highcharts.Tick#moveLabel
         */
        moveLabel(str, labelOptions) {
            const tick = this, label = tick.label, axis = tick.axis;
            let moved = false, labelPos;
            if (label && label.textStr === str) {
                tick.movedLabel = label;
                moved = true;
                delete tick.label;
            }
            else { // Find a label with the same string
                objectEach$8(axis.ticks, function (currentTick) {
                    if (!moved &&
                        !currentTick.isNew &&
                        currentTick !== tick &&
                        currentTick.label &&
                        currentTick.label.textStr === str) {
                        tick.movedLabel = currentTick.label;
                        moved = true;
                        currentTick.labelPos = tick.movedLabel.xy;
                        delete currentTick.label;
                    }
                });
            }
            // Create new label if the actual one is moved
            if (!moved && (tick.labelPos || label)) {
                labelPos = tick.labelPos || label.xy;
                tick.movedLabel = tick.createLabel(labelPos, str, labelOptions);
                if (tick.movedLabel) {
                    tick.movedLabel.attr({ opacity: 0 });
                }
            }
        }
        /**
         * Put everything in place
         *
         * @private
         * @param {number} index
         *
         * @param {boolean} [old]
         * Use old coordinates to prepare an animation into new position
         *
         * @param {number} [opacity]
         */
        render(index, old, opacity) {
            const tick = this, axis = tick.axis, horiz = axis.horiz, pos = tick.pos, tickmarkOffset = pick$b(tick.tickmarkOffset, axis.tickmarkOffset), xy = tick.getPosition(horiz, pos, tickmarkOffset, old), x = xy.x, y = xy.y, reverseCrisp = ((horiz && x === axis.pos + axis.len) ||
                (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687
            const labelOpacity = pick$b(opacity, tick.label && tick.label.newOpacity, // #15528
            1);
            opacity = pick$b(opacity, 1);
            this.isActive = true;
            // Create the grid line
            this.renderGridLine(old, opacity, reverseCrisp);
            // create the tick mark
            this.renderMark(xy, opacity, reverseCrisp);
            // the label is created on init - now move it into place
            this.renderLabel(xy, old, labelOpacity, index);
            tick.isNew = false;
            fireEvent$7(this, 'afterRender');
        }
        /**
         * Renders the gridLine.
         *
         * @private
         * @function Highcharts.Tick#renderGridLine
         * @param {boolean} old  Whether or not the tick is old
         * @param {number} opacity  The opacity of the grid line
         * @param {number} reverseCrisp  Modifier for avoiding overlapping 1 or -1
         */
        renderGridLine(old, opacity, reverseCrisp) {
            const tick = this, axis = tick.axis, options = axis.options, attribs = {}, pos = tick.pos, type = tick.type, tickmarkOffset = pick$b(tick.tickmarkOffset, axis.tickmarkOffset), renderer = axis.chart.renderer;
            let gridLine = tick.gridLine, gridLinePath, gridLineWidth = options.gridLineWidth, gridLineColor = options.gridLineColor, dashStyle = options.gridLineDashStyle;
            if (tick.type === 'minor') {
                gridLineWidth = options.minorGridLineWidth;
                gridLineColor = options.minorGridLineColor;
                dashStyle = options.minorGridLineDashStyle;
            }
            if (!gridLine) {
                if (!axis.chart.styledMode) {
                    attribs.stroke = gridLineColor;
                    attribs['stroke-width'] = gridLineWidth || 0;
                    attribs.dashstyle = dashStyle;
                }
                if (!type) {
                    attribs.zIndex = 1;
                }
                if (old) {
                    opacity = 0;
                }
                /**
                 * The rendered grid line of the tick.
                 * @name Highcharts.Tick#gridLine
                 * @type {Highcharts.SVGElement|undefined}
                 */
                tick.gridLine = gridLine = renderer.path()
                    .attr(attribs)
                    .addClass('highcharts-' + (type ? type + '-' : '') + 'grid-line')
                    .add(axis.gridGroup);
            }
            if (gridLine) {
                gridLinePath = axis.getPlotLinePath({
                    value: pos + tickmarkOffset,
                    lineWidth: gridLine.strokeWidth() * reverseCrisp,
                    force: 'pass',
                    old: old,
                    acrossPanes: false // #18025
                });
                // If the parameter 'old' is set, the current call will be followed
                // by another call, therefore do not do any animations this time
                if (gridLinePath) {
                    gridLine[old || tick.isNew ? 'attr' : 'animate']({
                        d: gridLinePath,
                        opacity: opacity
                    });
                }
            }
        }
        /**
         * Renders the tick mark.
         *
         * @private
         * @function Highcharts.Tick#renderMark
         * @param {Highcharts.PositionObject} xy  The position vector of the mark
         * @param {number} opacity  The opacity of the mark
         * @param {number} reverseCrisp  Modifier for avoiding overlapping 1 or -1
         */
        renderMark(xy, opacity, reverseCrisp) {
            const tick = this, axis = tick.axis, options = axis.options, renderer = axis.chart.renderer, type = tick.type, tickSize = axis.tickSize(type ? type + 'Tick' : 'tick'), x = xy.x, y = xy.y, tickWidth = pick$b(options[type !== 'minor' ? 'tickWidth' : 'minorTickWidth'], !type && axis.isXAxis ? 1 : 0), // X axis defaults to 1
            tickColor = options[type !== 'minor' ? 'tickColor' : 'minorTickColor'];
            let mark = tick.mark;
            const isNewMark = !mark;
            if (tickSize) {
                // negate the length
                if (axis.opposite) {
                    tickSize[0] = -tickSize[0];
                }
                // First time, create it
                if (!mark) {
                    /**
                     * The rendered mark of the tick.
                     * @name Highcharts.Tick#mark
                     * @type {Highcharts.SVGElement|undefined}
                     */
                    tick.mark = mark = renderer.path()
                        .addClass('highcharts-' + (type ? type + '-' : '') + 'tick')
                        .add(axis.axisGroup);
                    if (!axis.chart.styledMode) {
                        mark.attr({
                            stroke: tickColor,
                            'stroke-width': tickWidth
                        });
                    }
                }
                mark[isNewMark ? 'attr' : 'animate']({
                    d: tick.getMarkPath(x, y, tickSize[0], mark.strokeWidth() * reverseCrisp, axis.horiz, renderer),
                    opacity: opacity
                });
            }
        }
        /**
         * Renders the tick label.
         * Note: The label should already be created in init(), so it should only
         * have to be moved into place.
         *
         * @private
         * @function Highcharts.Tick#renderLabel
         * @param {Highcharts.PositionObject} xy  The position vector of the label
         * @param {boolean} old  Whether or not the tick is old
         * @param {number} opacity  The opacity of the label
         * @param {number} index  The index of the tick
         */
        renderLabel(xy, old, opacity, index) {
            const tick = this, axis = tick.axis, horiz = axis.horiz, options = axis.options, label = tick.label, labelOptions = options.labels, step = labelOptions.step, tickmarkOffset = pick$b(tick.tickmarkOffset, axis.tickmarkOffset), x = xy.x, y = xy.y;
            let show = true;
            if (label && isNumber$8(x)) {
                label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);
                // Apply show first and show last. If the tick is both first and
                // last, it is a single centered tick, in which case we show the
                // label anyway (#2100).
                if ((tick.isFirst &&
                    !tick.isLast &&
                    !options.showFirstLabel) ||
                    (tick.isLast &&
                        !tick.isFirst &&
                        !options.showLastLabel)) {
                    show = false;
                    // Handle label overflow and show or hide accordingly
                }
                else if (horiz &&
                    !labelOptions.step &&
                    !labelOptions.rotation &&
                    !old &&
                    opacity !== 0) {
                    tick.handleOverflow(xy);
                }
                // apply step
                if (step && index % step) {
                    // show those indices dividable by step
                    show = false;
                }
                // Set the new position, and show or hide
                if (show && isNumber$8(xy.y)) {
                    xy.opacity = opacity;
                    label[tick.isNewLabel ? 'attr' : 'animate'](xy).show(true);
                    tick.isNewLabel = false;
                }
                else {
                    label.hide(); // #1338, #15863
                    tick.isNewLabel = true;
                }
            }
        }
        /**
         * Replace labels with the moved ones to perform animation. Additionally
         * destroy unused labels.
         *
         * @private
         * @function Highcharts.Tick#replaceMovedLabel
         */
        replaceMovedLabel() {
            const tick = this, label = tick.label, axis = tick.axis;
            // Animate and destroy
            if (label && !tick.isNew) {
                label.animate({ opacity: 0 }, void 0, label.destroy);
                delete tick.label;
            }
            axis.isDirty = true;
            tick.label = tick.movedLabel;
            delete tick.movedLabel;
        }
    }

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { animObject: animObject$5 } = animationExports;
    const { defaultOptions: defaultOptions$4 } = DefaultOptions;
    const { registerEventOptions: registerEventOptions$2 } = Foundation$1;
    const { deg2rad: deg2rad$2 } = H;
    const { arrayMax: arrayMax$1, arrayMin: arrayMin$1, clamp: clamp$2, correctFloat: correctFloat$1, defined: defined$8, destroyObjectProperties: destroyObjectProperties$1, erase: erase$4, error: error$3, extend: extend$9, fireEvent: fireEvent$6, getClosestDistance: getClosestDistance$1, insertItem: insertItem$1, isArray: isArray$6, isNumber: isNumber$7, isString: isString$6, merge: merge$9, normalizeTickInterval, objectEach: objectEach$7, pick: pick$a, relativeLength: relativeLength$2, removeEvent: removeEvent$4, splat: splat$3, syncTimeout: syncTimeout$4 } = Utilities;
    const getNormalizedTickInterval = (axis, tickInterval) => normalizeTickInterval(tickInterval, void 0, void 0, pick$a(axis.options.allowDecimals, 
    // If the tick interval is greather than 0.5, avoid decimals, as
    // linear axes are often used to render discrete values (#3363). If
    // a tick amount is set, allow decimals by default, as it increases
    // the chances for a good fit.
    tickInterval < 0.5 || axis.tickAmount !== void 0), !!axis.tickAmount);
    /* *
     *
     *  Class
     *
     * */
    /**
     * Create a new axis object. Called internally when instanciating a new chart or
     * adding axes by {@link Highcharts.Chart#addAxis}.
     *
     * A chart can have from 0 axes (pie chart) to multiples. In a normal, single
     * series cartesian chart, there is one X axis and one Y axis.
     *
     * The X axis or axes are referenced by {@link Highcharts.Chart.xAxis}, which is
     * an array of Axis objects. If there is only one axis, it can be referenced
     * through `chart.xAxis[0]`, and multiple axes have increasing indices. The same
     * pattern goes for Y axes.
     *
     * If you need to get the axes from a series object, use the `series.xAxis` and
     * `series.yAxis` properties. These are not arrays, as one series can only be
     * associated to one X and one Y axis.
     *
     * A third way to reference the axis programmatically is by `id`. Add an `id` in
     * the axis configuration options, and get the axis by
     * {@link Highcharts.Chart#get}.
     *
     * Configuration options for the axes are given in options.xAxis and
     * options.yAxis.
     *
     * @class
     * @name Highcharts.Axis
     *
     * @param {Highcharts.Chart} chart
     * The Chart instance to apply the axis on.
     *
     * @param {Highcharts.AxisOptions} userOptions
     * Axis options
     */
    class Axis {
        /* *
         *
         *  Constructors
         *
         * */
        constructor(chart, userOptions, coll) {
            this.alternateBands = void 0;
            this.bottom = void 0;
            this.chart = void 0;
            this.closestPointRange = void 0;
            this.coll = void 0;
            this.eventOptions = void 0;
            this.hasNames = void 0;
            this.hasVisibleSeries = void 0;
            this.height = void 0;
            this.index = void 0;
            this.isLinked = void 0;
            this.labelEdge = void 0; // @todo
            this.labelFormatter = void 0;
            this.left = void 0;
            this.len = void 0;
            this.max = void 0;
            this.maxLabelLength = void 0;
            this.min = void 0;
            this.minorTickInterval = void 0;
            this.minorTicks = void 0;
            this.minPixelPadding = void 0;
            this.names = void 0;
            this.offset = void 0;
            this.options = void 0;
            this.overlap = void 0;
            this.paddedTicks = void 0;
            this.plotLinesAndBands = void 0;
            this.plotLinesAndBandsGroups = void 0;
            this.pointRange = void 0;
            this.pointRangePadding = void 0;
            this.pos = void 0;
            this.positiveValuesOnly = void 0;
            this.right = void 0;
            this.series = void 0;
            this.side = void 0;
            this.tickAmount = void 0;
            this.tickInterval = void 0;
            this.tickmarkOffset = void 0;
            this.tickPositions = void 0;
            this.tickRotCorr = void 0;
            this.ticks = void 0;
            this.top = void 0;
            this.transA = void 0;
            this.transB = void 0;
            this.translationSlope = void 0;
            this.userOptions = void 0;
            this.visible = void 0;
            this.width = void 0;
            this.zoomEnabled = void 0;
            this.init(chart, userOptions, coll);
        }
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Overrideable function to initialize the axis.
         *
         * @see {@link Axis}
         *
         * @function Highcharts.Axis#init
         *
         * @param {Highcharts.Chart} chart
         * The Chart instance to apply the axis on.
         *
         * @param {AxisOptions} userOptions
         * Axis options.
         *
         * @emits Highcharts.Axis#event:afterInit
         * @emits Highcharts.Axis#event:init
         */
        init(chart, userOptions, coll = this.coll) {
            const isXAxis = coll === 'xAxis', axis = this;
            /**
             * The Chart that the axis belongs to.
             *
             * @name Highcharts.Axis#chart
             * @type {Highcharts.Chart}
             */
            axis.chart = chart;
            /**
             * Whether the axis is horizontal.
             *
             * @name Highcharts.Axis#horiz
             * @type {boolean|undefined}
             */
            axis.horiz = axis.isZAxis || (chart.inverted ? !isXAxis : isXAxis);
            /**
             * Whether the axis is the x-axis.
             *
             * @name Highcharts.Axis#isXAxis
             * @type {boolean|undefined}
             */
            axis.isXAxis = isXAxis;
            /**
             * The collection where the axis belongs, for example `xAxis`, `yAxis`
             * or `colorAxis`. Corresponds to properties on Chart, for example
             * {@link Chart.xAxis}.
             *
             * @name Highcharts.Axis#coll
             * @type {string}
             */
            axis.coll = coll;
            fireEvent$6(this, 'init', { userOptions: userOptions });
            // Needed in setOptions
            axis.opposite = pick$a(userOptions.opposite, axis.opposite);
            /**
             * The side on which the axis is rendered. 0 is top, 1 is right, 2
             * is bottom and 3 is left.
             *
             * @name Highcharts.Axis#side
             * @type {number}
             */
            axis.side = pick$a(userOptions.side, axis.side, (axis.horiz ?
                (axis.opposite ? 0 : 2) : // top : bottom
                (axis.opposite ? 1 : 3)) // right : left
            );
            /**
             * Current options for the axis after merge of defaults and user's
             * options.
             *
             * @name Highcharts.Axis#options
             * @type {Highcharts.AxisOptions}
             */
            axis.setOptions(userOptions);
            const options = this.options, labelsOptions = options.labels, type = options.type;
            /**
             * User's options for this axis without defaults.
             *
             * @name Highcharts.Axis#userOptions
             * @type {Highcharts.AxisOptions}
             */
            axis.userOptions = userOptions;
            axis.minPixelPadding = 0;
            /**
             * Whether the axis is reversed. Based on the `axis.reversed`,
             * option, but inverted charts have reversed xAxis by default.
             *
             * @name Highcharts.Axis#reversed
             * @type {boolean}
             */
            axis.reversed = pick$a(options.reversed, axis.reversed);
            axis.visible = options.visible;
            axis.zoomEnabled = options.zoomEnabled;
            // Initial categories
            axis.hasNames =
                type === 'category' || options.categories === true;
            /**
             * If categories are present for the axis, names are used instead of
             * numbers for that axis.
             *
             * Since Highcharts 3.0, categories can also be extracted by giving each
             * point a name and setting axis type to `category`. However, if you
             * have multiple series, best practice remains defining the `categories`
             * array.
             *
             * @see [xAxis.categories](/highcharts/xAxis.categories)
             *
             * @name Highcharts.Axis#categories
             * @type {Array<string>}
             * @readonly
             */
            axis.categories = options.categories || (axis.hasNames ? [] : void 0);
            if (!axis.names) { // Preserve on update (#3830)
                axis.names = [];
                axis.names.keys = {};
            }
            // Placeholder for plotlines and plotbands groups
            axis.plotLinesAndBandsGroups = {};
            // Shorthand types
            axis.positiveValuesOnly = !!axis.logarithmic;
            // Flag, if axis is linked to another axis
            axis.isLinked = defined$8(options.linkedTo);
            /**
             * List of major ticks mapped by postition on axis.
             *
             * @see {@link Highcharts.Tick}
             *
             * @name Highcharts.Axis#ticks
             * @type {Highcharts.Dictionary<Highcharts.Tick>}
             */
            axis.ticks = {};
            axis.labelEdge = [];
            /**
             * List of minor ticks mapped by position on the axis.
             *
             * @see {@link Highcharts.Tick}
             *
             * @name Highcharts.Axis#minorTicks
             * @type {Highcharts.Dictionary<Highcharts.Tick>}
             */
            axis.minorTicks = {};
            // List of plotLines/Bands
            axis.plotLinesAndBands = [];
            // Alternate bands
            axis.alternateBands = {};
            // Axis metrics
            axis.len = 0;
            axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
            axis.range = options.range;
            axis.offset = options.offset || 0;
            /**
             * The maximum value of the axis. In a logarithmic axis, this is the
             * logarithm of the real value, and the real value can be obtained from
             * {@link Axis#getExtremes}.
             *
             * @name Highcharts.Axis#max
             * @type {number|null}
             */
            axis.max = null;
            /**
             * The minimum value of the axis. In a logarithmic axis, this is the
             * logarithm of the real value, and the real value can be obtained from
             * {@link Axis#getExtremes}.
             *
             * @name Highcharts.Axis#min
             * @type {number|null}
             */
            axis.min = null;
            /**
             * The processed crosshair options.
             *
             * @name Highcharts.Axis#crosshair
             * @type {boolean|Highcharts.AxisCrosshairOptions}
             */
            const crosshair = pick$a(options.crosshair, splat$3(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1]);
            axis.crosshair = crosshair === true ? {} : crosshair;
            // Register. Don't add it again on Axis.update().
            if (chart.axes.indexOf(axis) === -1) { //
                if (isXAxis) { // #2713
                    chart.axes.splice(chart.xAxis.length, 0, axis);
                }
                else {
                    chart.axes.push(axis);
                }
                insertItem$1(this, chart[this.coll]);
            }
            chart.orderItems(axis.coll);
            /**
             * All series associated to the axis.
             *
             * @name Highcharts.Axis#series
             * @type {Array<Highcharts.Series>}
             */
            axis.series = axis.series || []; // populated by Series
            // Reversed axis
            if (chart.inverted &&
                !axis.isZAxis &&
                isXAxis &&
                typeof axis.reversed === 'undefined') {
                axis.reversed = true;
            }
            axis.labelRotation = isNumber$7(labelsOptions.rotation) ?
                labelsOptions.rotation :
                void 0;
            // Register event listeners
            registerEventOptions$2(axis, options);
            fireEvent$6(this, 'afterInit');
        }
        /**
         * Merge and set options.
         *
         * @private
         * @function Highcharts.Axis#setOptions
         *
         * @param {Highcharts.AxisOptions} userOptions
         * Axis options.
         *
         * @emits Highcharts.Axis#event:afterSetOptions
         */
        setOptions(userOptions) {
            this.options = merge$9(AxisDefaults$1.defaultXAxisOptions, (this.coll === 'yAxis') && AxisDefaults$1.defaultYAxisOptions, [
                AxisDefaults$1.defaultTopAxisOptions,
                AxisDefaults$1.defaultRightAxisOptions,
                AxisDefaults$1.defaultBottomAxisOptions,
                AxisDefaults$1.defaultLeftAxisOptions
            ][this.side], merge$9(
            // if set in setOptions (#1053):
            defaultOptions$4[this.coll], userOptions));
            fireEvent$6(this, 'afterSetOptions', { userOptions: userOptions });
        }
        /**
         * The default label formatter. The context is a special config object for
         * the label. In apps, use the
         * [labels.formatter](https://api.highcharts.com/highcharts/xAxis.labels.formatter)
         * instead, except when a modification is needed.
         *
         * @function Highcharts.Axis#defaultLabelFormatter
         *
         * @param {Highcharts.AxisLabelsFormatterContextObject} this
         * Formatter context of axis label.
         *
         * @param {Highcharts.AxisLabelsFormatterContextObject} [ctx]
         * Formatter context of axis label.
         *
         * @return {string}
         * The formatted label content.
         */
        defaultLabelFormatter(ctx) {
            const axis = this.axis, chart = this.chart, { numberFormatter } = chart, value = isNumber$7(this.value) ? this.value : NaN, time = axis.chart.time, categories = axis.categories, dateTimeLabelFormat = this.dateTimeLabelFormat, lang = defaultOptions$4.lang, numericSymbols = lang.numericSymbols, numSymMagnitude = lang.numericSymbolMagnitude || 1000, 
            // make sure the same symbol is added for all labels on a linear
            // axis
            numericSymbolDetector = axis.logarithmic ?
                Math.abs(value) :
                axis.tickInterval;
            let i = numericSymbols && numericSymbols.length, multi, ret;
            if (categories) {
                ret = `${this.value}`;
            }
            else if (dateTimeLabelFormat) { // datetime axis
                ret = time.dateFormat(dateTimeLabelFormat, value);
            }
            else if (i && numericSymbolDetector >= 1000) {
                // Decide whether we should add a numeric symbol like k (thousands)
                // or M (millions). If we are to enable this in tooltip or other
                // places as well, we can move this logic to the numberFormatter and
                // enable it by a parameter.
                while (i-- && typeof ret === 'undefined') {
                    multi = Math.pow(numSymMagnitude, i + 1);
                    if (
                    // Only accept a numeric symbol when the distance is more
                    // than a full unit. So for example if the symbol is k, we
                    // don't accept numbers like 0.5k.
                    numericSymbolDetector >= multi &&
                        // Accept one decimal before the symbol. Accepts 0.5k but
                        // not 0.25k. How does this work with the previous?
                        (value * 10) % multi === 0 &&
                        numericSymbols[i] !== null &&
                        value !== 0) { // #5480
                        ret = numberFormatter(value / multi, -1) + numericSymbols[i];
                    }
                }
            }
            if (typeof ret === 'undefined') {
                if (Math.abs(value) >= 10000) { // add thousands separators
                    ret = numberFormatter(value, -1);
                }
                else { // small numbers
                    ret = numberFormatter(value, -1, void 0, ''); // #2466
                }
            }
            return ret;
        }
        /**
         * Get the minimum and maximum for the series of each axis. The function
         * analyzes the axis series and updates `this.dataMin` and `this.dataMax`.
         *
         * @private
         * @function Highcharts.Axis#getSeriesExtremes
         *
         * @emits Highcharts.Axis#event:afterGetSeriesExtremes
         * @emits Highcharts.Axis#event:getSeriesExtremes
         */
        getSeriesExtremes() {
            const axis = this, chart = axis.chart;
            let xExtremes;
            fireEvent$6(this, 'getSeriesExtremes', null, function () {
                axis.hasVisibleSeries = false;
                // Reset properties in case we're redrawing (#3353)
                axis.dataMin = axis.dataMax = axis.threshold = null;
                axis.softThreshold = !axis.isXAxis;
                // Loop through this axis' series
                axis.series.forEach(function (series) {
                    if (series.visible ||
                        !chart.options.chart.ignoreHiddenSeries) {
                        const seriesOptions = series.options;
                        let xData, threshold = seriesOptions.threshold, seriesDataMin, seriesDataMax;
                        axis.hasVisibleSeries = true;
                        // Validate threshold in logarithmic axes
                        if (axis.positiveValuesOnly && threshold <= 0) {
                            threshold = null;
                        }
                        // Get dataMin and dataMax for X axes
                        if (axis.isXAxis) {
                            xData = series.xData;
                            if (xData && xData.length) {
                                xData = axis.logarithmic ?
                                    xData.filter((x) => x > 0) :
                                    xData;
                                xExtremes = series.getXExtremes(xData);
                                // If xData contains values which is not numbers,
                                // then filter them out. To prevent performance hit,
                                // we only do this after we have already found
                                // seriesDataMin because in most cases all data is
                                // valid. #5234.
                                seriesDataMin = xExtremes.min;
                                seriesDataMax = xExtremes.max;
                                if (!isNumber$7(seriesDataMin) &&
                                    // #5010:
                                    !(seriesDataMin instanceof Date)) {
                                    xData = xData.filter(isNumber$7);
                                    xExtremes = series.getXExtremes(xData);
                                    // Do it again with valid data
                                    seriesDataMin = xExtremes.min;
                                    seriesDataMax = xExtremes.max;
                                }
                                if (xData.length) {
                                    axis.dataMin = Math.min(pick$a(axis.dataMin, seriesDataMin), seriesDataMin);
                                    axis.dataMax = Math.max(pick$a(axis.dataMax, seriesDataMax), seriesDataMax);
                                }
                            }
                            // Get dataMin and dataMax for Y axes, as well as handle
                            // stacking and processed data
                        }
                        else {
                            // Get this particular series extremes
                            const dataExtremes = series.applyExtremes();
                            // Get the dataMin and dataMax so far. If percentage is
                            // used, the min and max are always 0 and 100. If
                            // seriesDataMin and seriesDataMax is null, then series
                            // doesn't have active y data, we continue with nulls
                            if (isNumber$7(dataExtremes.dataMin)) {
                                seriesDataMin = dataExtremes.dataMin;
                                axis.dataMin = Math.min(pick$a(axis.dataMin, seriesDataMin), seriesDataMin);
                            }
                            if (isNumber$7(dataExtremes.dataMax)) {
                                seriesDataMax = dataExtremes.dataMax;
                                axis.dataMax = Math.max(pick$a(axis.dataMax, seriesDataMax), seriesDataMax);
                            }
                            // Adjust to threshold
                            if (defined$8(threshold)) {
                                axis.threshold = threshold;
                            }
                            // If any series has a hard threshold, it takes
                            // precedence
                            if (!seriesOptions.softThreshold ||
                                axis.positiveValuesOnly) {
                                axis.softThreshold = false;
                            }
                        }
                    }
                });
            });
            fireEvent$6(this, 'afterGetSeriesExtremes');
        }
        /**
         * Translate from axis value to pixel position on the chart, or back. Use
         * the `toPixels` and `toValue` functions in applications.
         *
         * @private
         * @function Highcharts.Axis#translate
         */
        translate(val, backwards, cvsCoord, old, handleLog, pointPlacement) {
            const axis = (this.linkedParent || this), // #1417
            localMin = (old && axis.old ? axis.old.min : axis.min);
            if (!isNumber$7(localMin)) {
                return NaN;
            }
            const minPixelPadding = axis.minPixelPadding, doPostTranslate = (axis.isOrdinal ||
                axis.brokenAxis && axis.brokenAxis.hasBreaks ||
                (axis.logarithmic && handleLog)) && axis.lin2val;
            let sign = 1, cvsOffset = 0, localA = old && axis.old ? axis.old.transA : axis.transA, returnValue = 0;
            if (!localA) {
                localA = axis.transA;
            }
            // In vertical axes, the canvas coordinates start from 0 at the top like
            // in SVG.
            if (cvsCoord) {
                sign *= -1; // canvas coordinates inverts the value
                cvsOffset = axis.len;
            }
            // Handle reversed axis
            if (axis.reversed) {
                sign *= -1;
                cvsOffset -= sign * (axis.sector || axis.len);
            }
            // From pixels to value
            if (backwards) { // reverse translation
                val = val * sign + cvsOffset;
                val -= minPixelPadding;
                // from chart pixel to value:
                returnValue = val / localA + localMin;
                if (doPostTranslate) { // log, ordinal and broken axis
                    returnValue = axis.lin2val(returnValue);
                }
                // From value to pixels
            }
            else {
                if (doPostTranslate) { // log, ordinal and broken axis
                    val = axis.val2lin(val);
                }
                const value = sign * (val - localMin) * localA;
                returnValue = (!axis.isRadial ? correctFloat$1(value) : value) +
                    cvsOffset +
                    (sign * minPixelPadding) +
                    (isNumber$7(pointPlacement) ? localA * pointPlacement : 0);
            }
            return returnValue;
        }
        /**
         * Translate a value in terms of axis units into pixels within the chart.
         *
         * @function Highcharts.Axis#toPixels
         *
         * @param {number} value
         * A value in terms of axis units.
         *
         * @param {boolean} paneCoordinates
         * Whether to return the pixel coordinate relative to the chart or just the
         * axis/pane itself.
         *
         * @return {number}
         * Pixel position of the value on the chart or axis.
         */
        toPixels(value, paneCoordinates) {
            return this.translate(value, false, !this.horiz, void 0, true) +
                (paneCoordinates ? 0 : this.pos);
        }
        /**
         * Translate a pixel position along the axis to a value in terms of axis
         * units.
         *
         * @function Highcharts.Axis#toValue
         *
         * @param {number} pixel
         * The pixel value coordinate.
         *
         * @param {boolean} [paneCoordinates=false]
         * Whether the input pixel is relative to the chart or just the axis/pane
         * itself.
         *
         * @return {number}
         * The axis value.
         */
        toValue(pixel, paneCoordinates) {
            return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, void 0, true);
        }
        /**
         * Create the path for a plot line that goes from the given value on
         * this axis, across the plot to the opposite side. Also used internally for
         * grid lines and crosshairs.
         *
         * @function Highcharts.Axis#getPlotLinePath
         *
         * @param {Highcharts.AxisPlotLinePathOptionsObject} options
         * Options for the path.
         *
         * @return {Highcharts.SVGPathArray|null}
         * The SVG path definition for the plot line.
         */
        getPlotLinePath(options) {
            const axis = this, chart = axis.chart, axisLeft = axis.left, axisTop = axis.top, old = options.old, value = options.value, lineWidth = options.lineWidth, cHeight = (old && chart.oldChartHeight) || chart.chartHeight, cWidth = (old && chart.oldChartWidth) || chart.chartWidth, transB = axis.transB;
            let translatedValue = options.translatedValue, force = options.force, x1, y1, x2, y2, skip;
            // eslint-disable-next-line valid-jsdoc
            /**
             * Check if x is between a and b. If not, either move to a/b
             * or skip, depending on the force parameter.
             * @private
             */
            function between(x, a, b) {
                if (force !== 'pass' && (x < a || x > b)) {
                    if (force) {
                        x = clamp$2(x, a, b);
                    }
                    else {
                        skip = true;
                    }
                }
                return x;
            }
            const evt = {
                value: value,
                lineWidth: lineWidth,
                old: old,
                force: force,
                acrossPanes: options.acrossPanes,
                translatedValue: translatedValue
            };
            fireEvent$6(this, 'getPlotLinePath', evt, function (e) {
                translatedValue = pick$a(translatedValue, axis.translate(value, void 0, void 0, old));
                // Keep the translated value within sane bounds, and avoid Infinity
                // to fail the isNumber test (#7709).
                translatedValue = clamp$2(translatedValue, -1e5, 1e5);
                x1 = x2 = Math.round(translatedValue + transB);
                y1 = y2 = Math.round(cHeight - translatedValue - transB);
                if (!isNumber$7(translatedValue)) { // no min or max
                    skip = true;
                    force = false; // #7175, don't force it when path is invalid
                }
                else if (axis.horiz) {
                    y1 = axisTop;
                    y2 = cHeight - axis.bottom;
                    x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
                }
                else {
                    x1 = axisLeft;
                    x2 = cWidth - axis.right;
                    y1 = y2 = between(y1, axisTop, axisTop + axis.height);
                }
                e.path = skip && !force ?
                    null :
                    chart.renderer.crispLine([['M', x1, y1], ['L', x2, y2]], lineWidth || 1);
            });
            return evt.path;
        }
        /**
         * Internal function to get the tick positions of a linear axis to round
         * values like whole tens or every five.
         *
         * @function Highcharts.Axis#getLinearTickPositions
         *
         * @param {number} tickInterval
         * The normalized tick interval.
         *
         * @param {number} min
         * Axis minimum.
         *
         * @param {number} max
         * Axis maximum.
         *
         * @return {Array<number>}
         * An array of axis values where ticks should be placed.
         */
        getLinearTickPositions(tickInterval, min, max) {
            const roundedMin = correctFloat$1(Math.floor(min / tickInterval) * tickInterval), roundedMax = correctFloat$1(Math.ceil(max / tickInterval) * tickInterval), tickPositions = [];
            let pos, lastPos, precision;
            // When the precision is higher than what we filter out in
            // correctFloat, skip it (#6183).
            if (correctFloat$1(roundedMin + tickInterval) === roundedMin) {
                precision = 20;
            }
            // For single points, add a tick regardless of the relative position
            // (#2662, #6274)
            if (this.single) {
                return [min];
            }
            // Populate the intermediate values
            pos = roundedMin;
            while (pos <= roundedMax) {
                // Place the tick on the rounded value
                tickPositions.push(pos);
                // Always add the raw tickInterval, not the corrected one.
                pos = correctFloat$1(pos + tickInterval, precision);
                // If the interval is not big enough in the current min - max range
                // to actually increase the loop variable, we need to break out to
                // prevent endless loop. Issue #619
                if (pos === lastPos) {
                    break;
                }
                // Record the last value
                lastPos = pos;
            }
            return tickPositions;
        }
        /**
         * Resolve the new minorTicks/minorTickInterval options into the legacy
         * loosely typed minorTickInterval option.
         *
         * @function Highcharts.Axis#getMinorTickInterval
         *
         * @return {number|"auto"|null}
         * Legacy option
         */
        getMinorTickInterval() {
            const options = this.options;
            if (options.minorTicks === true) {
                return pick$a(options.minorTickInterval, 'auto');
            }
            if (options.minorTicks === false) {
                return null;
            }
            return options.minorTickInterval;
        }
        /**
         * Internal function to return the minor tick positions. For logarithmic
         * axes, the same logic as for major ticks is reused.
         *
         * @function Highcharts.Axis#getMinorTickPositions
         *
         * @return {Array<number>}
         * An array of axis values where ticks should be placed.
         */
        getMinorTickPositions() {
            const axis = this, options = axis.options, tickPositions = axis.tickPositions, minorTickInterval = axis.minorTickInterval, pointRangePadding = axis.pointRangePadding || 0, min = axis.min - pointRangePadding, // #1498
            max = axis.max + pointRangePadding, // #1498
            range = max - min;
            let minorTickPositions = [], pos;
            // If minor ticks get too dense, they are hard to read, and may cause
            // long running script. So we don't draw them.
            if (range && range / minorTickInterval < axis.len / 3) { // #3875
                const logarithmic = axis.logarithmic;
                if (logarithmic) {
                    // For each interval in the major ticks, compute the minor ticks
                    // separately.
                    this.paddedTicks.forEach(function (_pos, i, paddedTicks) {
                        if (i) {
                            minorTickPositions.push.apply(minorTickPositions, logarithmic.getLogTickPositions(minorTickInterval, paddedTicks[i - 1], paddedTicks[i], true));
                        }
                    });
                }
                else if (axis.dateTime &&
                    this.getMinorTickInterval() === 'auto') { // #1314
                    minorTickPositions = minorTickPositions.concat(axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(minorTickInterval), min, max, options.startOfWeek));
                }
                else {
                    for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {
                        // Very, very, tight grid lines (#5771)
                        if (pos === minorTickPositions[0]) {
                            break;
                        }
                        minorTickPositions.push(pos);
                    }
                }
            }
            if (minorTickPositions.length !== 0) {
                axis.trimTicks(minorTickPositions); // #3652 #3743 #1498 #6330
            }
            return minorTickPositions;
        }
        /**
         * Adjust the min and max for the minimum range. Keep in mind that the
         * series data is not yet processed, so we don't have information on data
         * cropping and grouping, or updated `axis.pointRange` or
         * `series.pointRange`. The data can't be processed until we have finally
         * established min and max.
         *
         * @private
         * @function Highcharts.Axis#adjustForMinRange
         */
        adjustForMinRange() {
            const axis = this, options = axis.options, logarithmic = axis.logarithmic;
            let min = axis.min, max = axis.max, zoomOffset, spaceAvailable, closestDataRange, minArgs, maxArgs, minRange;
            // Set the automatic minimum range based on the closest point distance
            if (axis.isXAxis &&
                typeof axis.minRange === 'undefined' &&
                !logarithmic) {
                if (defined$8(options.min) ||
                    defined$8(options.max) ||
                    defined$8(options.floor) ||
                    defined$8(options.ceiling)) {
                    axis.minRange = null; // don't do this again
                }
                else {
                    // Find the closest distance between raw data points, as opposed
                    // to closestPointRange that applies to processed points
                    // (cropped and grouped)
                    closestDataRange = getClosestDistance$1(axis.series.map((s) => { var _a; 
                    // If xIncrement, we only need to measure the two first
                    // points to get the distance. Saves processing time.
                    return (s.xIncrement ? (_a = s.xData) === null || _a === void 0 ? void 0 : _a.slice(0, 2) : s.xData) || []; })) || 0;
                    axis.minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin);
                }
            }
            // if minRange is exceeded, adjust
            if (max - min < axis.minRange) {
                spaceAvailable =
                    axis.dataMax - axis.dataMin >=
                        axis.minRange;
                minRange = axis.minRange;
                zoomOffset = (minRange - max + min) / 2;
                // if min and max options have been set, don't go beyond it
                minArgs = [
                    min - zoomOffset,
                    pick$a(options.min, min - zoomOffset)
                ];
                // If space is available, stay within the data range
                if (spaceAvailable) {
                    minArgs[2] = logarithmic ?
                        logarithmic.log2lin(axis.dataMin) :
                        axis.dataMin;
                }
                min = arrayMax$1(minArgs);
                maxArgs = [
                    min + minRange,
                    pick$a(options.max, min + minRange)
                ];
                // If space is availabe, stay within the data range
                if (spaceAvailable) {
                    maxArgs[2] = logarithmic ?
                        logarithmic.log2lin(axis.dataMax) :
                        axis.dataMax;
                }
                max = arrayMin$1(maxArgs);
                // now if the max is adjusted, adjust the min back
                if (max - min < minRange) {
                    minArgs[0] = max - minRange;
                    minArgs[1] = pick$a(options.min, max - minRange);
                    min = arrayMax$1(minArgs);
                }
            }
            // Record modified extremes
            axis.min = min;
            axis.max = max;
        }
        /**
         * Find the closestPointRange across all series, including the single data
         * series.
         *
         * @private
         * @function Highcharts.Axis#getClosest
         */
        getClosest() {
            let closestSingleDistance, closestDistance;
            if (this.categories) {
                closestDistance = 1;
            }
            else {
                const singleXs = [];
                this.series.forEach(function (series) {
                    var _a;
                    const seriesClosest = series.closestPointRange, visible = series.visible ||
                        !series.chart.options.chart.ignoreHiddenSeries;
                    if (((_a = series.xData) === null || _a === void 0 ? void 0 : _a.length) === 1) {
                        singleXs.push(series.xData[0]);
                    }
                    else if (!series.noSharedTooltip &&
                        defined$8(seriesClosest) &&
                        visible) {
                        closestDistance = defined$8(closestDistance) ?
                            Math.min(closestDistance, seriesClosest) :
                            seriesClosest;
                    }
                });
                if (singleXs.length) {
                    singleXs.sort((a, b) => a - b);
                    closestSingleDistance = getClosestDistance$1([singleXs]);
                }
            }
            if (closestSingleDistance && closestDistance) {
                return Math.min(closestSingleDistance, closestDistance);
            }
            return closestSingleDistance || closestDistance;
        }
        /**
         * When a point name is given and no x, search for the name in the existing
         * categories, or if categories aren't provided, search names or create a
         * new category (#2522).
         *
         * @private
         * @function Highcharts.Axis#nameToX
         *
         * @param {Highcharts.Point} point
         * The point to inspect.
         *
         * @return {number}
         * The X value that the point is given.
         */
        nameToX(point) {
            const explicitCategories = isArray$6(this.options.categories), names = explicitCategories ? this.categories : this.names;
            let nameX = point.options.x, x;
            point.series.requireSorting = false;
            if (!defined$8(nameX)) {
                nameX = this.options.uniqueNames && names ?
                    (explicitCategories ?
                        names.indexOf(point.name) :
                        pick$a(names.keys[point.name], -1)) :
                    point.series.autoIncrement();
            }
            if (nameX === -1) { // Not found in currenct categories
                if (!explicitCategories && names) {
                    x = names.length;
                }
            }
            else {
                x = nameX;
            }
            // Write the last point's name to the names array
            if (typeof x !== 'undefined') {
                this.names[x] = point.name;
                // Backwards mapping is much faster than array searching (#7725)
                this.names.keys[point.name] = x;
            }
            else if (point.x) {
                x = point.x; // #17438
            }
            return x;
        }
        /**
         * When changes have been done to series data, update the axis.names.
         *
         * @private
         * @function Highcharts.Axis#updateNames
         */
        updateNames() {
            const axis = this, names = this.names, i = names.length;
            if (i > 0) {
                Object.keys(names.keys).forEach(function (key) {
                    delete (names.keys)[key];
                });
                names.length = 0;
                this.minRange = this.userMinRange; // Reset
                (this.series || []).forEach(function (series) {
                    // Reset incrementer (#5928)
                    series.xIncrement = null;
                    // When adding a series, points are not yet generated
                    if (!series.points || series.isDirtyData) {
                        // When we're updating the series with data that is longer
                        // than it was, and cropThreshold is passed, we need to make
                        // sure that the axis.max is increased _before_ running the
                        // premature processData. Otherwise this early iteration of
                        // processData will crop the points to axis.max, and the
                        // names array will be too short (#5857).
                        axis.max = Math.max(axis.max, series.xData.length - 1);
                        series.processData();
                        series.generatePoints();
                    }
                    series.data.forEach(function (point, i) {
                        let x;
                        if (point &&
                            point.options &&
                            typeof point.name !== 'undefined' // #9562
                        ) {
                            x = axis.nameToX(point);
                            if (typeof x !== 'undefined' && x !== point.x) {
                                point.x = x;
                                series.xData[i] = x;
                            }
                        }
                    });
                });
            }
        }
        /**
         * Update translation information.
         *
         * @private
         * @function Highcharts.Axis#setAxisTranslation
         *
         * @emits Highcharts.Axis#event:afterSetAxisTranslation
         */
        setAxisTranslation() {
            const axis = this, range = axis.max - axis.min, linkedParent = axis.linkedParent, hasCategories = !!axis.categories, isXAxis = axis.isXAxis;
            let pointRange = axis.axisPointRange || 0, closestPointRange, minPointOffset = 0, pointRangePadding = 0, ordinalCorrection, transA = axis.transA;
            // Adjust translation for padding. Y axis with categories need to go
            // through the same (#1784).
            if (isXAxis || hasCategories || pointRange) {
                // Get the closest points
                closestPointRange = axis.getClosest();
                if (linkedParent) {
                    minPointOffset = linkedParent.minPointOffset;
                    pointRangePadding = linkedParent.pointRangePadding;
                }
                else {
                    axis.series.forEach(function (series) {
                        const seriesPointRange = hasCategories ?
                            1 :
                            (isXAxis ?
                                pick$a(series.options.pointRange, closestPointRange, 0) :
                                (axis.axisPointRange || 0)), // #2806
                        pointPlacement = series.options.pointPlacement;
                        pointRange = Math.max(pointRange, seriesPointRange);
                        if (!axis.single || hasCategories) {
                            // TODO: series should internally set x- and y-
                            // pointPlacement to simplify this logic.
                            const isPointPlacementAxis = series.is('xrange') ?
                                !isXAxis :
                                isXAxis;
                            // minPointOffset is the value padding to the left of
                            // the axis in order to make room for points with a
                            // pointRange, typically columns. When the
                            // pointPlacement option is 'between' or 'on', this
                            // padding does not apply.
                            minPointOffset = Math.max(minPointOffset, isPointPlacementAxis && isString$6(pointPlacement) ?
                                0 :
                                seriesPointRange / 2);
                            // Determine the total padding needed to the length of
                            // the axis to make room for the pointRange. If the
                            // series' pointPlacement is 'on', no padding is added.
                            pointRangePadding = Math.max(pointRangePadding, isPointPlacementAxis && pointPlacement === 'on' ?
                                0 :
                                seriesPointRange);
                        }
                    });
                }
                // Record minPointOffset and pointRangePadding
                ordinalCorrection = (axis.ordinal && axis.ordinal.slope && closestPointRange) ?
                    axis.ordinal.slope / closestPointRange :
                    1; // #988, #1853
                axis.minPointOffset = minPointOffset =
                    minPointOffset * ordinalCorrection;
                axis.pointRangePadding =
                    pointRangePadding = pointRangePadding * ordinalCorrection;
                // pointRange means the width reserved for each point, like in a
                // column chart
                axis.pointRange = Math.min(pointRange, axis.single && hasCategories ? 1 : range);
                // closestPointRange means the closest distance between points. In
                // columns it is mostly equal to pointRange, but in lines pointRange
                // is 0 while closestPointRange is some other value
                if (isXAxis && closestPointRange) {
                    axis.closestPointRange = closestPointRange;
                }
            }
            // Secondary values
            axis.translationSlope = axis.transA = transA =
                axis.staticScale ||
                    axis.len / ((range + pointRangePadding) || 1);
            // Translation addend
            axis.transB = axis.horiz ? axis.left : axis.bottom;
            axis.minPixelPadding = transA * minPointOffset;
            fireEvent$6(this, 'afterSetAxisTranslation');
        }
        /**
         * @private
         * @function Highcharts.Axis#minFromRange
         */
        minFromRange() {
            const axis = this;
            return axis.max - axis.range;
        }
        /**
         * Set the tick positions to round values and optionally extend the extremes
         * to the nearest tick.
         *
         * @private
         * @function Highcharts.Axis#setTickInterval
         *
         * @param {boolean} secondPass
         * TO-DO: parameter description
         *
         * @emits Highcharts.Axis#event:foundExtremes
         */
        setTickInterval(secondPass) {
            const axis = this, chart = axis.chart, log = axis.logarithmic, options = axis.options, isXAxis = axis.isXAxis, isLinked = axis.isLinked, tickPixelIntervalOption = options.tickPixelInterval, categories = axis.categories, softThreshold = axis.softThreshold;
            let maxPadding = options.maxPadding, minPadding = options.minPadding, length, linkedParentExtremes, 
            // Only non-negative tickInterval is valid, #12961
            tickIntervalOption = isNumber$7(options.tickInterval) && options.tickInterval >= 0 ?
                options.tickInterval : void 0, threshold = isNumber$7(axis.threshold) ? axis.threshold : null, thresholdMin, thresholdMax, hardMin, hardMax;
            if (!axis.dateTime && !categories && !isLinked) {
                this.getTickAmount();
            }
            // Min or max set either by zooming/setExtremes or initial options
            hardMin = pick$a(axis.userMin, options.min);
            hardMax = pick$a(axis.userMax, options.max);
            // Linked axis gets the extremes from the parent axis
            if (isLinked) {
                axis.linkedParent = chart[axis.coll][options.linkedTo];
                linkedParentExtremes = axis.linkedParent.getExtremes();
                axis.min = pick$a(linkedParentExtremes.min, linkedParentExtremes.dataMin);
                axis.max = pick$a(linkedParentExtremes.max, linkedParentExtremes.dataMax);
                if (options.type !== axis.linkedParent.options.type) {
                    // Can't link axes of different type
                    error$3(11, 1, chart);
                }
                // Initial min and max from the extreme data values
            }
            else {
                // Adjust to hard threshold
                if (softThreshold && defined$8(threshold)) {
                    if (axis.dataMin >= threshold) {
                        thresholdMin = threshold;
                        minPadding = 0;
                    }
                    else if (axis.dataMax <= threshold) {
                        thresholdMax = threshold;
                        maxPadding = 0;
                    }
                }
                axis.min = pick$a(hardMin, thresholdMin, axis.dataMin);
                axis.max = pick$a(hardMax, thresholdMax, axis.dataMax);
            }
            if (log) {
                if (axis.positiveValuesOnly &&
                    !secondPass &&
                    Math.min(axis.min, pick$a(axis.dataMin, axis.min)) <= 0) { // #978
                    // Can't plot negative values on log axis
                    error$3(10, 1, chart);
                }
                // The correctFloat cures #934, float errors on full tens. But it
                // was too aggressive for #4360 because of conversion back to lin,
                // therefore use precision 15.
                axis.min = correctFloat$1(log.log2lin(axis.min), 16);
                axis.max = correctFloat$1(log.log2lin(axis.max), 16);
            }
            // handle zoomed range
            if (axis.range && defined$8(axis.max)) {
                // #618, #6773:
                axis.userMin = axis.min = hardMin =
                    Math.max(axis.dataMin, axis.minFromRange());
                axis.userMax = hardMax = axis.max;
                axis.range = null; // don't use it when running setExtremes
            }
            // Hook for Highcharts Stock Scroller.
            // Consider combining with beforePadding.
            fireEvent$6(axis, 'foundExtremes');
            // Hook for adjusting this.min and this.max. Used by bubble series.
            if (axis.beforePadding) {
                axis.beforePadding();
            }
            // Adjust min and max for the minimum range
            axis.adjustForMinRange();
            // Handle options for floor, ceiling, softMin and softMax (#6359)
            if (!isNumber$7(axis.userMin)) {
                if (isNumber$7(options.softMin) && options.softMin < axis.min) {
                    axis.min = hardMin = options.softMin; // #6894
                }
            }
            if (!isNumber$7(axis.userMax)) {
                if (isNumber$7(options.softMax) && options.softMax > axis.max) {
                    axis.max = hardMax = options.softMax; // #6894
                }
            }
            // Pad the values to get clear of the chart's edges. To avoid
            // tickInterval taking the padding into account, we do this after
            // computing tick interval (#1337).
            if (!categories &&
                !axis.axisPointRange &&
                !(axis.stacking && axis.stacking.usePercentage) &&
                !isLinked &&
                defined$8(axis.min) &&
                defined$8(axis.max)) {
                length = axis.max - axis.min;
                if (length) {
                    if (!defined$8(hardMin) && minPadding) {
                        axis.min -= length * minPadding;
                    }
                    if (!defined$8(hardMax) && maxPadding) {
                        axis.max += length * maxPadding;
                    }
                }
            }
            if (!isNumber$7(axis.userMin) && isNumber$7(options.floor)) {
                axis.min = Math.max(axis.min, options.floor);
            }
            if (!isNumber$7(axis.userMax) && isNumber$7(options.ceiling)) {
                axis.max = Math.min(axis.max, options.ceiling);
            }
            // When the threshold is soft, adjust the extreme value only if the data
            // extreme and the padded extreme land on either side of the threshold.
            // For example, a series of [0, 1, 2, 3] would make the yAxis add a tick
            // for -1 because of the default minPadding and startOnTick options.
            // This is prevented by the softThreshold option.
            if (softThreshold && defined$8(axis.dataMin)) {
                threshold = threshold || 0;
                if (!defined$8(hardMin) &&
                    axis.min < threshold &&
                    axis.dataMin >= threshold) {
                    axis.min = axis.options.minRange ?
                        Math.min(threshold, axis.max -
                            axis.minRange) :
                        threshold;
                }
                else if (!defined$8(hardMax) &&
                    axis.max > threshold &&
                    axis.dataMax <= threshold) {
                    axis.max = axis.options.minRange ?
                        Math.max(threshold, axis.min +
                            axis.minRange) :
                        threshold;
                }
            }
            // If min is bigger than highest, or if max less than lowest value, the
            // chart should not render points. (#14417)
            if (isNumber$7(axis.min) &&
                isNumber$7(axis.max) &&
                !this.chart.polar &&
                (axis.min > axis.max)) {
                if (defined$8(axis.options.min)) {
                    axis.max = axis.min;
                }
                else if (defined$8(axis.options.max)) {
                    axis.min = axis.max;
                }
            }
            // get tickInterval
            if (axis.min === axis.max ||
                typeof axis.min === 'undefined' ||
                typeof axis.max === 'undefined') {
                axis.tickInterval = 1;
            }
            else if (isLinked &&
                axis.linkedParent &&
                !tickIntervalOption &&
                tickPixelIntervalOption ===
                    axis.linkedParent.options.tickPixelInterval) {
                axis.tickInterval = tickIntervalOption =
                    axis.linkedParent.tickInterval;
            }
            else {
                axis.tickInterval = pick$a(tickIntervalOption, this.tickAmount ?
                    ((axis.max - axis.min) /
                        Math.max(this.tickAmount - 1, 1)) :
                    void 0, 
                // For categoried axis, 1 is default, for linear axis use
                // tickPix
                categories ?
                    1 :
                    // don't let it be more than the data range
                    (axis.max - axis.min) *
                        tickPixelIntervalOption /
                        Math.max(axis.len, tickPixelIntervalOption));
            }
            // Now we're finished detecting min and max, crop and group series data.
            // This is in turn needed in order to find tick positions in ordinal
            // axes.
            if (isXAxis && !secondPass) {
                const hasExtremesChanged = axis.min !==
                    (axis.old && axis.old.min) ||
                    axis.max !== (axis.old && axis.old.max);
                // First process all series assigned to that axis.
                axis.series.forEach(function (series) {
                    // Allows filtering out points outside the plot area.
                    series.forceCrop = (series.forceCropping &&
                        series.forceCropping());
                    series.processData(hasExtremesChanged);
                });
                // Then apply grouping if needed. The hasExtremesChanged helps to
                // decide if the data grouping should be skipped in the further
                // calculations #16319.
                fireEvent$6(this, 'postProcessData', { hasExtremesChanged });
            }
            // set the translation factor used in translate function
            axis.setAxisTranslation();
            // hook for ordinal axes and radial axes
            fireEvent$6(this, 'initialAxisTranslation');
            // In column-like charts, don't cramp in more ticks than there are
            // points (#1943, #4184)
            if (axis.pointRange && !tickIntervalOption) {
                axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);
            }
            // Before normalizing the tick interval, handle minimum tick interval.
            // This applies only if tickInterval is not defined.
            const minTickInterval = pick$a(options.minTickInterval, 
            // In datetime axes, don't go below the data interval, except when
            // there are scatter-like series involved (#13369).
            axis.dateTime &&
                !axis.series.some((s) => s.noSharedTooltip) ?
                axis.closestPointRange : 0);
            if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
                axis.tickInterval = minTickInterval;
            }
            // For linear axes, normalize the interval
            if (!axis.dateTime && !axis.logarithmic && !tickIntervalOption) {
                axis.tickInterval = getNormalizedTickInterval(axis, axis.tickInterval);
            }
            // Prevent ticks from getting so close that we can't draw the labels
            if (!this.tickAmount) {
                axis.tickInterval = axis.unsquish();
            }
            this.setTickPositions();
        }
        /**
         * Now we have computed the normalized tickInterval, get the tick positions.
         *
         * @private
         * @function Highcharts.Axis#setTickPositions
         *
         * @emits Highcharts.Axis#event:afterSetTickPositions
         */
        setTickPositions() {
            const axis = this, options = this.options, tickPositionsOption = options.tickPositions, tickPositioner = options.tickPositioner, minorTickIntervalOption = this.getMinorTickInterval(), hasVerticalPanning = this.hasVerticalPanning(), isColorAxis = this.coll === 'colorAxis', startOnTick = ((isColorAxis || !hasVerticalPanning) && options.startOnTick), endOnTick = ((isColorAxis || !hasVerticalPanning) && options.endOnTick);
            let tickPositions = [], tickPositionerResult;
            // Set the tickmarkOffset
            this.tickmarkOffset = (this.categories &&
                options.tickmarkPlacement === 'between' &&
                this.tickInterval === 1) ? 0.5 : 0; // #3202
            // get minorTickInterval
            this.minorTickInterval =
                minorTickIntervalOption === 'auto' &&
                    this.tickInterval ?
                    this.tickInterval / options.minorTicksPerMajor :
                    minorTickIntervalOption;
            // When there is only one point, or all points have the same value on
            // this axis, then min and max are equal and tickPositions.length is 0
            // or 1. In this case, add some padding in order to center the point,
            // but leave it with one tick. #1337.
            this.single =
                this.min === this.max &&
                    defined$8(this.min) &&
                    !this.tickAmount &&
                    (
                    // Data is on integer (#6563)
                    parseInt(this.min, 10) === this.min ||
                        // Between integers and decimals are not allowed (#6274)
                        options.allowDecimals !== false);
            /**
             * Contains the current positions that are laid out on the axis. The
             * positions are numbers in terms of axis values. In a category axis
             * they are integers, in a datetime axis they are also integers, but
             * designating milliseconds.
             *
             * This property is read only - for modifying the tick positions, use
             * the `tickPositioner` callback or [axis.tickPositions(
             * https://api.highcharts.com/highcharts/xAxis.tickPositions) option
             * instead.
             *
             * @name Highcharts.Axis#tickPositions
             * @type {Highcharts.AxisTickPositionsArray|undefined}
             */
            if (tickPositionsOption) {
                // Find the tick positions. Work on a copy (#1565)
                tickPositions = tickPositionsOption.slice();
            }
            else if (isNumber$7(this.min) && isNumber$7(this.max)) {
                // Too many ticks (#6405). Create a friendly warning and provide two
                // ticks so at least we can show the data series.
                if ((!axis.ordinal || !axis.ordinal.positions) &&
                    ((this.max - this.min) /
                        this.tickInterval >
                        Math.max(2 * this.len, 200))) {
                    tickPositions = [this.min, this.max];
                    error$3(19, false, this.chart);
                }
                else if (axis.dateTime) {
                    tickPositions = axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(this.tickInterval, options.units), this.min, this.max, options.startOfWeek, axis.ordinal && axis.ordinal.positions, this.closestPointRange, true);
                }
                else if (axis.logarithmic) {
                    tickPositions = axis.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
                }
                else {
                    const startingTickInterval = this.tickInterval;
                    let adjustedTickInterval = startingTickInterval;
                    while (adjustedTickInterval <= startingTickInterval * 2) {
                        tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);
                        // If there are more tick positions than the set tickAmount,
                        // increase the tickInterval and continue until it fits.
                        // (#17100)
                        if (this.tickAmount &&
                            tickPositions.length > this.tickAmount) {
                            this.tickInterval = getNormalizedTickInterval(this, adjustedTickInterval *= 1.1);
                        }
                        else {
                            break;
                        }
                    }
                }
                // Too dense ticks, keep only the first and last (#4477)
                if (tickPositions.length > this.len) {
                    tickPositions = [
                        tickPositions[0],
                        tickPositions[tickPositions.length - 1]
                    ];
                    // Reduce doubled value (#7339)
                    if (tickPositions[0] === tickPositions[1]) {
                        tickPositions.length = 1;
                    }
                }
                // Run the tick positioner callback, that allows modifying auto tick
                // positions.
                if (tickPositioner) {
                    // Make it available to the positioner
                    this.tickPositions = tickPositions;
                    tickPositionerResult = tickPositioner.apply(axis, [this.min, this.max]);
                    if (tickPositionerResult) {
                        tickPositions = tickPositionerResult;
                    }
                }
            }
            this.tickPositions = tickPositions;
            // Reset min/max or remove extremes based on start/end on tick
            this.paddedTicks = tickPositions.slice(0); // Used for logarithmic minor
            this.trimTicks(tickPositions, startOnTick, endOnTick);
            if (!this.isLinked && isNumber$7(this.min) && isNumber$7(this.max)) {
                // Substract half a unit (#2619, #2846, #2515, #3390), but not in
                // case of multiple ticks (#6897)
                if (this.single &&
                    tickPositions.length < 2 &&
                    !this.categories &&
                    !this.series.some((s) => (s.is('heatmap') && s.options.pointPlacement === 'between'))) {
                    this.min -= 0.5;
                    this.max += 0.5;
                }
                if (!tickPositionsOption && !tickPositionerResult) {
                    this.adjustTickAmount();
                }
            }
            fireEvent$6(this, 'afterSetTickPositions');
        }
        /**
         * Handle startOnTick and endOnTick by either adapting to padding min/max or
         * rounded min/max. Also handle single data points.
         *
         * @private
         * @function Highcharts.Axis#trimTicks
         *
         * @param {Array<number>} tickPositions
         * TO-DO: parameter description
         *
         * @param {boolean} [startOnTick]
         * TO-DO: parameter description
         *
         * @param {boolean} [endOnTick]
         * TO-DO: parameter description
         */
        trimTicks(tickPositions, startOnTick, endOnTick) {
            const roundedMin = tickPositions[0], roundedMax = tickPositions[tickPositions.length - 1], minPointOffset = (!this.isOrdinal && this.minPointOffset) || 0; // (#12716)
            fireEvent$6(this, 'trimTicks');
            if (!this.isLinked) {
                if (startOnTick && roundedMin !== -Infinity) { // #6502
                    this.min = roundedMin;
                }
                else {
                    while (this.min - minPointOffset > tickPositions[0]) {
                        tickPositions.shift();
                    }
                }
                if (endOnTick) {
                    this.max = roundedMax;
                }
                else {
                    while (this.max + minPointOffset <
                        tickPositions[tickPositions.length - 1]) {
                        tickPositions.pop();
                    }
                }
                // If no tick are left, set one tick in the middle (#3195)
                if (tickPositions.length === 0 &&
                    defined$8(roundedMin) &&
                    !this.options.tickPositions) {
                    tickPositions.push((roundedMax + roundedMin) / 2);
                }
            }
        }
        /**
         * Check if there are multiple axes in the same pane.
         *
         * @private
         * @function Highcharts.Axis#alignToOthers
         *
         * @return {boolean|undefined}
         * True if there are other axes.
         */
        alignToOthers() {
            const axis = this, alignedAxes = [this], options = axis.options, alignThresholds = (this.coll === 'yAxis' &&
                this.chart.options.chart.alignThresholds), thresholdAlignments = [];
            let hasOther;
            axis.thresholdAlignment = void 0;
            if ((
            // Only if alignTicks or alignThresholds is true
            (this.chart.options.chart.alignTicks !== false &&
                options.alignTicks) || (alignThresholds)) &&
                // Disabled when startOnTick or endOnTick are false (#7604)
                options.startOnTick !== false &&
                options.endOnTick !== false &&
                // Don't try to align ticks on a log axis, they are not evenly
                // spaced (#6021)
                !axis.logarithmic) {
                // Get a key identifying which pane the axis belongs to
                const getKey = (axis) => {
                    const { horiz, options } = axis;
                    return [
                        horiz ? options.left : options.top,
                        options.width,
                        options.height,
                        options.pane
                    ].join(',');
                };
                const thisKey = getKey(this);
                this.chart[this.coll].forEach(function (otherAxis) {
                    const { series } = otherAxis;
                    if (
                    // #4442
                    series.length &&
                        series.some((s) => s.visible) &&
                        otherAxis !== axis &&
                        getKey(otherAxis) === thisKey) {
                        hasOther = true; // #4201
                        alignedAxes.push(otherAxis);
                    }
                });
            }
            if (hasOther && alignThresholds) {
                // Handle alignThresholds. The `thresholdAlignments` array keeps
                // records of where each axis in the group wants its threshold, from
                // 0 which is on `axis.min`, to 1 which is on `axis.max`.
                alignedAxes.forEach((otherAxis) => {
                    const threshAlign = otherAxis.getThresholdAlignment(axis);
                    if (isNumber$7(threshAlign)) {
                        thresholdAlignments.push(threshAlign);
                    }
                });
                // For each of the axes in the group, record the average
                // `thresholdAlignment`.
                const thresholdAlignment = thresholdAlignments.length > 1 ?
                    thresholdAlignments.reduce((sum, n) => (sum += n), 0) / thresholdAlignments.length :
                    void 0;
                alignedAxes.forEach((axis) => {
                    axis.thresholdAlignment = thresholdAlignment;
                });
            }
            return hasOther;
        }
        /**
         * Where the axis wants its threshold, from 0 which is on `axis.min`, to 1 which
         * is on `axis.max`.
         *
         * @private
         * @function Highcharts.Axis#getThresholdAlignment
         */
        getThresholdAlignment(callerAxis) {
            if (!isNumber$7(this.dataMin) ||
                (this !== callerAxis &&
                    this.series.some((s) => (s.isDirty || s.isDirtyData)))) {
                this.getSeriesExtremes();
            }
            if (isNumber$7(this.threshold)) {
                let thresholdAlignment = clamp$2(((this.threshold - (this.dataMin || 0)) /
                    ((this.dataMax || 0) - (this.dataMin || 0))), 0, 1);
                if (this.options.reversed) {
                    thresholdAlignment = 1 - thresholdAlignment;
                }
                return thresholdAlignment;
            }
        }
        /**
         * Find the max ticks of either the x and y axis collection, and record it
         * in `this.tickAmount`.
         *
         * @private
         * @function Highcharts.Axis#getTickAmount
         */
        getTickAmount() {
            const axis = this, options = this.options, tickPixelInterval = options.tickPixelInterval;
            let tickAmount = options.tickAmount;
            if (!defined$8(options.tickInterval) &&
                !tickAmount &&
                this.len < tickPixelInterval &&
                !this.isRadial &&
                !axis.logarithmic &&
                options.startOnTick &&
                options.endOnTick) {
                tickAmount = 2;
            }
            if (!tickAmount && this.alignToOthers()) {
                // Add 1 because 4 tick intervals require 5 ticks (including first
                // and last)
                tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;
            }
            // For tick amounts of 2 and 3, compute five ticks and remove the
            // intermediate ones. This prevents the axis from adding ticks that are
            // too far away from the data extremes.
            if (tickAmount < 4) {
                this.finalTickAmt = tickAmount;
                tickAmount = 5;
            }
            this.tickAmount = tickAmount;
        }
        /**
         * When using multiple axes, adjust the number of ticks to match the highest
         * number of ticks in that group.
         *
         * @private
         * @function Highcharts.Axis#adjustTickAmount
         */
        adjustTickAmount() {
            const axis = this, { finalTickAmt, max, min, options, tickPositions, tickAmount, thresholdAlignment } = axis, currentTickAmount = tickPositions && tickPositions.length, threshold = pick$a(axis.threshold, axis.softThreshold ? 0 : null);
            let len, i, tickInterval = axis.tickInterval, thresholdTickIndex;
            const 
            // Extend the tickPositions by appending a position
            append = () => tickPositions.push(correctFloat$1(tickPositions[tickPositions.length - 1] +
                tickInterval)), 
            // Extend the tickPositions by prepending a position
            prepend = () => tickPositions.unshift(correctFloat$1(tickPositions[0] - tickInterval));
            // If `thresholdAlignment` is a number, it means the `alignThresholds`
            // option is true. The `thresholdAlignment` is a scalar value between 0
            // and 1 for where the threshold should be relative to `axis.min` and
            // `axis.max`. Now that we know the tick amount, convert this to the
            // tick index. Unless `thresholdAlignment` is exactly 0 or 1, avoid the
            // first or last tick because that would lead to series being clipped.
            if (isNumber$7(thresholdAlignment)) {
                thresholdTickIndex = thresholdAlignment < 0.5 ?
                    Math.ceil(thresholdAlignment * (tickAmount - 1)) :
                    Math.floor(thresholdAlignment * (tickAmount - 1));
                if (options.reversed) {
                    thresholdTickIndex = tickAmount - 1 - thresholdTickIndex;
                }
            }
            if (axis.hasData() && isNumber$7(min) && isNumber$7(max)) { // #14769
                // Adjust extremes and translation to the modified tick positions
                const adjustExtremes = () => {
                    axis.transA *= (currentTickAmount - 1) / (tickAmount - 1);
                    // Do not crop when ticks are not extremes (#9841)
                    axis.min = options.startOnTick ?
                        tickPositions[0] :
                        Math.min(min, tickPositions[0]);
                    axis.max = options.endOnTick ?
                        tickPositions[tickPositions.length - 1] :
                        Math.max(max, tickPositions[tickPositions.length - 1]);
                };
                // When the axis is subject to the alignThresholds option. Use
                // axis.threshold because the local threshold includes the
                // `softThreshold`.
                if (isNumber$7(thresholdTickIndex) && isNumber$7(axis.threshold)) {
                    // Throw away the previously computed tickPositions and start
                    // from scratch with only the threshold itself, then add ticks
                    // below the threshold first, then fill up above the threshold.
                    // If we are not able to fill up to axis.max, double the
                    // tickInterval and run again.
                    while (tickPositions[thresholdTickIndex] !== threshold ||
                        tickPositions.length !== tickAmount ||
                        tickPositions[0] > min ||
                        tickPositions[tickPositions.length - 1] < max) {
                        tickPositions.length = 0;
                        tickPositions.push(axis.threshold);
                        while (tickPositions.length < tickAmount) {
                            if (
                            // Start by prepending positions until the threshold
                            // is at the required index...
                            tickPositions[thresholdTickIndex] === void 0 ||
                                tickPositions[thresholdTickIndex] > axis.threshold) {
                                prepend();
                            }
                            else {
                                // ... then append positions until we have the
                                // required length
                                append();
                            }
                        }
                        // Safety vent
                        if (tickInterval > axis.tickInterval * 8) {
                            break;
                        }
                        tickInterval *= 2;
                    }
                    adjustExtremes();
                }
                else if (currentTickAmount < tickAmount) {
                    while (tickPositions.length < tickAmount) {
                        // Extend evenly for both sides unless we're on the
                        // threshold (#3965)
                        if (tickPositions.length % 2 || min === threshold) {
                            append();
                        }
                        else {
                            prepend();
                        }
                    }
                    adjustExtremes();
                }
                // The finalTickAmt property is set in getTickAmount
                if (defined$8(finalTickAmt)) {
                    i = len = tickPositions.length;
                    while (i--) {
                        if (
                        // Remove every other tick
                        (finalTickAmt === 3 && i % 2 === 1) ||
                            // Remove all but first and last
                            (finalTickAmt <= 2 && i > 0 && i < len - 1)) {
                            tickPositions.splice(i, 1);
                        }
                    }
                    axis.finalTickAmt = void 0;
                }
            }
        }
        /**
         * Set the scale based on data min and max, user set min and max or options.
         *
         * @private
         * @function Highcharts.Axis#setScale
         *
         * @emits Highcharts.Axis#event:afterSetScale
         */
        setScale() {
            const axis = this;
            let isDirtyData = false, isXAxisDirty = false;
            axis.series.forEach(function (series) {
                isDirtyData = isDirtyData || series.isDirtyData || series.isDirty;
                // When x axis is dirty, we need new data extremes for y as
                // well:
                isXAxisDirty = (isXAxisDirty ||
                    (series.xAxis && series.xAxis.isDirty) ||
                    false);
            });
            // set the new axisLength
            axis.setAxisSize();
            const isDirtyAxisLength = axis.len !== (axis.old && axis.old.len);
            // do we really need to go through all this?
            if (isDirtyAxisLength ||
                isDirtyData ||
                isXAxisDirty ||
                axis.isLinked ||
                axis.forceRedraw ||
                axis.userMin !== (axis.old && axis.old.userMin) ||
                axis.userMax !== (axis.old && axis.old.userMax) ||
                axis.alignToOthers()) {
                if (axis.stacking) {
                    axis.stacking.resetStacks();
                    axis.stacking.buildStacks();
                }
                axis.forceRedraw = false;
                // #18066 delete minRange property to ensure that it will be
                // calculated again after dirty data in series
                if (!axis.userMinRange) {
                    axis.minRange = void 0;
                }
                // get data extremes if needed
                axis.getSeriesExtremes();
                // get fixed positions based on tickInterval
                axis.setTickInterval();
                // Mark as dirty if it is not already set to dirty and extremes have
                // changed. #595.
                if (!axis.isDirty) {
                    axis.isDirty =
                        isDirtyAxisLength ||
                            axis.min !== (axis.old && axis.old.min) ||
                            axis.max !== (axis.old && axis.old.max);
                }
            }
            else if (axis.stacking) {
                axis.stacking.cleanStacks();
            }
            // Recalculate panning state object, when the data
            // has changed. It is required when vertical panning is enabled.
            if (isDirtyData && axis.panningState) {
                axis.panningState.isDirty = true;
            }
            fireEvent$6(this, 'afterSetScale');
        }
        /**
         * Set the minimum and maximum of the axes after render time. If the
         * `startOnTick` and `endOnTick` options are true, the minimum and maximum
         * values are rounded off to the nearest tick. To prevent this, these
         * options can be set to false before calling setExtremes. Also, setExtremes
         * will not allow a range lower than the `minRange` option, which by default
         * is the range of five points.
         *
         * @sample highcharts/members/axis-setextremes/
         *         Set extremes from a button
         * @sample highcharts/members/axis-setextremes-datetime/
         *         Set extremes on a datetime axis
         * @sample highcharts/members/axis-setextremes-off-ticks/
         *         Set extremes off ticks
         * @sample stock/members/axis-setextremes/
         *         Set extremes in Highcharts Stock
         *
         * @function Highcharts.Axis#setExtremes
         *
         * @param {number} [newMin]
         * The new minimum value.
         *
         * @param {number} [newMax]
         * The new maximum value.
         *
         * @param {boolean} [redraw=true]
         * Whether to redraw the chart or wait for an explicit call to
         * {@link Highcharts.Chart#redraw}
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation=true]
         * Enable or modify animations.
         *
         * @param {*} [eventArguments]
         * Arguments to be accessed in event handler.
         *
         * @emits Highcharts.Axis#event:setExtremes
         */
        setExtremes(newMin, newMax, redraw, animation, eventArguments) {
            const axis = this, chart = axis.chart;
            redraw = pick$a(redraw, true); // defaults to true
            axis.series.forEach(function (serie) {
                delete serie.kdTree;
            });
            // Extend the arguments with min and max
            eventArguments = extend$9(eventArguments, {
                min: newMin,
                max: newMax
            });
            // Fire the event
            fireEvent$6(axis, 'setExtremes', eventArguments, function () {
                axis.userMin = newMin;
                axis.userMax = newMax;
                axis.eventArgs = eventArguments;
                if (redraw) {
                    chart.redraw(animation);
                }
            });
        }
        /**
         * Overridable method for zooming chart. Pulled out in a separate method to
         * allow overriding in stock charts.
         *
         * @private
         * @function Highcharts.Axis#zoom
         */
        zoom(newMin, newMax) {
            const axis = this, dataMin = this.dataMin, dataMax = this.dataMax, options = this.options, min = Math.min(dataMin, pick$a(options.min, dataMin)), max = Math.max(dataMax, pick$a(options.max, dataMax)), evt = {
                newMin: newMin,
                newMax: newMax
            };
            fireEvent$6(this, 'zoom', evt, function (e) {
                // Use e.newMin and e.newMax - event handlers may have altered them
                let newMin = e.newMin, newMax = e.newMax;
                if (newMin !== axis.min || newMax !== axis.max) { // #5790
                    // Prevent pinch zooming out of range. Check for defined is for
                    // #1946. #1734.
                    if (!axis.allowZoomOutside) {
                        // #6014, sometimes newMax will be smaller than min (or
                        // newMin will be larger than max).
                        if (defined$8(dataMin)) {
                            if (newMin < min) {
                                newMin = min;
                            }
                            if (newMin > max) {
                                newMin = max;
                            }
                        }
                        if (defined$8(dataMax)) {
                            if (newMax < min) {
                                newMax = min;
                            }
                            if (newMax > max) {
                                newMax = max;
                            }
                        }
                    }
                    // In full view, displaying the reset zoom button is not
                    // required
                    axis.displayBtn = (typeof newMin !== 'undefined' ||
                        typeof newMax !== 'undefined');
                    // Do it
                    axis.setExtremes(newMin, newMax, false, void 0, { trigger: 'zoom' });
                }
                e.zoomed = true;
            });
            return evt.zoomed;
        }
        /**
         * Update the axis metrics.
         *
         * @private
         * @function Highcharts.Axis#setAxisSize
         */
        setAxisSize() {
            const chart = this.chart, options = this.options, 
            // [top, right, bottom, left]
            offsets = options.offsets || [0, 0, 0, 0], horiz = this.horiz, 
            // Check for percentage based input values. Rounding fixes problems
            // with column overflow and plot line filtering (#4898, #4899)
            width = this.width = Math.round(relativeLength$2(pick$a(options.width, chart.plotWidth - offsets[3] + offsets[1]), chart.plotWidth)), height = this.height = Math.round(relativeLength$2(pick$a(options.height, chart.plotHeight - offsets[0] + offsets[2]), chart.plotHeight)), top = this.top = Math.round(relativeLength$2(pick$a(options.top, chart.plotTop + offsets[0]), chart.plotHeight, chart.plotTop)), left = this.left = Math.round(relativeLength$2(pick$a(options.left, chart.plotLeft + offsets[3]), chart.plotWidth, chart.plotLeft));
            // Expose basic values to use in Series object and navigator
            this.bottom = chart.chartHeight - height - top;
            this.right = chart.chartWidth - width - left;
            // Direction agnostic properties
            this.len = Math.max(horiz ? width : height, 0); // Math.max fixes #905
            this.pos = horiz ? left : top; // distance from SVG origin
        }
        /**
         * Get the current extremes for the axis.
         *
         * @sample highcharts/members/axis-getextremes/
         *         Report extremes by click on a button
         *
         * @function Highcharts.Axis#getExtremes
         *
         * @return {Highcharts.ExtremesObject}
         * An object containing extremes information.
         */
        getExtremes() {
            const axis = this, log = axis.logarithmic;
            return {
                min: log ?
                    correctFloat$1(log.lin2log(axis.min)) :
                    axis.min,
                max: log ?
                    correctFloat$1(log.lin2log(axis.max)) :
                    axis.max,
                dataMin: axis.dataMin,
                dataMax: axis.dataMax,
                userMin: axis.userMin,
                userMax: axis.userMax
            };
        }
        /**
         * Get the zero plane either based on zero or on the min or max value.
         * Used in bar and area plots.
         *
         * @function Highcharts.Axis#getThreshold
         *
         * @param {number} threshold
         * The threshold in axis values.
         *
         * @return {number}
         * The translated threshold position in terms of pixels, and corrected to
         * stay within the axis bounds.
         */
        getThreshold(threshold) {
            const axis = this, log = axis.logarithmic, realMin = log ? log.lin2log(axis.min) : axis.min, realMax = log ? log.lin2log(axis.max) : axis.max;
            if (threshold === null || threshold === -Infinity) {
                threshold = realMin;
            }
            else if (threshold === Infinity) {
                threshold = realMax;
            }
            else if (realMin > threshold) {
                threshold = realMin;
            }
            else if (realMax < threshold) {
                threshold = realMax;
            }
            return axis.translate(threshold, 0, 1, 0, 1);
        }
        /**
         * Compute auto alignment for the axis label based on which side the axis is
         * on and the given rotation for the label.
         *
         * @private
         * @function Highcharts.Axis#autoLabelAlign
         *
         * @param {number} rotation
         * The rotation in degrees as set by either the `rotation` or `autoRotation`
         * options.
         *
         * @return {Highcharts.AlignValue}
         * Can be `"center"`, `"left"` or `"right"`.
         */
        autoLabelAlign(rotation) {
            const angle = (pick$a(rotation, 0) - (this.side * 90) + 720) % 360, evt = { align: 'center' };
            fireEvent$6(this, 'autoLabelAlign', evt, function (e) {
                if (angle > 15 && angle < 165) {
                    e.align = 'right';
                }
                else if (angle > 195 && angle < 345) {
                    e.align = 'left';
                }
            });
            return evt.align;
        }
        /**
         * Get the tick length and width for the axis based on axis options.
         *
         * @private
         * @function Highcharts.Axis#tickSize
         *
         * @param {string} [prefix]
         * 'tick' or 'minorTick'
         *
         * @return {Array<number,number>|undefined}
         * An array of tickLength and tickWidth
         */
        tickSize(prefix) {
            const options = this.options, tickWidth = pick$a(options[prefix === 'tick' ? 'tickWidth' : 'minorTickWidth'], 
            // Default to 1 on linear and datetime X axes
            prefix === 'tick' && this.isXAxis && !this.categories ? 1 : 0);
            let tickLength = options[prefix === 'tick' ? 'tickLength' : 'minorTickLength'], tickSize;
            if (tickWidth && tickLength) {
                // Negate the length
                if (options[prefix + 'Position'] === 'inside') {
                    tickLength = -tickLength;
                }
                tickSize = [tickLength, tickWidth];
            }
            const e = { tickSize };
            fireEvent$6(this, 'afterTickSize', e);
            return e.tickSize;
        }
        /**
         * Return the size of the labels.
         *
         * @private
         * @function Highcharts.Axis#labelMetrics
         */
        labelMetrics() {
            const renderer = this.chart.renderer, ticks = this.ticks, tick = ticks[Object.keys(ticks)[0]] || {};
            return this.chart.renderer.fontMetrics(tick.label ||
                tick.movedLabel ||
                renderer.box);
        }
        /**
         * Prevent the ticks from getting so close we can't draw the labels. On a
         * horizontal axis, this is handled by rotating the labels, removing ticks
         * and adding ellipsis. On a vertical axis remove ticks and add ellipsis.
         *
         * @private
         * @function Highcharts.Axis#unsquish
         */
        unsquish() {
            const labelOptions = this.options.labels, horiz = this.horiz, tickInterval = this.tickInterval, slotSize = this.len / (((this.categories ? 1 : 0) +
                this.max -
                this.min) /
                tickInterval), rotationOption = labelOptions.rotation, 
            // We don't know the actual rendered line height at this point, but
            // it defaults to 0.75em
            lineHeight = this.labelMetrics().h * 0.75, range = Math.max(this.max - this.min, 0), 
            // Return the multiple of tickInterval that is needed to avoid
            // collision
            getStep = function (spaceNeeded) {
                let step = spaceNeeded / (slotSize || 1);
                step = step > 1 ? Math.ceil(step) : 1;
                // Guard for very small or negative angles (#9835)
                if (step * tickInterval > range &&
                    spaceNeeded !== Infinity &&
                    slotSize !== Infinity &&
                    range) {
                    step = Math.ceil(range / tickInterval);
                }
                return correctFloat$1(step * tickInterval);
            };
            let newTickInterval = tickInterval, rotation, bestScore = Number.MAX_VALUE, autoRotation;
            if (horiz) {
                if (!labelOptions.staggerLines) {
                    if (isNumber$7(rotationOption)) {
                        autoRotation = [rotationOption];
                    }
                    else if (slotSize < labelOptions.autoRotationLimit) {
                        autoRotation = labelOptions.autoRotation;
                    }
                }
                if (autoRotation) {
                    let step, score;
                    // Loop over the given autoRotation options, and determine which
                    // gives the best score. The best score is that with the lowest
                    // number of steps and a rotation closest to horizontal.
                    for (const rot of autoRotation) {
                        if (rot === rotationOption ||
                            (rot && rot >= -90 && rot <= 90)) { // #3891
                            step = getStep(Math.abs(lineHeight / Math.sin(deg2rad$2 * rot)));
                            score = step + Math.abs(rot / 360);
                            if (score < bestScore) {
                                bestScore = score;
                                rotation = rot;
                                newTickInterval = step;
                            }
                        }
                    }
                }
            }
            else { // #4411
                newTickInterval = getStep(lineHeight);
            }
            this.autoRotation = autoRotation;
            this.labelRotation = pick$a(rotation, isNumber$7(rotationOption) ? rotationOption : 0);
            return labelOptions.step ? tickInterval : newTickInterval;
        }
        /**
         * Get the general slot width for labels/categories on this axis. This may
         * change between the pre-render (from Axis.getOffset) and the final tick
         * rendering and placement.
         *
         * @private
         * @function Highcharts.Axis#getSlotWidth
         *
         * @param {Highcharts.Tick} [tick] Optionally, calculate the slot width
         * basing on tick label. It is used in highcharts-3d module, where the slots
         * has different widths depending on perspective angles.
         *
         * @return {number}
         * The pixel width allocated to each axis label.
         */
        getSlotWidth(tick) {
            // #5086, #1580, #1931
            const chart = this.chart, horiz = this.horiz, labelOptions = this.options.labels, slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), marginLeft = chart.margin[3];
            // Used by grid axis
            if (tick && isNumber$7(tick.slotWidth)) { // #13221, can be 0
                return tick.slotWidth;
            }
            if (horiz && labelOptions.step < 2) {
                if (labelOptions.rotation) { // #4415
                    return 0;
                }
                return ((this.staggerLines || 1) * this.len) / slotCount;
            }
            if (!horiz) {
                // #7028
                const cssWidth = labelOptions.style.width;
                if (cssWidth !== void 0) {
                    return parseInt(String(cssWidth), 10);
                }
                if (marginLeft) {
                    return marginLeft - chart.spacing[3];
                }
            }
            // Last resort, a fraction of the available size
            return chart.chartWidth * 0.33;
        }
        /**
         * Render the axis labels and determine whether ellipsis or rotation need to
         * be applied.
         *
         * @private
         * @function Highcharts.Axis#renderUnsquish
         */
        renderUnsquish() {
            const chart = this.chart, renderer = chart.renderer, tickPositions = this.tickPositions, ticks = this.ticks, labelOptions = this.options.labels, labelStyleOptions = labelOptions.style, horiz = this.horiz, slotWidth = this.getSlotWidth(), innerWidth = Math.max(1, Math.round(slotWidth - 2 * labelOptions.padding)), attr = {}, labelMetrics = this.labelMetrics(), textOverflowOption = labelStyleOptions.textOverflow;
            let commonWidth, commonTextOverflow, maxLabelLength = 0, label, i, pos;
            // Set rotation option unless it is "auto", like in gauges
            if (!isString$6(labelOptions.rotation)) {
                // #4443
                attr.rotation = labelOptions.rotation || 0;
            }
            // Get the longest label length
            tickPositions.forEach(function (tickPosition) {
                const tick = ticks[tickPosition];
                // Replace label - sorting animation
                if (tick.movedLabel) {
                    tick.replaceMovedLabel();
                }
                if (tick &&
                    tick.label &&
                    tick.label.textPxLength > maxLabelLength) {
                    maxLabelLength = tick.label.textPxLength;
                }
            });
            this.maxLabelLength = maxLabelLength;
            // Handle auto rotation on horizontal axis
            if (this.autoRotation) {
                // Apply rotation only if the label is too wide for the slot, and
                // the label is wider than its height.
                if (maxLabelLength > innerWidth &&
                    maxLabelLength > labelMetrics.h) {
                    attr.rotation = this.labelRotation;
                }
                else {
                    this.labelRotation = 0;
                }
                // Handle word-wrap or ellipsis on vertical axis
            }
            else if (slotWidth) {
                // For word-wrap or ellipsis
                commonWidth = innerWidth;
                if (!textOverflowOption) {
                    commonTextOverflow = 'clip';
                    // On vertical axis, only allow word wrap if there is room
                    // for more lines.
                    i = tickPositions.length;
                    while (!horiz && i--) {
                        pos = tickPositions[i];
                        label = ticks[pos].label;
                        if (label) {
                            // Reset ellipsis in order to get the correct
                            // bounding box (#4070)
                            if (label.styles &&
                                label.styles.textOverflow === 'ellipsis') {
                                label.css({ textOverflow: 'clip' });
                                // Set the correct width in order to read
                                // the bounding box height (#4678, #5034)
                            }
                            else if (label.textPxLength > slotWidth) {
                                label.css({ width: slotWidth + 'px' });
                            }
                            if (label.getBBox().height > (this.len / tickPositions.length -
                                (labelMetrics.h - labelMetrics.f))) {
                                label.specificTextOverflow = 'ellipsis';
                            }
                        }
                    }
                }
            }
            // Add ellipsis if the label length is significantly longer than ideal
            if (attr.rotation) {
                commonWidth = (maxLabelLength > chart.chartHeight * 0.5 ?
                    chart.chartHeight * 0.33 :
                    maxLabelLength);
                if (!textOverflowOption) {
                    commonTextOverflow = 'ellipsis';
                }
            }
            // Set the explicit or automatic label alignment
            this.labelAlign = labelOptions.align ||
                this.autoLabelAlign(this.labelRotation);
            if (this.labelAlign) {
                attr.align = this.labelAlign;
            }
            // Apply general and specific CSS
            tickPositions.forEach(function (pos) {
                const tick = ticks[pos], label = tick && tick.label, widthOption = labelStyleOptions.width, css = {};
                if (label) {
                    // This needs to go before the CSS in old IE (#4502)
                    label.attr(attr);
                    if (tick.shortenLabel) {
                        tick.shortenLabel();
                    }
                    else if (commonWidth &&
                        !widthOption &&
                        // Setting width in this case messes with the bounding box
                        // (#7975)
                        labelStyleOptions.whiteSpace !== 'nowrap' &&
                        (
                        // Speed optimizing, #7656
                        commonWidth < label.textPxLength ||
                            // Resetting CSS, #4928
                            label.element.tagName === 'SPAN')) {
                        css.width = commonWidth + 'px';
                        if (!textOverflowOption) {
                            css.textOverflow = (label.specificTextOverflow ||
                                commonTextOverflow);
                        }
                        label.css(css);
                        // Reset previously shortened label (#8210)
                    }
                    else if (label.styles &&
                        label.styles.width &&
                        !css.width &&
                        !widthOption) {
                        label.css({ width: null });
                    }
                    delete label.specificTextOverflow;
                    tick.rotation = attr.rotation;
                }
            }, this);
            // Note: Why is this not part of getLabelPosition?
            this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);
        }
        /**
         * Return true if the axis has associated data.
         *
         * @function Highcharts.Axis#hasData
         *
         * @return {boolean}
         * True if the axis has associated visible series and those series have
         * either valid data points or explicit `min` and `max` settings.
         */
        hasData() {
            return this.series.some(function (s) {
                return s.hasData();
            }) ||
                (this.options.showEmpty &&
                    defined$8(this.min) &&
                    defined$8(this.max));
        }
        /**
         * Adds the title defined in axis.options.title.
         *
         * @function Highcharts.Axis#addTitle
         *
         * @param {boolean} [display]
         * Whether or not to display the title.
         */
        addTitle(display) {
            const axis = this, renderer = axis.chart.renderer, horiz = axis.horiz, opposite = axis.opposite, options = axis.options, axisTitleOptions = options.title, styledMode = axis.chart.styledMode;
            let textAlign;
            if (!axis.axisTitle) {
                textAlign = axisTitleOptions.textAlign;
                if (!textAlign) {
                    textAlign = (horiz ? {
                        low: 'left',
                        middle: 'center',
                        high: 'right'
                    } : {
                        low: opposite ? 'right' : 'left',
                        middle: 'center',
                        high: opposite ? 'left' : 'right'
                    })[axisTitleOptions.align];
                }
                axis.axisTitle = renderer
                    .text(axisTitleOptions.text || '', 0, 0, axisTitleOptions.useHTML)
                    .attr({
                    zIndex: 7,
                    rotation: axisTitleOptions.rotation,
                    align: textAlign
                })
                    .addClass('highcharts-axis-title');
                // #7814, don't mutate style option
                if (!styledMode) {
                    axis.axisTitle.css(merge$9(axisTitleOptions.style));
                }
                axis.axisTitle.add(axis.axisGroup);
                axis.axisTitle.isNew = true;
            }
            // Max width defaults to the length of the axis
            if (!styledMode &&
                !axisTitleOptions.style.width &&
                !axis.isRadial) {
                axis.axisTitle.css({
                    width: axis.len + 'px'
                });
            }
            // hide or show the title depending on whether showEmpty is set
            axis.axisTitle[display ? 'show' : 'hide'](display);
        }
        /**
         * Generates a tick for initial positioning.
         *
         * @private
         * @function Highcharts.Axis#generateTick
         *
         * @param {number} pos
         * The tick position in axis values.
         *
         * @param {number} [i]
         * The index of the tick in {@link Axis.tickPositions}.
         */
        generateTick(pos) {
            const axis = this, ticks = axis.ticks;
            if (!ticks[pos]) {
                ticks[pos] = new Tick(axis, pos);
            }
            else {
                ticks[pos].addLabel(); // update labels depending on tick interval
            }
        }
        /**
         * Render the tick labels to a preliminary position to get their sizes
         *
         * @private
         * @function Highcharts.Axis#getOffset
         *
         * @emits Highcharts.Axis#event:afterGetOffset
         */
        getOffset() {
            const axis = this, { chart, horiz, options, side, ticks, tickPositions, coll, axisParent // Used in color axis
             } = axis, renderer = chart.renderer, invertedSide = (chart.inverted && !axis.isZAxis ?
                [1, 0, 3, 2][side] :
                side), hasData = axis.hasData(), axisTitleOptions = options.title, labelOptions = options.labels, hasCrossing = isNumber$7(options.crossing), axisOffset = chart.axisOffset, clipOffset = chart.clipOffset, directionFactor = [-1, 1, 1, -1][side], className = options.className;
            let showAxis, titleOffset = 0, titleOffsetOption, titleMargin = 0, labelOffset = 0, // reset
            labelOffsetPadded, lineHeightCorrection;
            // For reuse in Axis.render
            axis.showAxis = showAxis = hasData || options.showEmpty;
            // Set/reset staggerLines
            axis.staggerLines = (axis.horiz && labelOptions.staggerLines) || void 0;
            // Create the axisGroup and gridGroup elements on first iteration
            if (!axis.axisGroup) {
                const createGroup = (name, suffix, zIndex) => renderer.g(name)
                    .attr({ zIndex })
                    .addClass(`highcharts-${coll.toLowerCase()}${suffix} ` +
                    (this.isRadial ? `highcharts-radial-axis${suffix} ` : '') +
                    (className || ''))
                    .add(axisParent);
                axis.gridGroup = createGroup('grid', '-grid', options.gridZIndex);
                axis.axisGroup = createGroup('axis', '', options.zIndex);
                axis.labelGroup = createGroup('axis-labels', '-labels', labelOptions.zIndex);
            }
            if (hasData || axis.isLinked) {
                // Generate ticks
                tickPositions.forEach(function (pos) {
                    // i is not used here, but may be used in overrides
                    axis.generateTick(pos);
                });
                axis.renderUnsquish();
                // Left side must be align: right and right side must
                // have align: left for labels
                axis.reserveSpaceDefault = (side === 0 ||
                    side === 2 ||
                    { 1: 'left', 3: 'right' }[side] === axis.labelAlign);
                if (pick$a(labelOptions.reserveSpace, hasCrossing ? false : null, axis.labelAlign === 'center' ? true : null, axis.reserveSpaceDefault)) {
                    tickPositions.forEach(function (pos) {
                        // get the highest offset
                        labelOffset = Math.max(ticks[pos].getLabelSize(), labelOffset);
                    });
                }
                if (axis.staggerLines) {
                    labelOffset *= axis.staggerLines;
                }
                axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);
            }
            else { // doesn't have data
                objectEach$7(ticks, function (tick, n) {
                    tick.destroy();
                    delete ticks[n];
                });
            }
            if (axisTitleOptions &&
                axisTitleOptions.text &&
                axisTitleOptions.enabled !== false) {
                axis.addTitle(showAxis);
                if (showAxis &&
                    !hasCrossing &&
                    axisTitleOptions.reserveSpace !== false) {
                    axis.titleOffset = titleOffset =
                        axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
                    titleOffsetOption = axisTitleOptions.offset;
                    titleMargin = defined$8(titleOffsetOption) ?
                        0 :
                        pick$a(axisTitleOptions.margin, horiz ? 5 : 10);
                }
            }
            // Render the axis line
            axis.renderLine();
            // handle automatic or user set offset
            axis.offset = directionFactor * pick$a(options.offset, axisOffset[side] ? axisOffset[side] + (options.margin || 0) : 0);
            axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar
            if (side === 0) {
                lineHeightCorrection = -axis.labelMetrics().h;
            }
            else if (side === 2) {
                lineHeightCorrection = axis.tickRotCorr.y;
            }
            else {
                lineHeightCorrection = 0;
            }
            // Find the padded label offset
            labelOffsetPadded = Math.abs(labelOffset) + titleMargin;
            if (labelOffset) {
                labelOffsetPadded -= lineHeightCorrection;
                labelOffsetPadded += directionFactor * (horiz ?
                    pick$a(labelOptions.y, axis.tickRotCorr.y +
                        directionFactor * labelOptions.distance) :
                    pick$a(labelOptions.x, directionFactor * labelOptions.distance));
            }
            axis.axisTitleMargin = pick$a(titleOffsetOption, labelOffsetPadded);
            if (axis.getMaxLabelDimensions) {
                axis.maxLabelDimensions = axis.getMaxLabelDimensions(ticks, tickPositions);
            }
            // Due to GridAxis.tickSize, tickSize should be calculated after ticks
            // has rendered.
            if (coll !== 'colorAxis') {
                const tickSize = this.tickSize('tick');
                axisOffset[side] = Math.max(axisOffset[side], (axis.axisTitleMargin || 0) + titleOffset +
                    directionFactor * axis.offset, labelOffsetPadded, // #3027
                tickPositions && tickPositions.length && tickSize ?
                    tickSize[0] + directionFactor * axis.offset :
                    0 // #4866
                );
                // Decide the clipping needed to keep the graph inside
                // the plot area and axis lines
                const clip = !axis.axisLine || options.offset ?
                    0 :
                    // #4308, #4371:
                    Math.floor(axis.axisLine.strokeWidth() / 2) * 2;
                clipOffset[invertedSide] =
                    Math.max(clipOffset[invertedSide], clip);
            }
            fireEvent$6(this, 'afterGetOffset');
        }
        /**
         * Internal function to get the path for the axis line. Extended for polar
         * charts.
         *
         * @function Highcharts.Axis#getLinePath
         *
         * @param {number} lineWidth
         * The line width in pixels.
         *
         * @return {Highcharts.SVGPathArray}
         * The SVG path definition in array form.
         */
        getLinePath(lineWidth) {
            const chart = this.chart, opposite = this.opposite, offset = this.offset, horiz = this.horiz, lineLeft = this.left + (opposite ? this.width : 0) + offset, lineTop = chart.chartHeight - this.bottom -
                (opposite ? this.height : 0) + offset;
            if (opposite) {
                lineWidth *= -1; // crispify the other way - #1480, #1687
            }
            return chart.renderer
                .crispLine([
                [
                    'M',
                    horiz ?
                        this.left :
                        lineLeft,
                    horiz ?
                        lineTop :
                        this.top
                ],
                [
                    'L',
                    horiz ?
                        chart.chartWidth - this.right :
                        lineLeft,
                    horiz ?
                        lineTop :
                        chart.chartHeight - this.bottom
                ]
            ], lineWidth);
        }
        /**
         * Render the axis line. Called internally when rendering and redrawing the
         * axis.
         *
         * @function Highcharts.Axis#renderLine
         */
        renderLine() {
            if (!this.axisLine) {
                this.axisLine = this.chart.renderer.path()
                    .addClass('highcharts-axis-line')
                    .add(this.axisGroup);
                if (!this.chart.styledMode) {
                    this.axisLine.attr({
                        stroke: this.options.lineColor,
                        'stroke-width': this.options.lineWidth,
                        zIndex: 7
                    });
                }
            }
        }
        /**
         * Position the axis title.
         *
         * @private
         * @function Highcharts.Axis#getTitlePosition
         *
         * @return {Highcharts.PositionObject}
         * X and Y positions for the title.
         */
        getTitlePosition(axisTitle) {
            // compute anchor points for each of the title align options
            const horiz = this.horiz, axisLeft = this.left, axisTop = this.top, axisLength = this.len, axisTitleOptions = this.options.title, margin = horiz ? axisLeft : axisTop, opposite = this.opposite, offset = this.offset, xOption = axisTitleOptions.x, yOption = axisTitleOptions.y, fontMetrics = this.chart.renderer.fontMetrics(axisTitle), 
            // The part of a multiline text that is below the baseline of the
            // first line. Subtract 1 to preserve pixel-perfectness from the
            // old behaviour (v5.0.12), where only one line was allowed.
            textHeightOvershoot = axisTitle ? Math.max(axisTitle.getBBox(false, 0).height - fontMetrics.h - 1, 0) : 0, 
            // the position in the length direction of the axis
            alongAxis = ({
                low: margin + (horiz ? 0 : axisLength),
                middle: margin + axisLength / 2,
                high: margin + (horiz ? axisLength : 0)
            })[axisTitleOptions.align], 
            // the position in the perpendicular direction of the axis
            offAxis = (horiz ? axisTop + this.height : axisLeft) +
                (horiz ? 1 : -1) * // horizontal axis reverses the margin
                    (opposite ? -1 : 1) * // so does opposite axes
                    (this.axisTitleMargin || 0) +
                [
                    -textHeightOvershoot,
                    textHeightOvershoot,
                    fontMetrics.f,
                    -textHeightOvershoot // left
                ][this.side], titlePosition = {
                x: horiz ?
                    alongAxis + xOption :
                    offAxis + (opposite ? this.width : 0) + offset + xOption,
                y: horiz ?
                    offAxis + yOption - (opposite ? this.height : 0) + offset :
                    alongAxis + yOption
            };
            fireEvent$6(this, 'afterGetTitlePosition', { titlePosition: titlePosition });
            return titlePosition;
        }
        /**
         * Render a minor tick into the given position. If a minor tick already
         * exists in this position, move it.
         *
         * @function Highcharts.Axis#renderMinorTick
         *
         * @param {number} pos
         * The position in axis values.
         *
         * @param {boolean} slideIn
         * Whether the tick should animate in from last computed position
         */
        renderMinorTick(pos, slideIn) {
            const axis = this;
            const minorTicks = axis.minorTicks;
            if (!minorTicks[pos]) {
                minorTicks[pos] = new Tick(axis, pos, 'minor');
            }
            // Render new ticks in old position
            if (slideIn && minorTicks[pos].isNew) {
                minorTicks[pos].render(null, true);
            }
            minorTicks[pos].render(null, false, 1);
        }
        /**
         * Render a major tick into the given position. If a tick already exists
         * in this position, move it.
         *
         * @function Highcharts.Axis#renderTick
         *
         * @param {number} pos
         * The position in axis values.
         *
         * @param {number} i
         * The tick index.
         *
         * @param {boolean} slideIn
         * Whether the tick should animate in from last computed position
         */
        renderTick(pos, i, slideIn) {
            const axis = this, isLinked = axis.isLinked, ticks = axis.ticks;
            // Linked axes need an extra check to find out if
            if (!isLinked ||
                (pos >= axis.min && pos <= axis.max) ||
                (axis.grid && axis.grid.isColumn)) {
                if (!ticks[pos]) {
                    ticks[pos] = new Tick(axis, pos);
                }
                // NOTE this seems like overkill. Could be handled in tick.render by
                // setting old position in attr, then set new position in animate.
                // render new ticks in old position
                if (slideIn && ticks[pos].isNew) {
                    // Start with negative opacity so that it is visible from
                    // halfway into the animation
                    ticks[pos].render(i, true, -1);
                }
                ticks[pos].render(i);
            }
        }
        /**
         * Render the axis.
         *
         * @private
         * @function Highcharts.Axis#render
         *
         * @emits Highcharts.Axis#event:afterRender
         */
        render() {
            const axis = this, chart = axis.chart, log = axis.logarithmic, renderer = chart.renderer, options = axis.options, isLinked = axis.isLinked, tickPositions = axis.tickPositions, axisTitle = axis.axisTitle, ticks = axis.ticks, minorTicks = axis.minorTicks, alternateBands = axis.alternateBands, stackLabelOptions = options.stackLabels, alternateGridColor = options.alternateGridColor, crossing = options.crossing, tickmarkOffset = axis.tickmarkOffset, axisLine = axis.axisLine, showAxis = axis.showAxis, animation = animObject$5(renderer.globalAnimation);
            let from, to;
            // Reset
            axis.labelEdge.length = 0;
            axis.overlap = false;
            // Mark all elements inActive before we go over and mark the active ones
            [ticks, minorTicks, alternateBands].forEach(function (coll) {
                objectEach$7(coll, function (tick) {
                    tick.isActive = false;
                });
            });
            // Crossing
            if (isNumber$7(crossing)) {
                const otherAxis = this.isXAxis ? chart.yAxis[0] : chart.xAxis[0], directionFactor = [1, -1, -1, 1][this.side];
                if (otherAxis) {
                    let px = otherAxis.toPixels(crossing, true);
                    if (axis.horiz) {
                        px = otherAxis.len - px;
                    }
                    axis.offset = directionFactor * px;
                }
            }
            // If the series has data draw the ticks. Else only the line and title
            if (axis.hasData() || isLinked) {
                const slideInTicks = axis.chart.hasRendered &&
                    axis.old && isNumber$7(axis.old.min);
                // minor ticks
                if (axis.minorTickInterval && !axis.categories) {
                    axis.getMinorTickPositions().forEach(function (pos) {
                        axis.renderMinorTick(pos, slideInTicks);
                    });
                }
                // Major ticks. Pull out the first item and render it last so that
                // we can get the position of the neighbour label. #808.
                if (tickPositions.length) { // #1300
                    tickPositions.forEach(function (pos, i) {
                        axis.renderTick(pos, i, slideInTicks);
                    });
                    // In a categorized axis, the tick marks are displayed
                    // between labels. So we need to add a tick mark and
                    // grid line at the left edge of the X axis.
                    if (tickmarkOffset && (axis.min === 0 || axis.single)) {
                        if (!ticks[-1]) {
                            ticks[-1] = new Tick(axis, -1, null, true);
                        }
                        ticks[-1].render(-1);
                    }
                }
                // alternate grid color
                if (alternateGridColor) {
                    tickPositions.forEach(function (pos, i) {
                        to = typeof tickPositions[i + 1] !== 'undefined' ?
                            tickPositions[i + 1] + tickmarkOffset :
                            axis.max - tickmarkOffset;
                        if (i % 2 === 0 &&
                            pos < axis.max &&
                            to <= axis.max + (chart.polar ?
                                -tickmarkOffset :
                                tickmarkOffset)) { // #2248, #4660
                            if (!alternateBands[pos]) {
                                // Should be imported from PlotLineOrBand.js, but
                                // the dependency cycle with axis is a problem
                                alternateBands[pos] = new H.PlotLineOrBand(axis);
                            }
                            from = pos + tickmarkOffset; // #949
                            alternateBands[pos].options = {
                                from: log ? log.lin2log(from) : from,
                                to: log ? log.lin2log(to) : to,
                                color: alternateGridColor,
                                className: 'highcharts-alternate-grid'
                            };
                            alternateBands[pos].render();
                            alternateBands[pos].isActive = true;
                        }
                    });
                }
                // custom plot lines and bands
                if (!axis._addedPlotLB) { // only first time
                    axis._addedPlotLB = true;
                    (options.plotLines || [])
                        .concat(options.plotBands || [])
                        .forEach(function (plotLineOptions) {
                        axis
                            .addPlotBandOrLine(plotLineOptions);
                    });
                }
            } // end if hasData
            // Remove inactive ticks
            [ticks, minorTicks, alternateBands].forEach(function (coll) {
                const forDestruction = [], delay = animation.duration, destroyInactiveItems = function () {
                    let i = forDestruction.length;
                    while (i--) {
                        // When resizing rapidly, the same items
                        // may be destroyed in different timeouts,
                        // or the may be reactivated
                        if (coll[forDestruction[i]] &&
                            !coll[forDestruction[i]].isActive) {
                            coll[forDestruction[i]].destroy();
                            delete coll[forDestruction[i]];
                        }
                    }
                };
                objectEach$7(coll, function (tick, pos) {
                    if (!tick.isActive) {
                        // Render to zero opacity
                        tick.render(pos, false, 0);
                        tick.isActive = false;
                        forDestruction.push(pos);
                    }
                });
                // When the objects are finished fading out, destroy them
                syncTimeout$4(destroyInactiveItems, coll === alternateBands ||
                    !chart.hasRendered ||
                    !delay ?
                    0 :
                    delay);
            });
            // Set the axis line path
            if (axisLine) {
                axisLine[axisLine.isPlaced ? 'animate' : 'attr']({
                    d: this.getLinePath(axisLine.strokeWidth())
                });
                axisLine.isPlaced = true;
                // Show or hide the line depending on options.showEmpty
                axisLine[showAxis ? 'show' : 'hide'](showAxis);
            }
            if (axisTitle && showAxis) {
                axisTitle[axisTitle.isNew ? 'attr' : 'animate'](axis.getTitlePosition(axisTitle));
                axisTitle.isNew = false;
            }
            // Stacked totals:
            if (stackLabelOptions && stackLabelOptions.enabled && axis.stacking) {
                axis.stacking.renderStackTotals();
            }
            // End stacked totals
            // Record old scaling for updating/animation
            axis.old = {
                len: axis.len,
                max: axis.max,
                min: axis.min,
                transA: axis.transA,
                userMax: axis.userMax,
                userMin: axis.userMin
            };
            axis.isDirty = false;
            fireEvent$6(this, 'afterRender');
        }
        /**
         * Redraw the axis to reflect changes in the data or axis extremes. Called
         * internally from Highcharts.Chart#redraw.
         *
         * @private
         * @function Highcharts.Axis#redraw
         */
        redraw() {
            if (this.visible) {
                // render the axis
                this.render();
                // move plot lines and bands
                this.plotLinesAndBands.forEach(function (plotLine) {
                    plotLine.render();
                });
            }
            // mark associated series as dirty and ready for redraw
            this.series.forEach(function (series) {
                series.isDirty = true;
            });
        }
        /**
         * Returns an array of axis properties, that should be untouched during
         * reinitialization.
         *
         * @private
         * @function Highcharts.Axis#getKeepProps
         */
        getKeepProps() {
            return (this.keepProps || Axis.keepProps);
        }
        /**
         * Destroys an Axis instance. See {@link Axis#remove} for the API endpoint
         * to fully remove the axis.
         *
         * @private
         * @function Highcharts.Axis#destroy
         *
         * @param {boolean} [keepEvents]
         * Whether to preserve events, used internally in Axis.update.
         */
        destroy(keepEvents) {
            const axis = this, plotLinesAndBands = axis.plotLinesAndBands, eventOptions = this.eventOptions;
            fireEvent$6(this, 'destroy', { keepEvents: keepEvents });
            // Remove the events
            if (!keepEvents) {
                removeEvent$4(axis);
            }
            // Destroy collections
            [axis.ticks, axis.minorTicks, axis.alternateBands].forEach(function (coll) {
                destroyObjectProperties$1(coll);
            });
            if (plotLinesAndBands) {
                let i = plotLinesAndBands.length;
                while (i--) { // #1975
                    plotLinesAndBands[i].destroy();
                }
            }
            // Destroy elements
            ['axisLine', 'axisTitle', 'axisGroup',
                'gridGroup', 'labelGroup', 'cross', 'scrollbar'].forEach(function (prop) {
                if (axis[prop]) {
                    axis[prop] = axis[prop].destroy();
                }
            });
            // Destroy each generated group for plotlines and plotbands
            for (const plotGroup in axis.plotLinesAndBandsGroups) { // eslint-disable-line guard-for-in
                axis.plotLinesAndBandsGroups[plotGroup] =
                    axis.plotLinesAndBandsGroups[plotGroup].destroy();
            }
            // Delete all properties and fall back to the prototype.
            objectEach$7(axis, function (val, key) {
                if (axis.getKeepProps().indexOf(key) === -1) {
                    delete axis[key];
                }
            });
            this.eventOptions = eventOptions;
        }
        /**
         * Internal function to draw a crosshair.
         *
         * @function Highcharts.Axis#drawCrosshair
         *
         * @param {Highcharts.PointerEventObject} [e]
         * The event arguments from the modified pointer event, extended with
         * `chartX` and `chartY`
         *
         * @param {Highcharts.Point} [point]
         * The Point object if the crosshair snaps to points.
         *
         * @emits Highcharts.Axis#event:afterDrawCrosshair
         * @emits Highcharts.Axis#event:drawCrosshair
         */
        drawCrosshair(e, point) {
            const options = this.crosshair, snap = pick$a(options && options.snap, true), chart = this.chart;
            let path, pos, categorized, graphic = this.cross, crossOptions;
            fireEvent$6(this, 'drawCrosshair', { e: e, point: point });
            // Use last available event when updating non-snapped crosshairs without
            // mouse interaction (#5287)
            if (!e) {
                e = this.cross && this.cross.e;
            }
            if (
            // Disabled in options
            !options ||
                // Snap
                ((defined$8(point) || !snap) === false)) {
                this.hideCrosshair();
            }
            else {
                // Get the path
                if (!snap) {
                    pos = e &&
                        (this.horiz ?
                            e.chartX - this.pos :
                            this.len - e.chartY + this.pos);
                }
                else if (defined$8(point)) {
                    // #3834
                    pos = pick$a(this.coll !== 'colorAxis' ?
                        point.crosshairPos : // 3D axis extension
                        null, this.isXAxis ?
                        point.plotX :
                        this.len - point.plotY);
                }
                if (defined$8(pos)) {
                    crossOptions = {
                        // value, only used on radial
                        value: point && (this.isXAxis ?
                            point.x :
                            pick$a(point.stackY, point.y)),
                        translatedValue: pos
                    };
                    if (chart.polar) {
                        // Additional information required for crosshairs in
                        // polar chart
                        extend$9(crossOptions, {
                            isCrosshair: true,
                            chartX: e && e.chartX,
                            chartY: e && e.chartY,
                            point: point
                        });
                    }
                    path = this.getPlotLinePath(crossOptions) ||
                        null; // #3189
                }
                if (!defined$8(path)) {
                    this.hideCrosshair();
                    return;
                }
                categorized = this.categories && !this.isRadial;
                // Draw the cross
                if (!graphic) {
                    this.cross = graphic = chart.renderer
                        .path()
                        .addClass('highcharts-crosshair highcharts-crosshair-' +
                        (categorized ? 'category ' : 'thin ') +
                        (options.className || ''))
                        .attr({
                        zIndex: pick$a(options.zIndex, 2)
                    })
                        .add();
                    // Presentational attributes
                    if (!chart.styledMode) {
                        graphic.attr({
                            stroke: options.color ||
                                (categorized ?
                                    Color
                                        .parse("#ccd3ff" /* Palette.highlightColor20 */)
                                        .setOpacity(0.25)
                                        .get() :
                                    "#cccccc" /* Palette.neutralColor20 */),
                            'stroke-width': pick$a(options.width, 1)
                        }).css({
                            'pointer-events': 'none'
                        });
                        if (options.dashStyle) {
                            graphic.attr({
                                dashstyle: options.dashStyle
                            });
                        }
                    }
                }
                graphic.show().attr({
                    d: path
                });
                if (categorized && !options.width) {
                    graphic.attr({
                        'stroke-width': this.transA
                    });
                }
                this.cross.e = e;
            }
            fireEvent$6(this, 'afterDrawCrosshair', { e: e, point: point });
        }
        /**
         * Hide the crosshair if visible.
         *
         * @function Highcharts.Axis#hideCrosshair
         */
        hideCrosshair() {
            if (this.cross) {
                this.cross.hide();
            }
            fireEvent$6(this, 'afterHideCrosshair');
        }
        /**
         * Check whether the chart has vertical panning ('y' or 'xy' type).
         *
         * @private
         * @function Highcharts.Axis#hasVerticalPanning
         */
        hasVerticalPanning() {
            const panningOptions = this.chart.options.chart.panning;
            return Boolean(panningOptions &&
                panningOptions.enabled && // #14624
                /y/.test(panningOptions.type));
        }
        /**
         * Update an axis object with a new set of options. The options are merged
         * with the existing options, so only new or altered options need to be
         * specified.
         *
         * @sample highcharts/members/axis-update/
         *         Axis update demo
         *
         * @function Highcharts.Axis#update
         *
         * @param {Highcharts.AxisOptions} options
         * The new options that will be merged in with existing options on the axis.
         *
         * @param {boolean} [redraw=true]
         * Whether to redraw the chart after the axis is altered. If doing more
         * operations on the chart, it is a good idea to set redraw to false and
         * call {@link Chart#redraw} after.
         */
        update(options, redraw) {
            const chart = this.chart;
            options = merge$9(this.userOptions, options);
            this.destroy(true);
            this.init(chart, options);
            chart.isDirtyBox = true;
            if (pick$a(redraw, true)) {
                chart.redraw();
            }
        }
        /**
         * Remove the axis from the chart.
         *
         * @sample highcharts/members/chart-addaxis/
         *         Add and remove axes
         *
         * @function Highcharts.Axis#remove
         *
         * @param {boolean} [redraw=true]
         * Whether to redraw the chart following the remove.
         */
        remove(redraw) {
            const chart = this.chart, coll = this.coll, axisSeries = this.series;
            let i = axisSeries.length;
            // Remove associated series (#2687)
            while (i--) {
                if (axisSeries[i]) {
                    axisSeries[i].remove(false);
                }
            }
            // Remove the axis
            erase$4(chart.axes, this);
            erase$4(chart[coll] || [], this);
            chart.orderItems(coll);
            this.destroy();
            chart.isDirtyBox = true;
            if (pick$a(redraw, true)) {
                chart.redraw();
            }
        }
        /**
         * Update the axis title by options after render time.
         *
         * @sample highcharts/members/axis-settitle/
         *         Set a new Y axis title
         *
         * @function Highcharts.Axis#setTitle
         *
         * @param {Highcharts.AxisTitleOptions} titleOptions
         * The additional title options.
         *
         * @param {boolean} [redraw=true]
         * Whether to redraw the chart after setting the title.
         */
        setTitle(titleOptions, redraw) {
            this.update({ title: titleOptions }, redraw);
        }
        /**
         * Set new axis categories and optionally redraw.
         *
         * @sample highcharts/members/axis-setcategories/
         *         Set categories by click on a button
         *
         * @function Highcharts.Axis#setCategories
         *
         * @param {Array<string>} categories
         * The new categories.
         *
         * @param {boolean} [redraw=true]
         * Whether to redraw the chart.
         */
        setCategories(categories, redraw) {
            this.update({ categories: categories }, redraw);
        }
    }
    /* *
     *
     *  Static Properties
     *
     * */
    Axis.defaultOptions = AxisDefaults$1.defaultXAxisOptions;
    // Properties to survive after destroy, needed for Axis.update (#4317,
    // #5773, #5881).
    Axis.keepProps = [
        'coll',
        'extKey',
        'hcEvents',
        'names',
        'series',
        'userMax',
        'userMin'
    ];

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    /* *
     *
     *  Namespace
     *
     * */
    var RendererRegistry;
    (function (RendererRegistry) {
        /* *
         *
         *  Constants
         *
         * */
        RendererRegistry.rendererTypes = {};
        /* *
         *
         *  Variables
         *
         * */
        let defaultRenderer;
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Gets a registered renderer class. If no renderer type is provided or the
         * requested renderer was not founded, the default renderer is returned.
         *
         * @param {string} [rendererType]
         * Renderer type or the default renderer.
         *
         * @return {Highcharts.Class<Highcharts.SVGRenderer>}
         * Returns the requested renderer class or the default renderer class.
         */
        function getRendererType(rendererType = defaultRenderer) {
            return (RendererRegistry.rendererTypes[rendererType] || RendererRegistry.rendererTypes[defaultRenderer]);
        }
        RendererRegistry.getRendererType = getRendererType;
        /**
         * Register a renderer class.
         *
         * @param {string} rendererType
         * Renderer type to register.
         *
         * @param {Highcharts.Class<Highcharts.SVGRenderer>} rendererClass
         * Returns the requested renderer class or the default renderer class.
         *
         * @param {boolean} setAsDefault
         * Sets the renderer class as the default renderer.
         */
        function registerRendererType(rendererType, rendererClass, setAsDefault) {
            RendererRegistry.rendererTypes[rendererType] = rendererClass;
            if (!defaultRenderer || setAsDefault) {
                defaultRenderer = rendererType;
                H.Renderer = rendererClass; // compatibility
            }
        }
        RendererRegistry.registerRendererType = registerRendererType;
    })(RendererRegistry || (RendererRegistry = {}));
    /* *
     *
     *  Default Export
     *
     * */
    var RendererRegistry$1 = RendererRegistry;

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { extend: extend$8, merge: merge$8, pick: pick$9 } = Utilities;
    /* *
     *
     *  Namespace
     *
     * */
    var LegendSymbol;
    (function (LegendSymbol) {
        /* *
        *
        *  Functions
        *
        * */
        /* eslint-disable valid-jsdoc */
        /**
         * Get the series' symbol in the legend.
         *
         * This method should be overridable to create custom symbols through
         * Highcharts.seriesTypes[type].prototype.drawLegendSymbol.
         *
         * @private
         * @function Highcharts.LegendSymbolMixin.lineMarker
         *
         * @param {Highcharts.Legend} legend
         * The legend object.
         */
        function lineMarker(legend, item) {
            const legendItem = this.legendItem = this.legendItem || {}, options = this.options, symbolWidth = legend.symbolWidth, symbolHeight = legend.symbolHeight, generalRadius = symbolHeight / 2, renderer = this.chart.renderer, legendItemGroup = legendItem.group, verticalCenter = legend.baseline -
                Math.round(legend.fontMetrics.b * 0.3);
            let attr = {}, legendSymbol, markerOptions = options.marker, lineSizer = 0;
            // Draw the line
            if (!this.chart.styledMode) {
                attr = {
                    'stroke-width': Math.min(options.lineWidth || 0, 24)
                };
                if (options.dashStyle) {
                    attr.dashstyle = options.dashStyle;
                }
                else if (options.linecap !== 'square') {
                    attr['stroke-linecap'] = 'round';
                }
            }
            legendItem.line = renderer
                .path()
                .addClass('highcharts-graph')
                .attr(attr)
                .add(legendItemGroup);
            if (attr['stroke-linecap']) {
                lineSizer = Math.min(legendItem.line.strokeWidth(), symbolWidth) / 2;
            }
            if (symbolWidth) {
                legendItem.line
                    .attr({
                    d: [
                        ['M', lineSizer, verticalCenter],
                        ['L', symbolWidth - lineSizer, verticalCenter]
                    ]
                });
            }
            // Draw the marker
            if (markerOptions && markerOptions.enabled !== false && symbolWidth) {
                // Do not allow the marker to be larger than the symbolHeight
                let radius = Math.min(pick$9(markerOptions.radius, generalRadius), generalRadius);
                // Restrict symbol markers size
                if (this.symbol.indexOf('url') === 0) {
                    markerOptions = merge$8(markerOptions, {
                        width: symbolHeight,
                        height: symbolHeight
                    });
                    radius = 0;
                }
                legendItem.symbol = legendSymbol = renderer
                    .symbol(this.symbol, (symbolWidth / 2) - radius, verticalCenter - radius, 2 * radius, 2 * radius, extend$8({ context: 'legend' }, markerOptions))
                    .addClass('highcharts-point')
                    .add(legendItemGroup);
                legendSymbol.isMarker = true;
            }
        }
        LegendSymbol.lineMarker = lineMarker;
        /**
         * Get the series' symbol in the legend.
         *
         * This method should be overridable to create custom symbols through
         * Highcharts.seriesTypes[type].prototype.drawLegendSymbol.
         *
         * @private
         * @function Highcharts.LegendSymbolMixin.rectangle
         *
         * @param {Highcharts.Legend} legend
         * The legend object
         *
         * @param {Highcharts.Point|Highcharts.Series} item
         * The series (this) or point
         */
        function rectangle(legend, item) {
            const legendItem = item.legendItem || {}, options = legend.options, symbolHeight = legend.symbolHeight, square = options.squareSymbol, symbolWidth = square ? symbolHeight : legend.symbolWidth;
            legendItem.symbol = this.chart.renderer
                .rect(square ? (legend.symbolWidth - symbolHeight) / 2 : 0, legend.baseline - symbolHeight + 1, // #3988
            symbolWidth, symbolHeight, pick$9(legend.options.symbolRadius, symbolHeight / 2))
                .addClass('highcharts-point')
                .attr({
                zIndex: 3
            })
                .add(legendItem.group);
        }
        LegendSymbol.rectangle = rectangle;
    })(LegendSymbol || (LegendSymbol = {}));
    /* *
     *
     *  Default Export
     *
     * */
    var LegendSymbol$1 = LegendSymbol;

    /* *
     *
     *  (c) 2010-2020 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { SVG_NS: SVG_NS$3, win: win$5 } = H;
    const { attr: attr$4, createElement: createElement$3, css: css$3, error: error$2, isFunction: isFunction$2, isString: isString$5, objectEach: objectEach$6, splat: splat$2 } = Utilities;
    const { trustedTypes } = win$5;
    /* *
     *
     *  Constants
     *
     * */
    // Create the trusted type policy. This should not be exposed.
    const trustedTypesPolicy = (trustedTypes &&
        isFunction$2(trustedTypes.createPolicy) &&
        trustedTypes.createPolicy('highcharts', {
            createHTML: (s) => s
        }));
    const emptyHTML = trustedTypesPolicy ?
        trustedTypesPolicy.createHTML('') :
        '';
    // IE9 and PhantomJS are only able to parse XML.
    const hasValidDOMParser = (function () {
        try {
            return Boolean(new DOMParser().parseFromString(emptyHTML, 'text/html'));
        }
        catch (e) {
            return false;
        }
    }());
    /* *
     *
     *  Class
     *
     * */
    /**
     * The AST class represents an abstract syntax tree of HTML or SVG content. It
     * can take HTML as an argument, parse it, optionally transform it to SVG, then
     * perform sanitation before inserting it into the DOM.
     *
     * @class
     * @name Highcharts.AST
     *
     * @param {string|Array<Highcharts.ASTNode>} source
     * Either an HTML string or an ASTNode list to populate the tree.
     */
    class AST {
        /* *
         *
         *  Static Functions
         *
         * */
        /**
         * Filter an object of SVG or HTML attributes against the allow list.
         *
         * @static
         *
         * @function Highcharts.AST#filterUserAttributes
         *
         * @param {Highcharts.SVGAttributes} attributes The attributes to filter
         *
         * @return {Highcharts.SVGAttributes}
         * The filtered attributes
         */
        static filterUserAttributes(attributes) {
            objectEach$6(attributes, (val, key) => {
                let valid = true;
                if (AST.allowedAttributes.indexOf(key) === -1) {
                    valid = false;
                }
                if (['background', 'dynsrc', 'href', 'lowsrc', 'src']
                    .indexOf(key) !== -1) {
                    valid = isString$5(val) && AST.allowedReferences.some((ref) => val.indexOf(ref) === 0);
                }
                if (!valid) {
                    error$2(33, false, void 0, {
                        'Invalid attribute in config': `${key}`
                    });
                    delete attributes[key];
                }
                // #17753, < is not allowed in SVG attributes
                if (isString$5(val) && attributes[key]) {
                    attributes[key] = val.replace(/</g, '&lt;');
                }
            });
            return attributes;
        }
        static parseStyle(style) {
            return style
                .split(';')
                .reduce((styles, line) => {
                const pair = line.split(':').map((s) => s.trim()), key = pair.shift();
                if (key && pair.length) {
                    styles[key.replace(/-([a-z])/g, (g) => g[1].toUpperCase())] = pair.join(':'); // #17146
                }
                return styles;
            }, {});
        }
        /**
         * Utility function to set html content for an element by passing in a
         * markup string. The markup is safely parsed by the AST class to avoid
         * XSS vulnerabilities. This function should be used instead of setting
         * `innerHTML` in all cases where the content is not fully trusted.
         *
         * @static
         * @function Highcharts.AST#setElementHTML
         *
         * @param {SVGDOMElement|HTMLDOMElement} el
         * Node to set content of.
         *
         * @param {string} html
         * Markup string
         */
        static setElementHTML(el, html) {
            el.innerHTML = AST.emptyHTML; // Clear previous
            if (html) {
                const ast = new AST(html);
                ast.addToDOM(el);
            }
        }
        /* *
         *
         *  Constructor
         *
         * */
        // Construct an AST from HTML markup, or wrap an array of existing AST nodes
        constructor(source) {
            this.nodes = typeof source === 'string' ?
                this.parseMarkup(source) : source;
        }
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Add the tree defined as a hierarchical JS structure to the DOM
         *
         * @function Highcharts.AST#addToDOM
         *
         * @param {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement} parent
         * The node where it should be added
         *
         * @return {Highcharts.HTMLDOMElement|Highcharts.SVGDOMElement}
         * The inserted node.
         */
        addToDOM(parent) {
            /**
             * @private
             * @param {Highcharts.ASTNode} subtree
             * HTML/SVG definition
             * @param {Element} [subParent]
             * parent node
             * @return {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement}
             * The inserted node.
             */
            function recurse(subtree, subParent) {
                let ret;
                splat$2(subtree).forEach(function (item) {
                    const tagName = item.tagName;
                    const textNode = item.textContent ?
                        H.doc.createTextNode(item.textContent) :
                        void 0;
                    // Whether to ignore the AST filtering totally, #15345
                    const bypassHTMLFiltering = AST.bypassHTMLFiltering;
                    let node;
                    if (tagName) {
                        if (tagName === '#text') {
                            node = textNode;
                        }
                        else if (AST.allowedTags.indexOf(tagName) !== -1 ||
                            bypassHTMLFiltering) {
                            const NS = tagName === 'svg' ?
                                SVG_NS$3 :
                                (subParent.namespaceURI || SVG_NS$3);
                            const element = H.doc.createElementNS(NS, tagName);
                            const attributes = item.attributes || {};
                            // Apply attributes from root of AST node, legacy from
                            // from before TextBuilder
                            objectEach$6(item, function (val, key) {
                                if (key !== 'tagName' &&
                                    key !== 'attributes' &&
                                    key !== 'children' &&
                                    key !== 'style' &&
                                    key !== 'textContent') {
                                    attributes[key] = val;
                                }
                            });
                            attr$4(element, bypassHTMLFiltering ?
                                attributes :
                                AST.filterUserAttributes(attributes));
                            if (item.style) {
                                css$3(element, item.style);
                            }
                            // Add text content
                            if (textNode) {
                                element.appendChild(textNode);
                            }
                            // Recurse
                            recurse(item.children || [], element);
                            node = element;
                        }
                        else {
                            error$2(33, false, void 0, {
                                'Invalid tagName in config': tagName
                            });
                        }
                    }
                    // Add to the tree
                    if (node) {
                        subParent.appendChild(node);
                    }
                    ret = node;
                });
                // Return last node added (on top level it's the only one)
                return ret;
            }
            return recurse(this.nodes, parent);
        }
        /**
         * Parse HTML/SVG markup into AST Node objects. Used internally from the
         * constructor.
         *
         * @private
         *
         * @function Highcharts.AST#getNodesFromMarkup
         *
         * @param {string} markup The markup string.
         *
         * @return {Array<Highcharts.ASTNode>} The parsed nodes.
         */
        parseMarkup(markup) {
            const nodes = [];
            markup = markup
                .trim()
                // The style attribute throws a warning when parsing when CSP is
                // enabled (#6884), so use an alias and pick it up below
                // Make all quotation marks parse correctly to DOM (#17627)
                .replace(/ style=(["'])/g, ' data-style=$1');
            let doc;
            if (hasValidDOMParser) {
                doc = new DOMParser().parseFromString(trustedTypesPolicy ?
                    trustedTypesPolicy.createHTML(markup) :
                    markup, 'text/html');
            }
            else {
                const body = createElement$3('div');
                body.innerHTML = markup;
                doc = { body };
            }
            const appendChildNodes = (node, addTo) => {
                const tagName = node.nodeName.toLowerCase();
                // Add allowed tags
                const astNode = {
                    tagName
                };
                if (tagName === '#text') {
                    astNode.textContent = node.textContent || '';
                }
                const parsedAttributes = node.attributes;
                // Add attributes
                if (parsedAttributes) {
                    const attributes = {};
                    [].forEach.call(parsedAttributes, (attrib) => {
                        if (attrib.name === 'data-style') {
                            astNode.style = AST.parseStyle(attrib.value);
                        }
                        else {
                            attributes[attrib.name] = attrib.value;
                        }
                    });
                    astNode.attributes = attributes;
                }
                // Handle children
                if (node.childNodes.length) {
                    const children = [];
                    [].forEach.call(node.childNodes, (childNode) => {
                        appendChildNodes(childNode, children);
                    });
                    if (children.length) {
                        astNode.children = children;
                    }
                }
                addTo.push(astNode);
            };
            [].forEach.call(doc.body.childNodes, (childNode) => appendChildNodes(childNode, nodes));
            return nodes;
        }
    }
    /* *
     *
     *  Static Properties
     *
     * */
    /**
     * The list of allowed SVG or HTML attributes, used for sanitizing
     * potentially harmful content from the chart configuration before adding to
     * the DOM.
     *
     * @see [Source code with default values](
     * https://github.com/highcharts/highcharts/blob/master/ts/Core/Renderer/HTML/AST.ts#:~:text=public%20static%20allowedAttributes)
     *
     * @example
     * // Allow a custom, trusted attribute
     * Highcharts.AST.allowedAttributes.push('data-value');
     *
     * @name Highcharts.AST.allowedAttributes
     * @type {Array<string>}
     */
    AST.allowedAttributes = [
        'alt',
        'aria-controls',
        'aria-describedby',
        'aria-expanded',
        'aria-haspopup',
        'aria-hidden',
        'aria-label',
        'aria-labelledby',
        'aria-live',
        'aria-pressed',
        'aria-readonly',
        'aria-roledescription',
        'aria-selected',
        'class',
        'clip-path',
        'color',
        'colspan',
        'cx',
        'cy',
        'd',
        'dx',
        'dy',
        'disabled',
        'fill',
        'flood-color',
        'flood-opacity',
        'height',
        'href',
        'id',
        'in',
        'markerHeight',
        'markerWidth',
        'offset',
        'opacity',
        'orient',
        'padding',
        'paddingLeft',
        'paddingRight',
        'patternUnits',
        'r',
        'refX',
        'refY',
        'role',
        'scope',
        'slope',
        'src',
        'startOffset',
        'stdDeviation',
        'stroke',
        'stroke-linecap',
        'stroke-width',
        'style',
        'tableValues',
        'result',
        'rowspan',
        'summary',
        'target',
        'tabindex',
        'text-align',
        'text-anchor',
        'textAnchor',
        'textLength',
        'title',
        'type',
        'valign',
        'width',
        'x',
        'x1',
        'x2',
        'xlink:href',
        'y',
        'y1',
        'y2',
        'zIndex'
    ];
    /**
     * The list of allowed references for referring attributes like `href` and
     * `src`. Attribute values will only be allowed if they start with one of
     * these strings.
     *
     * @see [Source code with default values](
     * https://github.com/highcharts/highcharts/blob/master/ts/Core/Renderer/HTML/AST.ts#:~:text=public%20static%20allowedReferences)
     *
     * @example
     * // Allow tel:
     * Highcharts.AST.allowedReferences.push('tel:');
     *
     * @name    Highcharts.AST.allowedReferences
     * @type    {Array<string>}
     */
    AST.allowedReferences = [
        'https://',
        'http://',
        'mailto:',
        '/',
        '../',
        './',
        '#'
    ];
    /**
     * The list of allowed SVG or HTML tags, used for sanitizing potentially
     * harmful content from the chart configuration before adding to the DOM.
     *
     * @see [Source code with default values](
     * https://github.com/highcharts/highcharts/blob/master/ts/Core/Renderer/HTML/AST.ts#:~:text=public%20static%20allowedTags)
     *
     * @example
     * // Allow a custom, trusted tag
     * Highcharts.AST.allowedTags.push('blink'); // ;)
     *
     * @name    Highcharts.AST.allowedTags
     * @type    {Array<string>}
     */
    AST.allowedTags = [
        'a',
        'abbr',
        'b',
        'br',
        'button',
        'caption',
        'circle',
        'clipPath',
        'code',
        'dd',
        'defs',
        'div',
        'dl',
        'dt',
        'em',
        'feComponentTransfer',
        'feDropShadow',
        'feFuncA',
        'feFuncB',
        'feFuncG',
        'feFuncR',
        'feGaussianBlur',
        'feOffset',
        'feMerge',
        'feMergeNode',
        'filter',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'hr',
        'i',
        'img',
        'li',
        'linearGradient',
        'marker',
        'ol',
        'p',
        'path',
        'pattern',
        'pre',
        'rect',
        'small',
        'span',
        'stop',
        'strong',
        'style',
        'sub',
        'sup',
        'svg',
        'table',
        'text',
        'textPath',
        'thead',
        'title',
        'tbody',
        'tspan',
        'td',
        'th',
        'tr',
        'u',
        'ul',
        '#text'
    ];
    AST.emptyHTML = emptyHTML;
    /**
     * Allow all custom SVG and HTML attributes, references and tags (together
     * with potentially harmful ones) to be added to the DOM from the chart
     * configuration. In other words, disable the the allow-listing which is the
     * primary functionality of the AST.
     *
     * WARNING: Setting this property to `true` while allowing untrusted user
     * data in the chart configuration will expose your application to XSS
     * security risks!
     *
     * Note that in case you want to allow a known set of tags or attributes,
     * you should allow-list them instead of disabling the filtering totally.
     * See [allowedAttributes](Highcharts.AST#.allowedAttributes),
     * [allowedReferences](Highcharts.AST#.allowedReferences) and
     * [allowedTags](Highcharts.AST#.allowedTags). The `bypassHTMLFiltering`
     * setting is intended only for those cases where allow-listing is not
     * practical, and the chart configuration already comes from a secure
     * source.
     *
     * @example
     * // Allow all custom attributes, references and tags (disable DOM XSS
     * // filtering)
     * Highcharts.AST.bypassHTMLFiltering = true;
     *
     * @name Highcharts.AST.bypassHTMLFiltering
     * @static
     */
    AST.bypassHTMLFiltering = false;

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { animObject: animObject$4 } = animationExports;
    const { defaultOptions: defaultOptions$3 } = DefaultOptions;
    const { format } = Templating;
    const { addEvent: addEvent$4, defined: defined$7, erase: erase$3, extend: extend$7, fireEvent: fireEvent$5, getNestedProperty: getNestedProperty$1, isArray: isArray$5, isFunction: isFunction$1, isNumber: isNumber$6, isObject: isObject$3, merge: merge$7, objectEach: objectEach$5, pick: pick$8, syncTimeout: syncTimeout$3, removeEvent: removeEvent$3, uniqueKey: uniqueKey$3 } = Utilities;
    /* eslint-disable no-invalid-this, valid-jsdoc */
    /* *
     *
     *  Class
     *
     * */
    /**
     * The Point object. The point objects are generated from the `series.data`
     * configuration objects or raw numbers. They can be accessed from the
     * `Series.points` array. Other ways to instantiate points are through {@link
     * Highcharts.Series#addPoint} or {@link Highcharts.Series#setData}.
     *
     * @class
     * @name Highcharts.Point
     */
    class Point {
        constructor() {
            /* *
             *
             *  Properties
             *
             * */
            /**
             * For categorized axes this property holds the category name for the
             * point. For other axes it holds the X value.
             *
             * @name Highcharts.Point#category
             * @type {number|string}
             */
            this.category = void 0;
            this.destroyed = false;
            this.formatPrefix = 'point';
            this.id = void 0;
            this.isNull = false;
            /**
             * The name of the point. The name can be given as the first position of the
             * point configuration array, or as a `name` property in the configuration:
             *
             * @example
             * // Array config
             * data: [
             *     ['John', 1],
             *     ['Jane', 2]
             * ]
             *
             * // Object config
             * data: [{
             *        name: 'John',
             *        y: 1
             * }, {
             *     name: 'Jane',
             *     y: 2
             * }]
             *
             * @name Highcharts.Point#name
             * @type {string}
             */
            this.name = void 0;
            /**
             * The point's options as applied in the initial configuration, or
             * extended through `Point.update`.
             *
             * In TypeScript you have to extend `PointOptionsObject` via an
             * additional interface to allow custom data options:
             *
             * ```
             * declare interface PointOptionsObject {
             *     customProperty: string;
             * }
             * ```
             *
             * @name Highcharts.Point#options
             * @type {Highcharts.PointOptionsObject}
             */
            this.options = void 0;
            /**
             * The percentage for points in a stacked series, pies or gauges.
             *
             * @name Highcharts.Point#percentage
             * @type {number|undefined}
             */
            this.percentage = void 0;
            this.selected = false;
            /**
             * The series object associated with the point.
             *
             * @name Highcharts.Point#series
             * @type {Highcharts.Series}
             */
            this.series = void 0;
            /**
             * The attributes of the rendered SVG shape like in `column` or `pie`
             * series.
             *
             * @readonly
             * @name Highcharts.Point#shapeArgs
             * @type {Readonly<Highcharts.SVGAttributes>|undefined}
             */
            this.shapeArgs = void 0;
            /**
             * The total of values in either a stack for stacked series, or a pie in a
             * pie series.
             *
             * @name Highcharts.Point#total
             * @type {number|undefined}
             */
            this.total = void 0;
            /**
             * For certain series types, like pie charts, where individual points can
             * be shown or hidden.
             *
             * @name Highcharts.Point#visible
             * @type {boolean}
             * @default true
             */
            this.visible = true;
            this.x = void 0;
        }
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Animate SVG elements associated with the point.
         *
         * @private
         * @function Highcharts.Point#animateBeforeDestroy
         */
        animateBeforeDestroy() {
            const point = this, animateParams = { x: point.startXPos, opacity: 0 }, graphicalProps = point.getGraphicalProps();
            graphicalProps.singular.forEach(function (prop) {
                const isDataLabel = prop === 'dataLabel';
                point[prop] = point[prop].animate(isDataLabel ? {
                    x: point[prop].startXPos,
                    y: point[prop].startYPos,
                    opacity: 0
                } : animateParams);
            });
            graphicalProps.plural.forEach(function (plural) {
                point[plural].forEach(function (item) {
                    if (item.element) {
                        item.animate(extend$7({ x: point.startXPos }, (item.startYPos ? {
                            x: item.startXPos,
                            y: item.startYPos
                        } : {})));
                    }
                });
            });
        }
        /**
         * Apply the options containing the x and y data and possible some extra
         * properties. Called on point init or from point.update.
         *
         * @private
         * @function Highcharts.Point#applyOptions
         *
         * @param {Highcharts.PointOptionsType} options
         *        The point options as defined in series.data.
         *
         * @param {number} [x]
         *        Optionally, the x value.
         *
         * @return {Highcharts.Point}
         *         The Point instance.
         */
        applyOptions(options, x) {
            const point = this, series = point.series, pointValKey = series.options.pointValKey || series.pointValKey;
            options = Point.prototype.optionsToObject.call(this, options);
            // copy options directly to point
            extend$7(point, options);
            point.options = point.options ?
                extend$7(point.options, options) :
                options;
            // Since options are copied into the Point instance, some accidental
            // options must be shielded (#5681)
            if (options.group) {
                delete point.group;
            }
            if (options.dataLabels) {
                delete point.dataLabels;
            }
            /**
             * The y value of the point.
             * @name Highcharts.Point#y
             * @type {number|undefined}
             */
            // For higher dimension series types. For instance, for ranges, point.y
            // is mapped to point.low.
            if (pointValKey) {
                point.y = Point.prototype.getNestedProperty.call(point, pointValKey);
            }
            point.isNull = this.isValid && !this.isValid();
            point.formatPrefix = point.isNull ? 'null' : 'point'; // #9233, #10874
            // The point is initially selected by options (#5777)
            if (point.selected) {
                point.state = 'select';
            }
            /**
             * The x value of the point.
             * @name Highcharts.Point#x
             * @type {number}
             */
            // If no x is set by now, get auto incremented value. All points must
            // have an x value, however the y value can be null to create a gap in
            // the series
            if ('name' in point &&
                typeof x === 'undefined' &&
                series.xAxis &&
                series.xAxis.hasNames) {
                point.x = series.xAxis.nameToX(point);
            }
            if (typeof point.x === 'undefined' && series) {
                if (typeof x === 'undefined') {
                    point.x = series.autoIncrement();
                }
                else {
                    point.x = x;
                }
            }
            else if (isNumber$6(options.x) && series.options.relativeXValue) {
                point.x = series.autoIncrement(options.x);
            }
            return point;
        }
        /**
         * Destroy a point to clear memory. Its reference still stays in
         * `series.data`.
         *
         * @private
         * @function Highcharts.Point#destroy
         */
        destroy() {
            if (!this.destroyed) {
                const point = this, series = point.series, chart = series.chart, dataSorting = series.options.dataSorting, hoverPoints = chart.hoverPoints, globalAnimation = point.series.chart.renderer.globalAnimation, animation = animObject$4(globalAnimation);
                /**
                 * Allow to call after animation.
                 * @private
                 */
                const destroyPoint = () => {
                    // Remove all events and elements
                    if (point.graphic ||
                        point.graphics ||
                        point.dataLabel ||
                        point.dataLabels) {
                        removeEvent$3(point);
                        point.destroyElements();
                    }
                    for (const prop in point) { // eslint-disable-line guard-for-in
                        delete point[prop];
                    }
                };
                if (point.legendItem) {
                    // pies have legend items
                    chart.legend.destroyItem(point);
                }
                if (hoverPoints) {
                    point.setState();
                    erase$3(hoverPoints, point);
                    if (!hoverPoints.length) {
                        chart.hoverPoints = null;
                    }
                }
                if (point === chart.hoverPoint) {
                    point.onMouseOut();
                }
                // Remove properties after animation
                if (!dataSorting || !dataSorting.enabled) {
                    destroyPoint();
                }
                else {
                    this.animateBeforeDestroy();
                    syncTimeout$3(destroyPoint, animation.duration);
                }
                chart.pointCount--;
            }
            this.destroyed = true;
        }
        /**
         * Destroy SVG elements associated with the point.
         *
         * @private
         * @function Highcharts.Point#destroyElements
         * @param {Highcharts.Dictionary<number>} [kinds]
         */
        destroyElements(kinds) {
            const point = this, props = point.getGraphicalProps(kinds);
            props.singular.forEach(function (prop) {
                point[prop] = point[prop].destroy();
            });
            props.plural.forEach(function (plural) {
                point[plural].forEach(function (item) {
                    if (item && item.element) {
                        item.destroy();
                    }
                });
                delete point[plural];
            });
        }
        /**
         * Fire an event on the Point object.
         *
         * @private
         * @function Highcharts.Point#firePointEvent
         *
         * @param {string} eventType
         *        Type of the event.
         *
         * @param {Highcharts.Dictionary<any>|Event} [eventArgs]
         *        Additional event arguments.
         *
         * @param {Highcharts.EventCallbackFunction<Highcharts.Point>|Function} [defaultFunction]
         *        Default event handler.
         *
         * @emits Highcharts.Point#event:*
         */
        firePointEvent(eventType, eventArgs, defaultFunction) {
            const point = this, series = this.series, seriesOptions = series.options;
            // load event handlers on demand to save time on mouseover/out
            if (seriesOptions.point.events[eventType] ||
                (point.options &&
                    point.options.events &&
                    point.options.events[eventType])) {
                point.importEvents();
            }
            // add default handler if in selection mode
            if (eventType === 'click' && seriesOptions.allowPointSelect) {
                defaultFunction = function (event) {
                    // Control key is for Windows, meta (= Cmd key) for Mac, Shift
                    // for Opera.
                    if (point.select) { // #2911
                        point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
                    }
                };
            }
            fireEvent$5(point, eventType, eventArgs, defaultFunction);
        }
        /**
         * Get the CSS class names for individual points. Used internally where the
         * returned value is set on every point.
         *
         * @function Highcharts.Point#getClassName
         *
         * @return {string}
         *         The class names.
         */
        getClassName() {
            const point = this;
            return 'highcharts-point' +
                (point.selected ? ' highcharts-point-select' : '') +
                (point.negative ? ' highcharts-negative' : '') +
                (point.isNull ? ' highcharts-null-point' : '') +
                (typeof point.colorIndex !== 'undefined' ?
                    ' highcharts-color-' + point.colorIndex : '') +
                (point.options.className ? ' ' + point.options.className : '') +
                (point.zone && point.zone.className ? ' ' +
                    point.zone.className.replace('highcharts-negative', '') : '');
        }
        /**
         * Get props of all existing graphical point elements.
         *
         * @private
         * @function Highcharts.Point#getGraphicalProps
         */
        getGraphicalProps(kinds) {
            const point = this, props = [], graphicalProps = { singular: [], plural: [] };
            let prop, i;
            kinds = kinds || { graphic: 1, dataLabel: 1 };
            if (kinds.graphic) {
                props.push('graphic');
            }
            if (kinds.dataLabel) {
                props.push('dataLabel', 'dataLabelPath', 'dataLabelUpper', 'connector');
            }
            i = props.length;
            while (i--) {
                prop = props[i];
                if (point[prop]) {
                    graphicalProps.singular.push(prop);
                }
            }
            [
                'graphic',
                'dataLabel',
                'connector'
            ].forEach(function (prop) {
                const plural = prop + 's';
                if (kinds[prop] && point[plural]) {
                    graphicalProps.plural.push(plural);
                }
            });
            return graphicalProps;
        }
        /**
         * Return the configuration hash needed for the data label and tooltip
         * formatters.
         *
         * @function Highcharts.Point#getLabelConfig
         *
         * @return {Highcharts.PointLabelObject}
         *         Abstract object used in formatters and formats.
         */
        getLabelConfig() {
            return {
                x: this.category,
                y: this.y,
                color: this.color,
                colorIndex: this.colorIndex,
                key: this.name || this.category,
                series: this.series,
                point: this,
                percentage: this.percentage,
                total: this.total || this.stackTotal
            };
        }
        /**
         * Returns the value of the point property for a given value.
         * @private
         */
        getNestedProperty(key) {
            if (!key) {
                return;
            }
            if (key.indexOf('custom.') === 0) {
                return getNestedProperty$1(key, this.options);
            }
            return this[key];
        }
        /**
         * In a series with `zones`, return the zone that the point belongs to.
         *
         * @function Highcharts.Point#getZone
         *
         * @return {Highcharts.SeriesZonesOptionsObject}
         *         The zone item.
         */
        getZone() {
            const series = this.series, zones = series.zones, zoneAxis = series.zoneAxis || 'y';
            let zone, i = 0;
            zone = zones[i];
            while (this[zoneAxis] >= zone.value) {
                zone = zones[++i];
            }
            // For resetting or reusing the point (#8100)
            if (!this.nonZonedColor) {
                this.nonZonedColor = this.color;
            }
            if (zone && zone.color && !this.options.color) {
                this.color = zone.color;
            }
            else {
                this.color = this.nonZonedColor;
            }
            return zone;
        }
        /**
         * Utility to check if point has new shape type. Used in column series and
         * all others that are based on column series.
         * @private
         */
        hasNewShapeType() {
            const point = this;
            const oldShapeType = point.graphic &&
                (point.graphic.symbolName || point.graphic.element.nodeName);
            return oldShapeType !== this.shapeType;
        }
        /**
         * Initialize the point. Called internally based on the `series.data`
         * option.
         *
         * @function Highcharts.Point#init
         *
         * @param {Highcharts.Series} series
         *        The series object containing this point.
         *
         * @param {Highcharts.PointOptionsType} options
         *        The data in either number, array or object format.
         *
         * @param {number} [x]
         *        Optionally, the X value of the point.
         *
         * @return {Highcharts.Point}
         *         The Point instance.
         *
         * @emits Highcharts.Point#event:afterInit
         */
        init(series, options, x) {
            this.series = series;
            this.applyOptions(options, x);
            // Add a unique ID to the point if none is assigned
            this.id = defined$7(this.id) ? this.id : uniqueKey$3();
            this.resolveColor();
            series.chart.pointCount++;
            fireEvent$5(this, 'afterInit');
            return this;
        }
        /**
         * Determine if point is valid.
         * @private
         * @function Highcharts.Point#isValid
         */
        isValid() {
            return this.x !== null && isNumber$6(this.y);
        }
        /**
         * Transform number or array configs into objects. Also called for object
         * configs. Used internally to unify the different configuration formats for
         * points. For example, a simple number `10` in a line series will be
         * transformed to `{ y: 10 }`, and an array config like `[1, 10]` in a
         * scatter series will be transformed to `{ x: 1, y: 10 }`.
         *
         * @deprecated
         * @function Highcharts.Point#optionsToObject
         *
         * @param {Highcharts.PointOptionsType} options
         * Series data options.
         *
         * @return {Highcharts.Dictionary<*>}
         * Transformed point options.
         */
        optionsToObject(options) {
            const series = this.series, keys = series.options.keys, pointArrayMap = keys || series.pointArrayMap || ['y'], valueCount = pointArrayMap.length;
            let ret = {}, firstItemType, i = 0, j = 0;
            if (isNumber$6(options) || options === null) {
                ret[pointArrayMap[0]] = options;
            }
            else if (isArray$5(options)) {
                // with leading x value
                if (!keys && options.length > valueCount) {
                    firstItemType = typeof options[0];
                    if (firstItemType === 'string') {
                        ret.name = options[0];
                    }
                    else if (firstItemType === 'number') {
                        ret.x = options[0];
                    }
                    i++;
                }
                while (j < valueCount) {
                    // Skip undefined positions for keys
                    if (!keys || typeof options[i] !== 'undefined') {
                        if (pointArrayMap[j].indexOf('.') > 0) {
                            // Handle nested keys, e.g. ['color.pattern.image']
                            // Avoid function call unless necessary.
                            Point.prototype.setNestedProperty(ret, options[i], pointArrayMap[j]);
                        }
                        else {
                            ret[pointArrayMap[j]] = options[i];
                        }
                    }
                    i++;
                    j++;
                }
            }
            else if (typeof options === 'object') {
                ret = options;
                // This is the fastest way to detect if there are individual point
                // dataLabels that need to be considered in drawDataLabels. These
                // can only occur in object configs.
                if (options.dataLabels) {
                    series._hasPointLabels = true;
                }
                // Same approach as above for markers
                if (options.marker) {
                    series._hasPointMarkers = true;
                }
            }
            return ret;
        }
        /**
         * Get the pixel position of the point relative to the plot area.
         * @private
         * @function Highcharts.Point#pos
         */
        pos(chartCoordinates, plotY = this.plotY) {
            if (!this.destroyed) {
                const { plotX, series } = this, { chart, xAxis, yAxis } = series;
                let posX = 0, posY = 0;
                if (isNumber$6(plotX) && isNumber$6(plotY)) {
                    if (chartCoordinates) {
                        posX = xAxis ? xAxis.pos : chart.plotLeft;
                        posY = yAxis ? yAxis.pos : chart.plotTop;
                    }
                    return chart.inverted && xAxis && yAxis ?
                        [yAxis.len - plotY + posY, xAxis.len - plotX + posX] :
                        [plotX + posX, plotY + posY];
                }
            }
        }
        /**
         * @private
         * @function Highcharts.Point#resolveColor
         */
        resolveColor() {
            const series = this.series, optionsChart = series.chart.options.chart, styledMode = series.chart.styledMode;
            let color, colors, colorCount = optionsChart.colorCount, colorIndex;
            // remove points nonZonedColor for later recalculation
            delete this.nonZonedColor;
            if (series.options.colorByPoint) {
                if (!styledMode) {
                    colors = series.options.colors || series.chart.options.colors;
                    color = colors[series.colorCounter];
                    colorCount = colors.length;
                }
                colorIndex = series.colorCounter;
                series.colorCounter++;
                // loop back to zero
                if (series.colorCounter === colorCount) {
                    series.colorCounter = 0;
                }
            }
            else {
                if (!styledMode) {
                    color = series.color;
                }
                colorIndex = series.colorIndex;
            }
            /**
             * The point's current color index, used in styled mode instead of
             * `color`. The color index is inserted in class names used for styling.
             *
             * @name Highcharts.Point#colorIndex
             * @type {number|undefined}
             */
            this.colorIndex = pick$8(this.options.colorIndex, colorIndex);
            /**
             * The point's current color.
             *
             * @name Highcharts.Point#color
             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject|undefined}
             */
            this.color = pick$8(this.options.color, color);
        }
        /**
         * Set a value in an object, on the property defined by key. The key
         * supports nested properties using dot notation. The function modifies the
         * input object and does not make a copy.
         *
         * @function Highcharts.Point#setNestedProperty<T>
         *
         * @param {T} object
         *        The object to set the value on.
         *
         * @param {*} value
         *        The value to set.
         *
         * @param {string} key
         *        Key to the property to set.
         *
         * @return {T}
         *         The modified object.
         */
        setNestedProperty(object, value, key) {
            const nestedKeys = key.split('.');
            nestedKeys.reduce(function (result, key, i, arr) {
                const isLastKey = arr.length - 1 === i;
                result[key] = (isLastKey ?
                    value :
                    isObject$3(result[key], true) ?
                        result[key] :
                        {});
                return result[key];
            }, object);
            return object;
        }
        shouldDraw() {
            return !this.isNull;
        }
        /**
         * Extendable method for formatting each point's tooltip line.
         *
         * @function Highcharts.Point#tooltipFormatter
         *
         * @param {string} pointFormat
         *        The point format.
         *
         * @return {string}
         *         A string to be concatenated in to the common tooltip text.
         */
        tooltipFormatter(pointFormat) {
            // Insert options for valueDecimals, valuePrefix, and valueSuffix
            const series = this.series, seriesTooltipOptions = series.tooltipOptions, valueDecimals = pick$8(seriesTooltipOptions.valueDecimals, ''), valuePrefix = seriesTooltipOptions.valuePrefix || '', valueSuffix = seriesTooltipOptions.valueSuffix || '';
            // Replace default point style with class name
            if (series.chart.styledMode) {
                pointFormat =
                    series.chart.tooltip.styledModeFormat(pointFormat);
            }
            // Loop over the point array map and replace unformatted values with
            // sprintf formatting markup
            (series.pointArrayMap || ['y']).forEach(function (key) {
                key = '{point.' + key; // without the closing bracket
                if (valuePrefix || valueSuffix) {
                    pointFormat = pointFormat.replace(RegExp(key + '}', 'g'), valuePrefix + key + '}' + valueSuffix);
                }
                pointFormat = pointFormat.replace(RegExp(key + '}', 'g'), key + ':,.' + valueDecimals + 'f}');
            });
            return format(pointFormat, {
                point: this,
                series: this.series
            }, series.chart);
        }
        /**
         * Update point with new options (typically x/y data) and optionally redraw
         * the series.
         *
         * @sample highcharts/members/point-update-column/
         *         Update column value
         * @sample highcharts/members/point-update-pie/
         *         Update pie slice
         * @sample maps/members/point-update/
         *         Update map area value in Highmaps
         *
         * @function Highcharts.Point#update
         *
         * @param {Highcharts.PointOptionsType} options
         *        The point options. Point options are handled as described under
         *        the `series.type.data` item for each series type. For example
         *        for a line series, if options is a single number, the point will
         *        be given that number as the marin y value. If it is an array, it
         *        will be interpreted as x and y values respectively. If it is an
         *        object, advanced options are applied.
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart after the point is updated. If doing
         *        more operations on the chart, it is best practice to set
         *        `redraw` to false and call `chart.redraw()` after.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation=true]
         *        Whether to apply animation, and optionally animation
         *        configuration.
         *
         * @emits Highcharts.Point#event:update
         */
        update(options, redraw, animation, runEvent) {
            const point = this, series = point.series, graphic = point.graphic, chart = series.chart, seriesOptions = series.options;
            let i;
            redraw = pick$8(redraw, true);
            /**
             * @private
             */
            function update() {
                point.applyOptions(options);
                // Update visuals, #4146
                // Handle mock graphic elements for a11y, #12718
                const hasMockGraphic = graphic && point.hasMockGraphic;
                const shouldDestroyGraphic = point.y === null ?
                    !hasMockGraphic :
                    hasMockGraphic;
                if (graphic && shouldDestroyGraphic) {
                    point.graphic = graphic.destroy();
                    delete point.hasMockGraphic;
                }
                if (isObject$3(options, true)) {
                    // Destroy so we can get new elements
                    if (graphic && graphic.element) {
                        // "null" is also a valid symbol
                        if (options &&
                            options.marker &&
                            typeof options.marker.symbol !== 'undefined') {
                            point.graphic = graphic.destroy();
                        }
                    }
                    if (options && options.dataLabels && point.dataLabel) {
                        point.dataLabel = point.dataLabel.destroy(); // #2468
                    }
                    if (point.connector) {
                        point.connector = point.connector.destroy(); // #7243
                    }
                }
                // record changes in the parallel arrays
                i = point.index;
                series.updateParallelArrays(point, i);
                // Record the options to options.data. If the old or the new config
                // is an object, use point options, otherwise use raw options
                // (#4701, #4916).
                seriesOptions.data[i] = (isObject$3(seriesOptions.data[i], true) ||
                    isObject$3(options, true)) ?
                    point.options :
                    pick$8(options, seriesOptions.data[i]);
                // redraw
                series.isDirty = series.isDirtyData = true;
                if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320
                    chart.isDirtyBox = true;
                }
                if (seriesOptions.legendType === 'point') { // #1831, #1885
                    chart.isDirtyLegend = true;
                }
                if (redraw) {
                    chart.redraw(animation);
                }
            }
            // Fire the event with a default handler of doing the update
            if (runEvent === false) { // When called from setData
                update();
            }
            else {
                point.firePointEvent('update', { options: options }, update);
            }
        }
        /**
         * Remove a point and optionally redraw the series and if necessary the axes
         *
         * @sample highcharts/plotoptions/series-point-events-remove/
         *         Remove point and confirm
         * @sample highcharts/members/point-remove/
         *         Remove pie slice
         * @sample maps/members/point-remove/
         *         Remove selected points in Highmaps
         *
         * @function Highcharts.Point#remove
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart or wait for an explicit call. When
         *        doing more operations on the chart, for example running
         *        `point.remove()` in a loop, it is best practice to set `redraw`
         *        to false and call `chart.redraw()` after.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation=false]
         *        Whether to apply animation, and optionally animation
         *        configuration.
         */
        remove(redraw, animation) {
            this.series.removePoint(this.series.data.indexOf(this), redraw, animation);
        }
        /**
         * Toggle the selection status of a point.
         *
         * @see Highcharts.Chart#getSelectedPoints
         *
         * @sample highcharts/members/point-select/
         *         Select a point from a button
         * @sample highcharts/chart/events-selection-points/
         *         Select a range of points through a drag selection
         * @sample maps/series/data-id/
         *         Select a point in Highmaps
         *
         * @function Highcharts.Point#select
         *
         * @param {boolean} [selected]
         * When `true`, the point is selected. When `false`, the point is
         * unselected. When `null` or `undefined`, the selection state is toggled.
         *
         * @param {boolean} [accumulate=false]
         * When `true`, the selection is added to other selected points.
         * When `false`, other selected points are deselected. Internally in
         * Highcharts, when
         * [allowPointSelect](https://api.highcharts.com/highcharts/plotOptions.series.allowPointSelect)
         * is `true`, selected points are accumulated on Control, Shift or Cmd
         * clicking the point.
         *
         * @emits Highcharts.Point#event:select
         * @emits Highcharts.Point#event:unselect
         */
        select(selected, accumulate) {
            const point = this, series = point.series, chart = series.chart;
            selected = pick$8(selected, !point.selected);
            this.selectedStaging = selected;
            // fire the event with the default handler
            point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {
                /**
                 * Whether the point is selected or not.
                 *
                 * @see Point#select
                 * @see Chart#getSelectedPoints
                 *
                 * @name Highcharts.Point#selected
                 * @type {boolean}
                 */
                point.selected = point.options.selected = selected;
                series.options.data[series.data.indexOf(point)] =
                    point.options;
                point.setState(selected && 'select');
                // unselect all other points unless Ctrl or Cmd + click
                if (!accumulate) {
                    chart.getSelectedPoints().forEach(function (loopPoint) {
                        const loopSeries = loopPoint.series;
                        if (loopPoint.selected && loopPoint !== point) {
                            loopPoint.selected = loopPoint.options.selected =
                                false;
                            loopSeries.options.data[loopSeries.data.indexOf(loopPoint)] = loopPoint.options;
                            // Programatically selecting a point should restore
                            // normal state, but when click happened on other
                            // point, set inactive state to match other points
                            loopPoint.setState(chart.hoverPoints &&
                                loopSeries.options.inactiveOtherPoints ?
                                'inactive' : '');
                            loopPoint.firePointEvent('unselect');
                        }
                    });
                }
            });
            delete this.selectedStaging;
        }
        /**
         * Runs on mouse over the point. Called internally from mouse and touch
         * events.
         *
         * @function Highcharts.Point#onMouseOver
         *
         * @param {Highcharts.PointerEventObject} [e]
         *        The event arguments.
         */
        onMouseOver(e) {
            const point = this, series = point.series, chart = series.chart, pointer = chart.pointer;
            e = e ?
                pointer.normalize(e) :
                // In cases where onMouseOver is called directly without an event
                pointer.getChartCoordinatesFromPoint(point, chart.inverted);
            pointer.runPointActions(e, point);
        }
        /**
         * Runs on mouse out from the point. Called internally from mouse and touch
         * events.
         *
         * @function Highcharts.Point#onMouseOut
         * @emits Highcharts.Point#event:mouseOut
         */
        onMouseOut() {
            const point = this, chart = point.series.chart;
            point.firePointEvent('mouseOut');
            if (!point.series.options.inactiveOtherPoints) {
                (chart.hoverPoints || []).forEach(function (p) {
                    p.setState();
                });
            }
            chart.hoverPoints = chart.hoverPoint = null;
        }
        /**
         * Import events from the series' and point's options. Only do it on
         * demand, to save processing time on hovering.
         *
         * @private
         * @function Highcharts.Point#importEvents
         */
        importEvents() {
            if (!this.hasImportedEvents) {
                const point = this, options = merge$7(point.series.options.point, point.options), events = options.events;
                point.events = events;
                objectEach$5(events, function (event, eventType) {
                    if (isFunction$1(event)) {
                        addEvent$4(point, eventType, event);
                    }
                });
                this.hasImportedEvents = true;
            }
        }
        /**
         * Set the point's state.
         *
         * @function Highcharts.Point#setState
         *
         * @param {Highcharts.PointStateValue|""} [state]
         *        The new state, can be one of `'hover'`, `'select'`, `'inactive'`,
         *        or `''` (an empty string), `'normal'` or `undefined` to set to
         *        normal state.
         * @param {boolean} [move]
         *        State for animation.
         *
         * @emits Highcharts.Point#event:afterSetState
         */
        setState(state, move) {
            const point = this, series = point.series, previousState = point.state, stateOptions = (series.options.states[state || 'normal'] ||
                {}), markerOptions = (defaultOptions$3.plotOptions[series.type].marker &&
                series.options.marker), normalDisabled = (markerOptions && markerOptions.enabled === false), markerStateOptions = ((markerOptions &&
                markerOptions.states &&
                markerOptions.states[state || 'normal']) || {}), stateDisabled = markerStateOptions.enabled === false, pointMarker = point.marker || {}, chart = series.chart, hasMarkers = (markerOptions && series.markerAttribs);
            let halo = series.halo, markerAttribs, pointAttribs, pointAttribsAnimation, stateMarkerGraphic = series.stateMarkerGraphic, newSymbol;
            state = state || ''; // empty string
            if (
            // already has this state
            (state === point.state && !move) ||
                // selected points don't respond to hover
                (point.selected && state !== 'select') ||
                // series' state options is disabled
                (stateOptions.enabled === false) ||
                // general point marker's state options is disabled
                (state && (stateDisabled ||
                    (normalDisabled &&
                        markerStateOptions.enabled === false))) ||
                // individual point marker's state options is disabled
                (state &&
                    pointMarker.states &&
                    pointMarker.states[state] &&
                    pointMarker.states[state].enabled === false) // #1610
            ) {
                return;
            }
            point.state = state;
            if (hasMarkers) {
                markerAttribs = series.markerAttribs(point, state);
            }
            // Apply hover styles to the existing point
            // Prevent from mocked null points (#14966)
            if (point.graphic && !point.hasMockGraphic) {
                if (previousState) {
                    point.graphic.removeClass('highcharts-point-' + previousState);
                }
                if (state) {
                    point.graphic.addClass('highcharts-point-' + state);
                }
                if (!chart.styledMode) {
                    pointAttribs = series.pointAttribs(point, state);
                    pointAttribsAnimation = pick$8(chart.options.chart.animation, stateOptions.animation);
                    const opacity = pointAttribs.opacity;
                    // Some inactive points (e.g. slices in pie) should apply
                    // opacity also for their labels
                    if (series.options.inactiveOtherPoints && isNumber$6(opacity)) {
                        (point.dataLabels || []).forEach(function (label) {
                            if (label &&
                                !label.hasClass('highcharts-data-label-hidden')) {
                                label.animate({ opacity }, pointAttribsAnimation);
                            }
                        });
                        if (point.connector) {
                            point.connector.animate({ opacity }, pointAttribsAnimation);
                        }
                    }
                    point.graphic.animate(pointAttribs, pointAttribsAnimation);
                }
                if (markerAttribs) {
                    point.graphic.animate(markerAttribs, pick$8(
                    // Turn off globally:
                    chart.options.chart.animation, markerStateOptions.animation, markerOptions.animation));
                }
                // Zooming in from a range with no markers to a range with markers
                if (stateMarkerGraphic) {
                    stateMarkerGraphic.hide();
                }
            }
            else {
                // if a graphic is not applied to each point in the normal state,
                // create a shared graphic for the hover state
                if (state && markerStateOptions) {
                    newSymbol = pointMarker.symbol || series.symbol;
                    // If the point has another symbol than the previous one, throw
                    // away the state marker graphic and force a new one (#1459)
                    if (stateMarkerGraphic &&
                        stateMarkerGraphic.currentSymbol !== newSymbol) {
                        stateMarkerGraphic = stateMarkerGraphic.destroy();
                    }
                    // Add a new state marker graphic
                    if (markerAttribs) {
                        if (!stateMarkerGraphic) {
                            if (newSymbol) {
                                series.stateMarkerGraphic = stateMarkerGraphic =
                                    chart.renderer
                                        .symbol(newSymbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height)
                                        .add(series.markerGroup);
                                stateMarkerGraphic.currentSymbol = newSymbol;
                            }
                            // Move the existing graphic
                        }
                        else {
                            stateMarkerGraphic[move ? 'animate' : 'attr']({
                                x: markerAttribs.x,
                                y: markerAttribs.y
                            });
                        }
                    }
                    if (!chart.styledMode && stateMarkerGraphic &&
                        point.state !== 'inactive') {
                        stateMarkerGraphic.attr(series.pointAttribs(point, state));
                    }
                }
                if (stateMarkerGraphic) {
                    stateMarkerGraphic[state && point.isInside ? 'show' : 'hide'](); // #2450
                    stateMarkerGraphic.element.point = point; // #4310
                    stateMarkerGraphic.addClass(point.getClassName(), true);
                }
            }
            // Show me your halo
            const haloOptions = stateOptions.halo;
            const markerGraphic = (point.graphic || stateMarkerGraphic);
            const markerVisibility = (markerGraphic && markerGraphic.visibility || 'inherit');
            if (haloOptions &&
                haloOptions.size &&
                markerGraphic &&
                markerVisibility !== 'hidden' &&
                !point.isCluster) {
                if (!halo) {
                    series.halo = halo = chart.renderer.path()
                        // #5818, #5903, #6705
                        .add(markerGraphic.parentGroup);
                }
                halo.show()[move ? 'animate' : 'attr']({
                    d: point.haloPath(haloOptions.size)
                });
                halo.attr({
                    'class': 'highcharts-halo highcharts-color-' +
                        pick$8(point.colorIndex, series.colorIndex) +
                        (point.className ? ' ' + point.className : ''),
                    'visibility': markerVisibility,
                    'zIndex': -1 // #4929, #8276
                });
                halo.point = point; // #6055
                if (!chart.styledMode) {
                    halo.attr(extend$7({
                        'fill': point.color || series.color,
                        'fill-opacity': haloOptions.opacity
                    }, AST.filterUserAttributes(haloOptions.attributes || {})));
                }
            }
            else if (halo && halo.point && halo.point.haloPath) {
                // Animate back to 0 on the current halo point (#6055)
                halo.animate({ d: halo.point.haloPath(0) }, null, 
                // Hide after unhovering. The `complete` callback runs in the
                // halo's context (#7681).
                halo.hide);
            }
            fireEvent$5(point, 'afterSetState', { state });
        }
        /**
         * Get the path definition for the halo, which is usually a shadow-like
         * circle around the currently hovered point.
         *
         * @function Highcharts.Point#haloPath
         *
         * @param {number} size
         *        The radius of the circular halo.
         *
         * @return {Highcharts.SVGPathArray}
         *         The path definition.
         */
        haloPath(size) {
            const pos = this.pos();
            return pos ? this.series.chart.renderer.symbols.circle(Math.floor(pos[0]) - size, pos[1] - size, size * 2, size * 2) : [];
        }
    }

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    /* *
     *
     *  API Options
     *
     * */
    /**
     * General options for all series types.
     *
     * @optionparent plotOptions.series
     */
    const seriesDefaults = {
        // base series options
        /**
         * The SVG value used for the `stroke-linecap` and `stroke-linejoin`
         * of a line graph. Round means that lines are rounded in the ends and
         * bends.
         *
         * @type       {Highcharts.SeriesLinecapValue}
         * @default    round
         * @since      3.0.7
         * @apioption  plotOptions.line.linecap
         */
        /**
         * Pixel width of the graph line.
         *
         * @see In styled mode, the line stroke-width can be set with the
         *      `.highcharts-graph` class name.
         *
         * @sample {highcharts} highcharts/plotoptions/series-linewidth-general/
         *         On all series
         * @sample {highcharts} highcharts/plotoptions/series-linewidth-specific/
         *         On one single series
         *
         * @product highcharts highstock
         */
        lineWidth: 1,
        /**
         * For some series, there is a limit that shuts down animation
         * by default when the total number of points in the chart is too high.
         * For example, for a column chart and its derivatives, animation does
         * not run if there is more than 250 points totally. To disable this
         * cap, set `animationLimit` to `Infinity`. This option works if animation
         * is fired on individual points, not on a group of points like e.g. during
         * the initial animation.
         *
         * @sample {highcharts} highcharts/plotoptions/series-animationlimit/
         *         Animation limit on updating individual points
         *
         * @type      {number}
         * @apioption plotOptions.series.animationLimit
         */
        /**
         * Allow this series' points to be selected by clicking on the graphic
         * (columns, point markers, pie slices, map areas etc).
         *
         * The selected points can be handled by point select and unselect
         * events, or collectively by the [getSelectedPoints
         * ](/class-reference/Highcharts.Chart#getSelectedPoints) function.
         *
         * And alternative way of selecting points is through dragging.
         *
         * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-line/
         *         Line
         * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-column/
         *         Column
         * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-pie/
         *         Pie
         * @sample {highcharts} highcharts/chart/events-selection-points/
         *         Select a range of points through a drag selection
         * @sample {highmaps} maps/plotoptions/series-allowpointselect/
         *         Map area
         * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
         *         Map bubble
         *
         * @since 1.2.0
         *
         * @private
         */
        allowPointSelect: false,
        /**
         * When true, each point or column edge is rounded to its nearest pixel
         * in order to render sharp on screen. In some cases, when there are a
         * lot of densely packed columns, this leads to visible difference
         * in column widths or distance between columns. In these cases,
         * setting `crisp` to `false` may look better, even though each column
         * is rendered blurry.
         *
         * @sample {highcharts} highcharts/plotoptions/column-crisp-false/
         *         Crisp is false
         *
         * @since   5.0.10
         * @product highcharts highstock gantt
         *
         * @private
         */
        crisp: true,
        /**
         * If true, a checkbox is displayed next to the legend item to allow
         * selecting the series. The state of the checkbox is determined by
         * the `selected` option.
         *
         * @productdesc {highmaps}
         * Note that if a `colorAxis` is defined, the color axis is represented
         * in the legend, not the series.
         *
         * @sample {highcharts} highcharts/plotoptions/series-showcheckbox-true/
         *         Show select box
         *
         * @since 1.2.0
         *
         * @private
         */
        showCheckbox: false,
        /**
         * Enable or disable the initial animation when a series is displayed.
         * The animation can also be set as a configuration object. Please
         * note that this option only applies to the initial animation of the
         * series itself. For other animations, see [chart.animation](
         * #chart.animation) and the animation parameter under the API methods.
         * The following properties are supported:
         *
         * - `defer`: The animation delay time in milliseconds.
         *
         * - `duration`: The duration of the animation in milliseconds. (Defaults to
         *   `1000`)
         *
         * - `easing`: Can be a string reference to an easing function set on
         *   the `Math` object or a function. See the _Custom easing function_
         *   demo below. (Defaults to `easeInOutSine`)
         *
         * Due to poor performance, animation is disabled in old IE browsers
         * for several chart types.
         *
         * @sample {highcharts} highcharts/plotoptions/series-animation-disabled/
         *         Animation disabled
         * @sample {highcharts} highcharts/plotoptions/series-animation-slower/
         *         Slower animation
         * @sample {highcharts} highcharts/plotoptions/series-animation-easing/
         *         Custom easing function
         * @sample {highstock} stock/plotoptions/animation-slower/
         *         Slower animation
         * @sample {highstock} stock/plotoptions/animation-easing/
         *         Custom easing function
         * @sample {highmaps} maps/plotoptions/series-animation-true/
         *         Animation enabled on map series
         * @sample {highmaps} maps/plotoptions/mapbubble-animation-false/
         *         Disabled on mapbubble series
         *
         * @type    {boolean|Highcharts.AnimationOptionsObject}
         * @default {highcharts} true
         * @default {highstock} true
         * @default {highmaps} false
         *
         * @private
         */
        animation: {
            /** @ignore-option */
            duration: 1000
        },
        /**
         * An additional class name to apply to the series' graphical elements.
         * This option does not replace default class names of the graphical
         * element. Changes to the series' color will also be reflected in a
         * chart's legend and tooltip.
         *
         * @sample {highcharts} highcharts/css/point-series-classname
         *
         * @type      {string}
         * @since     5.0.0
         * @apioption plotOptions.series.className
         */
        /**
         * Disable this option to allow series rendering in the whole plotting
         * area.
         *
         * **Note:** Clipping should be always enabled when
         * [chart.zoomType](#chart.zoomType) is set
         *
         * @sample {highcharts} highcharts/plotoptions/series-clip/
         *         Disabled clipping
         *
         * @default   true
         * @type      {boolean}
         * @since     3.0.0
         * @apioption plotOptions.series.clip
         */
        /**
         * The main color of the series. In line type series it applies to the
         * line and the point markers unless otherwise specified. In bar type
         * series it applies to the bars unless a color is specified per point.
         * The default value is pulled from the `options.colors` array.
         *
         * In styled mode, the color can be defined by the
         * [colorIndex](#plotOptions.series.colorIndex) option. Also, the series
         * color can be set with the `.highcharts-series`,
         * `.highcharts-color-{n}`, `.highcharts-{type}-series` or
         * `.highcharts-series-{n}` class, or individual classes given by the
         * `className` option.
         *
         * @productdesc {highmaps}
         * In maps, the series color is rarely used, as most choropleth maps use
         * the color to denote the value of each point. The series color can
         * however be used in a map with multiple series holding categorized
         * data.
         *
         * @sample {highcharts} highcharts/plotoptions/series-color-general/
         *         General plot option
         * @sample {highcharts} highcharts/plotoptions/series-color-specific/
         *         One specific series
         * @sample {highcharts} highcharts/plotoptions/series-color-area/
         *         Area color
         * @sample {highcharts} highcharts/series/infographic/
         *         Pattern fill
         * @sample {highmaps} maps/demo/category-map/
         *         Category map by multiple series
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @apioption plotOptions.series.color
         */
        /**
         * Styled mode only. A specific color index to use for the series, so its
         * graphic representations are given the class name `highcharts-color-{n}`.
         *
         * Since v11, CSS variables on the form `--highcharts-color-{n}` make
         * changing the color scheme very convenient.
         *
         * @sample    {highcharts} highcharts/css/colorindex/ Series and point color
         *            index
         *
         * @type      {number}
         * @since     5.0.0
         * @apioption plotOptions.series.colorIndex
         */
        /**
         * Whether to connect a graph line across null points, or render a gap
         * between the two points on either side of the null.
         *
         * In stacked area chart, if `connectNulls` is set to true,
         * null points are interpreted as 0.
         *
         * @sample {highcharts} highcharts/plotoptions/series-connectnulls-false/
         *         False by default
         * @sample {highcharts} highcharts/plotoptions/series-connectnulls-true/
         *         True
         *
         * @type      {boolean}
         * @default   false
         * @product   highcharts highstock
         * @apioption plotOptions.series.connectNulls
         */
        /**
         * You can set the cursor to "pointer" if you have click events attached
         * to the series, to signal to the user that the points and lines can
         * be clicked.
         *
         * In styled mode, the series cursor can be set with the same classes
         * as listed under [series.color](#plotOptions.series.color).
         *
         * @sample {highcharts} highcharts/plotoptions/series-cursor-line/
         *         On line graph
         * @sample {highcharts} highcharts/plotoptions/series-cursor-column/
         *         On columns
         * @sample {highcharts} highcharts/plotoptions/series-cursor-scatter/
         *         On scatter markers
         * @sample {highstock} stock/plotoptions/cursor/
         *         Pointer on a line graph
         * @sample {highmaps} maps/plotoptions/series-allowpointselect/
         *         Map area
         * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
         *         Map bubble
         *
         * @type      {string|Highcharts.CursorValue}
         * @apioption plotOptions.series.cursor
         */
        /**
         * A reserved subspace to store options and values for customized
         * functionality. Here you can add additional data for your own event
         * callbacks and formatter callbacks.
         *
         * @sample {highcharts} highcharts/point/custom/
         *         Point and series with custom data
         *
         * @type      {Highcharts.Dictionary<*>}
         * @apioption plotOptions.series.custom
         */
        /**
         * Name of the dash style to use for the graph, or for some series types
         * the outline of each shape.
         *
         * In styled mode, the
         * [stroke dash-array](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/series-dashstyle/)
         * can be set with the same classes as listed under
         * [series.color](#plotOptions.series.color).
         *
         * @sample {highcharts} highcharts/plotoptions/series-dashstyle-all/
         *         Possible values demonstrated
         * @sample {highcharts} highcharts/plotoptions/series-dashstyle/
         *         Chart suitable for printing in black and white
         * @sample {highstock} highcharts/plotoptions/series-dashstyle-all/
         *         Possible values demonstrated
         * @sample {highmaps} highcharts/plotoptions/series-dashstyle-all/
         *         Possible values demonstrated
         * @sample {highmaps} maps/plotoptions/series-dashstyle/
         *         Dotted borders on a map
         *
         * @type      {Highcharts.DashStyleValue}
         * @default   Solid
         * @since     2.1
         * @apioption plotOptions.series.dashStyle
         */
        /**
         * A description of the series to add to the screen reader information
         * about the series.
         *
         * @type      {string}
         * @since     5.0.0
         * @requires  modules/accessibility
         * @apioption plotOptions.series.description
         */
        /**
         * Options for the series data sorting.
         *
         * @type      {Highcharts.DataSortingOptionsObject}
         * @since     8.0.0
         * @product   highcharts highstock
         * @apioption plotOptions.series.dataSorting
         */
        /**
         * Enable or disable data sorting for the series. Use [xAxis.reversed](
         * #xAxis.reversed) to change the sorting order.
         *
         * @sample {highcharts} highcharts/datasorting/animation/
         *         Data sorting in scatter-3d
         * @sample {highcharts} highcharts/datasorting/labels-animation/
         *         Axis labels animation
         * @sample {highcharts} highcharts/datasorting/dependent-sorting/
         *         Dependent series sorting
         * @sample {highcharts} highcharts/datasorting/independent-sorting/
         *         Independent series sorting
         *
         * @type      {boolean}
         * @since     8.0.0
         * @apioption plotOptions.series.dataSorting.enabled
         */
        /**
         * Whether to allow matching points by name in an update. If this option
         * is disabled, points will be matched by order.
         *
         * @sample {highcharts} highcharts/datasorting/match-by-name/
         *         Enabled match by name
         *
         * @type      {boolean}
         * @since     8.0.0
         * @apioption plotOptions.series.dataSorting.matchByName
         */
        /**
         * Determines what data value should be used to sort by.
         *
         * @sample {highcharts} highcharts/datasorting/sort-key/
         *         Sort key as `z` value
         *
         * @type      {string}
         * @since     8.0.0
         * @default   y
         * @apioption plotOptions.series.dataSorting.sortKey
         */
        /**
         * Enable or disable the mouse tracking for a specific series. This
         * includes point tooltips and click events on graphs and points. For
         * large datasets it improves performance.
         *
         * @sample {highcharts} highcharts/plotoptions/series-enablemousetracking-false/
         *         No mouse tracking
         * @sample {highmaps} maps/plotoptions/series-enablemousetracking-false/
         *         No mouse tracking
         *
         * @type      {boolean}
         * @default   true
         * @apioption plotOptions.series.enableMouseTracking
         */
        enableMouseTracking: true,
        /**
         * Whether to use the Y extremes of the total chart width or only the
         * zoomed area when zooming in on parts of the X axis. By default, the
         * Y axis adjusts to the min and max of the visible data. Cartesian
         * series only.
         *
         * @type      {boolean}
         * @default   false
         * @since     4.1.6
         * @product   highcharts highstock gantt
         * @apioption plotOptions.series.getExtremesFromAll
         */
        /**
         * An array specifying which option maps to which key in the data point
         * array. This makes it convenient to work with unstructured data arrays
         * from different sources.
         *
         * @see [series.data](#series.line.data)
         *
         * @sample {highcharts|highstock} highcharts/series/data-keys/
         *         An extended data array with keys
         * @sample {highcharts|highstock} highcharts/series/data-nested-keys/
         *         Nested keys used to access object properties
         *
         * @type      {Array<string>}
         * @since     4.1.6
         * @apioption plotOptions.series.keys
         */
        /**
         * The line cap used for line ends and line joins on the graph.
         *
         * @sample highcharts/series-line/linecap/
         *         Line cap comparison
         *
         * @type       {Highcharts.SeriesLinecapValue}
         * @default    round
         * @product    highcharts highstock
         * @apioption  plotOptions.series.linecap
         */
        /**
         * The [id](#series.id) of another series to link to. Additionally,
         * the value can be ":previous" to link to the previous series. When
         * two series are linked, only the first one appears in the legend.
         * Toggling the visibility of this also toggles the linked series.
         *
         * If master series uses data sorting and linked series does not have
         * its own sorting definition, the linked series will be sorted in the
         * same order as the master one.
         *
         * @sample {highcharts|highstock} highcharts/demo/arearange-line/
         *         Linked series
         *
         * @type      {string}
         * @since     3.0
         * @product   highcharts highstock gantt
         * @apioption plotOptions.series.linkedTo
         */
        /**
         * Options for the corresponding navigator series if `showInNavigator`
         * is `true` for this series. Available options are the same as any
         * series, documented at [plotOptions](#plotOptions.series) and
         * [series](#series).
         *
         * These options are merged with options in [navigator.series](
         * #navigator.series), and will take precedence if the same option is
         * defined both places.
         *
         * @see [navigator.series](#navigator.series)
         *
         * @type      {Highcharts.PlotSeriesOptions}
         * @since     5.0.0
         * @product   highstock
         * @apioption plotOptions.series.navigatorOptions
         */
        /**
         * The color for the parts of the graph or points that are below the
         * [threshold](#plotOptions.series.threshold). Note that `zones` takes
         * precedence over the negative color. Using `negativeColor` is
         * equivalent to applying a zone with value of 0.
         *
         * @see In styled mode, a negative color is applied by setting this option
         *      to `true` combined with the `.highcharts-negative` class name.
         *
         * @sample {highcharts} highcharts/plotoptions/series-negative-color/
         *         Spline, area and column
         * @sample {highcharts} highcharts/plotoptions/arearange-negativecolor/
         *         Arearange
         * @sample {highcharts} highcharts/css/series-negative-color/
         *         Styled mode
         * @sample {highstock} highcharts/plotoptions/series-negative-color/
         *         Spline, area and column
         * @sample {highstock} highcharts/plotoptions/arearange-negativecolor/
         *         Arearange
         * @sample {highmaps} highcharts/plotoptions/series-negative-color/
         *         Spline, area and column
         * @sample {highmaps} highcharts/plotoptions/arearange-negativecolor/
         *         Arearange
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @since     3.0
         * @apioption plotOptions.series.negativeColor
         */
        /**
         * Same as
         * [accessibility.point.descriptionFormat](#accessibility.point.descriptionFormat),
         * but for an individual series. Overrides the chart wide configuration.
         *
         * @type      {Function}
         * @since 11.1.0
         * @apioption plotOptions.series.pointDescriptionFormat
         */
        /**
         * Same as
         * [accessibility.series.descriptionFormatter](#accessibility.series.descriptionFormatter),
         * but for an individual series. Overrides the chart wide configuration.
         *
         * @type      {Function}
         * @since     5.0.12
         * @apioption plotOptions.series.pointDescriptionFormatter
         */
        /**
         * If no x values are given for the points in a series, `pointInterval`
         * defines the interval of the x values. For example, if a series
         * contains one value every decade starting from year 0, set
         * `pointInterval` to `10`. In true `datetime` axes, the `pointInterval`
         * is set in milliseconds.
         *
         * It can be also be combined with `pointIntervalUnit` to draw irregular
         * time intervals.
         *
         * If combined with `relativeXValue`, an x value can be set on each
         * point, and the `pointInterval` is added x times to the `pointStart`
         * setting.
         *
         * Please note that this options applies to the _series data_, not the
         * interval of the axis ticks, which is independent.
         *
         * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/
         *         Datetime X axis
         * @sample {highcharts} highcharts/plotoptions/series-relativexvalue/
         *         Relative x value
         * @sample {highstock} stock/plotoptions/pointinterval-pointstart/
         *         Using pointStart and pointInterval
         * @sample {highstock} stock/plotoptions/relativexvalue/
         *         Relative x value
         *
         * @type      {number}
         * @default   1
         * @product   highcharts highstock gantt
         * @apioption plotOptions.series.pointInterval
         */
        /**
         * On datetime series, this allows for setting the
         * [pointInterval](#plotOptions.series.pointInterval) to irregular time
         * units, `day`, `month` and `year`. A day is usually the same as 24
         * hours, but `pointIntervalUnit` also takes the DST crossover into
         * consideration when dealing with local time. Combine this option with
         * `pointInterval` to draw weeks, quarters, 6 months, 10 years etc.
         *
         * Please note that this options applies to the _series data_, not the
         * interval of the axis ticks, which is independent.
         *
         * @sample {highcharts} highcharts/plotoptions/series-pointintervalunit/
         *         One point a month
         * @sample {highstock} highcharts/plotoptions/series-pointintervalunit/
         *         One point a month
         *
         * @type       {string}
         * @since      4.1.0
         * @product    highcharts highstock gantt
         * @validvalue ["day", "month", "year"]
         * @apioption  plotOptions.series.pointIntervalUnit
         */
        /**
         * Possible values: `"on"`, `"between"`, `number`.
         *
         * In a column chart, when pointPlacement is `"on"`, the point will not
         * create any padding of the X axis. In a polar column chart this means
         * that the first column points directly north. If the pointPlacement is
         * `"between"`, the columns will be laid out between ticks. This is
         * useful for example for visualising an amount between two points in
         * time or in a certain sector of a polar chart.
         *
         * Since Highcharts 3.0.2, the point placement can also be numeric,
         * where 0 is on the axis value, -0.5 is between this value and the
         * previous, and 0.5 is between this value and the next. Unlike the
         * textual options, numeric point placement options won't affect axis
         * padding.
         *
         * Note that pointPlacement needs a [pointRange](
         * #plotOptions.series.pointRange) to work. For column series this is
         * computed, but for line-type series it needs to be set.
         *
         * For the `xrange` series type and gantt charts, if the Y axis is a
         * category axis, the `pointPlacement` applies to the Y axis rather than
         * the (typically datetime) X axis.
         *
         * Defaults to `undefined` in cartesian charts, `"between"` in polar
         * charts.
         *
         * @see [xAxis.tickmarkPlacement](#xAxis.tickmarkPlacement)
         *
         * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-between/
         *         Between in a column chart
         * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-numeric/
         *         Numeric placement for custom layout
         * @sample {highcharts|highstock} maps/plotoptions/heatmap-pointplacement/
         *         Placement in heatmap
         *
         * @type      {string|number}
         * @since     2.3.0
         * @product   highcharts highstock gantt
         * @apioption plotOptions.series.pointPlacement
         */
        /**
         * If no x values are given for the points in a series, pointStart
         * defines on what value to start. For example, if a series contains one
         * yearly value starting from 1945, set pointStart to 1945.
         *
         * If combined with `relativeXValue`, an x value can be set on each
         * point. The x value from the point options is multiplied by
         * `pointInterval` and added to `pointStart` to produce a modified x
         * value.
         *
         * @sample {highcharts} highcharts/plotoptions/series-pointstart-linear/
         *         Linear
         * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/
         *         Datetime
         * @sample {highcharts} highcharts/plotoptions/series-relativexvalue/
         *         Relative x value
         * @sample {highstock} stock/plotoptions/pointinterval-pointstart/
         *         Using pointStart and pointInterval
         * @sample {highstock} stock/plotoptions/relativexvalue/
         *         Relative x value
         *
         * @type      {number}
         * @default   0
         * @product   highcharts highstock gantt
         * @apioption plotOptions.series.pointStart
         */
        /**
         * When true, X values in the data set are relative to the current
         * `pointStart`, `pointInterval` and `pointIntervalUnit` settings. This
         * allows compression of the data for datasets with irregular X values.
         *
         * The real X values are computed on the formula `f(x) = ax + b`, where
         * `a` is the `pointInterval` (optionally with a time unit given by
         * `pointIntervalUnit`), and `b` is the `pointStart`.
         *
         * @sample {highcharts} highcharts/plotoptions/series-relativexvalue/
         *         Relative X value
         * @sample {highstock} stock/plotoptions/relativexvalue/
         *         Relative X value
         *
         * @type      {boolean}
         * @default   false
         * @product   highcharts highstock
         * @apioption plotOptions.series.relativeXValue
         */
        /**
         * Whether to select the series initially. If `showCheckbox` is true,
         * the checkbox next to the series name in the legend will be checked
         * for a selected series.
         *
         * @sample {highcharts} highcharts/plotoptions/series-selected/
         *         One out of two series selected
         *
         * @type      {boolean}
         * @default   false
         * @since     1.2.0
         * @apioption plotOptions.series.selected
         */
        /**
         * Whether to apply a drop shadow to the graph line. Since 2.3 the
         * shadow can be an object configuration containing `color`, `offsetX`,
         * `offsetY`, `opacity` and `width`.
         *
         * Note that in some cases, like stacked columns or other dense layouts, the
         * series may cast shadows on each other. In that case, the
         * `chart.seriesGroupShadow` allows applying a common drop shadow to the
         * whole series group.
         *
         * @sample {highcharts} highcharts/plotoptions/series-shadow/
         *         Shadow enabled
         *
         * @type      {boolean|Highcharts.ShadowOptionsObject}
         * @default   false
         * @apioption plotOptions.series.shadow
         */
        /**
         * Whether to display this particular series or series type in the
         * legend. Standalone series are shown in legend by default, and linked
         * series are not. Since v7.2.0 it is possible to show series that use
         * colorAxis by setting this option to `true`.
         *
         * @sample {highcharts} highcharts/plotoptions/series-showinlegend/
         *         One series in the legend, one hidden
         *
         * @type      {boolean}
         * @apioption plotOptions.series.showInLegend
         */
        /**
         * Whether or not to show the series in the navigator. Takes precedence
         * over [navigator.baseSeries](#navigator.baseSeries) if defined.
         *
         * @type      {boolean}
         * @since     5.0.0
         * @product   highstock
         * @apioption plotOptions.series.showInNavigator
         */
        /**
         * If set to `true`, the accessibility module will skip past the points
         * in this series for keyboard navigation.
         *
         * @type      {boolean}
         * @since     5.0.12
         * @apioption plotOptions.series.skipKeyboardNavigation
         */
        /**
         * Whether to stack the values of each series on top of each other.
         * Possible values are `undefined` to disable, `"normal"` to stack by
         * value or `"percent"`.
         *
         * When stacking is enabled, data must be sorted
         * in ascending X order.
         *
         * Some stacking options are related to specific series types. In the
         * streamgraph series type, the stacking option is set to `"stream"`.
         * The second one is `"overlap"`, which only applies to waterfall
         * series.
         *
         * @see [yAxis.reversedStacks](#yAxis.reversedStacks)
         *
         * @sample {highcharts} highcharts/plotoptions/series-stacking-line/
         *         Line
         * @sample {highcharts} highcharts/plotoptions/series-stacking-column/
         *         Column
         * @sample {highcharts} highcharts/plotoptions/series-stacking-bar/
         *         Bar
         * @sample {highcharts} highcharts/plotoptions/series-stacking-area/
         *         Area
         * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-line/
         *         Line
         * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-column/
         *         Column
         * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-bar/
         *         Bar
         * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-area/
         *         Area
         * @sample {highcharts} highcharts/plotoptions/series-waterfall-with-normal-stacking
         *         Waterfall with normal stacking
         * @sample {highcharts} highcharts/plotoptions/series-waterfall-with-overlap-stacking
         *         Waterfall with overlap stacking
         * @sample {highstock} stock/plotoptions/stacking/
         *         Area
         *
         * @type       {string}
         * @product    highcharts highstock
         * @validvalue ["normal", "overlap", "percent", "stream"]
         * @apioption  plotOptions.series.stacking
         */
        /**
         * Whether to apply steps to the line. Possible values are `left`,
         * `center` and `right`.
         *
         * @sample {highcharts} highcharts/plotoptions/line-step/
         *         Different step line options
         * @sample {highcharts} highcharts/plotoptions/area-step/
         *         Stepped, stacked area
         * @sample {highstock} stock/plotoptions/line-step/
         *         Step line
         *
         * @type       {string}
         * @since      1.2.5
         * @product    highcharts highstock
         * @validvalue ["left", "center", "right"]
         * @apioption  plotOptions.series.step
         */
        /**
         * The threshold, also called zero level or base level. For line type
         * series this is only used in conjunction with
         * [negativeColor](#plotOptions.series.negativeColor).
         *
         * @see [softThreshold](#plotOptions.series.softThreshold).
         *
         * @type      {number|null}
         * @default   0
         * @since     3.0
         * @product   highcharts highstock
         * @apioption plotOptions.series.threshold
         */
        /**
         * Set the initial visibility of the series.
         *
         * @sample {highcharts} highcharts/plotoptions/series-visible/
         *         Two series, one hidden and one visible
         * @sample {highstock} stock/plotoptions/series-visibility/
         *         Hidden series
         *
         * @type      {boolean}
         * @default   true
         * @apioption plotOptions.series.visible
         */
        /**
         * Defines the Axis on which the zones are applied.
         *
         * @see [zones](#plotOptions.series.zones)
         *
         * @sample {highcharts} highcharts/series/color-zones-zoneaxis-x/
         *         Zones on the X-Axis
         * @sample {highstock} highcharts/series/color-zones-zoneaxis-x/
         *         Zones on the X-Axis
         *
         * @type      {string}
         * @default   y
         * @since     4.1.0
         * @product   highcharts highstock
         * @apioption plotOptions.series.zoneAxis
         */
        /**
         * General event handlers for the series items. These event hooks can
         * also be attached to the series at run time using the
         * `Highcharts.addEvent` function.
         *
         * @declare Highcharts.SeriesEventsOptionsObject
         *
         * @private
         */
        events: {},
        /**
         * Fires after the series has finished its initial animation, or in case
         * animation is disabled, immediately as the series is displayed.
         *
         * @sample {highcharts} highcharts/plotoptions/series-events-afteranimate/
         *         Show label after animate
         * @sample {highstock} highcharts/plotoptions/series-events-afteranimate/
         *         Show label after animate
         *
         * @type      {Highcharts.SeriesAfterAnimateCallbackFunction}
         * @since     4.0
         * @product   highcharts highstock gantt
         * @context   Highcharts.Series
         * @apioption plotOptions.series.events.afterAnimate
         */
        /**
         * Fires when the checkbox next to the series' name in the legend is
         * clicked. One parameter, `event`, is passed to the function. The state
         * of the checkbox is found by `event.checked`. The checked item is
         * found by `event.item`. Return `false` to prevent the default action
         * which is to toggle the select state of the series.
         *
         * @sample {highcharts} highcharts/plotoptions/series-events-checkboxclick/
         *         Alert checkbox status
         *
         * @type      {Highcharts.SeriesCheckboxClickCallbackFunction}
         * @since     1.2.0
         * @context   Highcharts.Series
         * @apioption plotOptions.series.events.checkboxClick
         */
        /**
         * Fires when the series is clicked. One parameter, `event`, is passed
         * to the function, containing common event information. Additionally,
         * `event.point` holds a pointer to the nearest point on the graph.
         *
         * @sample {highcharts} highcharts/plotoptions/series-events-click/
         *         Alert click info
         * @sample {highstock} stock/plotoptions/series-events-click/
         *         Alert click info
         * @sample {highmaps} maps/plotoptions/series-events-click/
         *         Display click info in subtitle
         *
         * @type      {Highcharts.SeriesClickCallbackFunction}
         * @context   Highcharts.Series
         * @apioption plotOptions.series.events.click
         */
        /**
         * Fires when the series is hidden after chart generation time, either
         * by clicking the legend item or by calling `.hide()`.
         *
         * @sample {highcharts} highcharts/plotoptions/series-events-hide/
         *         Alert when the series is hidden by clicking the legend item
         *
         * @type      {Highcharts.SeriesHideCallbackFunction}
         * @since     1.2.0
         * @context   Highcharts.Series
         * @apioption plotOptions.series.events.hide
         */
        /**
         * Fires when the legend item belonging to the series is clicked. One
         * parameter, `event`, is passed to the function. The default action
         * is to toggle the visibility of the series. This can be prevented
         * by returning `false` or calling `event.preventDefault()`.
         *
         * @sample {highcharts} highcharts/plotoptions/series-events-legenditemclick/
         *         Confirm hiding and showing
         *
         * @type      {Highcharts.SeriesLegendItemClickCallbackFunction}
         * @context   Highcharts.Series
         * @apioption plotOptions.series.events.legendItemClick
         */
        /**
         * Fires when the mouse leaves the graph. One parameter, `event`, is
         * passed to the function, containing common event information. If the
         * [stickyTracking](#plotOptions.series) option is true, `mouseOut`
         * doesn't happen before the mouse enters another graph or leaves the
         * plot area.
         *
         * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/
         *         With sticky tracking by default
         * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/
         *         Without sticky tracking
         *
         * @type      {Highcharts.SeriesMouseOutCallbackFunction}
         * @context   Highcharts.Series
         * @apioption plotOptions.series.events.mouseOut
         */
        /**
         * Fires when the mouse enters the graph. One parameter, `event`, is
         * passed to the function, containing common event information.
         *
         * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/
         *         With sticky tracking by default
         * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/
         *         Without sticky tracking
         *
         * @type      {Highcharts.SeriesMouseOverCallbackFunction}
         * @context   Highcharts.Series
         * @apioption plotOptions.series.events.mouseOver
         */
        /**
         * Fires when the series is shown after chart generation time, either
         * by clicking the legend item or by calling `.show()`.
         *
         * @sample {highcharts} highcharts/plotoptions/series-events-show/
         *         Alert when the series is shown by clicking the legend item.
         *
         * @type      {Highcharts.SeriesShowCallbackFunction}
         * @since     1.2.0
         * @context   Highcharts.Series
         * @apioption plotOptions.series.events.show
         */
        /**
         * Options for the point markers of line and scatter-like series. Properties
         * like `fillColor`, `lineColor` and `lineWidth` define the visual
         * appearance of the markers. The `symbol` option defines the shape. Other
         * series types, like column series, don't have markers, but have visual
         * options on the series level instead.
         *
         * In styled mode, the markers can be styled with the `.highcharts-point`,
         * `.highcharts-point-hover` and `.highcharts-point-select` class names.
         *
         * @declare Highcharts.PointMarkerOptionsObject
         *
         * @sample {highmaps} maps/demo/mappoint-mapmarker
         *         Using the mapmarker symbol for points
         *
         * @private
         */
        marker: {
            /**
             * Enable or disable the point marker. If `undefined`, the markers
             * are hidden when the data is dense, and shown for more widespread
             * data points.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-enabled/
             *         Disabled markers
             * @sample {highcharts} highcharts/plotoptions/series-marker-enabled-false/
             *         Disabled in normal state but enabled on hover
             * @sample {highstock} stock/plotoptions/series-marker/
             *         Enabled markers
             *
             * @type      {boolean}
             * @default   {highcharts} undefined
             * @default   {highstock} false
             * @apioption plotOptions.series.marker.enabled
             */
            /**
             * The threshold for how dense the point markers should be before
             * they are hidden, given that `enabled` is not defined. The number
             * indicates the horizontal distance between the two closest points
             * in the series, as multiples of the `marker.radius`. In other
             * words, the default value of 2 means points are hidden if
             * overlapping horizontally.
             *
             * @sample highcharts/plotoptions/series-marker-enabledthreshold
             *         A higher threshold
             *
             * @since 6.0.5
             */
            enabledThreshold: 2,
            /**
             * The fill color of the point marker. When `undefined`, the series'
             * or point's color is used.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
             *         White fill
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @apioption plotOptions.series.marker.fillColor
             */
            /**
             * Image markers only. Set the image width explicitly. When using
             * this option, a `width` must also be set.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/
             *         Fixed width and height
             * @sample {highstock} highcharts/plotoptions/series-marker-width-height/
             *         Fixed width and height
             *
             * @type      {number}
             * @since     4.0.4
             * @apioption plotOptions.series.marker.height
             */
            /**
             * The color of the point marker's outline. When `undefined`, the
             * series' or point's color is used.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
             *         Inherit from series color (undefined)
             *
             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             */
            lineColor: "#ffffff" /* Palette.backgroundColor */,
            /**
             * The width of the point marker's outline.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
             *         2px blue marker
             */
            lineWidth: 0,
            /**
             * The radius of the point marker.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-radius/
             *         Bigger markers
             *
             * @default {highstock} 2
             * @default {highcharts} 4
             *
             */
            radius: 4,
            /**
             * A predefined shape or symbol for the marker. When undefined, the
             * symbol is pulled from options.symbols. Other possible values are
             * `'circle'`, `'square'`,`'diamond'`, `'triangle'` and
             * `'triangle-down'`.
             *
             * Additionally, the URL to a graphic can be given on this form:
             * `'url(graphic.png)'`. Note that for the image to be applied to
             * exported charts, its URL needs to be accessible by the export
             * server.
             *
             * Custom callbacks for symbol path generation can also be added to
             * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
             * used by its method name, as shown in the demo.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/
             *         Predefined, graphic and custom markers
             * @sample {highstock} highcharts/plotoptions/series-marker-symbol/
             *         Predefined, graphic and custom markers
             * @sample {highmaps} maps/demo/mappoint-mapmarker
             *         Using the mapmarker symbol for points
             *
             * @type      {string}
             * @apioption plotOptions.series.marker.symbol
             */
            /**
             * Image markers only. Set the image width explicitly. When using
             * this option, a `height` must also be set.
             *
             * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/
             *         Fixed width and height
             * @sample {highstock} highcharts/plotoptions/series-marker-width-height/
             *         Fixed width and height
             *
             * @type      {number}
             * @since     4.0.4
             * @apioption plotOptions.series.marker.width
             */
            /**
             * States for a single point marker.
             *
             * @declare Highcharts.PointStatesOptionsObject
             */
            states: {
                /**
                 * The normal state of a single point marker. Currently only
                 * used for setting animation when returning to normal state
                 * from hover.
                 *
                 * @declare Highcharts.PointStatesNormalOptionsObject
                 */
                normal: {
                    /**
                     * Animation when returning to normal state after hovering.
                     *
                     * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
                     */
                    animation: true
                },
                /**
                 * The hover state for a single point marker.
                 *
                 * @declare Highcharts.PointStatesHoverOptionsObject
                 */
                hover: {
                    /**
                     * Animation when hovering over the marker.
                     *
                     * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
                     */
                    animation: {
                        /** @internal */
                        duration: 150
                    },
                    /**
                     * Enable or disable the point marker.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-enabled/
                     *         Disabled hover state
                     */
                    enabled: true,
                    /**
                     * The fill color of the marker in hover state. When
                     * `undefined`, the series' or point's fillColor for normal
                     * state is used.
                     *
                     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                     * @apioption plotOptions.series.marker.states.hover.fillColor
                     */
                    /**
                     * The color of the point marker's outline. When
                     * `undefined`, the series' or point's lineColor for normal
                     * state is used.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linecolor/
                     *         White fill color, black line color
                     *
                     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                     * @apioption plotOptions.series.marker.states.hover.lineColor
                     */
                    /**
                     * The width of the point marker's outline. When
                     * `undefined`, the series' or point's lineWidth for normal
                     * state is used.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linewidth/
                     *         3px line width
                     *
                     * @type      {number}
                     * @apioption plotOptions.series.marker.states.hover.lineWidth
                     */
                    /**
                     * The radius of the point marker. In hover state, it
                     * defaults to the normal state's radius + 2 as per the
                     * [radiusPlus](#plotOptions.series.marker.states.hover.radiusPlus)
                     * option.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-radius/
                     *         10px radius
                     *
                     * @type      {number}
                     * @apioption plotOptions.series.marker.states.hover.radius
                     */
                    /**
                     * The number of pixels to increase the radius of the
                     * hovered point.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
                     *         5 pixels greater radius on hover
                     * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
                     *         5 pixels greater radius on hover
                     *
                     * @since 4.0.3
                     */
                    radiusPlus: 2,
                    /**
                     * The additional line width for a hovered point.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
                     *         2 pixels wider on hover
                     * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
                     *         2 pixels wider on hover
                     *
                     * @since 4.0.3
                     */
                    lineWidthPlus: 1
                },
                /**
                 * The appearance of the point marker when selected. In order to
                 * allow a point to be selected, set the
                 * `series.allowPointSelect` option to true.
                 *
                 * @declare Highcharts.PointStatesSelectOptionsObject
                 */
                select: {
                    /**
                     * Enable or disable visible feedback for selection.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-enabled/
                     *         Disabled select state
                     *
                     * @type      {boolean}
                     * @default   true
                     * @apioption plotOptions.series.marker.states.select.enabled
                     */
                    /**
                     * The radius of the point marker. In hover state, it
                     * defaults to the normal state's radius + 2.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-radius/
                     *         10px radius for selected points
                     *
                     * @type      {number}
                     * @apioption plotOptions.series.marker.states.select.radius
                     */
                    /**
                     * The fill color of the point marker.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-fillcolor/
                     *         Solid red discs for selected points
                     *
                     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                     */
                    fillColor: "#cccccc" /* Palette.neutralColor20 */,
                    /**
                     * The color of the point marker's outline. When
                     * `undefined`, the series' or point's color is used.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-linecolor/
                     *         Red line color for selected points
                     *
                     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                     */
                    lineColor: "#000000" /* Palette.neutralColor100 */,
                    /**
                     * The width of the point marker's outline.
                     *
                     * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-linewidth/
                     *         3px line width for selected points
                     */
                    lineWidth: 2
                }
            }
        },
        /**
         * Properties for each single point.
         *
         * @declare Highcharts.PlotSeriesPointOptions
         *
         * @private
         */
        point: {
            /**
             * Fires when a point is clicked. One parameter, `event`, is passed
             * to the function, containing common event information.
             *
             * If the `series.allowPointSelect` option is true, the default
             * action for the point's click event is to toggle the point's
             * select state. Returning `false` cancels this action.
             *
             * @sample {highcharts} highcharts/plotoptions/series-point-events-click/
             *         Click marker to alert values
             * @sample {highcharts} highcharts/plotoptions/series-point-events-click-column/
             *         Click column
             * @sample {highcharts} highcharts/plotoptions/series-point-events-click-url/
             *         Go to URL
             * @sample {highmaps} maps/plotoptions/series-point-events-click/
             *         Click marker to display values
             * @sample {highmaps} maps/plotoptions/series-point-events-click-url/
             *         Go to URL
             *
             * @type      {Highcharts.PointClickCallbackFunction}
             * @context   Highcharts.Point
             * @apioption plotOptions.series.point.events.click
             */
            /**
             * Fires when the mouse leaves the area close to the point. One
             * parameter, `event`, is passed to the function, containing common
             * event information.
             *
             * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
             *         Show values in the chart's corner on mouse over
             *
             * @type      {Highcharts.PointMouseOutCallbackFunction}
             * @context   Highcharts.Point
             * @apioption plotOptions.series.point.events.mouseOut
             */
            /**
             * Fires when the mouse enters the area close to the point. One
             * parameter, `event`, is passed to the function, containing common
             * event information.
             *
             * Returning `false` cancels the default behavior, which is to show a
             * tooltip for the point.
             *
             * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
             *         Show values in the chart's corner on mouse over
             *
             * @type      {Highcharts.PointMouseOverCallbackFunction}
             * @context   Highcharts.Point
             * @apioption plotOptions.series.point.events.mouseOver
             */
            /**
             * Fires when the point is removed using the `.remove()` method. One
             * parameter, `event`, is passed to the function. Returning `false`
             * cancels the operation.
             *
             * @sample {highcharts} highcharts/plotoptions/series-point-events-remove/
             *         Remove point and confirm
             *
             * @type      {Highcharts.PointRemoveCallbackFunction}
             * @since     1.2.0
             * @context   Highcharts.Point
             * @apioption plotOptions.series.point.events.remove
             */
            /**
             * Fires when the point is selected either programmatically or
             * following a click on the point. One parameter, `event`, is passed
             * to the function. Returning `false` cancels the operation.
             *
             * @sample {highcharts} highcharts/plotoptions/series-point-events-select/
             *         Report the last selected point
             * @sample {highmaps} maps/plotoptions/series-allowpointselect/
             *         Report select and unselect
             *
             * @type      {Highcharts.PointSelectCallbackFunction}
             * @since     1.2.0
             * @context   Highcharts.Point
             * @apioption plotOptions.series.point.events.select
             */
            /**
             * Fires when the point is unselected either programmatically or
             * following a click on the point. One parameter, `event`, is passed
             * to the function.
             *  Returning `false` cancels the operation.
             *
             * @sample {highcharts} highcharts/plotoptions/series-point-events-unselect/
             *         Report the last unselected point
             * @sample {highmaps} maps/plotoptions/series-allowpointselect/
             *         Report select and unselect
             *
             * @type      {Highcharts.PointUnselectCallbackFunction}
             * @since     1.2.0
             * @context   Highcharts.Point
             * @apioption plotOptions.series.point.events.unselect
             */
            /**
             * Fires when the point is updated programmatically through the
             * `.update()` method. One parameter, `event`, is passed to the
             * function. The new point options can be accessed through
             * `event.options`. Returning `false` cancels the operation.
             *
             * @sample {highcharts} highcharts/plotoptions/series-point-events-update/
             *         Confirm point updating
             *
             * @type      {Highcharts.PointUpdateCallbackFunction}
             * @since     1.2.0
             * @context   Highcharts.Point
             * @apioption plotOptions.series.point.events.update
             */
            /**
             * Events for each single point.
             *
             * @declare Highcharts.PointEventsOptionsObject
             */
            events: {}
        },
        /**
         * Options for the series data labels, appearing next to each data
         * point.
         *
         * Since v6.2.0, multiple data labels can be applied to each single
         * point by defining them as an array of configs.
         *
         * In styled mode, the data labels can be styled with the
         * `.highcharts-data-label-box` and `.highcharts-data-label` class names
         * ([see example](https://www.highcharts.com/samples/highcharts/css/series-datalabels)).
         *
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-enabled
         *         Data labels enabled
         * @sample {highcharts} highcharts/plotoptions/series-datalabels-multiple
         *         Multiple data labels on a bar series
         * @sample {highcharts} highcharts/css/series-datalabels
         *         Styled mode example
         * @sample {highmaps} maps/demo/color-axis
         *         Choropleth map with data labels
         * @sample {highmaps} maps/demo/mappoint-datalabels-mapmarker
         *         Using data labels as map markers
         *
         * @type    {*|Array<*>}
         * @product highcharts highstock highmaps gantt
         *
         * @private
         */
        dataLabels: {
            /**
             * Enable or disable the initial animation when a series is displayed
             * for the `dataLabels`. The animation can also be set as a
             * configuration object. Please note that this option only applies to
             * the initial animation.
             *
             * For other animations, see [chart.animation](#chart.animation) and the
             * animation parameter under the API methods. The following properties
             * are supported:
             *
             * - `defer`: The animation delay time in milliseconds.
             *
             * @sample {highcharts} highcharts/plotoptions/animation-defer/
             *          Animation defer settings
             *
             * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
             * @since     8.2.0
             * @apioption plotOptions.series.dataLabels.animation
             */
            animation: {},
            /**
             * The animation delay time in milliseconds. Set to `0` to render the
             * data labels immediately. As `undefined` inherits defer time from the
             * [series.animation.defer](#plotOptions.series.animation.defer).
             *
             * @type      {number}
             * @since     8.2.0
             * @apioption plotOptions.series.dataLabels.animation.defer
             */
            /**
             * The alignment of the data label compared to the point. If `right`,
             * the right side of the label should be touching the point. For points
             * with an extent, like columns, the alignments also dictates how to
             * align it inside the box, as given with the
             * [inside](#plotOptions.column.dataLabels.inside) option. Can be one of
             * `left`, `center` or `right`.
             *
             * @sample {highcharts}
             *         highcharts/plotoptions/series-datalabels-align-left/ Left
             *         aligned
             * @sample {highcharts}
             *         highcharts/plotoptions/bar-datalabels-align-inside-bar/ Data
             *         labels inside the bar
             *
             * @type {Highcharts.AlignValue|null}
             */
            align: 'center',
            /**
             * Whether to allow data labels to overlap. To make the labels less
             * sensitive for overlapping, the
             * [dataLabels.padding](#plotOptions.series.dataLabels.padding)
             * can be set to 0.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-allowoverlap-false/
             *         Don't allow overlap
             *
             * @type      {boolean}
             * @default   false
             * @since     4.1.0
             * @apioption plotOptions.series.dataLabels.allowOverlap
             */
            /**
             * The background color or gradient for the data label. Setting it to
             * `auto` will use the point's color.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
             *         Data labels box options
             * @sample {highmaps} maps/plotoptions/series-datalabels-box/
             *         Data labels box options
             * @sample {highmaps} maps/demo/mappoint-datalabels-mapmarker
             *         Data labels as map markers
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @since     2.2.1
             * @apioption plotOptions.series.dataLabels.backgroundColor
             */
            /**
             * The border color for the data label. Setting it to `auto` will use
             * the point's color. Defaults to `undefined`.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
             *         Data labels box options
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @since     2.2.1
             * @apioption plotOptions.series.dataLabels.borderColor
             */
            /**
             * The border radius in pixels for the data label.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
             *         Data labels box options
             * @sample {highmaps} maps/plotoptions/series-datalabels-box/
             *         Data labels box options
             *
             * @type      {number}
             * @default   0
             * @since     2.2.1
             * @apioption plotOptions.series.dataLabels.borderRadius
             */
            /**
             * The border width in pixels for the data label.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
             *         Data labels box options
             *
             * @type      {number}
             * @default   0
             * @since     2.2.1
             * @apioption plotOptions.series.dataLabels.borderWidth
             */
            borderWidth: 0,
            /**
             * A class name for the data label. Particularly in styled mode,
             * this can be used to give each series' or point's data label
             * unique styling. In addition to this option, a default color class
             * name is added so that we can give the labels a contrast text
             * shadow.
             *
             * @sample {highcharts} highcharts/css/data-label-contrast/
             *         Contrast text shadow
             * @sample {highcharts} highcharts/css/series-datalabels/
             *         Styling by CSS
             *
             * @type      {string}
             * @since     5.0.0
             * @apioption plotOptions.series.dataLabels.className
             */
            /**
             * This options is deprecated.
             * Use [style.color](#plotOptions.series.dataLabels.style) instead.
             *
             * The text color for the data labels. Defaults to `undefined`. For
             * certain series types, like column or map, the data labels can be
             * drawn inside the points. In this case the data label will be
             * drawn with maximum contrast by default. Additionally, it will be
             * given a `text-outline` style with the opposite color, to further
             * increase the contrast. This can be overridden by setting the
             * `text-outline` style to `none` in the `dataLabels.style` option.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-color/
             *         Red data labels
             * @sample {highmaps} maps/demo/color-axis/
             *         White data labels
             *
             * @see [style.color](#plotOptions.series.dataLabels.style)
             *
             * @type       {Highcharts.ColorType}
             * @deprecated 10.3
             * @apioption  plotOptions.series.dataLabels.color
             */
            /**
             * Whether to hide data labels that are outside the plot area. By
             * default, the data label is moved inside the plot area according
             * to the
             * [overflow](#plotOptions.series.dataLabels.overflow)
             * option.
             *
             * @type      {boolean}
             * @default   true
             * @since     2.3.3
             * @apioption plotOptions.series.dataLabels.crop
             */
            /**
             * Whether to defer displaying the data labels until the initial
             * series animation has finished. Setting to `false` renders the
             * data label immediately. If set to `true` inherits the defer
             * time set in [plotOptions.series.animation](#plotOptions.series.animation).
             *
             * @since     4.0.0
             * @type      {boolean}
             * @product   highcharts highstock gantt
             */
            defer: true,
            /**
             * Enable or disable the data labels.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-enabled/
             *         Data labels enabled
             * @sample {highmaps} maps/demo/color-axis/
             *         Data labels enabled
             *
             * @type      {boolean}
             * @default   false
             * @apioption plotOptions.series.dataLabels.enabled
             */
            /**
             * A declarative filter to control of which data labels to display.
             * The declarative filter is designed for use when callback
             * functions are not available, like when the chart options require
             * a pure JSON structure or for use with graphical editors. For
             * programmatic control, use the `formatter` instead, and return
             * `undefined` to disable a single data label.
             *
             * @example
             * filter: {
             *     property: 'percentage',
             *     operator: '>',
             *     value: 4
             * }
             *
             * @sample {highcharts} highcharts/demo/pie-monochrome
             *         Data labels filtered by percentage
             *
             * @declare   Highcharts.DataLabelsFilterOptionsObject
             * @since     6.0.3
             * @apioption plotOptions.series.dataLabels.filter
             */
            /**
             * The operator to compare by. Can be one of `>`, `<`, `>=`, `<=`,
             * `==`, and `===`.
             *
             * @type       {string}
             * @validvalue [">", "<", ">=", "<=", "==", "==="]
             * @apioption  plotOptions.series.dataLabels.filter.operator
             */
            /**
             * The point property to filter by. Point options are passed
             * directly to properties, additionally there are `y` value,
             * `percentage` and others listed under {@link Highcharts.Point}
             * members.
             *
             * @type      {string}
             * @apioption plotOptions.series.dataLabels.filter.property
             */
            /**
             * The value to compare against.
             *
             * @type      {number}
             * @apioption plotOptions.series.dataLabels.filter.value
             */
            /**
             * A
             * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
             * for the data label. Available variables are the same as for
             * `formatter`.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-format/
             *         Add a unit
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-format-subexpression/
             *         Complex logic in the format string
             * @sample {highmaps} maps/plotoptions/series-datalabels-format/
             *         Formatted value in the data label
             *
             * @type      {string}
             * @default   y
             * @default   point.value
             * @since     3.0
             * @apioption plotOptions.series.dataLabels.format
             */
            // eslint-disable-next-line valid-jsdoc
            /**
             * Callback JavaScript function to format the data label. Note that if a
             * `format` is defined, the format takes precedence and the formatter is
             * ignored.
             *
             * @sample {highmaps} maps/plotoptions/series-datalabels-format/
             *         Formatted value
             *
             * @type {Highcharts.DataLabelsFormatterCallbackFunction}
             */
            formatter: function () {
                const { numberFormatter } = this.series.chart;
                return typeof this.y !== 'number' ?
                    '' : numberFormatter(this.y, -1);
            },
            /**
             * For points with an extent, like columns or map areas, whether to
             * align the data label inside the box or to the actual value point.
             * Defaults to `false` in most cases, `true` in stacked columns.
             *
             * @type      {boolean}
             * @since     3.0
             * @apioption plotOptions.series.dataLabels.inside
             */
            /**
             * Format for points with the value of null. Works analogously to
             * [format](#plotOptions.series.dataLabels.format). `nullFormat` can
             * be applied only to series which support displaying null points
             * i.e `heatmap` or `tilemap`. Does not work with series that don't
             * display null points, like `line`, `column`, `bar` or `pie`.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-nullformat/
             *         Format data label for null points in heat map
             *
             * @type      {boolean|string}
             * @since     7.1.0
             * @apioption plotOptions.series.dataLabels.nullFormat
             */
            /**
             * Callback JavaScript function that defines formatting for points
             * with the value of null. Works analogously to
             * [formatter](#plotOptions.series.dataLabels.formatter).
             * `nullFormatter` can be applied only to series which support
             * displaying null points i.e `heatmap` or `tilemap`. Does not work
             * with series that don't display null points, like `line`, `column`,
             * `bar` or `pie`.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-nullformat/
             *         Format data label for null points in heat map
             *
             * @type      {Highcharts.DataLabelsFormatterCallbackFunction}
             * @since     7.1.0
             * @apioption plotOptions.series.dataLabels.nullFormatter
             */
            /**
             * How to handle data labels that flow outside the plot area. The
             * default is `"justify"`, which aligns them inside the plot area.
             * For columns and bars, this means it will be moved inside the bar.
             * To display data labels outside the plot area, set `crop` to
             * `false` and `overflow` to `"allow"`.
             *
             * @type       {Highcharts.DataLabelsOverflowValue}
             * @default    justify
             * @since      3.0.6
             * @apioption  plotOptions.series.dataLabels.overflow
             */
            /**
             * When either the `borderWidth` or the `backgroundColor` is set,
             * this is the padding within the box.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
             *         Data labels box options
             * @sample {highmaps} maps/plotoptions/series-datalabels-box/
             *         Data labels box options
             *
             * @since 2.2.1
             */
            padding: 5,
            /**
             * Aligns data labels relative to points. If `center` alignment is
             * not possible, it defaults to `right`.
             *
             * @type      {Highcharts.AlignValue}
             * @default   center
             * @apioption plotOptions.series.dataLabels.position
             */
            /**
             * Text rotation in degrees. Note that due to a more complex
             * structure, backgrounds, borders and padding will be lost on a
             * rotated data label.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
             *         Vertical labels
             *
             * @type      {number}
             * @default   0
             * @apioption plotOptions.series.dataLabels.rotation
             */
            /**
             * The shadow of the box. Works best with `borderWidth` or
             * `backgroundColor`. Since 2.3 the shadow can be an object
             * configuration containing `color`, `offsetX`, `offsetY`, `opacity`
             * and `width`.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
             *         Data labels box options
             *
             * @type      {boolean|Highcharts.ShadowOptionsObject}
             * @default   false
             * @since     2.2.1
             * @apioption plotOptions.series.dataLabels.shadow
             */
            /**
             * The name of a symbol to use for the border around the label.
             * Symbols are predefined functions on the Renderer object.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-shape/
             *         A callout for annotations
             *
             * @type      {string}
             * @default   square
             * @since     4.1.2
             * @apioption plotOptions.series.dataLabels.shape
             */
            /**
             * Styles for the label. The default `color` setting is
             * `"contrast"`, which is a pseudo color that Highcharts picks up
             * and applies the maximum contrast to the underlying point item,
             * for example the bar in a bar chart.
             *
             * The `textOutline` is a pseudo property that applies an outline of
             * the given width with the given color, which by default is the
             * maximum contrast to the text. So a bright text color will result
             * in a black text outline for maximum readability on a mixed
             * background. In some cases, especially with grayscale text, the
             * text outline doesn't work well, in which cases it can be disabled
             * by setting it to `"none"`. When `useHTML` is true, the
             * `textOutline` will not be picked up. In this, case, the same
             * effect can be acheived through the `text-shadow` CSS property.
             *
             * For some series types, where each point has an extent, like for
             * example tree maps, the data label may overflow the point. There
             * are two strategies for handling overflow. By default, the text
             * will wrap to multiple lines. The other strategy is to set
             * `style.textOverflow` to `ellipsis`, which will keep the text on
             * one line plus it will break inside long words.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-style/
             *         Bold labels
             * @sample {highcharts} highcharts/plotoptions/pie-datalabels-overflow/
             *         Long labels truncated with an ellipsis in a pie
             * @sample {highcharts} highcharts/plotoptions/pie-datalabels-overflow-wrap/
             *         Long labels are wrapped in a pie
             * @sample {highmaps} maps/demo/color-axis/
             *         Bold labels
             *
             * @type      {Highcharts.CSSObject}
             * @since     4.1.0
             * @apioption plotOptions.series.dataLabels.style
             */
            style: {
                /** @internal */
                fontSize: '0.7em',
                /** @internal */
                fontWeight: 'bold',
                /** @internal */
                color: 'contrast',
                /** @internal */
                textOutline: '1px contrast'
            },
            /**
             * Options for a label text which should follow marker's shape.
             * Border and background are disabled for a label that follows a
             * path.
             *
             * **Note:** Only SVG-based renderer supports this option. Setting
             * `useHTML` to true will disable this option.
             *
             * @declare   Highcharts.DataLabelsTextPathOptionsObject
             * @since     7.1.0
             * @apioption plotOptions.series.dataLabels.textPath
             */
            /**
             * Presentation attributes for the text path.
             *
             * @type      {Highcharts.SVGAttributes}
             * @since     7.1.0
             * @apioption plotOptions.series.dataLabels.textPath.attributes
             */
            /**
             * Enable or disable `textPath` option for link's or marker's data
             * labels.
             *
             * @type      {boolean}
             * @since     7.1.0
             * @apioption plotOptions.series.dataLabels.textPath.enabled
             */
            /**
             * Whether to
             * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
             * to render the labels.
             *
             * @type      {boolean}
             * @default   false
             * @apioption plotOptions.series.dataLabels.useHTML
             */
            /**
             * The vertical alignment of a data label. Can be one of `top`,
             * `middle` or `bottom`. The default value depends on the data, for
             * instance in a column chart, the label is above positive values
             * and below negative values.
             *
             * @type  {Highcharts.VerticalAlignValue|null}
             * @since 2.3.3
             */
            verticalAlign: 'bottom',
            /**
             * The x position offset of the label relative to the point in
             * pixels.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
             *         Vertical and positioned
             * @sample {highcharts} highcharts/plotoptions/bar-datalabels-align-inside-bar/
             *         Data labels inside the bar
             */
            x: 0,
            /**
             * The z index of the data labels. Use a `zIndex` of 6 to display it above
             * the series, or use a `zIndex` of 2 to display it behind the series.
             *
             * @type      {number}
             * @default   6
             * @since     2.3.5
             * @apioption plotOptions.series.dataLabels.zIndex
             */
            /**
             * The y position offset of the label relative to the point in
             * pixels.
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
             *         Vertical and positioned
             */
            y: 0
        },
        /**
         * When the series contains less points than the crop threshold, all
         * points are drawn, even if the points fall outside the visible plot
         * area at the current zoom. The advantage of drawing all points
         * (including markers and columns), is that animation is performed on
         * updates. On the other hand, when the series contains more points than
         * the crop threshold, the series data is cropped to only contain points
         * that fall within the plot area. The advantage of cropping away
         * invisible points is to increase performance on large series.
         *
         * @since   2.2
         * @product highcharts highstock
         *
         * @private
         */
        cropThreshold: 300,
        /**
         * Opacity of a series parts: line, fill (e.g. area) and dataLabels.
         *
         * @see [states.inactive.opacity](#plotOptions.series.states.inactive.opacity)
         *
         * @since 7.1.0
         *
         * @private
         */
        opacity: 1,
        /**
         * The width of each point on the x axis. For example in a column chart
         * with one value each day, the pointRange would be 1 day (= 24 * 3600
         * * 1000 milliseconds). This is normally computed automatically, but
         * this option can be used to override the automatic value.
         *
         * @product highstock
         *
         * @private
         */
        pointRange: 0,
        /**
         * When this is true, the series will not cause the Y axis to cross
         * the zero plane (or [threshold](#plotOptions.series.threshold) option)
         * unless the data actually crosses the plane.
         *
         * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
         * 3 will make the Y axis show negative values according to the
         * `minPadding` option. If `softThreshold` is `true`, the Y axis starts
         * at 0.
         *
         * @since   4.1.9
         * @product highcharts highstock
         *
         * @private
         */
        softThreshold: true,
        /**
         * @declare Highcharts.SeriesStatesOptionsObject
         *
         * @private
         */
        states: {
            /**
             * The normal state of a series, or for point items in column, pie
             * and similar series. Currently only used for setting animation
             * when returning to normal state from hover.
             *
             * @declare Highcharts.SeriesStatesNormalOptionsObject
             */
            normal: {
                /**
                 * Animation when returning to normal state after hovering.
                 *
                     * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
                 */
                animation: true
            },
            /**
             * Options for the hovered series. These settings override the
             * normal state options when a series is moused over or touched.
             *
             * @declare Highcharts.SeriesStatesHoverOptionsObject
             */
            hover: {
                /**
                 * Enable separate styles for the hovered series to visualize
                 * that the user hovers either the series itself or the legend.
                 *
                 * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled/
                 *         Line
                 * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-column/
                 *         Column
                 * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-pie/
                 *         Pie
                 *
                 * @type      {boolean}
                 * @default   true
                 * @since     1.2
                 * @apioption plotOptions.series.states.hover.enabled
                 */
                /**
                 * Animation setting for hovering the graph in line-type series.
                 *
                 * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
                 * @since   5.0.8
                 * @product highcharts highstock
                 */
                animation: {
                    /**
                     * The duration of the hover animation in milliseconds. By
                     * default the hover state animates quickly in, and slowly
                     * back to normal.
                     *
                     * @internal
                     */
                    duration: 150
                },
                /**
                 * Pixel width of the graph line. By default this property is
                 * undefined, and the `lineWidthPlus` property dictates how much
                 * to increase the linewidth from normal state.
                 *
                 * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidth/
                 *         5px line on hover
                 *
                 * @type      {number}
                 * @product   highcharts highstock
                 * @apioption plotOptions.series.states.hover.lineWidth
                 */
                /**
                 * The additional line width for the graph of a hovered series.
                 *
                 * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
                 *         5 pixels wider
                 * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
                 *         5 pixels wider
                 *
                 * @since   4.0.3
                 * @product highcharts highstock
                 */
                lineWidthPlus: 1,
                /**
                 * In Highcharts 1.0, the appearance of all markers belonging
                 * to the hovered series. For settings on the hover state of the
                 * individual point, see
                 * [marker.states.hover](#plotOptions.series.marker.states.hover).
                 *
                 * @deprecated
                 *
                 * @extends   plotOptions.series.marker
                 * @excluding states, symbol
                 * @product   highcharts highstock
                 */
                marker: {
                // lineWidth: base + 1,
                // radius: base + 1
                },
                /**
                 * Options for the halo appearing around the hovered point in
                 * line-type series as well as outside the hovered slice in pie
                 * charts. By default the halo is filled by the current point or
                 * series color with an opacity of 0.25\. The halo can be
                 * disabled by setting the `halo` option to `null`.
                 *
                 * In styled mode, the halo is styled with the
                 * `.highcharts-halo` class, with colors inherited from
                 * `.highcharts-color-{n}`.
                 *
                 * @sample {highcharts} highcharts/plotoptions/halo/
                 *         Halo options
                 * @sample {highstock} highcharts/plotoptions/halo/
                 *         Halo options
                 *
                 * @declare Highcharts.SeriesStatesHoverHaloOptionsObject
                 * @type    {null|*}
                 * @since   4.0
                 * @product highcharts highstock
                 */
                halo: {
                    /**
                     * A collection of SVG attributes to override the appearance
                     * of the halo, for example `fill`, `stroke` and
                     * `stroke-width`.
                     *
                     * @type      {Highcharts.SVGAttributes}
                     * @since     4.0
                     * @product   highcharts highstock
                     * @apioption plotOptions.series.states.hover.halo.attributes
                     */
                    /**
                     * The pixel size of the halo. For point markers this is the
                     * radius of the halo. For pie slices it is the width of the
                     * halo outside the slice. For bubbles it defaults to 5 and
                     * is the width of the halo outside the bubble.
                     *
                     * @since   4.0
                     * @product highcharts highstock
                     */
                    size: 10,
                    /**
                     * Opacity for the halo unless a specific fill is overridden
                     * using the `attributes` setting. Note that Highcharts is
                     * only able to apply opacity to colors of hex or rgb(a)
                     * formats.
                     *
                     * @since   4.0
                     * @product highcharts highstock
                     */
                    opacity: 0.25
                }
            },
            /**
             * Specific options for point in selected states, after being
             * selected by
             * [allowPointSelect](#plotOptions.series.allowPointSelect)
             * or programmatically.
             *
             * @sample maps/plotoptions/series-allowpointselect/
             *         Allow point select demo
             *
             * @declare   Highcharts.SeriesStatesSelectOptionsObject
             * @extends   plotOptions.series.states.hover
             * @excluding brightness
             */
            select: {
                animation: {
                    /** @internal */
                    duration: 0
                }
            },
            /**
             * The opposite state of a hover for series.
             *
             * @sample highcharts/plotoptions/series-states-inactive-disabled
             *         Disabled inactive state
             *
             * @declare Highcharts.SeriesStatesInactiveOptionsObject
             */
            inactive: {
                /**
                 * Enable or disable the inactive state for a series
                 *
                 * @sample highcharts/plotoptions/series-states-inactive-disabled
                 *         Disabled inactive state
                 *
                 * @type {boolean}
                 * @default true
                 * @apioption plotOptions.series.states.inactive.enabled
                 */
                /**
                 * The animation for entering the inactive state.
                 *
                 * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
                 */
                animation: {
                    /** @internal */
                    duration: 150
                },
                /**
                 * Opacity of series elements (dataLabels, line, area).
                 *
                 * @type {number}
                 */
                opacity: 0.2
            }
        },
        /**
         * Sticky tracking of mouse events. When true, the `mouseOut` event on a
         * series isn't triggered until the mouse moves over another series, or
         * out of the plot area. When false, the `mouseOut` event on a series is
         * triggered when the mouse leaves the area around the series' graph or
         * markers. This also implies the tooltip when not shared. When
         * `stickyTracking` is false and `tooltip.shared` is false, the tooltip
         * will be hidden when moving the mouse between series. Defaults to true
         * for line and area type series, but to false for columns, pies etc.
         *
         * **Note:** The boost module will force this option because of
         * technical limitations.
         *
         * @sample {highcharts} highcharts/plotoptions/series-stickytracking-true/
         *         True by default
         * @sample {highcharts} highcharts/plotoptions/series-stickytracking-false/
         *         False
         *
         * @default {highcharts} true
         * @default {highstock} true
         * @default {highmaps} false
         * @since   2.0
         *
         * @private
         */
        stickyTracking: true,
        /**
         * A configuration object for the tooltip rendering of each single
         * series. Properties are inherited from [tooltip](#tooltip), but only
         * the following properties can be defined on a series level.
         *
         * @declare   Highcharts.SeriesTooltipOptionsObject
         * @since     2.3
         * @extends   tooltip
         * @excluding animation, backgroundColor, borderColor, borderRadius,
         *            borderWidth, className, crosshairs, enabled, formatter,
         *            headerShape, hideDelay, outside, padding, positioner,
         *            shadow, shape, shared, snap, split, stickOnContact,
         *            style, useHTML
         * @apioption plotOptions.series.tooltip
         */
        /**
         * When a series contains a data array that is longer than this, only
         * one dimensional arrays of numbers, or two dimensional arrays with
         * x and y values are allowed. Also, only the first point is tested,
         * and the rest are assumed to be the same format. This saves expensive
         * data checking and indexing in long series. Set it to `0` disable.
         *
         * Note:
         * In boost mode turbo threshold is forced. Only array of numbers or
         * two dimensional arrays are allowed.
         *
         * @since   2.2
         * @product highcharts highstock gantt
         *
         * @private
         */
        turboThreshold: 1000,
        /**
         * An array defining zones within a series. Zones can be applied to the
         * X axis, Y axis or Z axis for bubbles, according to the `zoneAxis`
         * option. The zone definitions have to be in ascending order regarding
         * to the value.
         *
         * In styled mode, the color zones are styled with the
         * `.highcharts-zone-{n}` class, or custom classed from the `className`
         * option
         * ([view live demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/color-zones/)).
         *
         * @see [zoneAxis](#plotOptions.series.zoneAxis)
         *
         * @sample {highcharts} highcharts/series/color-zones-simple/
         *         Color zones
         * @sample {highstock} highcharts/series/color-zones-simple/
         *         Color zones
         *
         * @declare   Highcharts.SeriesZonesOptionsObject
         * @type      {Array<*>}
         * @since     4.1.0
         * @product   highcharts highstock
         * @apioption plotOptions.series.zones
         */
        /**
         * Styled mode only. A custom class name for the zone.
         *
         * @sample highcharts/css/color-zones/
         *         Zones styled by class name
         *
         * @type      {string}
         * @since     5.0.0
         * @apioption plotOptions.series.zones.className
         */
        /**
         * Defines the color of the series.
         *
         * @see [series color](#plotOptions.series.color)
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @since     4.1.0
         * @product   highcharts highstock
         * @apioption plotOptions.series.zones.color
         */
        /**
         * A name for the dash style to use for the graph.
         *
         * @see [plotOptions.series.dashStyle](#plotOptions.series.dashStyle)
         *
         * @sample {highcharts|highstock} highcharts/series/color-zones-dashstyle-dot/
         *         Dashed line indicates prognosis
         *
         * @type      {Highcharts.DashStyleValue}
         * @since     4.1.0
         * @product   highcharts highstock
         * @apioption plotOptions.series.zones.dashStyle
         */
        /**
         * Defines the fill color for the series (in area type series)
         *
         * @see [fillColor](#plotOptions.area.fillColor)
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @since     4.1.0
         * @product   highcharts highstock
         * @apioption plotOptions.series.zones.fillColor
         */
        /**
         * The value up to where the zone extends, if undefined the zones
         * stretches to the last value in the series.
         *
         * @type      {number}
         * @since     4.1.0
         * @product   highcharts highstock
         * @apioption plotOptions.series.zones.value
         */
        /**
         * When using dual or multiple color axes, this number defines which
         * colorAxis the particular series is connected to. It refers to
         * either the
         * {@link #colorAxis.id|axis id}
         * or the index of the axis in the colorAxis array, with 0 being the
         * first. Set this option to false to prevent a series from connecting
         * to the default color axis.
         *
         * Since v7.2.0 the option can also be an axis id or an axis index
         * instead of a boolean flag.
         *
         * @sample highcharts/coloraxis/coloraxis-with-pie/
         *         Color axis with pie series
         * @sample highcharts/coloraxis/multiple-coloraxis/
         *         Multiple color axis
         *
         * @type      {number|string|boolean}
         * @default   0
         * @product   highcharts highstock highmaps
         * @apioption plotOptions.series.colorAxis
         */
        /**
         * Determines what data value should be used to calculate point color
         * if `colorAxis` is used. Requires to set `min` and `max` if some
         * custom point property is used or if approximation for data grouping
         * is set to `'sum'`.
         *
         * @sample highcharts/coloraxis/custom-color-key/
         *         Custom color key
         * @sample highcharts/coloraxis/color-key-with-stops/
         *         Custom colorKey with color axis stops
         * @sample highcharts/coloraxis/changed-default-color-key/
         *         Changed default color key
         *
         * @type      {string}
         * @default   y
         * @since     7.2.0
         * @product   highcharts highstock highmaps
         * @apioption plotOptions.series.colorKey
         */
        /**
         * What type of legend symbol to render for this series. Can be one of
         * `lineMarker` or `rectangle`.
         *
         * @validvalue ["lineMarker", "rectangle"]
         *
         * @sample {highcharts} highcharts/series/legend-symbol/
         *         Change the legend symbol
         *
         * @type      {string}
         * @default   rectangle
         * @since     11.0.1
         * @apioption plotOptions.series.legendSymbol
         */
        /**
         * Determines whether the series should look for the nearest point
         * in both dimensions or just the x-dimension when hovering the series.
         * Defaults to `'xy'` for scatter series and `'x'` for most other
         * series. If the data has duplicate x-values, it is recommended to
         * set this to `'xy'` to allow hovering over all points.
         *
         * Applies only to series types using nearest neighbor search (not
         * direct hover) for tooltip.
         *
         * @sample {highcharts} highcharts/series/findnearestpointby/
         *         Different hover behaviors
         * @sample {highstock} highcharts/series/findnearestpointby/
         *         Different hover behaviors
         * @sample {highmaps} highcharts/series/findnearestpointby/
         *         Different hover behaviors
         *
         * @since      5.0.10
         * @validvalue ["x", "xy"]
         *
         * @private
         */
        findNearestPointBy: 'x'
    };

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { defaultOptions: defaultOptions$2 } = DefaultOptions;
    const { extendClass, merge: merge$6 } = Utilities;
    /* *
     *
     *  Namespace
     *
     * */
    var SeriesRegistry;
    (function (SeriesRegistry) {
        /* *
         *
         *  Properties
         *
         * */
        /**
         * @internal
         * @todo Move `Globals.seriesTypes` code to her.
         */
        SeriesRegistry.seriesTypes = H.seriesTypes;
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Registers class pattern of a series.
         *
         * @private
         */
        function registerSeriesType(seriesType, SeriesClass) {
            const defaultPlotOptions = defaultOptions$2.plotOptions || {}, seriesOptions = SeriesClass.defaultOptions, seriesProto = SeriesClass.prototype;
            seriesProto.type = seriesType;
            if (!seriesProto.pointClass) {
                seriesProto.pointClass = Point;
            }
            if (seriesOptions) {
                defaultPlotOptions[seriesType] = seriesOptions;
            }
            SeriesRegistry.seriesTypes[seriesType] = SeriesClass;
        }
        SeriesRegistry.registerSeriesType = registerSeriesType;
        /**
         * Old factory to create new series prototypes.
         *
         * @deprecated
         * @function Highcharts.seriesType
         *
         * @param {string} type
         * The series type name.
         *
         * @param {string} parent
         * The parent series type name. Use `line` to inherit from the basic
         * {@link Series} object.
         *
         * @param {Highcharts.SeriesOptionsType|Highcharts.Dictionary<*>} options
         * The additional default options that are merged with the parent's options.
         *
         * @param {Highcharts.Dictionary<*>} [props]
         * The properties (functions and primitives) to set on the new prototype.
         *
         * @param {Highcharts.Dictionary<*>} [pointProps]
         * Members for a series-specific extension of the {@link Point} prototype if
         * needed.
         *
         * @return {Highcharts.Series}
         * The newly created prototype as extended from {@link Series} or its
         * derivatives.
         */
        function seriesType(type, parent, options, seriesProto, pointProto) {
            const defaultPlotOptions = defaultOptions$2.plotOptions || {};
            parent = parent || '';
            // Merge the options
            defaultPlotOptions[type] = merge$6(defaultPlotOptions[parent], options);
            // Create the class
            registerSeriesType(type, extendClass(SeriesRegistry.seriesTypes[parent] || function () { }, seriesProto));
            SeriesRegistry.seriesTypes[type].prototype.type = type;
            // Create the point class if needed
            if (pointProto) {
                SeriesRegistry.seriesTypes[type].prototype.pointClass = extendClass(Point, pointProto);
            }
            return SeriesRegistry.seriesTypes[type];
        }
        SeriesRegistry.seriesType = seriesType;
    })(SeriesRegistry || (SeriesRegistry = {}));
    /* *
     *
     *  Default Export
     *
     * */
    var SeriesRegistry$1 = SeriesRegistry;

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { animate: animate$1, animObject: animObject$3, stop } = animationExports;
    const { deg2rad: deg2rad$1, doc: doc$3, noop: noop$2, svg: svg$2, SVG_NS: SVG_NS$2, win: win$4 } = H;
    const { addEvent: addEvent$3, attr: attr$3, createElement: createElement$2, css: css$2, defined: defined$6, erase: erase$2, extend: extend$6, fireEvent: fireEvent$4, isArray: isArray$4, isFunction, isObject: isObject$2, isString: isString$4, merge: merge$5, objectEach: objectEach$4, pick: pick$7, pInt: pInt$2, syncTimeout: syncTimeout$2, uniqueKey: uniqueKey$2 } = Utilities;
    /* *
     *
     *  Class
     *
     * */
    /* eslint-disable no-invalid-this, valid-jsdoc */
    /**
     * The SVGElement prototype is a JavaScript wrapper for SVG elements used in the
     * rendering layer of Highcharts. Combined with the
     * {@link Highcharts.SVGRenderer}
     * object, these prototypes allow freeform annotation in the charts or even in
     * HTML pages without instanciating a chart. The SVGElement can also wrap HTML
     * labels, when `text` or `label` elements are created with the `useHTML`
     * parameter.
     *
     * The SVGElement instances are created through factory functions on the
     * {@link Highcharts.SVGRenderer}
     * object, like
     * {@link Highcharts.SVGRenderer#rect|rect},
     * {@link Highcharts.SVGRenderer#path|path},
     * {@link Highcharts.SVGRenderer#text|text},
     * {@link Highcharts.SVGRenderer#label|label},
     * {@link Highcharts.SVGRenderer#g|g}
     * and more.
     *
     * @class
     * @name Highcharts.SVGElement
     */
    class SVGElement {
        constructor() {
            /* *
             *
             *  Properties
             *
             * */
            this.element = void 0;
            this.onEvents = {};
            this.opacity = 1; // Default base for animation
            this.renderer = void 0;
            this.SVG_NS = SVG_NS$2;
        }
        // @todo public zIndex?: number;
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Get the current value of an attribute or pseudo attribute,
         * used mainly for animation. Called internally from
         * the {@link Highcharts.SVGRenderer#attr} function.
         *
         * @private
         * @function Highcharts.SVGElement#_defaultGetter
         *
         * @param {string} key
         *        Property key.
         *
         * @return {number|string}
         *         Property value.
         */
        _defaultGetter(key) {
            let ret = pick$7(this[key + 'Value'], // align getter
            this[key], this.element ? this.element.getAttribute(key) : null, 0);
            if (/^[\-0-9\.]+$/.test(ret)) { // is numerical
                ret = parseFloat(ret);
            }
            return ret;
        }
        /**
         * @private
         * @function Highcharts.SVGElement#_defaultSetter
         *
         * @param {string} value
         *
         * @param {string} key
         *
         * @param {Highcharts.SVGDOMElement} element
         *
         */
        _defaultSetter(value, key, element) {
            element.setAttribute(key, value);
        }
        /**
         * Add the element to the DOM. All elements must be added this way.
         *
         * @sample highcharts/members/renderer-g
         *         Elements added to a group
         *
         * @function Highcharts.SVGElement#add
         *
         * @param {Highcharts.SVGElement} [parent]
         *        The parent item to add it to. If undefined, the element is added
         *        to the {@link Highcharts.SVGRenderer.box}.
         *
         * @return {Highcharts.SVGElement}
         *         Returns the SVGElement for chaining.
         */
        add(parent) {
            const renderer = this.renderer, element = this.element;
            let inserted;
            if (parent) {
                this.parentGroup = parent;
            }
            // Build formatted text
            if (typeof this.textStr !== 'undefined' &&
                this.element.nodeName === 'text' // Not for SVGLabel instances
            ) {
                renderer.buildText(this);
            }
            // Mark as added
            this.added = true;
            // If we're adding to renderer root, or other elements in the group
            // have a z index, we need to handle it
            if (!parent || parent.handleZ || this.zIndex) {
                inserted = this.zIndexSetter();
            }
            // If zIndex is not handled, append at the end
            if (!inserted) {
                (parent ?
                    parent.element :
                    renderer.box).appendChild(element);
            }
            // fire an event for internal hooks
            if (this.onAdd) {
                this.onAdd();
            }
            return this;
        }
        /**
         * Add a class name to an element.
         *
         * @function Highcharts.SVGElement#addClass
         *
         * @param {string} className
         * The new class name to add.
         *
         * @param {boolean} [replace=false]
         * When true, the existing class name(s) will be overwritten with the new
         * one. When false, the new one is added.
         *
         * @return {Highcharts.SVGElement}
         * Return the SVG element for chainability.
         */
        addClass(className, replace) {
            const currentClassName = replace ? '' : (this.attr('class') || '');
            // Trim the string and remove duplicates
            className = (className || '')
                .split(/ /g)
                .reduce(function (newClassName, name) {
                if (currentClassName.indexOf(name) === -1) {
                    newClassName.push(name);
                }
                return newClassName;
            }, (currentClassName ?
                [currentClassName] :
                []))
                .join(' ');
            if (className !== currentClassName) {
                this.attr('class', className);
            }
            return this;
        }
        /**
         * This method is executed in the end of `attr()`, after setting all
         * attributes in the hash. In can be used to efficiently consolidate
         * multiple attributes in one SVG property -- e.g., translate, rotate and
         * scale are merged in one "transform" attribute in the SVG node.
         *
         * @private
         * @function Highcharts.SVGElement#afterSetters
         */
        afterSetters() {
            // Update transform. Do this outside the loop to prevent redundant
            // updating for batch setting of attributes.
            if (this.doTransform) {
                this.updateTransform();
                this.doTransform = false;
            }
        }
        /**
         * Align the element relative to the chart or another box.
         *
         * @function Highcharts.SVGElement#align
         *
         * @param {Highcharts.AlignObject} [alignOptions]
         *        The alignment options. The function can be called without this
         *        parameter in order to re-align an element after the box has been
         *        updated.
         *
         * @param {boolean} [alignByTranslate]
         *        Align element by translation.
         *
         * @param {string|Highcharts.BBoxObject} [box]
         *        The box to align to, needs a width and height. When the box is a
         *        string, it refers to an object in the Renderer. For example, when
         *        box is `spacingBox`, it refers to `Renderer.spacingBox` which
         *        holds `width`, `height`, `x` and `y` properties.
         *
         * @return {Highcharts.SVGElement} Returns the SVGElement for chaining.
         */
        align(alignOptions, alignByTranslate, box) {
            const attribs = {}, renderer = this.renderer, alignedObjects = renderer.alignedObjects;
            let x, y, alignTo, alignFactor, vAlignFactor;
            // First call on instanciate
            if (alignOptions) {
                this.alignOptions = alignOptions;
                this.alignByTranslate = alignByTranslate;
                if (!box || isString$4(box)) {
                    this.alignTo = alignTo = box || 'renderer';
                    // prevent duplicates, like legendGroup after resize
                    erase$2(alignedObjects, this);
                    alignedObjects.push(this);
                    box = void 0; // reassign it below
                }
                // When called on resize, no arguments are supplied
            }
            else {
                alignOptions = this.alignOptions;
                alignByTranslate = this.alignByTranslate;
                alignTo = this.alignTo;
            }
            box = pick$7(box, renderer[alignTo], alignTo === 'scrollablePlotBox' ?
                renderer.plotBox : void 0, renderer);
            // Assign variables
            const align = alignOptions.align, vAlign = alignOptions.verticalAlign;
            // default: left align
            x = (box.x || 0) + (alignOptions.x || 0);
            // default: top align
            y = (box.y || 0) + (alignOptions.y || 0);
            // Align
            if (align === 'right') {
                alignFactor = 1;
            }
            else if (align === 'center') {
                alignFactor = 2;
            }
            if (alignFactor) {
                x += (box.width - (alignOptions.width || 0)) /
                    alignFactor;
            }
            attribs[alignByTranslate ? 'translateX' : 'x'] = Math.round(x);
            // Vertical align
            if (vAlign === 'bottom') {
                vAlignFactor = 1;
            }
            else if (vAlign === 'middle') {
                vAlignFactor = 2;
            }
            if (vAlignFactor) {
                y += (box.height - (alignOptions.height || 0)) /
                    vAlignFactor;
            }
            attribs[alignByTranslate ? 'translateY' : 'y'] = Math.round(y);
            // Animate only if already placed
            this[this.placed ? 'animate' : 'attr'](attribs);
            this.placed = true;
            this.alignAttr = attribs;
            return this;
        }
        /**
         * @private
         * @function Highcharts.SVGElement#alignSetter
         * @param {"left"|"center"|"right"} value
         */
        alignSetter(value) {
            const convert = {
                left: 'start',
                center: 'middle',
                right: 'end'
            };
            if (convert[value]) {
                this.alignValue = value;
                this.element.setAttribute('text-anchor', convert[value]);
            }
        }
        /**
         * Animate to given attributes or CSS properties.
         *
         * @sample highcharts/members/element-on/
         *         Setting some attributes by animation
         *
         * @function Highcharts.SVGElement#animate
         *
         * @param {Highcharts.SVGAttributes} params
         *        SVG attributes or CSS to animate.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [options]
         *        Animation options.
         *
         * @param {Function} [complete]
         *        Function to perform at the end of animation.
         *
         * @return {Highcharts.SVGElement}
         *         Returns the SVGElement for chaining.
         */
        animate(params, options, complete) {
            const animOptions = animObject$3(pick$7(options, this.renderer.globalAnimation, true)), deferTime = animOptions.defer;
            // When the page is hidden save resources in the background by not
            // running animation at all (#9749).
            if (doc$3.hidden) {
                animOptions.duration = 0;
            }
            if (animOptions.duration !== 0) {
                // allows using a callback with the global animation without
                // overwriting it
                if (complete) {
                    animOptions.complete = complete;
                }
                // If defer option is defined delay the animation #12901
                syncTimeout$2(() => {
                    if (this.element) {
                        animate$1(this, params, animOptions);
                    }
                }, deferTime);
            }
            else {
                this.attr(params, void 0, complete || animOptions.complete);
                // Call the end step synchronously
                objectEach$4(params, function (val, prop) {
                    if (animOptions.step) {
                        animOptions.step.call(this, val, { prop: prop, pos: 1, elem: this });
                    }
                }, this);
            }
            return this;
        }
        /**
         * Apply a text outline through a custom CSS property, by copying the text
         * element and apply stroke to the copy. Used internally. Contrast checks at
         * [example](https://jsfiddle.net/highcharts/43soe9m1/2/).
         *
         * @example
         * // Specific color
         * text.css({
         *    textOutline: '1px black'
         * });
         * // Automatic contrast
         * text.css({
         *    color: '#000000', // black text
         *    textOutline: '1px contrast' // => white outline
         * });
         *
         * @private
         * @function Highcharts.SVGElement#applyTextOutline
         *
         * @param {string} textOutline
         *        A custom CSS `text-outline` setting, defined by `width color`.
         */
        applyTextOutline(textOutline) {
            const elem = this.element, hasContrast = textOutline.indexOf('contrast') !== -1;
            // When the text shadow is set to contrast, use dark stroke for light
            // text and vice versa.
            if (hasContrast) {
                textOutline = textOutline.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));
            }
            // Extract the stroke width and color
            const parts = textOutline.split(' ');
            const color = parts[parts.length - 1];
            let strokeWidth = parts[0];
            if (strokeWidth && strokeWidth !== 'none' && H.svg) {
                this.fakeTS = true; // Fake text shadow
                // Since the stroke is applied on center of the actual outline, we
                // need to double it to get the correct stroke-width outside the
                // glyphs.
                strokeWidth = strokeWidth.replace(/(^[\d\.]+)(.*?)$/g, function (match, digit, unit) {
                    return (2 * Number(digit)) + unit;
                });
                // Remove shadows from previous runs.
                this.removeTextOutline();
                const outline = doc$3.createElementNS(SVG_NS$2, 'tspan');
                attr$3(outline, {
                    'class': 'highcharts-text-outline',
                    fill: color,
                    stroke: color,
                    'stroke-width': strokeWidth,
                    'stroke-linejoin': 'round'
                });
                // For each of the tspans and text nodes, create a copy in the
                // outline.
                const parentElem = elem.querySelector('textPath') || elem;
                [].forEach.call(parentElem.childNodes, (childNode) => {
                    const clone = childNode.cloneNode(true);
                    if (clone.removeAttribute) {
                        ['fill', 'stroke', 'stroke-width', 'stroke'].forEach((prop) => clone
                            .removeAttribute(prop));
                    }
                    outline.appendChild(clone);
                });
                // Collect the sum of dy from all children, included nested ones
                let totalHeight = 0;
                [].forEach.call(parentElem.querySelectorAll('text tspan'), (element) => {
                    totalHeight += Number(element.getAttribute('dy'));
                });
                // Insert an absolutely positioned break before the original text
                // to keep it in place
                const br = doc$3.createElementNS(SVG_NS$2, 'tspan');
                br.textContent = '\u200B';
                // Reset the position for the following text
                attr$3(br, {
                    x: Number(elem.getAttribute('x')),
                    dy: -totalHeight
                });
                // Insert the outline
                outline.appendChild(br);
                parentElem.insertBefore(outline, parentElem.firstChild);
            }
        }
        /**
         * @function Highcharts.SVGElement#attr
         * @param {string} key
         * @return {number|string}
         */ /**
        * Apply native and custom attributes to the SVG elements.
        *
        * In order to set the rotation center for rotation, set x and y to 0 and
        * use `translateX` and `translateY` attributes to position the element
        * instead.
        *
        * Attributes frequently used in Highcharts are `fill`, `stroke`,
        * `stroke-width`.
        *
        * @sample highcharts/members/renderer-rect/
        *         Setting some attributes
        *
        * @example
        * // Set multiple attributes
        * element.attr({
        *     stroke: 'red',
        *     fill: 'blue',
        *     x: 10,
        *     y: 10
        * });
        *
        * // Set a single attribute
        * element.attr('stroke', 'red');
        *
        * // Get an attribute
        * element.attr('stroke'); // => 'red'
        *
        * @function Highcharts.SVGElement#attr
        *
        * @param {string|Highcharts.SVGAttributes} [hash]
        *        The native and custom SVG attributes.
        *
        * @param {number|string|Highcharts.SVGPathArray} [val]
        *        If the type of the first argument is `string`, the second can be a
        *        value, which will serve as a single attribute setter. If the first
        *        argument is a string and the second is undefined, the function
        *        serves as a getter and the current value of the property is
        *        returned.
        *
        * @param {Function} [complete]
        *        A callback function to execute after setting the attributes. This
        *        makes the function compliant and interchangeable with the
        *        {@link SVGElement#animate} function.
        *
        * @param {boolean} [continueAnimation=true]
        *        Used internally when `.attr` is called as part of an animation
        *        step. Otherwise, calling `.attr` for an attribute will stop
        *        animation for that attribute.
        *
        * @return {Highcharts.SVGElement}
        *         If used as a setter, it returns the current
        *         {@link Highcharts.SVGElement} so the calls can be chained. If
        *         used as a getter, the current value of the attribute is returned.
        */
        attr(hash, val, complete, continueAnimation) {
            const element = this.element, symbolCustomAttribs = SVGElement.symbolCustomAttribs;
            let key, hasSetSymbolSize, ret = this, skipAttr, setter;
            // single key-value pair
            if (typeof hash === 'string' && typeof val !== 'undefined') {
                key = hash;
                hash = {};
                hash[key] = val;
            }
            // used as a getter: first argument is a string, second is undefined
            if (typeof hash === 'string') {
                ret = (this[hash + 'Getter'] ||
                    this._defaultGetter).call(this, hash, element);
                // setter
            }
            else {
                objectEach$4(hash, function eachAttribute(val, key) {
                    skipAttr = false;
                    // Unless .attr is from the animator update, stop current
                    // running animation of this property
                    if (!continueAnimation) {
                        stop(this, key);
                    }
                    // Special handling of symbol attributes
                    if (this.symbolName &&
                        symbolCustomAttribs.indexOf(key) !== -1) {
                        if (!hasSetSymbolSize) {
                            this.symbolAttr(hash);
                            hasSetSymbolSize = true;
                        }
                        skipAttr = true;
                    }
                    if (this.rotation && (key === 'x' || key === 'y')) {
                        this.doTransform = true;
                    }
                    if (!skipAttr) {
                        setter = (this[key + 'Setter'] ||
                            this._defaultSetter);
                        setter.call(this, val, key, element);
                    }
                }, this);
                this.afterSetters();
            }
            // In accordance with animate, run a complete callback
            if (complete) {
                complete.call(this);
            }
            return ret;
        }
        /**
         * Apply a clipping rectangle to this element.
         *
         * @function Highcharts.SVGElement#clip
         *
         * @param {Highcharts.ClipRectElement} [clipRect]
         *        The clipping rectangle. If skipped, the current clip is removed.
         *
         * @return {Highcharts.SVGElement}
         *         Returns the SVG element to allow chaining.
         */
        clip(clipRect) {
            return this.attr('clip-path', clipRect ?
                'url(' + this.renderer.url + '#' + clipRect.id + ')' :
                'none');
        }
        /**
         * Calculate the coordinates needed for drawing a rectangle crisply and
         * return the calculated attributes.
         *
         * @function Highcharts.SVGElement#crisp
         *
         * @param {Highcharts.RectangleObject} rect
         * Rectangle to crisp.
         *
         * @param {number} [strokeWidth]
         * The stroke width to consider when computing crisp positioning. It can
         * also be set directly on the rect parameter.
         *
         * @return {Highcharts.RectangleObject}
         * The modified rectangle arguments.
         */
        crisp(rect, strokeWidth) {
            const wrapper = this;
            strokeWidth = strokeWidth || rect.strokeWidth || 0;
            // Math.round because strokeWidth can sometimes have roundoff errors
            const normalizer = Math.round(strokeWidth) % 2 / 2;
            // normalize for crisp edges
            rect.x = Math.floor(rect.x || wrapper.x || 0) + normalizer;
            rect.y = Math.floor(rect.y || wrapper.y || 0) + normalizer;
            rect.width = Math.floor((rect.width || wrapper.width || 0) - 2 * normalizer);
            rect.height = Math.floor((rect.height || wrapper.height || 0) - 2 * normalizer);
            if (defined$6(rect.strokeWidth)) {
                rect.strokeWidth = strokeWidth;
            }
            return rect;
        }
        /**
         * Build and apply an SVG gradient out of a common JavaScript configuration
         * object. This function is called from the attribute setters. An event
         * hook is added for supporting other complex color types.
         *
         * @private
         * @function Highcharts.SVGElement#complexColor
         *
         * @param {Highcharts.GradientColorObject|Highcharts.PatternObject} colorOptions
         * The gradient or pattern options structure.
         *
         * @param {string} prop
         * The property to apply, can either be `fill` or `stroke`.
         *
         * @param {Highcharts.SVGDOMElement} elem
         * SVG element to apply the gradient on.
         */
        complexColor(colorOptions, prop, elem) {
            const renderer = this.renderer;
            let colorObject, gradName, gradAttr, radAttr, gradients, stops, stopColor, stopOpacity, radialReference, id, key = [], value;
            fireEvent$4(this.renderer, 'complexColor', {
                args: arguments
            }, function () {
                // Apply linear or radial gradients
                if (colorOptions.radialGradient) {
                    gradName = 'radialGradient';
                }
                else if (colorOptions.linearGradient) {
                    gradName = 'linearGradient';
                }
                if (gradName) {
                    gradAttr = colorOptions[gradName];
                    gradients = renderer.gradients;
                    stops = colorOptions.stops;
                    radialReference = elem.radialReference;
                    // Keep < 2.2 kompatibility
                    if (isArray$4(gradAttr)) {
                        colorOptions[gradName] = gradAttr = {
                            x1: gradAttr[0],
                            y1: gradAttr[1],
                            x2: gradAttr[2],
                            y2: gradAttr[3],
                            gradientUnits: 'userSpaceOnUse'
                        };
                    }
                    // Correct the radial gradient for the radial reference system
                    if (gradName === 'radialGradient' &&
                        radialReference &&
                        !defined$6(gradAttr.gradientUnits)) {
                        // Save the radial attributes for updating
                        radAttr = gradAttr;
                        gradAttr = merge$5(gradAttr, renderer.getRadialAttr(radialReference, radAttr), { gradientUnits: 'userSpaceOnUse' });
                    }
                    // Build the unique key to detect whether we need to create a
                    // new element (#1282)
                    objectEach$4(gradAttr, function (value, n) {
                        if (n !== 'id') {
                            key.push(n, value);
                        }
                    });
                    objectEach$4(stops, function (val) {
                        key.push(val);
                    });
                    key = key.join(',');
                    // Check if a gradient object with the same config object is
                    // created within this renderer
                    if (gradients[key]) {
                        id = gradients[key].attr('id');
                    }
                    else {
                        // Set the id and create the element
                        gradAttr.id = id = uniqueKey$2();
                        const gradientObject = gradients[key] =
                            renderer.createElement(gradName)
                                .attr(gradAttr)
                                .add(renderer.defs);
                        gradientObject.radAttr = radAttr;
                        // The gradient needs to keep a list of stops to be able to
                        // destroy them
                        gradientObject.stops = [];
                        stops.forEach(function (stop) {
                            if (stop[1].indexOf('rgba') === 0) {
                                colorObject = Color.parse(stop[1]);
                                stopColor = colorObject.get('rgb');
                                stopOpacity = colorObject.get('a');
                            }
                            else {
                                stopColor = stop[1];
                                stopOpacity = 1;
                            }
                            const stopObject = renderer.createElement('stop').attr({
                                offset: stop[0],
                                'stop-color': stopColor,
                                'stop-opacity': stopOpacity
                            }).add(gradientObject);
                            // Add the stop element to the gradient
                            gradientObject.stops.push(stopObject);
                        });
                    }
                    // Set the reference to the gradient object
                    value = 'url(' + renderer.url + '#' + id + ')';
                    elem.setAttribute(prop, value);
                    elem.gradient = key;
                    // Allow the color to be concatenated into tooltips formatters
                    // etc. (#2995)
                    colorOptions.toString = function () {
                        return value;
                    };
                }
            });
        }
        /**
         * Set styles for the element. In addition to CSS styles supported by
         * native SVG and HTML elements, there are also some custom made for
         * Highcharts, like `width`, `ellipsis` and `textOverflow` for SVG text
         * elements.
         *
         * @sample highcharts/members/renderer-text-on-chart/
         *         Styled text
         *
         * @function Highcharts.SVGElement#css
         *
         * @param {Highcharts.CSSObject} styles
         *        The new CSS styles.
         *
         * @return {Highcharts.SVGElement}
         *         Return the SVG element for chaining.
         */
        css(styles) {
            const oldStyles = this.styles, newStyles = {}, elem = this.element;
            let textWidth, hasNew = !oldStyles;
            // Filter out existing styles to increase performance (#2640)
            if (oldStyles) {
                objectEach$4(styles, function (value, n) {
                    if (oldStyles && oldStyles[n] !== value) {
                        newStyles[n] = value;
                        hasNew = true;
                    }
                });
            }
            if (hasNew) {
                // Merge the new styles with the old ones
                if (oldStyles) {
                    styles = extend$6(oldStyles, newStyles);
                }
                // Get the text width from style
                // Previously set, unset it (#8234)
                if (styles.width === null || styles.width === 'auto') {
                    delete this.textWidth;
                    // Apply new
                }
                else if (elem.nodeName.toLowerCase() === 'text' &&
                    styles.width) {
                    textWidth = this.textWidth = pInt$2(styles.width);
                }
                // store object
                this.styles = styles;
                if (textWidth && (!svg$2 && this.renderer.forExport)) {
                    delete styles.width;
                }
                const stylesToApply = merge$5(styles);
                if (elem.namespaceURI === this.SVG_NS) {
                    // These CSS properties are interpreted internally by the SVG
                    // renderer, but are not supported by SVG and should not be
                    // added to the DOM. In styled mode, no CSS should find its way
                    // to the DOM whatsoever (#6173, #6474).
                    ['textOutline', 'textOverflow', 'width'].forEach((key) => (stylesToApply &&
                        delete stylesToApply[key]));
                    // SVG requires fill for text
                    if (stylesToApply.color) {
                        stylesToApply.fill = stylesToApply.color;
                    }
                }
                css$2(elem, stylesToApply);
            }
            if (this.added) {
                // Rebuild text after added. Cache mechanisms in the buildText will
                // prevent building if there are no significant changes.
                if (this.element.nodeName === 'text') {
                    this.renderer.buildText(this);
                }
                // Apply text outline after added
                if (styles.textOutline) {
                    this.applyTextOutline(styles.textOutline);
                }
            }
            return this;
        }
        /**
         * @private
         * @function Highcharts.SVGElement#dashstyleSetter
         * @param {string} value
         */
        dashstyleSetter(value) {
            let i, strokeWidth = this['stroke-width'];
            // If "inherit", like maps in IE, assume 1 (#4981). With HC5 and the new
            // strokeWidth function, we should be able to use that instead.
            if (strokeWidth === 'inherit') {
                strokeWidth = 1;
            }
            value = value && value.toLowerCase();
            if (value) {
                const v = value
                    .replace('shortdashdotdot', '3,1,1,1,1,1,')
                    .replace('shortdashdot', '3,1,1,1')
                    .replace('shortdot', '1,1,')
                    .replace('shortdash', '3,1,')
                    .replace('longdash', '8,3,')
                    .replace(/dot/g, '1,3,')
                    .replace('dash', '4,3,')
                    .replace(/,$/, '')
                    .split(','); // ending comma
                i = v.length;
                while (i--) {
                    v[i] = '' + (pInt$2(v[i]) * pick$7(strokeWidth, NaN));
                }
                value = v.join(',').replace(/NaN/g, 'none'); // #3226
                this.element.setAttribute('stroke-dasharray', value);
            }
        }
        /**
         * Destroy the element and element wrapper and clear up the DOM and event
         * hooks.
         *
         * @function Highcharts.SVGElement#destroy
         */
        destroy() {
            const wrapper = this, element = wrapper.element || {}, renderer = wrapper.renderer, ownerSVGElement = element.ownerSVGElement;
            let parentToClean = (element.nodeName === 'SPAN' &&
                wrapper.parentGroup ||
                void 0), grandParent, i;
            // remove events
            element.onclick = element.onmouseout = element.onmouseover =
                element.onmousemove = element.point = null;
            stop(wrapper); // stop running animations
            if (wrapper.clipPath && ownerSVGElement) {
                const clipPath = wrapper.clipPath;
                // Look for existing references to this clipPath and remove them
                // before destroying the element (#6196).
                // The upper case version is for Edge
                [].forEach.call(ownerSVGElement.querySelectorAll('[clip-path],[CLIP-PATH]'), function (el) {
                    if (el.getAttribute('clip-path').indexOf(clipPath.element.id) > -1) {
                        el.removeAttribute('clip-path');
                    }
                });
                wrapper.clipPath = clipPath.destroy();
            }
            // Destroy stops in case this is a gradient object @todo old code?
            if (wrapper.stops) {
                for (i = 0; i < wrapper.stops.length; i++) {
                    wrapper.stops[i].destroy();
                }
                wrapper.stops.length = 0;
                wrapper.stops = void 0;
            }
            // remove element
            wrapper.safeRemoveChild(element);
            // In case of useHTML, clean up empty containers emulating SVG groups
            // (#1960, #2393, #2697).
            while (parentToClean &&
                parentToClean.div &&
                parentToClean.div.childNodes.length === 0) {
                grandParent = parentToClean.parentGroup;
                wrapper.safeRemoveChild(parentToClean.div);
                delete parentToClean.div;
                parentToClean = grandParent;
            }
            // remove from alignObjects
            if (wrapper.alignTo) {
                erase$2(renderer.alignedObjects, wrapper);
            }
            objectEach$4(wrapper, function (val, key) {
                // Destroy child elements of a group
                if (wrapper[key] &&
                    wrapper[key].parentGroup === wrapper &&
                    wrapper[key].destroy) {
                    wrapper[key].destroy();
                }
                // Delete all properties
                delete wrapper[key];
            });
            return;
        }
        /**
         * @private
         * @function Highcharts.SVGElement#dSettter
         * @param {number|string|Highcharts.SVGPathArray} value
         * @param {string} key
         * @param {Highcharts.SVGDOMElement} element
         */
        dSetter(value, key, element) {
            if (isArray$4(value)) {
                // Backwards compatibility, convert one-dimensional array into an
                // array of segments
                if (typeof value[0] === 'string') {
                    value = this.renderer.pathToSegments(value);
                }
                this.pathArray = value;
                value = value.reduce((acc, seg, i) => {
                    if (!seg || !seg.join) {
                        return (seg || '').toString();
                    }
                    return (i ? acc + ' ' : '') + seg.join(' ');
                }, '');
            }
            if (/(NaN| {2}|^$)/.test(value)) {
                value = 'M 0 0';
            }
            // Check for cache before resetting. Resetting causes disturbance in the
            // DOM, causing flickering in some cases in Edge/IE (#6747). Also
            // possible performance gain.
            if (this[key] !== value) {
                element.setAttribute(key, value);
                this[key] = value;
            }
        }
        /**
         * Fade out an element by animating its opacity down to 0, and hide it on
         * complete. Used internally for the tooltip.
         *
         * @function Highcharts.SVGElement#fadeOut
         *
         * @param {number} [duration=150]
         * The fade duration in milliseconds.
         */
        fadeOut(duration) {
            const elemWrapper = this;
            elemWrapper.animate({
                opacity: 0
            }, {
                duration: pick$7(duration, 150),
                complete: function () {
                    // #3088, assuming we're only using this for tooltips
                    elemWrapper.hide();
                }
            });
        }
        /**
         * @private
         * @function Highcharts.SVGElement#fillSetter
         * @param {Highcharts.ColorType} value
         * @param {string} key
         * @param {Highcharts.SVGDOMElement} element
         */
        fillSetter(value, key, element) {
            if (typeof value === 'string') {
                element.setAttribute(key, value);
            }
            else if (value) {
                this.complexColor(value, key, element);
            }
        }
        /**
         * Get the bounding box (width, height, x and y) for the element. Generally
         * used to get rendered text size. Since this is called a lot in charts,
         * the results are cached based on text properties, in order to save DOM
         * traffic. The returned bounding box includes the rotation, so for example
         * a single text line of rotation 90 will report a greater height, and a
         * width corresponding to the line-height.
         *
         * @sample highcharts/members/renderer-on-chart/
         *         Draw a rectangle based on a text's bounding box
         *
         * @function Highcharts.SVGElement#getBBox
         *
         * @param {boolean} [reload]
         *        Skip the cache and get the updated DOM bouding box.
         *
         * @param {number} [rot]
         *        Override the element's rotation. This is internally used on axis
         *        labels with a value of 0 to find out what the bounding box would
         *        be have been if it were not rotated.
         *
         * @return {Highcharts.BBoxObject}
         *         The bounding box with `x`, `y`, `width` and `height` properties.
         */
        getBBox(reload, rot) {
            const wrapper = this, { alignValue, element, renderer, styles, textStr } = wrapper, { cache, cacheKeys } = renderer, isSVG = element.namespaceURI === wrapper.SVG_NS, rotation = pick$7(rot, wrapper.rotation, 0), fontSize = renderer.styledMode ? (element &&
                SVGElement.prototype.getStyle.call(element, 'font-size')) : (styles && styles.fontSize);
            let bBox, width, height, toggleTextShadowShim, cacheKey;
            // Avoid undefined and null (#7316)
            if (defined$6(textStr)) {
                cacheKey = textStr.toString();
                // Since numbers are monospaced, and numerical labels appear a lot
                // in a chart, we assume that a label of n characters has the same
                // bounding box as others of the same length. Unless there is inner
                // HTML in the label. In that case, leave the numbers as is (#5899).
                if (cacheKey.indexOf('<') === -1) {
                    cacheKey = cacheKey.replace(/[0-9]/g, '0');
                }
                // Properties that affect bounding box
                cacheKey += [
                    '',
                    renderer.rootFontSize,
                    fontSize,
                    rotation,
                    wrapper.textWidth,
                    alignValue,
                    styles && styles.textOverflow,
                    styles && styles.fontWeight // #12163
                ].join(',');
            }
            if (cacheKey && !reload) {
                bBox = cache[cacheKey];
            }
            // No cache found
            if (!bBox) {
                // SVG elements
                if (isSVG || renderer.forExport) {
                    try { // Fails in Firefox if the container has display: none.
                        // When the text shadow shim is used, we need to hide the
                        // fake shadows to get the correct bounding box (#3872)
                        toggleTextShadowShim = this.fakeTS && function (display) {
                            const outline = element.querySelector('.highcharts-text-outline');
                            if (outline) {
                                css$2(outline, { display });
                            }
                        };
                        // Workaround for #3842, Firefox reporting wrong bounding
                        // box for shadows
                        if (isFunction(toggleTextShadowShim)) {
                            toggleTextShadowShim('none');
                        }
                        bBox = element.getBBox ?
                            // SVG: use extend because IE9 is not allowed to change
                            // width and height in case of rotation (below)
                            extend$6({}, element.getBBox()) : {
                            // HTML elements with `exporting.allowHTML` and
                            // legacy IE in export mode
                            width: element.offsetWidth,
                            height: element.offsetHeight,
                            x: 0,
                            y: 0
                        };
                        // #3842
                        if (isFunction(toggleTextShadowShim)) {
                            toggleTextShadowShim('');
                        }
                    }
                    catch (e) {
                    }
                    // If the bBox is not set, the try-catch block above failed. The
                    // other condition is for Opera that returns a width of
                    // -Infinity on hidden elements.
                    if (!bBox || bBox.width < 0) {
                        bBox = { x: 0, y: 0, width: 0, height: 0 };
                    }
                    // useHTML within SVG
                }
                else {
                    bBox = wrapper.htmlGetBBox();
                }
                // True SVG elements as well as HTML elements in modern browsers
                // using the .useHTML option need to compensated for rotation
                width = bBox.width;
                height = bBox.height;
                // Workaround for wrong bounding box in IE, Edge and Chrome on
                // Windows. With Highcharts' default font, IE and Edge report
                // a box height of 16.899 and Chrome rounds it to 17. If this
                // stands uncorrected, it results in more padding added below
                // the text than above when adding a label border or background.
                // Also vertical positioning is affected.
                // https://jsfiddle.net/highcharts/em37nvuj/
                // (#1101, #1505, #1669, #2568, #6213).
                if (isSVG) {
                    bBox.height = height = ({
                        '11px,17': 14,
                        '13px,20': 16
                    }[`${fontSize || ''},${Math.round(height)}`] ||
                        height);
                }
                // Adjust for rotated text
                if (rotation) {
                    const baseline = Number(element.getAttribute('y') || 0) - bBox.y, alignFactor = {
                        'right': 1,
                        'center': 0.5
                    }[alignValue || 0] || 0, rad = rotation * deg2rad$1, rad90 = (rotation - 90) * deg2rad$1, wCosRad = width * Math.cos(rad), wSinRad = width * Math.sin(rad), cosRad90 = Math.cos(rad90), sinRad90 = Math.sin(rad90), 
                    // Find the starting point on the left side baseline of
                    // the text
                    pX = bBox.x + alignFactor * (width - wCosRad), pY = bBox.y + baseline - alignFactor * wSinRad, 
                    // Find all corners
                    aX = pX + baseline * cosRad90, bX = aX + wCosRad, cX = bX - height * cosRad90, dX = cX - wCosRad, aY = pY + baseline * sinRad90, bY = aY + wSinRad, cY = bY - height * sinRad90, dY = cY - wSinRad;
                    // Deduct the bounding box from the corners
                    bBox.x = Math.min(aX, bX, cX, dX);
                    bBox.y = Math.min(aY, bY, cY, dY);
                    bBox.width = Math.max(aX, bX, cX, dX) - bBox.x;
                    bBox.height = Math.max(aY, bY, cY, dY) - bBox.y;
                }
            }
            // Cache it. When loading a chart in a hidden iframe in Firefox and
            // IE/Edge, the bounding box height is 0, so don't cache it (#5620).
            if (cacheKey && (textStr === '' || bBox.height > 0)) {
                // Rotate (#4681)
                while (cacheKeys.length > 250) {
                    delete cache[cacheKeys.shift()];
                }
                if (!cache[cacheKey]) {
                    cacheKeys.push(cacheKey);
                }
                cache[cacheKey] = bBox;
            }
            return bBox;
        }
        /**
         * Get the computed style. Only in styled mode.
         *
         * @example
         * chart.series[0].points[0].graphic.getStyle('stroke-width'); // => '1px'
         *
         * @function Highcharts.SVGElement#getStyle
         *
         * @param {string} prop
         *        The property name to check for.
         *
         * @return {string}
         *         The current computed value.
         */
        getStyle(prop) {
            return win$4
                .getComputedStyle(this.element || this, '')
                .getPropertyValue(prop);
        }
        /**
         * Check if an element has the given class name.
         *
         * @function Highcharts.SVGElement#hasClass
         *
         * @param {string} className
         * The class name to check for.
         *
         * @return {boolean}
         * Whether the class name is found.
         */
        hasClass(className) {
            return ('' + this.attr('class'))
                .split(' ')
                .indexOf(className) !== -1;
        }
        /**
         * Hide the element, similar to setting the `visibility` attribute to
         * `hidden`.
         *
         * @function Highcharts.SVGElement#hide
         *
         * @return {Highcharts.SVGElement}
         *         Returns the SVGElement for chaining.
         */
        hide() {
            return this.attr({ visibility: 'hidden' });
        }
        /**
         * @private
         */
        htmlGetBBox() {
            return { height: 0, width: 0, x: 0, y: 0 };
        }
        /**
         * Initialize the SVG element. This function only exists to make the
         * initialization process overridable. It should not be called directly.
         *
         * @function Highcharts.SVGElement#init
         *
         * @param {Highcharts.SVGRenderer} renderer
         * The SVGRenderer instance to initialize to.
         *
         * @param {string} nodeName
         * The SVG node name.
         */
        init(renderer, nodeName) {
            /**
             * The primary DOM node. Each `SVGElement` instance wraps a main DOM
             * node, but may also represent more nodes.
             *
             * @name Highcharts.SVGElement#element
             * @type {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement}
             */
            this.element = nodeName === 'span' ?
                createElement$2(nodeName) :
                doc$3.createElementNS(this.SVG_NS, nodeName);
            /**
             * The renderer that the SVGElement belongs to.
             *
             * @name Highcharts.SVGElement#renderer
             * @type {Highcharts.SVGRenderer}
             */
            this.renderer = renderer;
            fireEvent$4(this, 'afterInit');
        }
        /**
         * Add an event listener. This is a simple setter that replaces the
         * previous event of the same type added by this function, as opposed to
         * the {@link Highcharts#addEvent} function.
         *
         * @sample highcharts/members/element-on/
         *         A clickable rectangle
         *
         * @function Highcharts.SVGElement#on
         *
         * @param {string} eventType
         * The event type.
         *
         * @param {Function} handler
         * The handler callback.
         *
         * @return {Highcharts.SVGElement}
         * The SVGElement for chaining.
         */
        on(eventType, handler) {
            const { onEvents } = this;
            if (onEvents[eventType]) {
                // Unbind existing event
                onEvents[eventType]();
            }
            onEvents[eventType] = addEvent$3(this.element, eventType, handler);
            return this;
        }
        /**
         * @private
         * @function Highcharts.SVGElement#opacitySetter
         * @param {string} value
         * @param {string} key
         * @param {Highcharts.SVGDOMElement} element
         */
        opacitySetter(value, key, element) {
            // Round off to avoid float errors, like tests where opacity lands on
            // 9.86957e-06 instead of 0
            const opacity = Number(Number(value).toFixed(3));
            this.opacity = opacity;
            element.setAttribute(key, opacity);
        }
        /**
         * Remove a class name from the element.
         *
         * @function Highcharts.SVGElement#removeClass
         *
         * @param {string|RegExp} className
         *        The class name to remove.
         *
         * @return {Highcharts.SVGElement} Returns the SVG element for chainability.
         */
        removeClass(className) {
            return this.attr('class', ('' + this.attr('class'))
                .replace(isString$4(className) ?
                new RegExp(`(^| )${className}( |$)`) : // #12064, #13590
                className, ' ')
                .replace(/ +/g, ' ')
                .trim());
        }
        /**
         *
         * @private
         */
        removeTextOutline() {
            const outline = this.element
                .querySelector('tspan.highcharts-text-outline');
            if (outline) {
                this.safeRemoveChild(outline);
            }
        }
        /**
         * Removes an element from the DOM.
         *
         * @private
         * @function Highcharts.SVGElement#safeRemoveChild
         *
         * @param {Highcharts.SVGDOMElement|Highcharts.HTMLDOMElement} element
         * The DOM node to remove.
         */
        safeRemoveChild(element) {
            const parentNode = element.parentNode;
            if (parentNode) {
                parentNode.removeChild(element);
            }
        }
        /**
         * Set the coordinates needed to draw a consistent radial gradient across
         * a shape regardless of positioning inside the chart. Used on pie slices
         * to make all the slices have the same radial reference point.
         *
         * @function Highcharts.SVGElement#setRadialReference
         *
         * @param {Array<number>} coordinates
         * The center reference. The format is `[centerX, centerY, diameter]` in
         * pixels.
         *
         * @return {Highcharts.SVGElement}
         * Returns the SVGElement for chaining.
         */
        setRadialReference(coordinates) {
            const existingGradient = (this.element.gradient &&
                this.renderer.gradients[this.element.gradient]);
            this.element.radialReference = coordinates;
            // On redrawing objects with an existing gradient, the gradient needs
            // to be repositioned (#3801)
            if (existingGradient && existingGradient.radAttr) {
                existingGradient.animate(this.renderer.getRadialAttr(coordinates, existingGradient.radAttr));
            }
            return this;
        }
        /**
         * Set a text path for a `text` or `label` element, allowing the text to
         * flow along a path.
         *
         * In order to unset the path for an existing element, call `setTextPath`
         * with `{ enabled: false }` as the second argument.
         *
         * @sample highcharts/members/renderer-textpath/ Text path demonstrated
         *
         * @function Highcharts.SVGElement#setTextPath
         *
         * @param {Highcharts.SVGElement|undefined} path
         *        Path to follow. If undefined, it allows changing options for the
         *        existing path.
         *
         * @param {Highcharts.DataLabelsTextPathOptionsObject} textPathOptions
         *        Options.
         *
         * @return {Highcharts.SVGElement} Returns the SVGElement for chaining.
         */
        setTextPath(path, textPathOptions) {
            // Defaults
            textPathOptions = merge$5(true, {
                enabled: true,
                attributes: {
                    dy: -5,
                    startOffset: '50%',
                    textAnchor: 'middle'
                }
            }, textPathOptions);
            const url = this.renderer.url, textWrapper = this.text || this, textPath = textWrapper.textPath, { attributes, enabled } = textPathOptions;
            path = path || (textPath && textPath.path);
            // Remove previously added event
            if (textPath) {
                textPath.undo();
            }
            if (path && enabled) {
                const undo = addEvent$3(textWrapper, 'afterModifyTree', (e) => {
                    if (path && enabled) {
                        // Set ID for the path
                        let textPathId = path.attr('id');
                        if (!textPathId) {
                            path.attr('id', textPathId = uniqueKey$2());
                        }
                        // Set attributes for the <text>
                        const textAttribs = {
                            // dx/dy options must by set on <text> (parent), the
                            // rest should be set on <textPath>
                            x: 0,
                            y: 0
                        };
                        if (defined$6(attributes.dx)) {
                            textAttribs.dx = attributes.dx;
                            delete attributes.dx;
                        }
                        if (defined$6(attributes.dy)) {
                            textAttribs.dy = attributes.dy;
                            delete attributes.dy;
                        }
                        textWrapper.attr(textAttribs);
                        // Handle label properties
                        this.attr({ transform: '' });
                        if (this.box) {
                            this.box = this.box.destroy();
                        }
                        // Wrap the nodes in a textPath
                        const children = e.nodes.slice(0);
                        e.nodes.length = 0;
                        e.nodes[0] = {
                            tagName: 'textPath',
                            attributes: extend$6(attributes, {
                                'text-anchor': attributes.textAnchor,
                                href: `${url}#${textPathId}`
                            }),
                            children
                        };
                    }
                });
                // Set the reference
                textWrapper.textPath = { path, undo };
            }
            else {
                textWrapper.attr({ dx: 0, dy: 0 });
                delete textWrapper.textPath;
            }
            if (this.added) {
                // Rebuild text after added
                textWrapper.textCache = '';
                this.renderer.buildText(textWrapper);
            }
            return this;
        }
        /**
         * Add a shadow to the element. In styled mode, this method is not used,
         * instead use `defs` and filters.
         *
         * @example
         * renderer.rect(10, 100, 100, 100)
         *     .attr({ fill: 'red' })
         *     .shadow(true);
         *
         * @function Highcharts.SVGElement#shadow
         *
         * @param {boolean|Highcharts.ShadowOptionsObject} [shadowOptions] The
         *        shadow options. If `true`, the default options are applied. If
         *        `false`, the current shadow will be removed.
         *
         * @return {Highcharts.SVGElement} Returns the SVGElement for chaining.
         */
        shadow(shadowOptions) {
            var _a;
            const { renderer } = this, options = merge$5(((_a = this.parentGroup) === null || _a === void 0 ? void 0 : _a.rotation) === 90 ? {
                offsetX: -1,
                offsetY: -1
            } : {}, isObject$2(shadowOptions) ? shadowOptions : {}), id = renderer.shadowDefinition(options);
            return this.attr({
                filter: shadowOptions ?
                    `url(${renderer.url}#${id})` :
                    'none'
            });
        }
        /**
         * Show the element after it has been hidden.
         *
         * @function Highcharts.SVGElement#show
         *
         * @param {boolean} [inherit=true]
         *        Set the visibility attribute to `inherit` rather than `visible`.
         *        The difference is that an element with `visibility="visible"`
         *        will be visible even if the parent is hidden.
         *
         * @return {Highcharts.SVGElement}
         *         Returns the SVGElement for chaining.
         */
        show(inherit = true) {
            return this.attr({ visibility: inherit ? 'inherit' : 'visible' });
        }
        /**
         * Set the stroke-width and record it on the SVGElement
         *
         * @private
         * @function Highcharts.SVGElement#strokeSetter
         * @param {number|string|ColorType} value
         * @param {string} key
         * @param {Highcharts.SVGDOMElement} element
         */
        'stroke-widthSetter'(value, key, element) {
            // Record it for quick access in getter
            this[key] = value;
            element.setAttribute(key, value);
        }
        /**
         * Get the computed stroke width in pixel values. This is used extensively
         * when drawing shapes to ensure the shapes are rendered crisp and
         * positioned correctly relative to each other. Using
         * `shape-rendering: crispEdges` leaves us less control over positioning,
         * for example when we want to stack columns next to each other, or position
         * things pixel-perfectly within the plot box.
         *
         * The common pattern when placing a shape is:
         * - Create the SVGElement and add it to the DOM. In styled mode, it will
         *   now receive a stroke width from the style sheet. In classic mode we
         *   will add the `stroke-width` attribute.
         * - Read the computed `elem.strokeWidth()`.
         * - Place it based on the stroke width.
         *
         * @function Highcharts.SVGElement#strokeWidth
         *
         * @return {number}
         * The stroke width in pixels. Even if the given stroke widtch (in CSS or by
         * attributes) is based on `em` or other units, the pixel size is returned.
         */
        strokeWidth() {
            // In non-styled mode, read the stroke width as set by .attr
            if (!this.renderer.styledMode) {
                return this['stroke-width'] || 0;
            }
            // In styled mode, read computed stroke width
            const val = this.getStyle('stroke-width');
            let ret = 0, dummy;
            // Read pixel values directly
            if (val.indexOf('px') === val.length - 2) {
                ret = pInt$2(val);
                // Other values like em, pt etc need to be measured
            }
            else if (val !== '') {
                dummy = doc$3.createElementNS(SVG_NS$2, 'rect');
                attr$3(dummy, {
                    width: val,
                    'stroke-width': 0
                });
                this.element.parentNode.appendChild(dummy);
                ret = dummy.getBBox().width;
                dummy.parentNode.removeChild(dummy);
            }
            return ret;
        }
        /**
         * If one of the symbol size affecting parameters are changed,
         * check all the others only once for each call to an element's
         * .attr() method
         *
         * @private
         * @function Highcharts.SVGElement#symbolAttr
         *
         * @param {Highcharts.SVGAttributes} hash
         * The attributes to set.
         */
        symbolAttr(hash) {
            const wrapper = this;
            SVGElement.symbolCustomAttribs.forEach(function (key) {
                wrapper[key] = pick$7(hash[key], wrapper[key]);
            });
            wrapper.attr({
                d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.width, wrapper.height, wrapper)
            });
        }
        /**
         * @private
         * @function Highcharts.SVGElement#textSetter
         * @param {string} value
         */
        textSetter(value) {
            if (value !== this.textStr) {
                // Delete size caches when the text changes
                // delete this.bBox; // old code in series-label
                delete this.textPxLength;
                this.textStr = value;
                if (this.added) {
                    this.renderer.buildText(this);
                }
            }
        }
        /**
         * @private
         * @function Highcharts.SVGElement#titleSetter
         * @param {string} value
         */
        titleSetter(value) {
            const el = this.element;
            const titleNode = el.getElementsByTagName('title')[0] ||
                doc$3.createElementNS(this.SVG_NS, 'title');
            // Move to first child
            if (el.insertBefore) {
                el.insertBefore(titleNode, el.firstChild);
            }
            else {
                el.appendChild(titleNode);
            }
            // Replace text content and escape markup
            titleNode.textContent =
                // #3276, #3895
                String(pick$7(value, ''))
                    .replace(/<[^>]*>/g, '')
                    .replace(/&lt;/g, '<')
                    .replace(/&gt;/g, '>');
        }
        /**
         * Bring the element to the front. Alternatively, a new zIndex can be set.
         *
         * @sample highcharts/members/element-tofront/
         *         Click an element to bring it to front
         *
         * @function Highcharts.SVGElement#toFront
         *
         * @return {Highcharts.SVGElement}
         * Returns the SVGElement for chaining.
         */
        toFront() {
            const element = this.element;
            element.parentNode.appendChild(element);
            return this;
        }
        /**
         * Move an object and its children by x and y values.
         *
         * @function Highcharts.SVGElement#translate
         *
         * @param {number} x
         * The x value.
         *
         * @param {number} y
         * The y value.
         *
         * @return {Highcharts.SVGElement}
         * Translated element.
         */
        translate(x, y) {
            return this.attr({
                translateX: x,
                translateY: y
            });
        }
        /**
         * Update the transform attribute based on internal properties. Deals with
         * the custom `translateX`, `translateY`, `rotation`, `scaleX` and `scaleY`
         * attributes and updates the SVG `transform` attribute.
         *
         * @private
         * @function Highcharts.SVGElement#updateTransform
         */
        updateTransform() {
            const { element, matrix, rotation = 0, scaleX, scaleY, translateX = 0, translateY = 0 } = this;
            // Apply translate. Nearly all transformed elements have translation,
            // so instead of checking for translate = 0, do it always (#1767,
            // #1846).
            const transform = ['translate(' + translateX + ',' + translateY + ')'];
            // apply matrix
            if (defined$6(matrix)) {
                transform.push('matrix(' + matrix.join(',') + ')');
            }
            // Apply rotation
            if (rotation) { // text rotation or inverted chart
                transform.push('rotate(' + rotation + ' ' +
                    pick$7(this.rotationOriginX, element.getAttribute('x'), 0) +
                    ' ' +
                    pick$7(this.rotationOriginY, element.getAttribute('y') || 0) + ')');
            }
            // apply scale
            if (defined$6(scaleX) || defined$6(scaleY)) {
                transform.push('scale(' + pick$7(scaleX, 1) + ' ' + pick$7(scaleY, 1) + ')');
            }
            if (transform.length && !(this.text || this).textPath) {
                element.setAttribute('transform', transform.join(' '));
            }
        }
        /**
         * @private
         * @function Highcharts.SVGElement#visibilitySetter
         *
         * @param {string} value
         *
         * @param {string} key
         *
         * @param {Highcharts.SVGDOMElement} element
         *
         */
        visibilitySetter(value, key, element) {
            // IE9-11 doesn't handle visibilty:inherit well, so we remove the
            // attribute instead (#2881, #3909)
            if (value === 'inherit') {
                element.removeAttribute(key);
            }
            else if (this[key] !== value) { // #6747
                element.setAttribute(key, value);
            }
            this[key] = value;
        }
        /**
         * @private
         * @function Highcharts.SVGElement#xGetter
         */
        xGetter(key) {
            if (this.element.nodeName === 'circle') {
                if (key === 'x') {
                    key = 'cx';
                }
                else if (key === 'y') {
                    key = 'cy';
                }
            }
            return this._defaultGetter(key);
        }
        /**
         * @private
         * @function Highcharts.SVGElement#zIndexSetter
         */
        zIndexSetter(value, key) {
            const renderer = this.renderer, parentGroup = this.parentGroup, parentWrapper = parentGroup || renderer, parentNode = parentWrapper.element || renderer.box, element = this.element, svgParent = parentNode === renderer.box;
            let childNodes, otherElement, otherZIndex, inserted = false, undefinedOtherZIndex, run = this.added, i;
            if (defined$6(value)) {
                // So we can read it for other elements in the group
                element.setAttribute('data-z-index', value);
                value = +value;
                if (this[key] === value) {
                    // Only update when needed (#3865)
                    run = false;
                }
            }
            else if (defined$6(this[key])) {
                element.removeAttribute('data-z-index');
            }
            this[key] = value;
            // Insert according to this and other elements' zIndex. Before .add() is
            // called, nothing is done. Then on add, or by later calls to
            // zIndexSetter, the node is placed on the right place in the DOM.
            if (run) {
                value = this.zIndex;
                if (value && parentGroup) {
                    parentGroup.handleZ = true;
                }
                childNodes = parentNode.childNodes;
                for (i = childNodes.length - 1; i >= 0 && !inserted; i--) {
                    otherElement = childNodes[i];
                    otherZIndex = otherElement.getAttribute('data-z-index');
                    undefinedOtherZIndex = !defined$6(otherZIndex);
                    if (otherElement !== element) {
                        if (
                        // Negative zIndex versus no zIndex:
                        // On all levels except the highest. If the parent is
                        // <svg>, then we don't want to put items before <desc>
                        // or <defs>
                        value < 0 &&
                            undefinedOtherZIndex &&
                            !svgParent &&
                            !i) {
                            parentNode.insertBefore(element, childNodes[i]);
                            inserted = true;
                        }
                        else if (
                        // Insert after the first element with a lower zIndex
                        pInt$2(otherZIndex) <= value ||
                            // If negative zIndex, add this before first undefined
                            // zIndex element
                            (undefinedOtherZIndex &&
                                (!defined$6(value) || value >= 0))) {
                            parentNode.insertBefore(element, childNodes[i + 1]);
                            inserted = true;
                        }
                    }
                }
                if (!inserted) {
                    parentNode.insertBefore(element, childNodes[svgParent ? 3 : 0]);
                    inserted = true;
                }
            }
            return inserted;
        }
    }
    // Custom attributes used for symbols, these should be filtered out when
    // setting SVGElement attributes (#9375).
    SVGElement.symbolCustomAttribs = [
        'anchorX',
        'anchorY',
        'clockwise',
        'end',
        'height',
        'innerR',
        'r',
        'start',
        'width',
        'x',
        'y'
    ];
    // Some shared setters and getters
    SVGElement.prototype.strokeSetter = SVGElement.prototype.fillSetter;
    SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
    SVGElement.prototype.matrixSetter =
        SVGElement.prototype.rotationOriginXSetter =
            SVGElement.prototype.rotationOriginYSetter =
                SVGElement.prototype.rotationSetter =
                    SVGElement.prototype.scaleXSetter =
                        SVGElement.prototype.scaleYSetter =
                            SVGElement.prototype.translateXSetter =
                                SVGElement.prototype.translateYSetter =
                                    SVGElement.prototype.verticalAlignSetter = function (value, key) {
                                        this[key] = value;
                                        this.doTransform = true;
                                    };

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { animObject: animObject$2, setAnimation: setAnimation$1 } = animationExports;
    const { defaultOptions: defaultOptions$1 } = DefaultOptions;
    const { registerEventOptions: registerEventOptions$1 } = Foundation$1;
    const { hasTouch: hasTouch$1, svg: svg$1, win: win$3 } = H;
    const { seriesTypes: seriesTypes$1 } = SeriesRegistry$1;
    const { addEvent: addEvent$2, arrayMax, arrayMin, clamp: clamp$1, correctFloat, defined: defined$5, diffObjects: diffObjects$1, erase: erase$1, error: error$1, extend: extend$5, find: find$1, fireEvent: fireEvent$3, getClosestDistance, getNestedProperty, insertItem, isArray: isArray$3, isNumber: isNumber$5, isString: isString$3, merge: merge$4, objectEach: objectEach$3, pick: pick$6, removeEvent: removeEvent$2, splat: splat$1, syncTimeout: syncTimeout$1 } = Utilities;
    /* *
     *
     *  Class
     *
     * */
    /**
     * This is the base series prototype that all other series types inherit from.
     * A new series is initialized either through the
     * [series](https://api.highcharts.com/highcharts/series)
     * option structure, or after the chart is initialized, through
     * {@link Highcharts.Chart#addSeries}.
     *
     * The object can be accessed in a number of ways. All series and point event
     * handlers give a reference to the `series` object. The chart object has a
     * {@link Highcharts.Chart#series|series} property that is a collection of all
     * the chart's series. The point objects and axis objects also have the same
     * reference.
     *
     * Another way to reference the series programmatically is by `id`. Add an id
     * in the series configuration options, and get the series object by
     * {@link Highcharts.Chart#get}.
     *
     * Configuration options for the series are given in three levels. Options for
     * all series in a chart are given in the
     * [plotOptions.series](https://api.highcharts.com/highcharts/plotOptions.series)
     * object. Then options for all series of a specific type
     * are given in the plotOptions of that type, for example `plotOptions.line`.
     * Next, options for one single series are given in the series array, or as
     * arguments to `chart.addSeries`.
     *
     * The data in the series is stored in various arrays.
     *
     * - First, `series.options.data` contains all the original config options for
     *   each point whether added by options or methods like `series.addPoint`.
     *
     * - Next, `series.data` contains those values converted to points, but in case
     *   the series data length exceeds the `cropThreshold`, or if the data is
     *   grouped, `series.data` doesn't contain all the points. It only contains the
     *   points that have been created on demand.
     *
     * - Then there's `series.points` that contains all currently visible point
     *   objects. In case of cropping, the cropped-away points are not part of this
     *   array. The `series.points` array starts at `series.cropStart` compared to
     *   `series.data` and `series.options.data`. If however the series data is
     *   grouped, these can't be correlated one to one.
     *
     * - `series.xData` and `series.processedXData` contain clean x values,
     *   equivalent to `series.data` and `series.points`.
     *
     * - `series.yData` and `series.processedYData` contain clean y values,
     *   equivalent to `series.data` and `series.points`.
     *
     * @class
     * @name Highcharts.Series
     *
     * @param {Highcharts.Chart} chart
     * The chart instance.
     *
     * @param {Highcharts.SeriesOptionsType|object} options
     * The series options.
     */
    class Series {
        constructor() {
            /* *
             *
             *  Static Properties
             *
             * */
            this._i = void 0;
            this.chart = void 0;
            this.data = void 0;
            this.eventOptions = void 0;
            this.eventsToUnbind = void 0;
            this.index = void 0;
            this.linkedSeries = void 0;
            this.options = void 0;
            this.points = void 0;
            this.processedXData = void 0;
            this.processedYData = void 0;
            this.tooltipOptions = void 0;
            this.userOptions = void 0;
            this.xAxis = void 0;
            this.yAxis = void 0;
            this.zones = void 0;
            /** eslint-enable valid-jsdoc */
        }
        /* *
         *
         *  Functions
         *
         * */
        /* eslint-disable valid-jsdoc */
        init(chart, userOptions) {
            fireEvent$3(this, 'init', { options: userOptions });
            const series = this, chartSeries = chart.series;
            // The 'eventsToUnbind' property moved from prototype into the
            // Series init to avoid reference to the same array between
            // the different series and charts. #12959, #13937
            this.eventsToUnbind = [];
            /**
             * Read only. The chart that the series belongs to.
             *
             * @name Highcharts.Series#chart
             * @type {Highcharts.Chart}
             */
            series.chart = chart;
            /**
             * Read only. The series' type, like "line", "area", "column" etc.
             * The type in the series options anc can be altered using
             * {@link Series#update}.
             *
             * @name Highcharts.Series#type
             * @type {string}
             */
            /**
             * Read only. The series' current options. To update, use
             * {@link Series#update}.
             *
             * @name Highcharts.Series#options
             * @type {Highcharts.SeriesOptionsType}
             */
            series.options = series.setOptions(userOptions);
            const options = series.options;
            series.linkedSeries = [];
            // bind the axes
            series.bindAxes();
            extend$5(series, {
                /**
                 * The series name as given in the options. Defaults to
                 * "Series {n}".
                 *
                 * @name Highcharts.Series#name
                 * @type {string}
                 */
                name: options.name,
                state: '',
                /**
                 * Read only. The series' visibility state as set by {@link
                 * Series#show}, {@link Series#hide}, or in the initial
                 * configuration.
                 *
                 * @name Highcharts.Series#visible
                 * @type {boolean}
                 */
                visible: options.visible !== false,
                /**
                 * Read only. The series' selected state as set by {@link
                 * Highcharts.Series#select}.
                 *
                 * @name Highcharts.Series#selected
                 * @type {boolean}
                 */
                selected: options.selected === true // false by default
            });
            registerEventOptions$1(this, options);
            const events = options.events;
            if ((events && events.click) ||
                (options.point &&
                    options.point.events &&
                    options.point.events.click) ||
                options.allowPointSelect) {
                chart.runTrackerClick = true;
            }
            series.getColor();
            series.getSymbol();
            // Initialize the parallel data arrays
            series.parallelArrays.forEach(function (key) {
                if (!series[key + 'Data']) {
                    series[key + 'Data'] = [];
                }
            });
            // Mark cartesian
            if (series.isCartesian) {
                chart.hasCartesianSeries = true;
            }
            // Get the index and register the series in the chart. The index is
            // one more than the current latest series index (#5960).
            let lastSeries;
            if (chartSeries.length) {
                lastSeries = chartSeries[chartSeries.length - 1];
            }
            series._i = pick$6(lastSeries && lastSeries._i, -1) + 1;
            series.opacity = series.options.opacity;
            // Insert the series and re-order all series above the insertion
            // point.
            chart.orderItems('series', insertItem(this, chartSeries));
            // Set options for series with sorting and set data later.
            if (options.dataSorting && options.dataSorting.enabled) {
                series.setDataSortingOptions();
            }
            else if (!series.points && !series.data) {
                series.setData(options.data, false);
            }
            fireEvent$3(this, 'afterInit');
        }
        /**
         * Check whether the series item is itself or inherits from a certain
         * series type.
         *
         * @function Highcharts.Series#is
         * @param {string} type The type of series to check for, can be either
         *        featured or custom series types. For example `column`, `pie`,
         *        `ohlc` etc.
         *
         * @return {boolean}
         *        True if this item is or inherits from the given type.
         */
        is(type) {
            return seriesTypes$1[type] && this instanceof seriesTypes$1[type];
        }
        /**
         * Set the xAxis and yAxis properties of cartesian series, and register
         * the series in the `axis.series` array.
         *
         * @private
         * @function Highcharts.Series#bindAxes
         */
        bindAxes() {
            const series = this, seriesOptions = series.options, chart = series.chart;
            let axisOptions;
            fireEvent$3(this, 'bindAxes', null, function () {
                // repeat for xAxis and yAxis
                (series.axisTypes || []).forEach(function (coll) {
                    // loop through the chart's axis objects
                    chart[coll].forEach(function (axis) {
                        axisOptions = axis.options;
                        // apply if the series xAxis or yAxis option mathches
                        // the number of the axis, or if undefined, use the
                        // first axis
                        if (pick$6(seriesOptions[coll], 0) === axis.index ||
                            (typeof seriesOptions[coll] !==
                                'undefined' &&
                                seriesOptions[coll] === axisOptions.id)) {
                            // register this series in the axis.series lookup
                            insertItem(series, axis.series);
                            // set this series.xAxis or series.yAxis reference
                            /**
                             * Read only. The unique xAxis object associated
                             * with the series.
                             *
                             * @name Highcharts.Series#xAxis
                             * @type {Highcharts.Axis}
                             */
                            /**
                             * Read only. The unique yAxis object associated
                             * with the series.
                             *
                             * @name Highcharts.Series#yAxis
                             * @type {Highcharts.Axis}
                             */
                            series[coll] = axis;
                            // mark dirty for redraw
                            axis.isDirty = true;
                        }
                    });
                    // The series needs an X and an Y axis
                    if (!series[coll] &&
                        series.optionalAxis !== coll) {
                        error$1(18, true, chart);
                    }
                });
            });
            fireEvent$3(this, 'afterBindAxes');
        }
        /**
         * For simple series types like line and column, the data values are
         * held in arrays like xData and yData for quick lookup to find extremes
         * and more. For multidimensional series like bubble and map, this can
         * be extended with arrays like zData and valueData by adding to the
         * `series.parallelArrays` array.
         *
         * @private
         * @function Highcharts.Series#updateParallelArrays
         */
        updateParallelArrays(point, i, iArgs) {
            const series = point.series, fn = isNumber$5(i) ?
                // Insert the value in the given position
                function (key) {
                    const val = key === 'y' && series.toYData ?
                        series.toYData(point) :
                        point[key];
                    series[key + 'Data'][i] = val;
                } :
                // Apply the method specified in i with the following
                // arguments as arguments
                function (key) {
                    Array.prototype[i].apply(series[key + 'Data'], iArgs);
                };
            series.parallelArrays.forEach(fn);
        }
        /**
         * Define hasData functions for series. These return true if there
         * are data points on this series within the plot area.
         *
         * @private
         * @function Highcharts.Series#hasData
         */
        hasData() {
            return ((this.visible &&
                typeof this.dataMax !== 'undefined' &&
                typeof this.dataMin !== 'undefined') || ( // #3703
            this.visible &&
                this.yData &&
                this.yData.length > 0) // #9758
            );
        }
        /**
         * Return an auto incremented x value based on the pointStart and
         * pointInterval options. This is only used if an x value is not given
         * for the point that calls autoIncrement.
         *
         * @private
         * @function Highcharts.Series#autoIncrement
         */
        autoIncrement(x) {
            const options = this.options, pointIntervalUnit = options.pointIntervalUnit, relativeXValue = options.relativeXValue, time = this.chart.time;
            let xIncrement = this.xIncrement, date, pointInterval;
            xIncrement = pick$6(xIncrement, options.pointStart, 0);
            this.pointInterval = pointInterval = pick$6(this.pointInterval, options.pointInterval, 1);
            if (relativeXValue && isNumber$5(x)) {
                pointInterval *= x;
            }
            // Added code for pointInterval strings
            if (pointIntervalUnit) {
                date = new time.Date(xIncrement);
                if (pointIntervalUnit === 'day') {
                    time.set('Date', date, time.get('Date', date) + pointInterval);
                }
                else if (pointIntervalUnit === 'month') {
                    time.set('Month', date, time.get('Month', date) + pointInterval);
                }
                else if (pointIntervalUnit === 'year') {
                    time.set('FullYear', date, time.get('FullYear', date) + pointInterval);
                }
                pointInterval = date.getTime() - xIncrement;
            }
            if (relativeXValue && isNumber$5(x)) {
                return xIncrement + pointInterval;
            }
            this.xIncrement = xIncrement + pointInterval;
            return xIncrement;
        }
        /**
         * Internal function to set properties for series if data sorting is
         * enabled.
         *
         * @private
         * @function Highcharts.Series#setDataSortingOptions
         */
        setDataSortingOptions() {
            const options = this.options;
            extend$5(this, {
                requireSorting: false,
                sorted: false,
                enabledDataSorting: true,
                allowDG: false
            });
            // To allow unsorted data for column series.
            if (!defined$5(options.pointRange)) {
                options.pointRange = 1;
            }
        }
        /**
         * Set the series options by merging from the options tree. Called
         * internally on initializing and updating series. This function will
         * not redraw the series. For API usage, use {@link Series#update}.
         * @private
         * @function Highcharts.Series#setOptions
         * @param {Highcharts.SeriesOptionsType} itemOptions
         * The series options.
         * @emits Highcharts.Series#event:afterSetOptions
         */
        setOptions(itemOptions) {
            var _a, _b;
            const chart = this.chart, chartOptions = chart.options, plotOptions = chartOptions.plotOptions, userOptions = chart.userOptions || {}, seriesUserOptions = merge$4(itemOptions), styledMode = chart.styledMode, e = {
                plotOptions: plotOptions,
                userOptions: seriesUserOptions
            };
            let zone;
            fireEvent$3(this, 'setOptions', e);
            // These may be modified by the event
            const typeOptions = e.plotOptions[this.type], userPlotOptions = (userOptions.plotOptions || {}), userPlotOptionsSeries = userPlotOptions.series || {}, defaultPlotOptionsType = (defaultOptions$1.plotOptions[this.type] || {}), userPlotOptionsType = userPlotOptions[this.type] || {};
            // use copy to prevent undetected changes (#9762)
            /**
             * Contains series options by the user without defaults.
             * @name Highcharts.Series#userOptions
             * @type {Highcharts.SeriesOptionsType}
             */
            this.userOptions = e.userOptions;
            const options = merge$4(typeOptions, plotOptions.series, 
            // #3881, chart instance plotOptions[type] should trump
            // plotOptions.series
            userPlotOptionsType, seriesUserOptions);
            // The tooltip options are merged between global and series specific
            // options. Importance order asscendingly:
            // globals: (1)tooltip, (2)plotOptions.series,
            // (3)plotOptions[this.type]
            // init userOptions with possible later updates: 4-6 like 1-3 and
            // (7)this series options
            this.tooltipOptions = merge$4(defaultOptions$1.tooltip, // 1
            (_a = defaultOptions$1.plotOptions.series) === null || _a === void 0 ? void 0 : _a.tooltip, // 2
            defaultPlotOptionsType === null || defaultPlotOptionsType === void 0 ? void 0 : defaultPlotOptionsType.tooltip, // 3
            chart.userOptions.tooltip, // 4
            (_b = userPlotOptions.series) === null || _b === void 0 ? void 0 : _b.tooltip, // 5
            userPlotOptionsType.tooltip, // 6
            seriesUserOptions.tooltip // 7
            );
            // When shared tooltip, stickyTracking is true by default,
            // unless user says otherwise.
            this.stickyTracking = pick$6(seriesUserOptions.stickyTracking, userPlotOptionsType.stickyTracking, userPlotOptionsSeries.stickyTracking, (this.tooltipOptions.shared && !this.noSharedTooltip ?
                true :
                options.stickyTracking));
            // Delete marker object if not allowed (#1125)
            if (typeOptions.marker === null) {
                delete options.marker;
            }
            // Handle color zones
            this.zoneAxis = options.zoneAxis;
            const zones = this.zones = (options.zones || []).slice();
            if ((options.negativeColor || options.negativeFillColor) &&
                !options.zones) {
                zone = {
                    value: options[this.zoneAxis + 'Threshold'] ||
                        options.threshold ||
                        0,
                    className: 'highcharts-negative'
                };
                if (!styledMode) {
                    zone.color = options.negativeColor;
                    zone.fillColor = options.negativeFillColor;
                }
                zones.push(zone);
            }
            if (zones.length) { // Push one extra zone for the rest
                if (defined$5(zones[zones.length - 1].value)) {
                    zones.push(styledMode ? {} : {
                        color: this.color,
                        fillColor: this.fillColor
                    });
                }
            }
            fireEvent$3(this, 'afterSetOptions', { options: options });
            return options;
        }
        /**
         * Return series name in "Series {Number}" format or the one defined by
         * a user. This method can be simply overridden as series name format
         * can vary (e.g. technical indicators).
         *
         * @function Highcharts.Series#getName
         *
         * @return {string}
         * The series name.
         */
        getName() {
            // #4119
            return pick$6(this.options.name, 'Series ' + (this.index + 1));
        }
        /**
         * @private
         * @function Highcharts.Series#getCyclic
         */
        getCyclic(prop, value, defaults) {
            const chart = this.chart, indexName = `${prop}Index`, counterName = `${prop}Counter`, len = (
            // Symbol count
            (defaults === null || defaults === void 0 ? void 0 : defaults.length) ||
                // Color count
                chart.options.chart.colorCount);
            let i, setting;
            if (!value) {
                // Pick up either the colorIndex option, or the series.colorIndex
                // after Series.update()
                setting = pick$6(prop === 'color' ? this.options.colorIndex : void 0, this[indexName]);
                if (defined$5(setting)) { // after Series.update()
                    i = setting;
                }
                else {
                    // #6138
                    if (!chart.series.length) {
                        chart[counterName] = 0;
                    }
                    i = chart[counterName] % len;
                    chart[counterName] += 1;
                }
                if (defaults) {
                    value = defaults[i];
                }
            }
            // Set the colorIndex
            if (typeof i !== 'undefined') {
                this[indexName] = i;
            }
            this[prop] = value;
        }
        /**
         * Get the series' color based on either the options or pulled from
         * global options.
         *
         * @private
         * @function Highcharts.Series#getColor
         */
        getColor() {
            if (this.chart.styledMode) {
                this.getCyclic('color');
            }
            else if (this.options.colorByPoint) {
                this.color = "#cccccc" /* Palette.neutralColor20 */;
            }
            else {
                this.getCyclic('color', this.options.color ||
                    defaultOptions$1.plotOptions[this.type].color, this.chart.options.colors);
            }
        }
        /**
         * Get all points' instances created for this series.
         *
         * @private
         * @function Highcharts.Series#getPointsCollection
         */
        getPointsCollection() {
            return (this.hasGroupedData ? this.points : this.data) || [];
        }
        /**
         * Get the series' symbol based on either the options or pulled from
         * global options.
         *
         * @private
         * @function Highcharts.Series#getSymbol
         */
        getSymbol() {
            const seriesMarkerOption = this.options.marker;
            this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);
        }
        /**
         * Finds the index of an existing point that matches the given point
         * options.
         *
         * @private
         * @function Highcharts.Series#findPointIndex
         * @param {Highcharts.PointOptionsObject} optionsObject
         * The options of the point.
         * @param {number} fromIndex
         * The index to start searching from, used for optimizing series with
         * required sorting.
         * @return {number|undefined}
         * Returns the index of a matching point, or undefined if no match is found.
         */
        findPointIndex(optionsObject, fromIndex) {
            const id = optionsObject.id, x = optionsObject.x, oldData = this.points, dataSorting = this.options.dataSorting;
            let matchingPoint, matchedById, pointIndex;
            if (id) {
                const item = this.chart.get(id);
                if (item instanceof Point) {
                    matchingPoint = item;
                }
            }
            else if (this.linkedParent ||
                this.enabledDataSorting ||
                this.options.relativeXValue) {
                let matcher = (oldPoint) => !oldPoint.touched &&
                    oldPoint.index === optionsObject.index;
                if (dataSorting && dataSorting.matchByName) {
                    matcher = (oldPoint) => !oldPoint.touched &&
                        oldPoint.name === optionsObject.name;
                }
                else if (this.options.relativeXValue) {
                    matcher = (oldPoint) => !oldPoint.touched &&
                        oldPoint.options.x === optionsObject.x;
                }
                matchingPoint = find$1(oldData, matcher);
                // Add unmatched point as a new point
                if (!matchingPoint) {
                    return void 0;
                }
            }
            if (matchingPoint) {
                pointIndex = matchingPoint && matchingPoint.index;
                if (typeof pointIndex !== 'undefined') {
                    matchedById = true;
                }
            }
            // Search for the same X in the existing data set
            if (typeof pointIndex === 'undefined' && isNumber$5(x)) {
                pointIndex = this.xData.indexOf(x, fromIndex);
            }
            // Reduce pointIndex if data is cropped
            if (pointIndex !== -1 &&
                typeof pointIndex !== 'undefined' &&
                this.cropped) {
                pointIndex = (pointIndex >= this.cropStart) ?
                    pointIndex - this.cropStart : pointIndex;
            }
            if (!matchedById &&
                isNumber$5(pointIndex) &&
                oldData[pointIndex] && oldData[pointIndex].touched) {
                pointIndex = void 0;
            }
            return pointIndex;
        }
        /**
         * Internal function called from setData. If the point count is the same
         * as it was, or if there are overlapping X values, just run
         * Point.update which is cheaper, allows animation, and keeps references
         * to points. This also allows adding or removing points if the X-es
         * don't match.
         *
         * @private
         * @function Highcharts.Series#updateData
         */
        updateData(data, animation) {
            const options = this.options, dataSorting = options.dataSorting, oldData = this.points, pointsToAdd = [], requireSorting = this.requireSorting, equalLength = data.length === oldData.length;
            let hasUpdatedByKey, i, point, lastIndex, succeeded = true;
            this.xIncrement = null;
            // Iterate the new data
            data.forEach(function (pointOptions, i) {
                const optionsObject = (defined$5(pointOptions) &&
                    this.pointClass.prototype.optionsToObject.call({ series: this }, pointOptions)) || {};
                let pointIndex;
                // Get the x of the new data point
                const x = optionsObject.x, id = optionsObject.id;
                if (id || isNumber$5(x)) {
                    pointIndex = this.findPointIndex(optionsObject, lastIndex);
                    // Matching X not found
                    // or used already due to ununique x values (#8995),
                    // add point (but later)
                    if (pointIndex === -1 ||
                        typeof pointIndex === 'undefined') {
                        pointsToAdd.push(pointOptions);
                        // Matching X found, update
                    }
                    else if (oldData[pointIndex] &&
                        pointOptions !== options.data[pointIndex]) {
                        oldData[pointIndex].update(pointOptions, false, null, false);
                        // Mark it touched, below we will remove all points that
                        // are not touched.
                        oldData[pointIndex].touched = true;
                        // Speed optimize by only searching after last known
                        // index. Performs ~20% bettor on large data sets.
                        if (requireSorting) {
                            lastIndex = pointIndex + 1;
                        }
                        // Point exists, no changes, don't remove it
                    }
                    else if (oldData[pointIndex]) {
                        oldData[pointIndex].touched = true;
                    }
                    // If the length is equal and some of the nodes had a
                    // match in the same position, we don't want to remove
                    // non-matches.
                    if (!equalLength ||
                        i !== pointIndex ||
                        (dataSorting && dataSorting.enabled) ||
                        this.hasDerivedData) {
                        hasUpdatedByKey = true;
                    }
                }
                else {
                    // Gather all points that are not matched
                    pointsToAdd.push(pointOptions);
                }
            }, this);
            // Remove points that don't exist in the updated data set
            if (hasUpdatedByKey) {
                i = oldData.length;
                while (i--) {
                    point = oldData[i];
                    if (point && !point.touched && point.remove) {
                        point.remove(false, animation);
                    }
                }
                // If we did not find keys (ids or x-values), and the length is the
                // same, update one-to-one
            }
            else if (equalLength && (!dataSorting || !dataSorting.enabled)) {
                data.forEach(function (point, i) {
                    // .update doesn't exist on a linked, hidden series (#3709)
                    // (#10187)
                    if (point !== oldData[i].y && !oldData[i].destroyed) {
                        oldData[i].update(point, false, null, false);
                    }
                });
                // Don't add new points since those configs are used above
                pointsToAdd.length = 0;
                // Did not succeed in updating data
            }
            else {
                succeeded = false;
            }
            oldData.forEach(function (point) {
                if (point) {
                    point.touched = false;
                }
            });
            if (!succeeded) {
                return false;
            }
            // Add new points
            pointsToAdd.forEach(function (point) {
                this.addPoint(point, false, null, null, false);
            }, this);
            if (this.xIncrement === null &&
                this.xData &&
                this.xData.length) {
                this.xIncrement = arrayMax(this.xData);
                this.autoIncrement();
            }
            return true;
        }
        /**
         * Apply a new set of data to the series and optionally redraw it. The
         * new data array is passed by reference (except in case of
         * `updatePoints`), and may later be mutated when updating the chart
         * data.
         *
         * Note the difference in behaviour when setting the same amount of
         * points, or a different amount of points, as handled by the
         * `updatePoints` parameter.
         *
         * @sample highcharts/members/series-setdata/
         *         Set new data from a button
         * @sample highcharts/members/series-setdata-pie/
         *         Set data in a pie
         * @sample stock/members/series-setdata/
         *         Set new data in Highcharts Stock
         * @sample maps/members/series-setdata/
         *         Set new data in Highmaps
         *
         * @function Highcharts.Series#setData
         *
         * @param {Array<Highcharts.PointOptionsType>} data
         *        Takes an array of data in the same format as described under
         *        `series.{type}.data` for the given series type, for example a
         *        line series would take data in the form described under
         *        [series.line.data](https://api.highcharts.com/highcharts/series.line.data).
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart after the series is altered. If
         *        doing more operations on the chart, it is a good idea to set
         *        redraw to false and call {@link Chart#redraw} after.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
         *        When the updated data is the same length as the existing data,
         *        points will be updated by default, and animation visualizes
         *        how the points are changed. Set false to disable animation, or
         *        a configuration object to set duration or easing.
         *
         * @param {boolean} [updatePoints=true]
         *        When this is true, points will be updated instead of replaced
         *        whenever possible. This occurs a) when the updated data is the
         *        same length as the existing data, b) when points are matched
         *        by their id's, or c) when points can be matched by X values.
         *        This allows updating with animation and performs better. In
         *        this case, the original array is not passed by reference. Set
         *        `false` to prevent.
         */
        setData(data, redraw = true, animation, updatePoints) {
            var _a;
            const series = this, oldData = series.points, oldDataLength = (oldData && oldData.length) || 0, options = series.options, chart = series.chart, dataSorting = options.dataSorting, xAxis = series.xAxis, turboThreshold = options.turboThreshold, xData = this.xData, yData = this.yData, pointArrayMap = series.pointArrayMap, valueCount = pointArrayMap && pointArrayMap.length, keys = options.keys;
            let i, pt, updatedData, indexOfX = 0, indexOfY = 1, firstPoint = null, copiedData;
            if (!chart.options.chart.allowMutatingData) { // #4259
                // Remove old reference
                if (options.data) {
                    delete series.options.data;
                }
                if (series.userOptions.data) {
                    delete series.userOptions.data;
                }
                copiedData = merge$4(true, data);
            }
            data = copiedData || data || [];
            const dataLength = data.length;
            if (dataSorting && dataSorting.enabled) {
                data = this.sortData(data);
            }
            // First try to run Point.update which is cheaper, allows animation,
            // and keeps references to points.
            if (chart.options.chart.allowMutatingData &&
                updatePoints !== false &&
                dataLength &&
                oldDataLength &&
                !series.cropped &&
                !series.hasGroupedData &&
                series.visible &&
                // Soft updating has no benefit in boost, and causes JS error
                // (#8355)
                !series.boosted) {
                updatedData = this.updateData(data, animation);
            }
            if (!updatedData) {
                // Reset properties
                series.xIncrement = null;
                series.colorCounter = 0; // for series with colorByPoint (#1547)
                // Update parallel arrays
                this.parallelArrays.forEach(function (key) {
                    series[key + 'Data'].length = 0;
                });
                // In turbo mode, only one- or twodimensional arrays of numbers
                // are allowed. The first value is tested, and we assume that
                // all the rest are defined the same way. Although the 'for'
                // loops are similar, they are repeated inside each if-else
                // conditional for max performance.
                if (turboThreshold && dataLength > turboThreshold) {
                    firstPoint = series.getFirstValidPoint(data);
                    if (isNumber$5(firstPoint)) { // assume all points are numbers
                        for (i = 0; i < dataLength; i++) {
                            xData[i] = this.autoIncrement();
                            yData[i] = data[i];
                        }
                        // Assume all points are arrays when first point is
                    }
                    else if (isArray$3(firstPoint)) {
                        if (valueCount) { // [x, low, high] or [x, o, h, l, c]
                            if (firstPoint.length === valueCount) {
                                for (i = 0; i < dataLength; i++) {
                                    xData[i] = this.autoIncrement();
                                    yData[i] = data[i];
                                }
                            }
                            else {
                                for (i = 0; i < dataLength; i++) {
                                    pt = data[i];
                                    xData[i] = pt[0];
                                    yData[i] =
                                        pt.slice(1, valueCount + 1);
                                }
                            }
                        }
                        else { // [x, y]
                            if (keys) {
                                indexOfX = keys.indexOf('x');
                                indexOfY = keys.indexOf('y');
                                indexOfX = indexOfX >= 0 ? indexOfX : 0;
                                indexOfY = indexOfY >= 0 ? indexOfY : 1;
                            }
                            if (firstPoint.length === 1) {
                                indexOfY = 0;
                            }
                            if (indexOfX === indexOfY) {
                                for (i = 0; i < dataLength; i++) {
                                    xData[i] = this.autoIncrement();
                                    yData[i] = data[i][indexOfY];
                                }
                            }
                            else {
                                for (i = 0; i < dataLength; i++) {
                                    pt = data[i];
                                    xData[i] = pt[indexOfX];
                                    yData[i] = pt[indexOfY];
                                }
                            }
                        }
                    }
                    else {
                        // Highcharts expects configs to be numbers or arrays in
                        // turbo mode
                        error$1(12, false, chart);
                    }
                }
                else {
                    for (i = 0; i < dataLength; i++) {
                        pt = { series: series };
                        series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
                        series.updateParallelArrays(pt, i);
                    }
                }
                // Forgetting to cast strings to numbers is a common caveat when
                // handling CSV or JSON
                if (yData && isString$3(yData[0])) {
                    error$1(14, true, chart);
                }
                series.data = [];
                series.options.data = series.userOptions.data = data;
                // destroy old points
                i = oldDataLength;
                while (i--) {
                    (_a = oldData[i]) === null || _a === void 0 ? void 0 : _a.destroy();
                }
                // reset minRange (#878)
                if (xAxis) {
                    xAxis.minRange = xAxis.userMinRange;
                }
                // redraw
                series.isDirty = chart.isDirtyBox = true;
                series.isDirtyData = !!oldData;
                animation = false;
            }
            // Typically for pie series, points need to be processed and
            // generated prior to rendering the legend
            if (options.legendType === 'point') {
                this.processData();
                this.generatePoints();
            }
            if (redraw) {
                chart.redraw(animation);
            }
        }
        /**
         * Internal function to sort series data
         *
         * @private
         * @function Highcharts.Series#sortData
         * @param {Array<Highcharts.PointOptionsType>} data
         * Force data grouping.
         */
        sortData(data) {
            const series = this, options = series.options, dataSorting = options.dataSorting, sortKey = dataSorting.sortKey || 'y', getPointOptionsObject = function (series, pointOptions) {
                return (defined$5(pointOptions) &&
                    series.pointClass.prototype.optionsToObject.call({
                        series: series
                    }, pointOptions)) || {};
            };
            data.forEach(function (pointOptions, i) {
                data[i] = getPointOptionsObject(series, pointOptions);
                data[i].index = i;
            }, this);
            // Sorting
            const sortedData = data.concat().sort((a, b) => {
                const aValue = getNestedProperty(sortKey, a);
                const bValue = getNestedProperty(sortKey, b);
                return bValue < aValue ? -1 : bValue > aValue ? 1 : 0;
            });
            // Set x value depending on the position in the array
            sortedData.forEach(function (point, i) {
                point.x = i;
            }, this);
            // Set the same x for linked series points if they don't have their
            // own sorting
            if (series.linkedSeries) {
                series.linkedSeries.forEach(function (linkedSeries) {
                    const options = linkedSeries.options, seriesData = options.data;
                    if ((!options.dataSorting ||
                        !options.dataSorting.enabled) &&
                        seriesData) {
                        seriesData.forEach(function (pointOptions, i) {
                            seriesData[i] = getPointOptionsObject(linkedSeries, pointOptions);
                            if (data[i]) {
                                seriesData[i].x = data[i].x;
                                seriesData[i].index = i;
                            }
                        });
                        linkedSeries.setData(seriesData, false);
                    }
                });
            }
            return data;
        }
        /**
         * Internal function to process the data by cropping away unused data
         * points if the series is longer than the crop threshold. This saves
         * computing time for large series.
         *
         * @private
         * @function Highcharts.Series#getProcessedData
         * @param {boolean} [forceExtremesFromAll]
         * Force getting extremes of a total series data range.
         */
        getProcessedData(forceExtremesFromAll) {
            const series = this, xAxis = series.xAxis, options = series.options, cropThreshold = options.cropThreshold, getExtremesFromAll = forceExtremesFromAll ||
                series.getExtremesFromAll ||
                options.getExtremesFromAll, // #4599
            logarithmic = xAxis === null || xAxis === void 0 ? void 0 : xAxis.logarithmic, isCartesian = series.isCartesian;
            let croppedData, cropped, cropStart = 0, xExtremes, min, max, 
            // copied during slice operation:
            processedXData = series.xData, processedYData = series.yData, updatingNames = false;
            const dataLength = processedXData.length;
            if (xAxis) {
                // corrected for log axis (#3053)
                xExtremes = xAxis.getExtremes();
                min = xExtremes.min;
                max = xExtremes.max;
                updatingNames = !!(xAxis.categories && !xAxis.names.length);
            }
            // optionally filter out points outside the plot area
            if (isCartesian &&
                series.sorted &&
                !getExtremesFromAll &&
                (!cropThreshold ||
                    dataLength > cropThreshold ||
                    series.forceCrop)) {
                // it's outside current extremes
                if (processedXData[dataLength - 1] < min ||
                    processedXData[0] > max) {
                    processedXData = [];
                    processedYData = [];
                    // only crop if it's actually spilling out
                }
                else if (series.yData && (processedXData[0] < min ||
                    processedXData[dataLength - 1] > max)) {
                    croppedData = this.cropData(series.xData, series.yData, min, max);
                    processedXData = croppedData.xData;
                    processedYData = croppedData.yData;
                    cropStart = croppedData.start;
                    cropped = true;
                }
            }
            // Find the closest distance between processed points
            const closestPointRange = getClosestDistance([
                logarithmic ?
                    processedXData.map(logarithmic.log2lin) :
                    processedXData
            ], 
            // Unsorted data is not supported by the line tooltip, as well as
            // data grouping and navigation in Stock charts (#725) and width
            // calculation of columns (#1900). Avoid warning during the
            // premature processing pass in updateNames (#16104).
            () => (series.requireSorting &&
                !updatingNames &&
                error$1(15, false, series.chart)));
            return {
                xData: processedXData,
                yData: processedYData,
                cropped: cropped,
                cropStart: cropStart,
                closestPointRange: closestPointRange
            };
        }
        /**
         * Internal function to apply processed data.
         * In Highcharts Stock, this function is extended to provide data grouping.
         *
         * @private
         * @function Highcharts.Series#processData
         * @param {boolean} [force]
         * Force data grouping.
         */
        processData(force) {
            const series = this, xAxis = series.xAxis;
            // If the series data or axes haven't changed, don't go through
            // this. Return false to pass the message on to override methods
            // like in data grouping.
            if (series.isCartesian &&
                !series.isDirty &&
                !xAxis.isDirty &&
                !series.yAxis.isDirty &&
                !force) {
                return false;
            }
            const processedData = series.getProcessedData();
            // Record the properties
            series.cropped = processedData.cropped; // undefined or true
            series.cropStart = processedData.cropStart;
            series.processedXData = processedData.xData;
            series.processedYData = processedData.yData;
            series.closestPointRange = (series.basePointRange = processedData.closestPointRange);
            fireEvent$3(series, 'afterProcessData');
        }
        /**
         * Iterate over xData and crop values between min and max. Returns
         * object containing crop start/end cropped xData with corresponding
         * part of yData, dataMin and dataMax within the cropped range.
         *
         * @private
         * @function Highcharts.Series#cropData
         */
        cropData(xData, yData, min, max, cropShoulder) {
            const dataLength = xData.length;
            let i, j, cropStart = 0, cropEnd = dataLength;
            // line-type series need one point outside
            cropShoulder = pick$6(cropShoulder, this.cropShoulder);
            // iterate up to find slice start
            for (i = 0; i < dataLength; i++) {
                if (xData[i] >= min) {
                    cropStart = Math.max(0, i - cropShoulder);
                    break;
                }
            }
            // proceed to find slice end
            for (j = i; j < dataLength; j++) {
                if (xData[j] > max) {
                    cropEnd = j + cropShoulder;
                    break;
                }
            }
            return {
                xData: xData.slice(cropStart, cropEnd),
                yData: yData.slice(cropStart, cropEnd),
                start: cropStart,
                end: cropEnd
            };
        }
        /**
         * Generate the data point after the data has been processed by cropping
         * away unused points and optionally grouped in Highcharts Stock.
         *
         * @private
         * @function Highcharts.Series#generatePoints
         */
        generatePoints() {
            const series = this, options = series.options, dataOptions = (series.processedData || options.data), processedXData = series.processedXData, processedYData = series.processedYData, PointClass = series.pointClass, processedDataLength = processedXData.length, cropStart = series.cropStart || 0, hasGroupedData = series.hasGroupedData, keys = options.keys, points = [], groupCropStartIndex = (options.dataGrouping &&
                options.dataGrouping.groupAll ?
                cropStart :
                0);
            let dataLength, cursor, point, i, data = series.data;
            if (!data && !hasGroupedData) {
                const arr = [];
                arr.length = dataOptions.length;
                data = series.data = arr;
            }
            if (keys && hasGroupedData) {
                // grouped data has already applied keys (#6590)
                series.options.keys = false;
            }
            for (i = 0; i < processedDataLength; i++) {
                cursor = cropStart + i;
                if (!hasGroupedData) {
                    point = data[cursor];
                    // #970:
                    if (!point &&
                        typeof dataOptions[cursor] !== 'undefined') {
                        data[cursor] = point = (new PointClass()).init(series, dataOptions[cursor], processedXData[i]);
                    }
                }
                else {
                    // splat the y data in case of ohlc data array
                    point = (new PointClass()).init(series, [processedXData[i]].concat(splat$1(processedYData[i])));
                    point.dataGroup = series.groupMap[groupCropStartIndex + i];
                    if (point.dataGroup.options) {
                        point.options = point.dataGroup.options;
                        extend$5(point, point.dataGroup.options);
                        // Collision of props and options (#9770)
                        delete point.dataLabels;
                    }
                }
                if (point) { // #6279
                    /**
                     * Contains the point's index in the `Series.points` array.
                     *
                     * @name Highcharts.Point#index
                     * @type {number}
                     * @readonly
                     */
                    // For faster access in Point.update
                    point.index = hasGroupedData ?
                        (groupCropStartIndex + i) : cursor;
                    points[i] = point;
                }
            }
            // restore keys options (#6590)
            series.options.keys = keys;
            // Hide cropped-away points - this only runs when the number of
            // points is above cropThreshold, or when swithching view from
            // non-grouped data to grouped data (#637)
            if (data &&
                (processedDataLength !== (dataLength = data.length) ||
                    hasGroupedData)) {
                for (i = 0; i < dataLength; i++) {
                    // when has grouped data, clear all points
                    if (i === cropStart && !hasGroupedData) {
                        i += processedDataLength;
                    }
                    if (data[i]) {
                        data[i].destroyElements();
                        data[i].plotX = void 0; // #1003
                    }
                }
            }
            /**
             * Read only. An array containing those values converted to points.
             * In case the series data length exceeds the `cropThreshold`, or if
             * the data is grouped, `series.data` doesn't contain all the
             * points. Also, in case a series is hidden, the `data` array may be
             * empty. To access raw values, `series.options.data` will always be
             * up to date. `Series.data` only contains the points that have been
             * created on demand. To modify the data, use
             * {@link Highcharts.Series#setData} or
             * {@link Highcharts.Point#update}.
             *
             * @see Series.points
             *
             * @name Highcharts.Series#data
             * @type {Array<Highcharts.Point>}
             */
            series.data = data;
            /**
             * An array containing all currently visible point objects. In case
             * of cropping, the cropped-away points are not part of this array.
             * The `series.points` array starts at `series.cropStart` compared
             * to `series.data` and `series.options.data`. If however the series
             * data is grouped, these can't be correlated one to one. To modify
             * the data, use {@link Highcharts.Series#setData} or
             * {@link Highcharts.Point#update}.
             *
             * @name Highcharts.Series#points
             * @type {Array<Highcharts.Point>}
             */
            series.points = points;
            fireEvent$3(this, 'afterGeneratePoints');
        }
        /**
         * Get current X extremes for the visible data.
         *
         * @private
         * @function Highcharts.Series#getXExtremes
         * @param {Array<number>} xData
         * The data to inspect. Defaults to the current data within the visible
         * range.
         */
        getXExtremes(xData) {
            return {
                min: arrayMin(xData),
                max: arrayMax(xData)
            };
        }
        /**
         * Calculate Y extremes for the visible data. The result is returned
         * as an object with `dataMin` and `dataMax` properties.
         *
         * @private
         * @function Highcharts.Series#getExtremes
         * @param {Array<number>} [yData]
         * The data to inspect. Defaults to the current data within the visible
         * range.
         * @param {boolean} [forceExtremesFromAll]
         * Force getting extremes of a total series data range.
         */
        getExtremes(yData, forceExtremesFromAll) {
            const xAxis = this.xAxis, yAxis = this.yAxis, xData = this.processedXData || this.xData, activeYData = [], 
            // Handle X outside the viewed area. This does not work with
            // non-sorted data like scatter (#7639).
            shoulder = this.requireSorting ? this.cropShoulder : 0, positiveValuesOnly = yAxis ? yAxis.positiveValuesOnly : false;
            // #2117, need to compensate for log X axis
            let xExtremes, validValue, withinRange, x, y, i, j, xMin = 0, xMax = 0, activeCounter = 0;
            yData = yData || this.stackedYData || this.processedYData || [];
            const yDataLength = yData.length;
            if (xAxis) {
                xExtremes = xAxis.getExtremes();
                xMin = xExtremes.min;
                xMax = xExtremes.max;
            }
            for (i = 0; i < yDataLength; i++) {
                x = xData[i];
                y = yData[i];
                // For points within the visible range, including the first
                // point outside the visible range (#7061), consider y extremes.
                validValue = ((isNumber$5(y) || isArray$3(y)) &&
                    ((y.length || y > 0) || !positiveValuesOnly));
                withinRange = (forceExtremesFromAll ||
                    this.getExtremesFromAll ||
                    this.options.getExtremesFromAll ||
                    this.cropped ||
                    !xAxis || // for colorAxis support
                    ((xData[i + shoulder] || x) >= xMin &&
                        (xData[i - shoulder] || x) <= xMax));
                if (validValue && withinRange) {
                    j = y.length;
                    if (j) { // array, like ohlc or range data
                        while (j--) {
                            if (isNumber$5(y[j])) { // #7380, #11513
                                activeYData[activeCounter++] = y[j];
                            }
                        }
                    }
                    else {
                        activeYData[activeCounter++] = y;
                    }
                }
            }
            const dataExtremes = {
                activeYData,
                dataMin: arrayMin(activeYData),
                dataMax: arrayMax(activeYData)
            };
            fireEvent$3(this, 'afterGetExtremes', { dataExtremes });
            return dataExtremes;
        }
        /**
         * Set the current data extremes as `dataMin` and `dataMax` on the
         * Series item. Use this only when the series properties should be
         * updated.
         *
         * @private
         * @function Highcharts.Series#applyExtremes
         */
        applyExtremes() {
            const dataExtremes = this.getExtremes();
            /**
             * Contains the minimum value of the series' data point. Some series
             * types like `networkgraph` do not support this property as they
             * lack a `y`-value.
             * @name Highcharts.Series#dataMin
             * @type {number|undefined}
             * @readonly
             */
            this.dataMin = dataExtremes.dataMin;
            /**
             * Contains the maximum value of the series' data point. Some series
             * types like `networkgraph` do not support this property as they
             * lack a `y`-value.
             * @name Highcharts.Series#dataMax
             * @type {number|undefined}
             * @readonly
             */
            this.dataMax = dataExtremes.dataMax;
            return dataExtremes;
        }
        /**
         * Find and return the first non null point in the data
         *
         * @private
         * @function Highcharts.Series.getFirstValidPoint
         * @param {Array<Highcharts.PointOptionsType>} data
         * Array of options for points
         */
        getFirstValidPoint(data) {
            const dataLength = data.length;
            let i = 0, firstPoint = null;
            while (firstPoint === null && i < dataLength) {
                firstPoint = data[i];
                i++;
            }
            return firstPoint;
        }
        /**
         * Translate data points from raw data values to chart specific
         * positioning data needed later in the `drawPoints` and `drawGraph`
         * functions. This function can be overridden in plugins and custom
         * series type implementations.
         *
         * @function Highcharts.Series#translate
         *
         * @emits Highcharts.Series#events:translate
         */
        translate() {
            var _a;
            if (!this.processedXData) { // hidden series
                this.processData();
            }
            this.generatePoints();
            const series = this, options = series.options, stacking = options.stacking, xAxis = series.xAxis, categories = xAxis.categories, enabledDataSorting = series.enabledDataSorting, yAxis = series.yAxis, points = series.points, dataLength = points.length, pointPlacement = series.pointPlacementToXValue(), // #7860
            dynamicallyPlaced = Boolean(pointPlacement), threshold = options.threshold, stackThreshold = options.startFromThreshold ? threshold : 0;
            let i, plotX, lastPlotX, stackIndicator, closestPointRangePx = Number.MAX_VALUE;
            /**
             * Plotted coordinates need to be within a limited range. Drawing
             * too far outside the viewport causes various rendering issues
             * (#3201, #3923, #7555).
             * @private
             */
            function limitedRange(val) {
                return clamp$1(val, -1e5, 1e5);
            }
            // Translate each point
            for (i = 0; i < dataLength; i++) {
                const point = points[i], xValue = point.x;
                let stackItem, stackValues, yValue = point.y, lowValue = point.low;
                const stacks = stacking && ((_a = yAxis.stacking) === null || _a === void 0 ? void 0 : _a.stacks[(series.negStacks &&
                    yValue <
                        (stackThreshold ? 0 : threshold) ?
                    '-' :
                    '') + series.stackKey]);
                plotX = xAxis.translate(// #3923
                xValue, false, false, false, true, pointPlacement);
                /**
                 * The translated X value for the point in terms of pixels. Relative
                 * to the X axis position if the series has one, otherwise relative
                 * to the plot area. Depending on the series type this value might
                 * not be defined.
                 * @name Highcharts.Point#plotX
                 * @type {number|undefined}
                 */
                point.plotX = isNumber$5(plotX) ? correctFloat(// #5236
                limitedRange(plotX) // #3923
                ) : void 0;
                // Calculate the bottom y value for stacked series
                if (stacking &&
                    series.visible &&
                    stacks &&
                    stacks[xValue]) {
                    stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);
                    if (!point.isNull && stackIndicator.key) {
                        stackItem = stacks[xValue];
                        stackValues = stackItem.points[stackIndicator.key];
                    }
                    if (stackItem && isArray$3(stackValues)) {
                        lowValue = stackValues[0];
                        yValue = stackValues[1];
                        if (lowValue === stackThreshold &&
                            stackIndicator.key === stacks[xValue].base) {
                            lowValue = pick$6(isNumber$5(threshold) ? threshold : yAxis.min);
                        }
                        // #1200, #1232
                        if (yAxis.positiveValuesOnly &&
                            defined$5(lowValue) &&
                            lowValue <= 0) {
                            lowValue = void 0;
                        }
                        point.total = point.stackTotal = pick$6(stackItem.total);
                        point.percentage = defined$5(point.y) && stackItem.total ?
                            (point.y / stackItem.total * 100) : void 0;
                        point.stackY = yValue;
                        // in case of variwide series (where widths of points are
                        // different in most cases), stack labels are positioned
                        // wrongly, so the call of the setOffset is omited here and
                        // labels are correctly positioned later, at the end of the
                        // variwide's translate function (#10962)
                        if (!series.irregularWidths) {
                            stackItem.setOffset(series.pointXOffset || 0, series.barW || 0, void 0, void 0, void 0, series.xAxis);
                        }
                    }
                }
                // Set translated yBottom or remove it
                point.yBottom = defined$5(lowValue) ?
                    limitedRange(yAxis.translate(lowValue, false, true, false, true)) :
                    void 0;
                // General hook, used for Highcharts Stock compare and cumulative
                if (series.dataModify) {
                    yValue = series.dataModify.modifyValue(yValue, i);
                }
                // Set the the plotY value, reset it for redraws #3201, #18422
                let plotY;
                if (isNumber$5(yValue) && point.plotX !== void 0) {
                    plotY = yAxis.translate(yValue, false, true, false, true);
                    plotY = isNumber$5(plotY) ? limitedRange(plotY) : void 0;
                }
                /**
                 * The translated Y value for the point in terms of pixels. Relative
                 * to the Y axis position if the series has one, otherwise relative
                 * to the plot area. Depending on the series type this value might
                 * not be defined.
                 * @name Highcharts.Point#plotY
                 * @type {number|undefined}
                 */
                point.plotY = plotY;
                point.isInside = this.isPointInside(point);
                // Set client related positions for mouse tracking
                point.clientX = dynamicallyPlaced ?
                    correctFloat(xAxis.translate(xValue, false, false, false, true, pointPlacement)) :
                    plotX; // #1514, #5383, #5518
                // Negative points #19028
                point.negative = (point.y || 0) < (threshold || 0);
                // some API data
                point.category = pick$6(categories && categories[point.x], point.x);
                // Determine auto enabling of markers (#3635, #5099)
                if (!point.isNull && point.visible !== false) {
                    if (typeof lastPlotX !== 'undefined') {
                        closestPointRangePx = Math.min(closestPointRangePx, Math.abs(plotX - lastPlotX));
                    }
                    lastPlotX = plotX;
                }
                // Find point zone
                point.zone = this.zones.length ? point.getZone() : void 0;
                // Animate new points with data sorting
                if (!point.graphic && series.group && enabledDataSorting) {
                    point.isNew = true;
                }
            }
            series.closestPointRangePx = closestPointRangePx;
            fireEvent$3(this, 'afterTranslate');
        }
        /**
         * Return the series points with null points filtered out.
         *
         * @function Highcharts.Series#getValidPoints
         *
         * @param {Array<Highcharts.Point>} [points]
         * The points to inspect, defaults to {@link Series.points}.
         *
         * @param {boolean} [insideOnly=false]
         * Whether to inspect only the points that are inside the visible view.
         *
         * @param {boolean} [allowNull=false]
         * Whether to allow null points to pass as valid points.
         *
         * @return {Array<Highcharts.Point>}
         * The valid points.
         */
        getValidPoints(points, insideOnly, allowNull) {
            const chart = this.chart;
            // #3916, #5029, #5085
            return (points || this.points || []).filter(function (point) {
                const { plotX, plotY } = point, 
                // Undefined plotY is treated as null when negative values
                // in log axis (#18422)
                asNull = !allowNull && (point.isNull || !isNumber$5(plotY));
                if (asNull || (insideOnly && !chart.isInsidePlot(plotX, plotY, { inverted: chart.inverted }))) {
                    return false;
                }
                return point.visible !== false;
            });
        }
        /**
         * Get the clipping for the series. Could be called for a series to
         * initiate animating the clip or to set the final clip (only width
         * and x).
         *
         * @private
         * @function Highcharts.Series#getClip
         */
        getClipBox() {
            const { chart, xAxis, yAxis } = this;
            // If no axes on the series, use global clipBox
            const seriesBox = merge$4(chart.clipBox);
            // Otherwise, use clipBox.width which is corrected for plotBorderWidth
            // and clipOffset
            if (xAxis && xAxis.len !== chart.plotSizeX) {
                seriesBox.width = xAxis.len;
            }
            if (yAxis && yAxis.len !== chart.plotSizeY) {
                seriesBox.height = yAxis.len;
            }
            return seriesBox;
        }
        /**
         * Get the shared clip key, creating it if it doesn't exist.
         *
         * @private
         * @function Highcharts.Series#getSharedClipKey
         */
        getSharedClipKey() {
            this.sharedClipKey = (this.options.xAxis || 0) + ',' +
                (this.options.yAxis || 0);
            return this.sharedClipKey;
        }
        /**
         * Set the clipping for the series. For animated series the clip is later
         * modified.
         *
         * @private
         * @function Highcharts.Series#setClip
         */
        setClip() {
            const { chart, group, markerGroup } = this, sharedClips = chart.sharedClips, renderer = chart.renderer, clipBox = this.getClipBox(), sharedClipKey = this.getSharedClipKey(); // #4526
            let clipRect = sharedClips[sharedClipKey];
            // If a clipping rectangle for the same set of axes does not exist,
            // create it
            if (!clipRect) {
                sharedClips[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
                // When setting chart size, or when the series is rendered again before
                // starting animating, in compliance to a responsive rule
            }
            else {
                clipRect.animate(clipBox);
            }
            if (group) {
                // When clip is false, reset to no clip after animation
                group.clip(this.options.clip === false ? void 0 : clipRect);
            }
            // Unclip temporary animation clip
            if (markerGroup) {
                markerGroup.clip();
            }
        }
        /**
         * Animate in the series. Called internally twice. First with the `init`
         * parameter set to true, which sets up the initial state of the
         * animation. Then when ready, it is called with the `init` parameter
         * undefined, in order to perform the actual animation.
         *
         * @function Highcharts.Series#animate
         *
         * @param {boolean} [init]
         * Initialize the animation.
         */
        animate(init) {
            const { chart, group, markerGroup } = this, inverted = chart.inverted, animation = animObject$2(this.options.animation), 
            // The key for temporary animation clips
            animationClipKey = [
                this.getSharedClipKey(),
                animation.duration,
                animation.easing,
                animation.defer
            ].join(',');
            let animationClipRect = chart.sharedClips[animationClipKey], markerAnimationClipRect = chart.sharedClips[animationClipKey + 'm'];
            // Initialize the animation. Set up the clipping rectangle.
            if (init && group) {
                const clipBox = this.getClipBox();
                // Create temporary animation clips
                if (!animationClipRect) {
                    clipBox.width = 0;
                    if (inverted) {
                        clipBox.x = chart.plotHeight;
                    }
                    animationClipRect = chart.renderer.clipRect(clipBox);
                    chart.sharedClips[animationClipKey] = animationClipRect;
                    // The marker clip box. The number 99 is a safe margin to avoid
                    // markers being clipped during animation.
                    const markerClipBox = {
                        x: inverted ? -99 : -99,
                        y: inverted ? -99 : -99,
                        width: inverted ? chart.plotWidth + 199 : 99,
                        height: inverted ? 99 : chart.plotHeight + 199
                    };
                    markerAnimationClipRect = chart.renderer.clipRect(markerClipBox);
                    chart.sharedClips[animationClipKey + 'm'] = markerAnimationClipRect;
                }
                else {
                    // When height changes during animation, typically due to
                    // responsive settings
                    animationClipRect.attr('height', clipBox.height);
                }
                group.clip(animationClipRect);
                if (markerGroup) {
                    markerGroup.clip(markerAnimationClipRect);
                }
                // Run the animation
            }
            else if (animationClipRect &&
                // Only first series in this pane
                !animationClipRect.hasClass('highcharts-animating')) {
                const finalBox = this.getClipBox(), step = animation.step;
                // Only do this when there are actually markers
                if (markerGroup && markerGroup.element.childNodes.length) {
                    // To provide as smooth animation as possible, update the marker
                    // group clipping in steps of the main group animation
                    animation.step = function (val, fx) {
                        if (step) {
                            step.apply(fx, arguments);
                        }
                        if (fx.prop === 'width' &&
                            markerAnimationClipRect &&
                            markerAnimationClipRect.element) {
                            markerAnimationClipRect.attr(inverted ? 'height' : 'width', val + 99);
                        }
                    };
                }
                animationClipRect
                    .addClass('highcharts-animating')
                    .animate(finalBox, animation);
            }
        }
        /**
         * This runs after animation to land on the final plot clipping.
         *
         * @private
         * @function Highcharts.Series#afterAnimate
         *
         * @emits Highcharts.Series#event:afterAnimate
         */
        afterAnimate() {
            this.setClip();
            // Destroy temporary clip rectangles that are no longer in use
            objectEach$3(this.chart.sharedClips, (clip, key, sharedClips) => {
                if (clip && !this.chart.container.querySelector(`[clip-path="url(#${clip.id})"]`)) {
                    clip.destroy();
                    delete sharedClips[key];
                }
            });
            this.finishedAnimating = true;
            fireEvent$3(this, 'afterAnimate');
        }
        /**
         * Draw the markers for line-like series types, and columns or other
         * graphical representation for {@link Point} objects for other series
         * types. The resulting element is typically stored as
         * {@link Point.graphic}, and is created on the first call and updated
         * and moved on subsequent calls.
         *
         * @function Highcharts.Series#drawPoints
         */
        drawPoints(points = this.points) {
            const series = this, chart = series.chart, styledMode = chart.styledMode, { colorAxis, options } = series, seriesMarkerOptions = options.marker, markerGroup = series[series.specialGroup || 'markerGroup'], xAxis = series.xAxis, globallyEnabled = pick$6(seriesMarkerOptions.enabled, !xAxis || xAxis.isRadial ? true : null, 
            // Use larger or equal as radius is null in bubbles (#6321)
            series.closestPointRangePx >= (seriesMarkerOptions.enabledThreshold *
                seriesMarkerOptions.radius));
            let i, point, graphic, verb, pointMarkerOptions, hasPointMarker, markerAttribs;
            if (seriesMarkerOptions.enabled !== false ||
                series._hasPointMarkers) {
                for (i = 0; i < points.length; i++) {
                    point = points[i];
                    graphic = point.graphic;
                    verb = graphic ? 'animate' : 'attr';
                    pointMarkerOptions = point.marker || {};
                    hasPointMarker = !!point.marker;
                    const shouldDrawMarker = ((globallyEnabled &&
                        typeof pointMarkerOptions.enabled === 'undefined') || pointMarkerOptions.enabled) && !point.isNull && point.visible !== false;
                    // only draw the point if y is defined
                    if (shouldDrawMarker) {
                        // Shortcuts
                        const symbol = pick$6(pointMarkerOptions.symbol, series.symbol, 'rect');
                        markerAttribs = series.markerAttribs(point, (point.selected && 'select'));
                        // Set starting position for point sliding animation.
                        if (series.enabledDataSorting) {
                            point.startXPos = xAxis.reversed ?
                                -(markerAttribs.width || 0) :
                                xAxis.width;
                        }
                        const isInside = point.isInside !== false;
                        if (!graphic &&
                            isInside &&
                            ((markerAttribs.width || 0) > 0 || point.hasImage)) {
                            /**
                             * SVG graphic representing the point in the chart. In
                             * some cases it may be a hidden graphic to improve
                             * accessibility.
                             *
                             * Typically this is a simple shape, like a `rect`
                             * for column charts or `path` for line markers, but
                             * for some complex series types like boxplot or 3D
                             * charts, the graphic may be a `g` element
                             * containing other shapes. The graphic is generated
                             * the first time {@link Series#drawPoints} runs,
                             * and updated and moved on subsequent runs.
                             *
                             * @see Highcharts.Point#graphics
                             *
                             * @name Highcharts.Point#graphic
                             * @type {Highcharts.SVGElement|undefined}
                             */
                            point.graphic = graphic = chart.renderer
                                .symbol(symbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height, hasPointMarker ?
                                pointMarkerOptions :
                                seriesMarkerOptions)
                                .add(markerGroup);
                            // Sliding animation for new points
                            if (series.enabledDataSorting &&
                                chart.hasRendered) {
                                graphic.attr({
                                    x: point.startXPos
                                });
                                verb = 'animate';
                            }
                        }
                        if (graphic && verb === 'animate') { // update
                            // Since the marker group isn't clipped, each
                            // individual marker must be toggled
                            graphic[isInside ? 'show' : 'hide'](isInside)
                                .animate(markerAttribs);
                        }
                        // Presentational attributes
                        if (graphic) {
                            const pointAttr = series.pointAttribs(point, ((styledMode || !point.selected) ?
                                void 0 :
                                'select'));
                            if (!styledMode) {
                                graphic[verb](pointAttr);
                            }
                            else if (colorAxis) { // #14114
                                graphic['css']({
                                    fill: pointAttr.fill
                                });
                            }
                        }
                        if (graphic) {
                            graphic.addClass(point.getClassName(), true);
                        }
                    }
                    else if (graphic) {
                        point.graphic = graphic.destroy(); // #1269
                    }
                }
            }
        }
        /**
         * Get non-presentational attributes for a point. Used internally for
         * both styled mode and classic. Can be overridden for different series
         * types.
         *
         * @see Series#pointAttribs
         *
         * @function Highcharts.Series#markerAttribs
         *
         * @param {Highcharts.Point} point
         * The Point to inspect.
         *
         * @param {string} [state]
         * The state, can be either `hover`, `select` or undefined.
         *
         * @return {Highcharts.SVGAttributes}
         * A hash containing those attributes that are not settable from CSS.
         */
        markerAttribs(point, state) {
            const seriesOptions = this.options, seriesMarkerOptions = seriesOptions.marker, pointMarkerOptions = point.marker || {}, symbol = (pointMarkerOptions.symbol ||
                seriesMarkerOptions.symbol), attribs = {};
            let seriesStateOptions, pointStateOptions, radius = pick$6(pointMarkerOptions.radius, seriesMarkerOptions && seriesMarkerOptions.radius);
            // Handle hover and select states
            if (state) {
                seriesStateOptions = seriesMarkerOptions.states[state];
                pointStateOptions = pointMarkerOptions.states &&
                    pointMarkerOptions.states[state];
                radius = pick$6(pointStateOptions && pointStateOptions.radius, seriesStateOptions && seriesStateOptions.radius, radius && radius + (seriesStateOptions && seriesStateOptions.radiusPlus ||
                    0));
            }
            point.hasImage = symbol && symbol.indexOf('url') === 0;
            if (point.hasImage) {
                radius = 0; // and subsequently width and height is not set
            }
            const pos = point.pos();
            if (isNumber$5(radius) && pos) {
                attribs.x = pos[0] - radius;
                attribs.y = pos[1] - radius;
                if (seriesOptions.crisp) {
                    // Math.floor for #1843:
                    attribs.x = Math.floor(attribs.x);
                }
            }
            if (radius) {
                attribs.width = attribs.height = 2 * radius;
            }
            return attribs;
        }
        /**
         * Internal function to get presentational attributes for each point.
         * Unlike {@link Series#markerAttribs}, this function should return
         * those attributes that can also be set in CSS. In styled mode,
         * `pointAttribs` won't be called.
         *
         * @private
         * @function Highcharts.Series#pointAttribs
         *
         * @param {Highcharts.Point} [point]
         * The point instance to inspect.
         *
         * @param {string} [state]
         * The point state, can be either `hover`, `select` or 'normal'. If
         * undefined, normal state is assumed.
         *
         * @return {Highcharts.SVGAttributes}
         * The presentational attributes to be set on the point.
         */
        pointAttribs(point, state) {
            const seriesMarkerOptions = this.options.marker, pointOptions = point && point.options, pointMarkerOptions = ((pointOptions && pointOptions.marker) || {}), pointColorOption = pointOptions && pointOptions.color, pointColor = point && point.color, zoneColor = point && point.zone && point.zone.color;
            let seriesStateOptions, pointStateOptions, color = this.color, fill, stroke, strokeWidth = pick$6(pointMarkerOptions.lineWidth, seriesMarkerOptions.lineWidth), opacity = 1;
            color = (pointColorOption ||
                zoneColor ||
                pointColor ||
                color);
            fill = (pointMarkerOptions.fillColor ||
                seriesMarkerOptions.fillColor ||
                color);
            stroke = (pointMarkerOptions.lineColor ||
                seriesMarkerOptions.lineColor ||
                color);
            // Handle hover and select states
            state = state || 'normal';
            if (state) {
                seriesStateOptions = (seriesMarkerOptions.states[state] || {});
                pointStateOptions = (pointMarkerOptions.states &&
                    pointMarkerOptions.states[state]) || {};
                strokeWidth = pick$6(pointStateOptions.lineWidth, seriesStateOptions.lineWidth, strokeWidth + pick$6(pointStateOptions.lineWidthPlus, seriesStateOptions.lineWidthPlus, 0));
                fill = (pointStateOptions.fillColor ||
                    seriesStateOptions.fillColor ||
                    fill);
                stroke = (pointStateOptions.lineColor ||
                    seriesStateOptions.lineColor ||
                    stroke);
                opacity = pick$6(pointStateOptions.opacity, seriesStateOptions.opacity, opacity);
            }
            return {
                'stroke': stroke,
                'stroke-width': strokeWidth,
                'fill': fill,
                'opacity': opacity
            };
        }
        /**
         * Clear DOM objects and free up memory.
         *
         * @private
         * @function Highcharts.Series#destroy
         *
         * @emits Highcharts.Series#event:destroy
         */
        destroy(keepEventsForUpdate) {
            const series = this, chart = series.chart, issue134 = /AppleWebKit\/533/.test(win$3.navigator.userAgent), data = series.data || [];
            let destroy, i, point, axis;
            // add event hook
            fireEvent$3(series, 'destroy', { keepEventsForUpdate });
            // remove events
            this.removeEvents(keepEventsForUpdate);
            // erase from axes
            (series.axisTypes || []).forEach(function (AXIS) {
                axis = series[AXIS];
                if (axis && axis.series) {
                    erase$1(axis.series, series);
                    axis.isDirty = axis.forceRedraw = true;
                }
            });
            // remove legend items
            if (series.legendItem) {
                series.chart.legend.destroyItem(series);
            }
            // destroy all points with their elements
            i = data.length;
            while (i--) {
                point = data[i];
                if (point && point.destroy) {
                    point.destroy();
                }
            }
            if (series.clips) {
                series.clips.forEach((clip) => clip.destroy());
            }
            // Clear the animation timeout if we are destroying the series
            // during initial animation
            Utilities.clearTimeout(series.animationTimeout);
            // Destroy all SVGElements associated to the series
            objectEach$3(series, function (val, prop) {
                // Survive provides a hook for not destroying
                if (val instanceof SVGElement && !val.survive) {
                    // issue 134 workaround
                    destroy = issue134 && prop === 'group' ?
                        'hide' :
                        'destroy';
                    val[destroy]();
                }
            });
            // remove from hoverSeries
            if (chart.hoverSeries === series) {
                chart.hoverSeries = void 0;
            }
            erase$1(chart.series, series);
            chart.orderItems('series');
            // clear all members
            objectEach$3(series, function (val, prop) {
                if (!keepEventsForUpdate || prop !== 'hcEvents') {
                    delete series[prop];
                }
            });
        }
        /**
         * Clip the graphs into zones for colors and styling.
         *
         * @private
         * @function Highcharts.Series#applyZones
         */
        applyZones() {
            const series = this, chart = this.chart, renderer = chart.renderer, zones = this.zones, clips = (this.clips || []), graph = this.graph, area = this.area, plotSizeMax = Math.max(chart.plotWidth, chart.plotHeight), axis = this[(this.zoneAxis || 'y') + 'Axis'], inverted = chart.inverted;
            let translatedFrom, translatedTo, clipAttr, extremes, reversed, horiz, pxRange, pxPosMin, pxPosMax, zoneArea, zoneGraph, ignoreZones = false;
            if (zones.length &&
                (graph || area) &&
                axis &&
                typeof axis.min !== 'undefined') {
                reversed = axis.reversed;
                horiz = axis.horiz;
                // The use of the Color Threshold assumes there are no gaps
                // so it is safe to hide the original graph and area
                // unless it is not waterfall series, then use showLine property
                // to set lines between columns to be visible (#7862)
                if (graph && !this.showLine) {
                    graph.hide();
                }
                if (area) {
                    area.hide();
                }
                // Create the clips
                extremes = axis.getExtremes();
                zones.forEach(function (threshold, i) {
                    translatedFrom = reversed ?
                        (horiz ? chart.plotWidth : 0) :
                        (horiz ? 0 : (axis.toPixels(extremes.min) || 0));
                    translatedFrom = clamp$1(pick$6(translatedTo, translatedFrom), 0, plotSizeMax);
                    translatedTo = clamp$1(Math.round(axis.toPixels(pick$6(threshold.value, extremes.max), true) || 0), 0, plotSizeMax);
                    if (ignoreZones) {
                        translatedFrom = translatedTo =
                            axis.toPixels(extremes.max);
                    }
                    pxRange = Math.abs(translatedFrom - translatedTo);
                    pxPosMin = Math.min(translatedFrom, translatedTo);
                    pxPosMax = Math.max(translatedFrom, translatedTo);
                    if (axis.isXAxis) {
                        clipAttr = {
                            x: inverted ? pxPosMax : pxPosMin,
                            y: 0,
                            width: pxRange,
                            height: plotSizeMax
                        };
                        if (!horiz) {
                            clipAttr.x = chart.plotHeight - clipAttr.x;
                        }
                    }
                    else {
                        clipAttr = {
                            x: 0,
                            y: inverted ? pxPosMax : pxPosMin,
                            width: plotSizeMax,
                            height: pxRange
                        };
                        if (horiz) {
                            clipAttr.y = chart.plotWidth - clipAttr.y;
                        }
                    }
                    if (clips[i]) {
                        clips[i].animate(clipAttr);
                    }
                    else {
                        clips[i] = renderer.clipRect(clipAttr);
                    }
                    // when no data, graph zone is not applied and after setData
                    // clip was ignored. As a result, it should be applied each
                    // time.
                    zoneArea = series['zone-area-' + i];
                    zoneGraph = series['zone-graph-' + i];
                    if (graph && zoneGraph) {
                        zoneGraph.clip(clips[i]);
                    }
                    if (area && zoneArea) {
                        zoneArea.clip(clips[i]);
                    }
                    // if this zone extends out of the axis, ignore the others
                    ignoreZones = threshold.value > extremes.max;
                    // Clear translatedTo for indicators
                    if (series.resetZones && translatedTo === 0) {
                        translatedTo = void 0;
                    }
                });
                this.clips = clips;
            }
            else if (series.visible) {
                // If zones were removed, restore graph and area
                if (graph) {
                    graph.show();
                }
                if (area) {
                    area.show();
                }
            }
        }
        /**
         * General abstraction for creating plot groups like series.group,
         * series.dataLabelsGroup and series.markerGroup. On subsequent calls,
         * the group will only be adjusted to the updated plot size.
         *
         * @private
         * @function Highcharts.Series#plotGroup
         */
        plotGroup(prop, name, visibility, zIndex, parent) {
            let group = this[prop];
            const isNew = !group, attrs = {
                visibility,
                zIndex: zIndex || 0.1 // Pointer logic uses this
            };
            // Avoid setting undefined opacity, or in styled mode
            if (typeof this.opacity !== 'undefined' &&
                !this.chart.styledMode && this.state !== 'inactive' // #13719
            ) {
                attrs.opacity = this.opacity;
            }
            // Generate it on first call
            if (isNew) {
                this[prop] = group = this.chart.renderer
                    .g()
                    .add(parent);
            }
            // Add the class names, and replace existing ones as response to
            // Series.update (#6660)
            group.addClass(('highcharts-' + name +
                ' highcharts-series-' + this.index +
                ' highcharts-' + this.type + '-series ' +
                (defined$5(this.colorIndex) ?
                    'highcharts-color-' + this.colorIndex + ' ' :
                    '') +
                (this.options.className || '') +
                (group.hasClass('highcharts-tracker') ?
                    ' highcharts-tracker' :
                    '')), true);
            // Place it on first and subsequent (redraw) calls
            group.attr(attrs)[isNew ? 'attr' : 'animate'](this.getPlotBox(name));
            return group;
        }
        /**
         * Get the translation and scale for the plot area of this series.
         *
         * @function Highcharts.Series#getPlotBox
         */
        getPlotBox(name) {
            let horAxis = this.xAxis, vertAxis = this.yAxis;
            const chart = this.chart, inverted = (chart.inverted &&
                !chart.polar &&
                horAxis &&
                this.invertible !== false &&
                name === 'series');
            // Swap axes for inverted (#2339)
            if (chart.inverted) {
                horAxis = vertAxis;
                vertAxis = this.xAxis;
            }
            return {
                translateX: horAxis ? horAxis.left : chart.plotLeft,
                translateY: vertAxis ? vertAxis.top : chart.plotTop,
                rotation: inverted ? 90 : 0,
                rotationOriginX: inverted ?
                    (horAxis.len - vertAxis.len) / 2 :
                    0,
                rotationOriginY: inverted ?
                    (horAxis.len + vertAxis.len) / 2 :
                    0,
                scaleX: inverted ? -1 : 1,
                scaleY: 1
            };
        }
        /**
         * Removes the event handlers attached previously with addEvents.
         * @private
         * @function Highcharts.Series#removeEvents
         */
        removeEvents(keepEventsForUpdate) {
            const series = this;
            if (!keepEventsForUpdate) {
                // remove all events
                removeEvent$2(series);
            }
            if (series.eventsToUnbind.length) {
                // remove only internal events for proper update
                // #12355 - solves problem with multiple destroy events
                series.eventsToUnbind.forEach(function (unbind) {
                    unbind();
                });
                series.eventsToUnbind.length = 0;
            }
        }
        /**
         * Render the graph and markers. Called internally when first rendering
         * and later when redrawing the chart. This function can be extended in
         * plugins, but normally shouldn't be called directly.
         *
         * @function Highcharts.Series#render
         *
         * @emits Highcharts.Series#event:afterRender
         */
        render() {
            const series = this, chart = series.chart, options = series.options, animOptions = animObject$2(options.animation), visibility = series.visible ?
                'inherit' : 'hidden', // #2597
            zIndex = options.zIndex, hasRendered = series.hasRendered, chartSeriesGroup = chart.seriesGroup; chart.inverted;
            let animDuration = (!series.finishedAnimating) ?
                animOptions.duration : 0;
            fireEvent$3(this, 'render');
            // the group
            series.plotGroup('group', 'series', visibility, zIndex, chartSeriesGroup);
            series.markerGroup = series.plotGroup('markerGroup', 'markers', visibility, zIndex, chartSeriesGroup);
            // Initial clipping, applies to columns etc. (#3839).
            if (options.clip !== false) {
                series.setClip();
            }
            // Initialize the animation
            if (series.animate && animDuration) {
                series.animate(true);
            }
            // Draw the graph if any
            if (series.drawGraph) {
                series.drawGraph();
                series.applyZones();
            }
            // Draw the points
            if (series.visible) {
                series.drawPoints();
            }
            // Draw the data labels
            if (series.drawDataLabels) {
                series.drawDataLabels();
            }
            // In pie charts, slices are added to the DOM, but actual rendering
            // is postponed until labels reserved their space
            if (series.redrawPoints) {
                series.redrawPoints();
            }
            // Draw the mouse tracking area
            if (series.drawTracker &&
                options.enableMouseTracking) {
                series.drawTracker();
            }
            // Run the animation
            if (series.animate && animDuration) {
                series.animate();
            }
            // Call the afterAnimate function on animation complete (but don't
            // overwrite the animation.complete option which should be available
            // to the user).
            if (!hasRendered) {
                // Additional time if defer is defined before afterAnimate
                // will be triggered
                if (animDuration && animOptions.defer) {
                    animDuration += animOptions.defer;
                }
                series.animationTimeout = syncTimeout$1(function () {
                    series.afterAnimate();
                }, animDuration || 0);
            }
            // Means data is in accordance with what you see
            series.isDirty = false;
            // (See #322) series.isDirty = series.isDirtyData = false; // means
            // data is in accordance with what you see
            series.hasRendered = true;
            fireEvent$3(series, 'afterRender');
        }
        /**
         * Redraw the series. This function is called internally from
         * `chart.redraw` and normally shouldn't be called directly.
         * @private
         * @function Highcharts.Series#redraw
         */
        redraw() {
            // Cache it here as it is set to false in render, but used after
            const wasDirty = this.isDirty || this.isDirtyData;
            this.translate();
            this.render();
            if (wasDirty) { // #3868, #3945
                delete this.kdTree;
            }
        }
        /**
         * Find the nearest point from a pointer event. This applies to series that
         * use k-d-trees to get the nearest point. Native pointer events must be
         * normalized using `Pointer.normalize`, that adds `chartX` and `chartY`
         * properties.
         *
         * @sample highcharts/demo/synchronized-charts
         *         Synchronized charts with tooltips
         *
         * @function Highcharts.Series#searchPoint
         *
         * @param {Highcharts.PointerEvent} e
         *        The normalized pointer event
         * @param {boolean} [compareX=false]
         *        Search only by the X value, not Y
         *
         * @return {Point|undefined}
         *        The closest point to the pointer event
         */
        searchPoint(e, compareX) {
            const series = this, xAxis = series.xAxis, yAxis = series.yAxis, inverted = series.chart.inverted;
            return this.searchKDTree({
                clientX: inverted ?
                    xAxis.len - e.chartY + xAxis.pos :
                    e.chartX - xAxis.pos,
                plotY: inverted ?
                    yAxis.len - e.chartX + yAxis.pos :
                    e.chartY - yAxis.pos
            }, compareX, e);
        }
        /**
         * Build the k-d-tree that is used by mouse and touch interaction to get
         * the closest point. Line-like series typically have a one-dimensional
         * tree where points are searched along the X axis, while scatter-like
         * series typically search in two dimensions, X and Y.
         *
         * @private
         * @function Highcharts.Series#buildKDTree
         */
        buildKDTree(e) {
            // Prevent multiple k-d-trees from being built simultaneously
            // (#6235)
            this.buildingKdTree = true;
            const series = this, dimensions = series.options.findNearestPointBy
                .indexOf('y') > -1 ? 2 : 1;
            /**
             * Internal function
             * @private
             */
            function _kdtree(points, depth, dimensions) {
                const length = points && points.length;
                let axis, median;
                if (length) {
                    // alternate between the axis
                    axis = series.kdAxisArray[depth % dimensions];
                    // sort point array
                    points.sort(function (a, b) {
                        return a[axis] - b[axis];
                    });
                    median = Math.floor(length / 2);
                    // build and return nod
                    return {
                        point: points[median],
                        left: _kdtree(points.slice(0, median), depth + 1, dimensions),
                        right: _kdtree(points.slice(median + 1), depth + 1, dimensions)
                    };
                }
            }
            /**
             * Start the recursive build process with a clone of the points
             * array and null points filtered out. (#3873)
             * @private
             */
            function startRecursive() {
                series.kdTree = _kdtree(series.getValidPoints(null, 
                // For line-type series restrict to plot area, but
                // column-type series not (#3916, #4511)
                !series.directTouch), dimensions, dimensions);
                series.buildingKdTree = false;
            }
            delete series.kdTree;
            // For testing tooltips, don't build async. Also if touchstart, we
            // may be dealing with click events on mobile, so don't delay
            // (#6817).
            syncTimeout$1(startRecursive, series.options.kdNow || (e && e.type === 'touchstart') ? 0 : 1);
        }
        /**
         * @private
         * @function Highcharts.Series#searchKDTree
         */
        searchKDTree(point, compareX, e) {
            const series = this, kdX = this.kdAxisArray[0], kdY = this.kdAxisArray[1], kdComparer = compareX ? 'distX' : 'dist', kdDimensions = series.options.findNearestPointBy
                .indexOf('y') > -1 ? 2 : 1;
            /**
             * Set the one and two dimensional distance on the point object.
             * @private
             */
            function setDistance(p1, p2) {
                const x = (defined$5(p1[kdX]) &&
                    defined$5(p2[kdX])) ?
                    Math.pow(p1[kdX] - p2[kdX], 2) :
                    null, y = (defined$5(p1[kdY]) &&
                    defined$5(p2[kdY])) ?
                    Math.pow(p1[kdY] - p2[kdY], 2) :
                    null, r = (x || 0) + (y || 0);
                p2.dist = defined$5(r) ? Math.sqrt(r) : Number.MAX_VALUE;
                p2.distX = defined$5(x) ? Math.sqrt(x) : Number.MAX_VALUE;
            }
            /**
             * @private
             */
            function _search(search, tree, depth, dimensions) {
                const point = tree.point, axis = series.kdAxisArray[depth % dimensions];
                let nPoint1, nPoint2, ret = point;
                setDistance(search, point);
                // Pick side based on distance to splitting point
                const tdist = search[axis] - point[axis], sideA = tdist < 0 ? 'left' : 'right', sideB = tdist < 0 ? 'right' : 'left';
                // End of tree
                if (tree[sideA]) {
                    nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);
                    ret = (nPoint1[kdComparer] <
                        ret[kdComparer] ?
                        nPoint1 :
                        point);
                }
                if (tree[sideB]) {
                    // compare distance to current best to splitting point to
                    // decide whether to check side B or not
                    if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {
                        nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);
                        ret = (nPoint2[kdComparer] <
                            ret[kdComparer] ?
                            nPoint2 :
                            ret);
                    }
                }
                return ret;
            }
            if (!this.kdTree && !this.buildingKdTree) {
                this.buildKDTree(e);
            }
            if (this.kdTree) {
                return _search(point, this.kdTree, kdDimensions, kdDimensions);
            }
        }
        /**
         * @private
         * @function Highcharts.Series#pointPlacementToXValue
         */
        pointPlacementToXValue() {
            const { options: { pointPlacement, pointRange }, xAxis: axis } = this;
            let factor = pointPlacement;
            // Point placement is relative to each series pointRange (#5889)
            if (factor === 'between') {
                factor = axis.reversed ? -0.5 : 0.5; // #11955
            }
            return isNumber$5(factor) ?
                factor * (pointRange || axis.pointRange) :
                0;
        }
        /**
         * @private
         * @function Highcharts.Series#isPointInside
         */
        isPointInside(point) {
            const { chart, xAxis, yAxis } = this, isInside = (typeof point.plotY !== 'undefined' &&
                typeof point.plotX !== 'undefined' &&
                point.plotY >= 0 &&
                point.plotY <= (yAxis ? yAxis.len : chart.plotHeight) &&
                point.plotX >= 0 &&
                point.plotX <= (xAxis ? xAxis.len : chart.plotWidth));
            return isInside;
        }
        /**
         * Draw the tracker object that sits above all data labels and markers to
         * track mouse events on the graph or points. For the line type charts
         * the tracker uses the same graphPath, but with a greater stroke width
         * for better control.
         * @private
         */
        drawTracker() {
            const series = this, options = series.options, trackByArea = options.trackByArea, trackerPath = [].concat(trackByArea ?
                series.areaPath :
                series.graphPath), 
            // trackerPathLength = trackerPath.length,
            chart = series.chart, pointer = chart.pointer, renderer = chart.renderer, snap = chart.options.tooltip.snap, tracker = series.tracker, onMouseOver = function (e) {
                if (options.enableMouseTracking &&
                    chart.hoverSeries !== series) {
                    series.onMouseOver();
                }
            }, 
            /*
             * Empirical lowest possible opacities for TRACKER_FILL for an
             * element to stay invisible but clickable
             * IE9: 0.00000000001 (unlimited)
             * IE10: 0.0001 (exporting only)
             * FF: 0.00000000001 (unlimited)
             * Chrome: 0.000001
             * Safari: 0.000001
             * Opera: 0.00000000001 (unlimited)
             */
            TRACKER_FILL = 'rgba(192,192,192,' + (svg$1 ? 0.0001 : 0.002) + ')';
            // Draw the tracker
            if (tracker) {
                tracker.attr({ d: trackerPath });
            }
            else if (series.graph) { // create
                series.tracker = renderer.path(trackerPath)
                    .attr({
                    visibility: series.visible ? 'inherit' : 'hidden',
                    zIndex: 2
                })
                    .addClass(trackByArea ?
                    'highcharts-tracker-area' :
                    'highcharts-tracker-line')
                    .add(series.group);
                if (!chart.styledMode) {
                    series.tracker.attr({
                        'stroke-linecap': 'round',
                        'stroke-linejoin': 'round',
                        stroke: TRACKER_FILL,
                        fill: trackByArea ? TRACKER_FILL : 'none',
                        'stroke-width': series.graph.strokeWidth() +
                            (trackByArea ? 0 : 2 * snap)
                    });
                }
                // The tracker is added to the series group, which is clipped, but
                // is covered by the marker group. So the marker group also needs to
                // capture events.
                [
                    series.tracker,
                    series.markerGroup,
                    series.dataLabelsGroup
                ].forEach(function (tracker) {
                    if (tracker) {
                        tracker.addClass('highcharts-tracker')
                            .on('mouseover', onMouseOver)
                            .on('mouseout', function (e) {
                            pointer.onTrackerMouseOut(e);
                        });
                        if (options.cursor && !chart.styledMode) {
                            tracker.css({ cursor: options.cursor });
                        }
                        if (hasTouch$1) {
                            tracker.on('touchstart', onMouseOver);
                        }
                    }
                });
            }
            fireEvent$3(this, 'afterDrawTracker');
        }
        /**
         * Add a point to the series after render time. The point can be added at
         * the end, or by giving it an X value, to the start or in the middle of the
         * series.
         *
         * @sample highcharts/members/series-addpoint-append/
         *         Append point
         * @sample highcharts/members/series-addpoint-append-and-shift/
         *         Append and shift
         * @sample highcharts/members/series-addpoint-x-and-y/
         *         Both X and Y values given
         * @sample highcharts/members/series-addpoint-pie/
         *         Append pie slice
         * @sample stock/members/series-addpoint/
         *         Append 100 points in Highcharts Stock
         * @sample stock/members/series-addpoint-shift/
         *         Append and shift in Highcharts Stock
         * @sample maps/members/series-addpoint/
         *         Add a point in Highmaps
         *
         * @function Highcharts.Series#addPoint
         *
         * @param {Highcharts.PointOptionsType} options
         *        The point options. If options is a single number, a point with
         *        that y value is appended to the series. If it is an array, it will
         *        be interpreted as x and y values respectively. If it is an
         *        object, advanced options as outlined under `series.data` are
         *        applied.
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart after the point is added. When adding
         *        more than one point, it is highly recommended that the redraw
         *        option be set to false, and instead {@link Chart#redraw} is
         *        explicitly called after the adding of points is finished.
         *        Otherwise, the chart will redraw after adding each point.
         *
         * @param {boolean} [shift=false]
         *        If true, a point is shifted off the start of the series as one is
         *        appended to the end.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
         *        Whether to apply animation, and optionally animation
         *        configuration.
         *
         * @param {boolean} [withEvent=true]
         *        Used internally, whether to fire the series `addPoint` event.
         *
         * @emits Highcharts.Series#event:addPoint
         */
        addPoint(options, redraw, shift, animation, withEvent) {
            const series = this, seriesOptions = series.options, data = series.data, chart = series.chart, xAxis = series.xAxis, names = xAxis && xAxis.hasNames && xAxis.names, dataOptions = seriesOptions.data, xData = series.xData;
            let isInTheMiddle, i;
            // Optional redraw, defaults to true
            redraw = pick$6(redraw, true);
            // Get options and push the point to xData, yData and series.options. In
            // series.generatePoints the Point instance will be created on demand
            // and pushed to the series.data array.
            const point = { series: series };
            series.pointClass.prototype.applyOptions.apply(point, [options]);
            const x = point.x;
            // Get the insertion point
            i = xData.length;
            if (series.requireSorting && x < xData[i - 1]) {
                isInTheMiddle = true;
                while (i && xData[i - 1] > x) {
                    i--;
                }
            }
            // Insert undefined item
            series.updateParallelArrays(point, 'splice', [i, 0, 0]);
            // Update it
            series.updateParallelArrays(point, i);
            if (names && point.name) {
                names[x] = point.name;
            }
            dataOptions.splice(i, 0, options);
            if (isInTheMiddle ||
                // When processedData is present we need to splice an empty slot
                // into series.data, otherwise generatePoints won't pick it up.
                series.processedData) {
                series.data.splice(i, 0, null);
                series.processData();
            }
            // Generate points to be added to the legend (#1329)
            if (seriesOptions.legendType === 'point') {
                series.generatePoints();
            }
            // Shift the first point off the parallel arrays
            if (shift) {
                if (data[0] && (data[0].remove)) {
                    data[0].remove(false);
                }
                else {
                    data.shift();
                    series.updateParallelArrays(point, 'shift');
                    dataOptions.shift();
                }
            }
            // Fire event
            if (withEvent !== false) {
                fireEvent$3(series, 'addPoint', { point: point });
            }
            // redraw
            series.isDirty = true;
            series.isDirtyData = true;
            if (redraw) {
                chart.redraw(animation); // Animation is set anyway on redraw, #5665
            }
        }
        /**
         * Remove a point from the series. Unlike the
         * {@link Highcharts.Point#remove} method, this can also be done on a point
         * that is not instanciated because it is outside the view or subject to
         * Highcharts Stock data grouping.
         *
         * @sample highcharts/members/series-removepoint/
         *         Remove cropped point
         *
         * @function Highcharts.Series#removePoint
         *
         * @param {number} i
         *        The index of the point in the {@link Highcharts.Series.data|data}
         *        array.
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart after the point is added. When
         *        removing more than one point, it is highly recommended that the
         *        `redraw` option be set to `false`, and instead {@link
         *        Highcharts.Chart#redraw} is explicitly called after the adding of
         *        points is finished.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
         *        Whether and optionally how the series should be animated.
         *
         * @emits Highcharts.Point#event:remove
         */
        removePoint(i, redraw, animation) {
            const series = this, data = series.data, point = data[i], points = series.points, chart = series.chart, remove = function () {
                if (points && points.length === data.length) { // #4935
                    points.splice(i, 1);
                }
                data.splice(i, 1);
                series.options.data.splice(i, 1);
                series.updateParallelArrays(point || { series: series }, 'splice', [i, 1]);
                if (point) {
                    point.destroy();
                }
                // redraw
                series.isDirty = true;
                series.isDirtyData = true;
                if (redraw) {
                    chart.redraw();
                }
            };
            setAnimation$1(animation, chart);
            redraw = pick$6(redraw, true);
            // Fire the event with a default handler of removing the point
            if (point) {
                point.firePointEvent('remove', null, remove);
            }
            else {
                remove();
            }
        }
        /**
         * Remove a series and optionally redraw the chart.
         *
         * @sample highcharts/members/series-remove/
         *         Remove first series from a button
         *
         * @function Highcharts.Series#remove
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart or wait for an explicit call to
         *        {@link Highcharts.Chart#redraw}.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
         *        Whether to apply animation, and optionally animation
         *        configuration.
         *
         * @param {boolean} [withEvent=true]
         *        Used internally, whether to fire the series `remove` event.
         *
         * @emits Highcharts.Series#event:remove
         */
        remove(redraw, animation, withEvent, keepEvents) {
            const series = this, chart = series.chart;
            /**
             * @private
             */
            function remove() {
                // Destroy elements
                series.destroy(keepEvents);
                // Redraw
                chart.isDirtyLegend = chart.isDirtyBox = true;
                chart.linkSeries(keepEvents);
                if (pick$6(redraw, true)) {
                    chart.redraw(animation);
                }
            }
            // Fire the event with a default handler of removing the point
            if (withEvent !== false) {
                fireEvent$3(series, 'remove', null, remove);
            }
            else {
                remove();
            }
        }
        /**
         * Update the series with a new set of options. For a clean and precise
         * handling of new options, all methods and elements from the series are
         * removed, and it is initialized from scratch. Therefore, this method is
         * more performance expensive than some other utility methods like {@link
         * Series#setData} or {@link Series#setVisible}.
         *
         * Note that `Series.update` may mutate the passed `data` options.
         *
         * @sample highcharts/members/series-update/
         *         Updating series options
         * @sample maps/members/series-update/
         *         Update series options in Highmaps
         *
         * @function Highcharts.Series#update
         *
         * @param {Highcharts.SeriesOptionsType} options
         *        New options that will be merged with the series' existing options.
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart after the series is altered. If doing
         *        more operations on the chart, it is a good idea to set redraw to
         *        false and call {@link Chart#redraw} after.
         *
         * @emits Highcharts.Series#event:update
         * @emits Highcharts.Series#event:afterUpdate
         */
        update(options, redraw) {
            options = diffObjects$1(options, this.userOptions);
            fireEvent$3(this, 'update', { options: options });
            const series = this, chart = series.chart, 
            // must use user options when changing type because series.options
            // is merged in with type specific plotOptions
            oldOptions = series.userOptions, initialType = series.initialType || series.type, plotOptions = chart.options.plotOptions, initialSeriesProto = seriesTypes$1[initialType].prototype, groups = [
                'group',
                'markerGroup',
                'dataLabelsGroup',
                'transformGroup'
            ], 
            // Animation must be enabled when calling update before the initial
            // animation has first run. This happens when calling update
            // directly after chart initialization, or when applying responsive
            // rules (#6912).
            animation = series.finishedAnimating && { animation: false }, kinds = {};
            let seriesOptions, n, preserve = [
                'colorIndex',
                'eventOptions',
                'navigatorSeries',
                'symbolIndex',
                'baseSeries'
            ], newType = (options.type ||
                oldOptions.type ||
                chart.options.chart.type);
            const keepPoints = !(
            // Indicators, histograms etc recalculate the data. It should be
            // possible to omit this.
            this.hasDerivedData ||
                // New type requires new point classes
                (newType && newType !== this.type) ||
                // New options affecting how the data points are built
                typeof options.pointStart !== 'undefined' ||
                typeof options.pointInterval !== 'undefined' ||
                typeof options.relativeXValue !== 'undefined' ||
                options.joinBy ||
                options.mapData || // #11636
                // Changes to data grouping requires new points in new group
                series.hasOptionChanged('dataGrouping') ||
                series.hasOptionChanged('pointStart') ||
                series.hasOptionChanged('pointInterval') ||
                series.hasOptionChanged('pointIntervalUnit') ||
                series.hasOptionChanged('keys'));
            newType = newType || initialType;
            if (keepPoints) {
                preserve.push('data', 'isDirtyData', 'points', 'processedData', // #17057
                'processedXData', 'processedYData', 'xIncrement', 'cropped', '_hasPointMarkers', '_hasPointLabels', 'clips', // #15420
                // Networkgraph (#14397)
                'nodes', 'layout', 
                // Treemap
                'level', 
                // Map specific, consider moving it to series-specific preserve-
                // properties (#10617)
                'mapMap', 'mapData', 'minY', 'maxY', 'minX', 'maxX');
                if (options.visible !== false) {
                    preserve.push('area', 'graph');
                }
                series.parallelArrays.forEach(function (key) {
                    preserve.push(key + 'Data');
                });
                if (options.data) {
                    // setData uses dataSorting options so we need to update them
                    // earlier
                    if (options.dataSorting) {
                        extend$5(series.options.dataSorting, options.dataSorting);
                    }
                    this.setData(options.data, false);
                }
            }
            // Do the merge, with some forced options
            options = merge$4(oldOptions, animation, {
                // When oldOptions.index is null it should't be cleared.
                // Otherwise navigator series will have wrong indexes (#10193).
                index: typeof oldOptions.index === 'undefined' ?
                    series.index : oldOptions.index,
                pointStart: pick$6(
                // when updating from blank (#7933)
                (plotOptions &&
                    plotOptions.series &&
                    plotOptions.series.pointStart), oldOptions.pointStart, 
                // when updating after addPoint
                series.xData[0])
            }, (!keepPoints && { data: series.options.data }), options);
            // Merge does not merge arrays, but replaces them. Since points were
            // updated, `series.options.data` has correct merged options, use it:
            if (keepPoints && options.data) {
                options.data = series.options.data;
            }
            // Make sure preserved properties are not destroyed (#3094)
            preserve = groups.concat(preserve);
            preserve.forEach(function (prop) {
                preserve[prop] = series[prop];
                delete series[prop];
            });
            let casting = false;
            if (seriesTypes$1[newType]) {
                casting = newType !== series.type;
                // Destroy the series and delete all properties, it will be
                // reinserted within the `init` call below
                series.remove(false, false, false, true);
                if (casting) {
                    // Modern browsers including IE11
                    if (Object.setPrototypeOf) {
                        Object.setPrototypeOf(series, seriesTypes$1[newType].prototype);
                        // Legacy (IE < 11)
                    }
                    else {
                        const ownEvents = Object.hasOwnProperty.call(series, 'hcEvents') && series.hcEvents;
                        for (n in initialSeriesProto) { // eslint-disable-line guard-for-in
                            series[n] = void 0;
                        }
                        // Reinsert all methods and properties from the new type
                        // prototype (#2270, #3719).
                        extend$5(series, seriesTypes$1[newType].prototype);
                        // The events are tied to the prototype chain, don't copy if
                        // they're not the series' own
                        if (ownEvents) {
                            series.hcEvents = ownEvents;
                        }
                        else {
                            delete series.hcEvents;
                        }
                    }
                }
            }
            else {
                error$1(17, true, chart, { missingModuleFor: newType });
            }
            // Re-register groups (#3094) and other preserved properties
            preserve.forEach(function (prop) {
                series[prop] = preserve[prop];
            });
            series.init(chart, options);
            // Remove particular elements of the points. Check `series.options`
            // because we need to consider the options being set on plotOptions as
            // well.
            if (keepPoints && this.points) {
                seriesOptions = series.options;
                // What kind of elements to destroy
                if (seriesOptions.visible === false) {
                    kinds.graphic = 1;
                    kinds.dataLabel = 1;
                }
                else if (!series._hasPointLabels) {
                    const { marker, dataLabels } = seriesOptions, oldMarker = oldOptions.marker || {};
                    // If the  marker got disabled or changed its symbol, width or
                    // height - destroy
                    if (marker && (marker.enabled === false ||
                        oldMarker.symbol !== marker.symbol || // #10870, #15946
                        oldMarker.height !== marker.height || // #16274
                        oldMarker.width !== marker.width // #16274
                    )) {
                        kinds.graphic = 1;
                    }
                    if (dataLabels &&
                        dataLabels.enabled === false) {
                        kinds.dataLabel = 1;
                    }
                }
                for (const point of this.points) {
                    if (point && point.series) {
                        point.resolveColor();
                        // Destroy elements in order to recreate based on updated
                        // series options.
                        if (Object.keys(kinds).length) {
                            point.destroyElements(kinds);
                        }
                        if (seriesOptions.showInLegend === false &&
                            point.legendItem) {
                            chart.legend.destroyItem(point);
                        }
                    }
                }
            }
            series.initialType = initialType;
            chart.linkSeries(); // Links are lost in series.remove (#3028)
            // #15383: Fire updatedData if the type has changed to keep linked
            // series such as indicators updated
            if (casting && series.linkedSeries.length) {
                series.isDirtyData = true;
            }
            fireEvent$3(this, 'afterUpdate');
            if (pick$6(redraw, true)) {
                chart.redraw(keepPoints ? void 0 : false);
            }
        }
        /**
         * Used from within series.update
         * @private
         */
        setName(name) {
            this.name = this.options.name = this.userOptions.name = name;
            this.chart.isDirtyLegend = true;
        }
        /**
         * Check if the option has changed.
         * @private
         */
        hasOptionChanged(optionName) {
            const chart = this.chart, option = this.options[optionName], plotOptions = chart.options.plotOptions, oldOption = this.userOptions[optionName];
            if (oldOption) {
                return option !== oldOption;
            }
            return option !==
                pick$6(plotOptions &&
                    plotOptions[this.type] &&
                    plotOptions[this.type][optionName], plotOptions &&
                    plotOptions.series &&
                    plotOptions.series[optionName], option);
        }
        /**
         * Runs on mouse over the series graphical items.
         *
         * @function Highcharts.Series#onMouseOver
         * @emits Highcharts.Series#event:mouseOver
         */
        onMouseOver() {
            const series = this, chart = series.chart, hoverSeries = chart.hoverSeries, pointer = chart.pointer;
            pointer.setHoverChartIndex();
            // set normal state to previous series
            if (hoverSeries && hoverSeries !== series) {
                hoverSeries.onMouseOut();
            }
            // trigger the event, but to save processing time,
            // only if defined
            if (series.options.events.mouseOver) {
                fireEvent$3(series, 'mouseOver');
            }
            // hover this
            series.setState('hover');
            /**
             * Contains the original hovered series.
             *
             * @name Highcharts.Chart#hoverSeries
             * @type {Highcharts.Series|null}
             */
            chart.hoverSeries = series;
        }
        /**
         * Runs on mouse out of the series graphical items.
         *
         * @function Highcharts.Series#onMouseOut
         *
         * @emits Highcharts.Series#event:mouseOut
         */
        onMouseOut() {
            // trigger the event only if listeners exist
            const series = this, options = series.options, chart = series.chart, tooltip = chart.tooltip, hoverPoint = chart.hoverPoint;
            // #182, set to null before the mouseOut event fires
            chart.hoverSeries = null;
            // trigger mouse out on the point, which must be in this series
            if (hoverPoint) {
                hoverPoint.onMouseOut();
            }
            // fire the mouse out event
            if (series && options.events.mouseOut) {
                fireEvent$3(series, 'mouseOut');
            }
            // hide the tooltip
            if (tooltip &&
                !series.stickyTracking &&
                (!tooltip.shared || series.noSharedTooltip)) {
                tooltip.hide();
            }
            // Reset all inactive states
            chart.series.forEach(function (s) {
                s.setState('', true);
            });
        }
        /**
         * Set the state of the series. Called internally on mouse interaction
         * operations, but it can also be called directly to visually
         * highlight a series.
         *
         * @function Highcharts.Series#setState
         *
         * @param {Highcharts.SeriesStateValue|""} [state]
         *        The new state, can be either `'hover'`, `'inactive'`, `'select'`,
         *        or `''` (an empty string), `'normal'` or `undefined` to set to
         *        normal state.
         * @param {boolean} [inherit]
         *        Determines if state should be inherited by points too.
         */
        setState(state, inherit) {
            const series = this, options = series.options, graph = series.graph, inactiveOtherPoints = options.inactiveOtherPoints, stateOptions = options.states, 
            // By default a quick animation to hover/inactive,
            // slower to un-hover
            stateAnimation = pick$6((stateOptions[state || 'normal'] &&
                stateOptions[state || 'normal'].animation), series.chart.options.chart.animation);
            let attribs, lineWidth = options.lineWidth, i = 0, opacity = options.opacity;
            state = state || '';
            if (series.state !== state) {
                // Toggle class names
                [
                    series.group,
                    series.markerGroup,
                    series.dataLabelsGroup
                ].forEach(function (group) {
                    if (group) {
                        // Old state
                        if (series.state) {
                            group.removeClass('highcharts-series-' + series.state);
                        }
                        // New state
                        if (state) {
                            group.addClass('highcharts-series-' + state);
                        }
                    }
                });
                series.state = state;
                if (!series.chart.styledMode) {
                    if (stateOptions[state] &&
                        stateOptions[state].enabled === false) {
                        return;
                    }
                    if (state) {
                        lineWidth = (stateOptions[state].lineWidth ||
                            lineWidth + (stateOptions[state].lineWidthPlus || 0)); // #4035
                        opacity = pick$6(stateOptions[state].opacity, opacity);
                    }
                    if (graph && !graph.dashstyle && isNumber$5(lineWidth)) {
                        attribs = {
                            'stroke-width': lineWidth
                        };
                        // Animate the graph stroke-width.
                        graph.animate(attribs, stateAnimation);
                        while (series['zone-graph-' + i]) {
                            series['zone-graph-' + i].animate(attribs, stateAnimation);
                            i = i + 1;
                        }
                    }
                    // For some types (pie, networkgraph, sankey) opacity is
                    // resolved on a point level
                    if (!inactiveOtherPoints) {
                        [
                            series.group,
                            series.markerGroup,
                            series.dataLabelsGroup,
                            series.labelBySeries
                        ].forEach(function (group) {
                            if (group) {
                                group.animate({
                                    opacity: opacity
                                }, stateAnimation);
                            }
                        });
                    }
                }
            }
            // Don't loop over points on a series that doesn't apply inactive state
            // to siblings markers (e.g. line, column)
            if (inherit && inactiveOtherPoints && series.points) {
                series.setAllPointsToState(state || void 0);
            }
        }
        /**
         * Set the state for all points in the series.
         *
         * @function Highcharts.Series#setAllPointsToState
         *
         * @private
         *
         * @param {string} [state]
         *        Can be either `hover` or undefined to set to normal state.
         */
        setAllPointsToState(state) {
            this.points.forEach(function (point) {
                if (point.setState) {
                    point.setState(state);
                }
            });
        }
        /**
         * Show or hide the series.
         *
         * @function Highcharts.Series#setVisible
         *
         * @param {boolean} [visible]
         * True to show the series, false to hide. If undefined, the visibility is
         * toggled.
         *
         * @param {boolean} [redraw=true]
         * Whether to redraw the chart after the series is altered. If doing more
         * operations on the chart, it is a good idea to set redraw to false and
         * call {@link Chart#redraw|chart.redraw()} after.
         *
         * @emits Highcharts.Series#event:hide
         * @emits Highcharts.Series#event:show
         */
        setVisible(vis, redraw) {
            const series = this, chart = series.chart, ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries, oldVisibility = series.visible;
            // if called without an argument, toggle visibility
            series.visible =
                vis =
                    series.options.visible =
                        series.userOptions.visible =
                            typeof vis === 'undefined' ? !oldVisibility : vis; // #5618
            const showOrHide = vis ? 'show' : 'hide';
            // show or hide elements
            [
                'group',
                'dataLabelsGroup',
                'markerGroup',
                'tracker',
                'tt'
            ].forEach(function (key) {
                if (series[key]) {
                    series[key][showOrHide]();
                }
            });
            // hide tooltip (#1361)
            if (chart.hoverSeries === series ||
                (chart.hoverPoint && chart.hoverPoint.series) === series) {
                series.onMouseOut();
            }
            if (series.legendItem) {
                chart.legend.colorizeItem(series, vis);
            }
            // rescale or adapt to resized chart
            series.isDirty = true;
            // in a stack, all other series are affected
            if (series.options.stacking) {
                chart.series.forEach(function (otherSeries) {
                    if (otherSeries.options.stacking && otherSeries.visible) {
                        otherSeries.isDirty = true;
                    }
                });
            }
            // show or hide linked series
            series.linkedSeries.forEach(function (otherSeries) {
                otherSeries.setVisible(vis, false);
            });
            if (ignoreHiddenSeries) {
                chart.isDirtyBox = true;
            }
            fireEvent$3(series, showOrHide);
            if (redraw !== false) {
                chart.redraw();
            }
        }
        /**
         * Show the series if hidden.
         *
         * @sample highcharts/members/series-hide/
         *         Toggle visibility from a button
         *
         * @function Highcharts.Series#show
         * @emits Highcharts.Series#event:show
         */
        show() {
            this.setVisible(true);
        }
        /**
         * Hide the series if visible. If the
         * [chart.ignoreHiddenSeries](https://api.highcharts.com/highcharts/chart.ignoreHiddenSeries)
         * option is true, the chart is redrawn without this series.
         *
         * @sample highcharts/members/series-hide/
         *         Toggle visibility from a button
         *
         * @function Highcharts.Series#hide
         * @emits Highcharts.Series#event:hide
         */
        hide() {
            this.setVisible(false);
        }
        /**
         * Select or unselect the series. This means its
         * {@link Highcharts.Series.selected|selected}
         * property is set, the checkbox in the legend is toggled and when selected,
         * the series is returned by the {@link Highcharts.Chart#getSelectedSeries}
         * function.
         *
         * @sample highcharts/members/series-select/
         *         Select a series from a button
         *
         * @function Highcharts.Series#select
         *
         * @param {boolean} [selected]
         * True to select the series, false to unselect. If undefined, the selection
         * state is toggled.
         *
         * @emits Highcharts.Series#event:select
         * @emits Highcharts.Series#event:unselect
         */
        select(selected) {
            const series = this;
            series.selected =
                selected =
                    this.options.selected = (typeof selected === 'undefined' ?
                        !series.selected :
                        selected);
            if (series.checkbox) {
                series.checkbox.checked = selected;
            }
            fireEvent$3(series, selected ? 'select' : 'unselect');
        }
        /**
         * Checks if a tooltip should be shown for a given point.
         *
         * @private
         */
        shouldShowTooltip(plotX, plotY, options = {}) {
            options.series = this;
            options.visiblePlotOnly = true;
            return this.chart.isInsidePlot(plotX, plotY, options);
        }
        /**
         * Draws the legend symbol based on the legendSymbol user option.
         *
         * @private
         */
        drawLegendSymbol(legend, item) {
            var _a;
            (_a = LegendSymbol$1[this.options.legendSymbol || 'rectangle']) === null || _a === void 0 ? void 0 : _a.call(this, legend, item);
        }
    }
    Series.defaultOptions = seriesDefaults;
    /**
     * Registry of all available series types.
     *
     * @name Highcharts.Series.types
     * @type {Highcharts.Dictionary<typeof_Highcharts.Series>}
     */
    Series.types = SeriesRegistry$1.seriesTypes;
    /* *
     *
     *  Static Functions
     *
     * */
    /**
     * Registers a series class to be accessible via `Series.types`.
     *
     * @function Highcharts.Series.registerType
     *
     * @param {string} seriesType
     * The series type as an identifier string in lower case.
     *
     * @param {Function} SeriesClass
     * The series class as a class pattern or a constructor function with
     * prototype.
     */
    Series.registerType = SeriesRegistry$1.registerSeriesType;
    extend$5(Series.prototype, {
        axisTypes: ['xAxis', 'yAxis'],
        coll: 'series',
        colorCounter: 0,
        cropShoulder: 1,
        directTouch: false,
        isCartesian: true,
        kdAxisArray: ['clientX', 'plotY'],
        // each point's x and y values are stored in this.xData and this.yData:
        parallelArrays: ['x', 'y'],
        pointClass: Point,
        requireSorting: true,
        // requires the data to be sorted:
        sorted: true
    });
    /* *
     *
     *  Registry
     *
     * */
    SeriesRegistry$1.series = Series;

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { defined: defined$4, extend: extend$4, isNumber: isNumber$4, merge: merge$3, pick: pick$5, removeEvent: removeEvent$1 } = Utilities;
    /* *
     *
     *  Class
     *
     * */
    /**
     * SVG label to render text.
     * @private
     * @class
     * @name Highcharts.SVGLabel
     * @augments Highcharts.SVGElement
     */
    class SVGLabel extends SVGElement {
        /* *
         *
         *  Constructor
         *
         * */
        constructor(renderer, str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
            super();
            this.paddingLeftSetter = this.paddingSetter;
            this.paddingRightSetter = this.paddingSetter;
            this.init(renderer, 'g');
            this.textStr = str;
            this.x = x;
            this.y = y;
            this.anchorX = anchorX;
            this.anchorY = anchorY;
            this.baseline = baseline;
            this.className = className;
            this.addClass(className === 'button' ?
                'highcharts-no-tooltip' :
                'highcharts-label');
            if (className) {
                this.addClass('highcharts-' + className);
            }
            // Create the text element. An undefined text content prevents redundant
            // box calculation (#16121)
            this.text = renderer.text(void 0, 0, 0, useHTML).attr({ zIndex: 1 });
            // Validate the shape argument
            let hasBGImage;
            if (typeof shape === 'string') {
                hasBGImage = /^url\((.*?)\)$/.test(shape);
                if (hasBGImage || this.renderer.symbols[shape]) {
                    this.symbolKey = shape;
                }
            }
            this.bBox = SVGLabel.emptyBBox;
            this.padding = 3;
            this.baselineOffset = 0;
            this.needsBox = renderer.styledMode || hasBGImage;
            this.deferredAttr = {};
            this.alignFactor = 0;
        }
        /* *
         *
         *  Functions
         *
         * */
        alignSetter(value) {
            const alignFactor = ({
                left: 0,
                center: 0.5,
                right: 1
            })[value];
            if (alignFactor !== this.alignFactor) {
                this.alignFactor = alignFactor;
                // Bounding box exists, means we're dynamically changing
                if (this.bBox && isNumber$4(this.xSetting)) {
                    this.attr({ x: this.xSetting }); // #5134
                }
            }
        }
        anchorXSetter(value, key) {
            this.anchorX = value;
            this.boxAttr(key, Math.round(value) - this.getCrispAdjust() - this.xSetting);
        }
        anchorYSetter(value, key) {
            this.anchorY = value;
            this.boxAttr(key, value - this.ySetting);
        }
        /*
         * Set a box attribute, or defer it if the box is not yet created
         */
        boxAttr(key, value) {
            if (this.box) {
                this.box.attr(key, value);
            }
            else {
                this.deferredAttr[key] = value;
            }
        }
        /*
         * Pick up some properties and apply them to the text instead of the
         * wrapper.
         */
        css(styles) {
            if (styles) {
                const textStyles = {};
                // Create a copy to avoid altering the original object
                // (#537)
                styles = merge$3(styles);
                SVGLabel.textProps.forEach((prop) => {
                    if (typeof styles[prop] !== 'undefined') {
                        textStyles[prop] = styles[prop];
                        delete styles[prop];
                    }
                });
                this.text.css(textStyles);
                // Update existing text, box (#9400, #12163, #18212)
                if ('fontSize' in textStyles || 'fontWeight' in textStyles) {
                    this.updateTextPadding();
                }
                else if ('width' in textStyles || 'textOverflow' in textStyles) {
                    this.updateBoxSize();
                }
            }
            return SVGElement.prototype.css.call(this, styles);
        }
        /*
         * Destroy and release memory.
         */
        destroy() {
            // Added by button implementation
            removeEvent$1(this.element, 'mouseenter');
            removeEvent$1(this.element, 'mouseleave');
            if (this.text) {
                this.text.destroy();
            }
            if (this.box) {
                this.box = this.box.destroy();
            }
            // Call base implementation to destroy the rest
            SVGElement.prototype.destroy.call(this);
            return void 0;
        }
        fillSetter(value, key) {
            if (value) {
                this.needsBox = true;
            }
            // for animation getter (#6776)
            this.fill = value;
            this.boxAttr(key, value);
        }
        /*
         * Return the bounding box of the box, not the group.
         */
        getBBox() {
            // If we have a text string and the DOM bBox was 0, it typically means
            // that the label was first rendered hidden, so we need to update the
            // bBox (#15246)
            if (this.textStr && this.bBox.width === 0 && this.bBox.height === 0) {
                this.updateBoxSize();
            }
            const padding = this.padding;
            const paddingLeft = pick$5(this.paddingLeft, padding);
            return {
                width: this.width,
                height: this.height,
                x: this.bBox.x - paddingLeft,
                y: this.bBox.y - padding
            };
        }
        getCrispAdjust() {
            return this.renderer.styledMode && this.box ?
                this.box.strokeWidth() % 2 / 2 :
                (this['stroke-width'] ? parseInt(this['stroke-width'], 10) : 0) % 2 / 2;
        }
        heightSetter(value) {
            this.heightSetting = value;
        }
        /*
         * After the text element is added, get the desired size of the border
         * box and add it before the text in the DOM.
         */
        onAdd() {
            this.text.add(this);
            this.attr({
                // Alignment is available now  (#3295, 0 not rendered if given
                // as a value)
                text: pick$5(this.textStr, ''),
                x: this.x || 0,
                y: this.y || 0
            });
            if (this.box && defined$4(this.anchorX)) {
                this.attr({
                    anchorX: this.anchorX,
                    anchorY: this.anchorY
                });
            }
        }
        paddingSetter(value, key) {
            if (!isNumber$4(value)) {
                this[key] = void 0;
            }
            else if (value !== this[key]) {
                this[key] = value;
                this.updateTextPadding();
            }
        }
        rSetter(value, key) {
            this.boxAttr(key, value);
        }
        strokeSetter(value, key) {
            // for animation getter (#6776)
            this.stroke = value;
            this.boxAttr(key, value);
        }
        'stroke-widthSetter'(value, key) {
            if (value) {
                this.needsBox = true;
            }
            this['stroke-width'] = value;
            this.boxAttr(key, value);
        }
        'text-alignSetter'(value) {
            this.textAlign = value;
        }
        textSetter(text) {
            if (typeof text !== 'undefined') {
                // Must use .attr to ensure transforms are done (#10009)
                this.text.attr({ text });
            }
            this.updateTextPadding();
        }
        /*
         * This function runs after the label is added to the DOM (when the bounding
         * box is available), and after the text of the label is updated to detect
         * the new bounding box and reflect it in the border box.
         */
        updateBoxSize() {
            const text = this.text, attribs = {}, padding = this.padding, 
            // #12165 error when width is null (auto)
            // #12163 when fontweight: bold, recalculate bBox withot cache
            // #3295 && 3514 box failure when string equals 0
            bBox = this.bBox = (((!isNumber$4(this.widthSetting) ||
                !isNumber$4(this.heightSetting) ||
                this.textAlign) && defined$4(text.textStr)) ?
                text.getBBox() :
                SVGLabel.emptyBBox);
            let crispAdjust;
            this.width = this.getPaddedWidth();
            this.height = (this.heightSetting || bBox.height || 0) + 2 * padding;
            const metrics = this.renderer.fontMetrics(text);
            // Update the label-scoped y offset. Math.min because of inline
            // style (#9400)
            this.baselineOffset = padding + Math.min(
            // When applicable, use the font size of the first line (#15707)
            (this.text.firstLineMetrics || metrics).b, 
            // When the height is 0, there is no bBox, so go with the font
            // metrics. Highmaps CSS demos.
            bBox.height || Infinity);
            // #15491: Vertical centering
            if (this.heightSetting) {
                this.baselineOffset += (this.heightSetting - metrics.h) / 2;
            }
            if (this.needsBox && !text.textPath) {
                // Create the border box if it is not already present
                if (!this.box) {
                    // Symbol definition exists (#5324)
                    const box = this.box = this.symbolKey ?
                        this.renderer.symbol(this.symbolKey) :
                        this.renderer.rect();
                    box.addClass(// Don't use label className for buttons
                    (this.className === 'button' ?
                        '' : 'highcharts-label-box') +
                        (this.className ?
                            ' highcharts-' + this.className + '-box' : ''));
                    box.add(this);
                }
                crispAdjust = this.getCrispAdjust();
                attribs.x = crispAdjust;
                attribs.y = ((this.baseline ? -this.baselineOffset : 0) + crispAdjust);
                // Apply the box attributes
                attribs.width = Math.round(this.width);
                attribs.height = Math.round(this.height);
                this.box.attr(extend$4(attribs, this.deferredAttr));
                this.deferredAttr = {};
            }
        }
        /*
         * This function runs after setting text or padding, but only if padding
         * is changed.
         */
        updateTextPadding() {
            const text = this.text;
            if (!text.textPath) {
                this.updateBoxSize();
                // Determine y based on the baseline
                const textY = this.baseline ? 0 : this.baselineOffset;
                let textX = pick$5(this.paddingLeft, this.padding);
                // compensate for alignment
                if (defined$4(this.widthSetting) &&
                    this.bBox &&
                    (this.textAlign === 'center' || this.textAlign === 'right')) {
                    textX += { center: 0.5, right: 1 }[this.textAlign] * (this.widthSetting - this.bBox.width);
                }
                // update if anything changed
                if (textX !== text.x || textY !== text.y) {
                    text.attr('x', textX);
                    // #8159 - prevent misplaced data labels in treemap
                    // (useHTML: true)
                    if (text.hasBoxWidthChanged) {
                        this.bBox = text.getBBox(true);
                    }
                    if (typeof textY !== 'undefined') {
                        text.attr('y', textY);
                    }
                }
                // record current values
                text.x = textX;
                text.y = textY;
            }
        }
        widthSetter(value) {
            // width:auto => null
            this.widthSetting = isNumber$4(value) ? value : void 0;
        }
        getPaddedWidth() {
            const padding = this.padding;
            const paddingLeft = pick$5(this.paddingLeft, padding);
            const paddingRight = pick$5(this.paddingRight, padding);
            return ((this.widthSetting || this.bBox.width || 0) +
                paddingLeft +
                paddingRight);
        }
        xSetter(value) {
            this.x = value; // for animation getter
            if (this.alignFactor) {
                value -= this.alignFactor * this.getPaddedWidth();
                // Force animation even when setting to the same value (#7898)
                this['forceAnimate:x'] = true;
            }
            this.xSetting = Math.round(value);
            this.attr('translateX', this.xSetting);
        }
        ySetter(value) {
            this.ySetting = this.y = Math.round(value);
            this.attr('translateY', this.ySetting);
        }
    }
    /* *
     *
     *  Static Properties
     *
     * */
    SVGLabel.emptyBBox = {
        width: 0,
        height: 0,
        x: 0,
        y: 0
    };
    /**
     * For labels, these CSS properties are applied to the `text` node directly.
     *
     * @private
     * @name Highcharts.SVGLabel#textProps
     * @type {Array<string>}
     */
    SVGLabel.textProps = [
        'color', 'direction', 'fontFamily', 'fontSize', 'fontStyle',
        'fontWeight', 'lineHeight', 'textAlign', 'textDecoration',
        'textOutline', 'textOverflow', 'whiteSpace', 'width'
    ];

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { defined: defined$3, isNumber: isNumber$3, pick: pick$4 } = Utilities;
    /* *
     *
     *  Functions
     *
     * */
    /* eslint-disable require-jsdoc, valid-jsdoc */
    function arc(cx, cy, w, h, options) {
        const arc = [];
        if (options) {
            const start = options.start || 0, rx = pick$4(options.r, w), ry = pick$4(options.r, h || w), proximity = 0.001, fullCircle = (Math.abs((options.end || 0) - start - 2 * Math.PI) <
                proximity), 
            // Substract a small number to prevent cos and sin of start
            // and end from becoming equal on 360 arcs (related: #1561)
            end = (options.end || 0) - proximity, innerRadius = options.innerR, open = pick$4(options.open, fullCircle), cosStart = Math.cos(start), sinStart = Math.sin(start), cosEnd = Math.cos(end), sinEnd = Math.sin(end), 
            // Proximity takes care of rounding errors around PI (#6971)
            longArc = pick$4(options.longArc, end - start - Math.PI < proximity ? 0 : 1);
            let arcSegment = [
                'A',
                rx,
                ry,
                0,
                longArc,
                pick$4(options.clockwise, 1),
                cx + rx * cosEnd,
                cy + ry * sinEnd
            ];
            arcSegment.params = { start, end, cx, cy }; // Memo for border radius
            arc.push([
                'M',
                cx + rx * cosStart,
                cy + ry * sinStart
            ], arcSegment);
            if (defined$3(innerRadius)) {
                arcSegment = [
                    'A',
                    innerRadius,
                    innerRadius,
                    0,
                    longArc,
                    // Clockwise - opposite to the outer arc clockwise
                    defined$3(options.clockwise) ? 1 - options.clockwise : 0,
                    cx + innerRadius * cosStart,
                    cy + innerRadius * sinStart
                ];
                // Memo for border radius
                arcSegment.params = {
                    start: end,
                    end: start,
                    cx,
                    cy
                };
                arc.push(open ?
                    [
                        'M',
                        cx + innerRadius * cosEnd,
                        cy + innerRadius * sinEnd
                    ] : [
                    'L',
                    cx + innerRadius * cosEnd,
                    cy + innerRadius * sinEnd
                ], arcSegment);
            }
            if (!open) {
                arc.push(['Z']);
            }
        }
        return arc;
    }
    /**
     * Callout shape used for default tooltips.
     */
    function callout(x, y, w, h, options) {
        const arrowLength = 6, halfDistance = 6, r = Math.min((options && options.r) || 0, w, h), safeDistance = r + halfDistance, anchorX = options && options.anchorX, anchorY = options && options.anchorY || 0;
        const path = roundedRect(x, y, w, h, { r });
        if (!isNumber$3(anchorX)) {
            return path;
        }
        // Anchor on right side
        if (x + anchorX >= w) {
            // Chevron
            if (anchorY > y + safeDistance &&
                anchorY < y + h - safeDistance) {
                path.splice(3, 1, ['L', x + w, anchorY - halfDistance], ['L', x + w + arrowLength, anchorY], ['L', x + w, anchorY + halfDistance], ['L', x + w, y + h - r]);
                // Simple connector
            }
            else {
                path.splice(3, 1, ['L', x + w, h / 2], ['L', anchorX, anchorY], ['L', x + w, h / 2], ['L', x + w, y + h - r]);
            }
            // Anchor on left side
        }
        else if (x + anchorX <= 0) {
            // Chevron
            if (anchorY > y + safeDistance &&
                anchorY < y + h - safeDistance) {
                path.splice(7, 1, ['L', x, anchorY + halfDistance], ['L', x - arrowLength, anchorY], ['L', x, anchorY - halfDistance], ['L', x, y + r]);
                // Simple connector
            }
            else {
                path.splice(7, 1, ['L', x, h / 2], ['L', anchorX, anchorY], ['L', x, h / 2], ['L', x, y + r]);
            }
        }
        else if ( // replace bottom
        anchorY &&
            anchorY > h &&
            anchorX > x + safeDistance &&
            anchorX < x + w - safeDistance) {
            path.splice(5, 1, ['L', anchorX + halfDistance, y + h], ['L', anchorX, y + h + arrowLength], ['L', anchorX - halfDistance, y + h], ['L', x + r, y + h]);
        }
        else if ( // replace top
        anchorY &&
            anchorY < 0 &&
            anchorX > x + safeDistance &&
            anchorX < x + w - safeDistance) {
            path.splice(1, 1, ['L', anchorX - halfDistance, y], ['L', anchorX, y - arrowLength], ['L', anchorX + halfDistance, y], ['L', w - r, y]);
        }
        return path;
    }
    function circle(x, y, w, h) {
        // Return a full arc
        return arc(x + w / 2, y + h / 2, w / 2, h / 2, {
            start: Math.PI * 0.5,
            end: Math.PI * 2.5,
            open: false
        });
    }
    function diamond(x, y, w, h) {
        return [
            ['M', x + w / 2, y],
            ['L', x + w, y + h / 2],
            ['L', x + w / 2, y + h],
            ['L', x, y + h / 2],
            ['Z']
        ];
    }
    // #15291
    function rect(x, y, w, h, options) {
        if (options && options.r) {
            return roundedRect(x, y, w, h, options);
        }
        return [
            ['M', x, y],
            ['L', x + w, y],
            ['L', x + w, y + h],
            ['L', x, y + h],
            ['Z']
        ];
    }
    function roundedRect(x, y, w, h, options) {
        const r = (options === null || options === void 0 ? void 0 : options.r) || 0;
        return [
            ['M', x + r, y],
            ['L', x + w - r, y],
            ['A', r, r, 0, 0, 1, x + w, y + r],
            ['L', x + w, y + h - r],
            ['A', r, r, 0, 0, 1, x + w - r, y + h],
            ['L', x + r, y + h],
            ['A', r, r, 0, 0, 1, x, y + h - r],
            ['L', x, y + r],
            ['A', r, r, 0, 0, 1, x + r, y],
            ['Z'] // top-left corner
        ];
    }
    function triangle(x, y, w, h) {
        return [
            ['M', x + w / 2, y],
            ['L', x + w, y + h],
            ['L', x, y + h],
            ['Z']
        ];
    }
    function triangleDown(x, y, w, h) {
        return [
            ['M', x, y],
            ['L', x + w, y],
            ['L', x + w / 2, y + h],
            ['Z']
        ];
    }
    const Symbols = {
        arc,
        callout,
        circle,
        diamond,
        rect,
        roundedRect,
        square: rect,
        triangle,
        'triangle-down': triangleDown
    };

    /* *
     *
     *  (c) 2010-2020 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { doc: doc$2, SVG_NS: SVG_NS$1, win: win$2 } = H;
    const { attr: attr$2, extend: extend$3, fireEvent: fireEvent$2, isString: isString$2, objectEach: objectEach$2, pick: pick$3 } = Utilities;
    /* *
     *
     *  Class
     *
     * */
    /**
     * SVG Text Builder
     * @private
     * @class
     * @name Highcharts.TextBuilder
     */
    class TextBuilder {
        constructor(svgElement) {
            const textStyles = svgElement.styles;
            this.renderer = svgElement.renderer;
            this.svgElement = svgElement;
            this.width = svgElement.textWidth;
            this.textLineHeight = textStyles && textStyles.lineHeight;
            this.textOutline = textStyles && textStyles.textOutline;
            this.ellipsis = Boolean(textStyles && textStyles.textOverflow === 'ellipsis');
            this.noWrap = Boolean(textStyles && textStyles.whiteSpace === 'nowrap');
        }
        /**
         * Build an SVG representation of the pseudo HTML given in the object's
         * svgElement.
         *
         * @private
         *
         * @return {void}.
         */
        buildSVG() {
            const wrapper = this.svgElement, textNode = wrapper.element, renderer = wrapper.renderer, textStr = pick$3(wrapper.textStr, '').toString(), hasMarkup = textStr.indexOf('<') !== -1, childNodes = textNode.childNodes, tempParent = !wrapper.added && renderer.box, regexMatchBreaks = /<br.*?>/g, 
            // The buildText code is quite heavy, so if we're not changing
            // something that affects the text, skip it (#6113).
            textCache = [
                textStr,
                this.ellipsis,
                this.noWrap,
                this.textLineHeight,
                this.textOutline,
                wrapper.getStyle('font-size'),
                this.width
            ].join(',');
            if (textCache === wrapper.textCache) {
                return;
            }
            wrapper.textCache = textCache;
            delete wrapper.actualWidth;
            // Remove old text
            for (let i = childNodes.length; i--;) {
                textNode.removeChild(childNodes[i]);
            }
            // Simple strings, add text directly and return
            if (!hasMarkup &&
                !this.ellipsis &&
                !this.width &&
                !wrapper.textPath &&
                (textStr.indexOf(' ') === -1 ||
                    (this.noWrap && !regexMatchBreaks.test(textStr)))) {
                textNode.appendChild(doc$2.createTextNode(this.unescapeEntities(textStr)));
                // Complex strings, add more logic
            }
            else if (textStr !== '') {
                if (tempParent) {
                    // attach it to the DOM to read offset width and font size
                    tempParent.appendChild(textNode);
                }
                // Step 1. Parse the markup safely and directly into a tree
                // structure.
                const ast = new AST(textStr);
                // Step 2. Do as many as we can of the modifications to the tree
                // structure before it is added to the DOM
                this.modifyTree(ast.nodes);
                ast.addToDOM(textNode);
                // Step 3. Some modifications can't be done until the structure is
                // in the DOM, because we need to read computed metrics.
                this.modifyDOM();
                // Add title if an ellipsis was added
                if (this.ellipsis &&
                    (textNode.textContent || '').indexOf('\u2026') !== -1) {
                    wrapper.attr('title', this.unescapeEntities(wrapper.textStr || '', ['&lt;', '&gt;']) // #7179
                    );
                }
                if (tempParent) {
                    tempParent.removeChild(textNode);
                }
            }
            // Apply the text outline
            if (isString$2(this.textOutline) && wrapper.applyTextOutline) {
                wrapper.applyTextOutline(this.textOutline);
            }
        }
        /**
         * Modify the DOM of the generated SVG structure. This function only does
         * operations that cannot be done until the elements are attached to the
         * DOM, like doing layout based on rendered metrics of the added elements.
         *
         * @private
         *
         */
        modifyDOM() {
            const wrapper = this.svgElement;
            const x = attr$2(wrapper.element, 'x');
            wrapper.firstLineMetrics = void 0;
            // Remove empty tspans (including breaks) from the beginning because
            // SVG's getBBox doesn't count empty lines. The use case is tooltip
            // where the header is empty. By doing this in the DOM rather than in
            // the AST, we can inspect the textContent directly and don't have to
            // recurse down to look for valid content.
            let firstChild;
            while ((firstChild = wrapper.element.firstChild)) {
                if (/^[\s\u200B]*$/.test(firstChild.textContent || ' ')) {
                    wrapper.element.removeChild(firstChild);
                }
                else {
                    break;
                }
            }
            // Modify hard line breaks by applying the rendered line height
            [].forEach.call(wrapper.element.querySelectorAll('tspan.highcharts-br'), (br, i) => {
                if (br.nextSibling && br.previousSibling) { // #5261
                    if (i === 0 && br.previousSibling.nodeType === 1) {
                        wrapper.firstLineMetrics = wrapper.renderer
                            .fontMetrics(br.previousSibling);
                    }
                    attr$2(br, {
                        // Since the break is inserted in front of the next
                        // line, we need to use the next sibling for the line
                        // height
                        dy: this.getLineHeight(br.nextSibling),
                        x
                    });
                }
            });
            // Constrain the line width, either by ellipsis or wrapping
            const width = this.width || 0;
            if (!width) {
                return;
            }
            // Insert soft line breaks into each text node
            const modifyTextNode = (textNode, parentElement) => {
                const text = textNode.textContent || '';
                const words = text
                    .replace(/([^\^])-/g, '$1- ') // Split on hyphens
                    // .trim()
                    .split(' '); // #1273
                const hasWhiteSpace = !this.noWrap && (words.length > 1 || wrapper.element.childNodes.length > 1);
                const dy = this.getLineHeight(parentElement);
                let lineNo = 0;
                let startAt = wrapper.actualWidth;
                if (this.ellipsis) {
                    if (text) {
                        this.truncate(textNode, text, void 0, 0, 
                        // Target width
                        Math.max(0, 
                        // Substract the font face to make room for the
                        // ellipsis itself
                        width - 0.8 * dy), 
                        // Build the text to test for
                        (text, currentIndex) => text.substring(0, currentIndex) + '\u2026');
                    }
                }
                else if (hasWhiteSpace) {
                    const lines = [];
                    // Remove preceding siblings in order to make the text length
                    // calculation correct in the truncate function
                    const precedingSiblings = [];
                    while (parentElement.firstChild &&
                        parentElement.firstChild !== textNode) {
                        precedingSiblings.push(parentElement.firstChild);
                        parentElement.removeChild(parentElement.firstChild);
                    }
                    while (words.length) {
                        // Apply the previous line
                        if (words.length && !this.noWrap && lineNo > 0) {
                            lines.push(textNode.textContent || '');
                            textNode.textContent = words.join(' ')
                                .replace(/- /g, '-');
                        }
                        // For each line, truncate the remaining
                        // words into the line length.
                        this.truncate(textNode, void 0, words, lineNo === 0 ? (startAt || 0) : 0, width, 
                        // Build the text to test for
                        (t, currentIndex) => words
                            .slice(0, currentIndex)
                            .join(' ')
                            .replace(/- /g, '-'));
                        startAt = wrapper.actualWidth;
                        lineNo++;
                    }
                    // Reinsert the preceding child nodes
                    precedingSiblings.forEach((childNode) => {
                        parentElement.insertBefore(childNode, textNode);
                    });
                    // Insert the previous lines before the original text node
                    lines.forEach((line) => {
                        // Insert the line
                        parentElement.insertBefore(doc$2.createTextNode(line), textNode);
                        // Insert a break
                        const br = doc$2.createElementNS(SVG_NS$1, 'tspan');
                        br.textContent = '\u200B'; // zero-width space
                        attr$2(br, { dy, x });
                        parentElement.insertBefore(br, textNode);
                    });
                }
            };
            // Recurse down the DOM tree and handle line breaks for each text node
            const modifyChildren = ((node) => {
                const childNodes = [].slice.call(node.childNodes);
                childNodes.forEach((childNode) => {
                    if (childNode.nodeType === win$2.Node.TEXT_NODE) {
                        modifyTextNode(childNode, node);
                    }
                    else {
                        // Reset word-wrap width readings after hard breaks
                        if (childNode.className.baseVal
                            .indexOf('highcharts-br') !== -1) {
                            wrapper.actualWidth = 0;
                        }
                        // Recurse down to child node
                        modifyChildren(childNode);
                    }
                });
            });
            modifyChildren(wrapper.element);
        }
        /**
         * Get the rendered line height of a <text>, <tspan> or pure text node.
         *
         * @param {DOMElementType|Text} node The node to check for
         *
         * @return {number} The rendered line height
         */
        getLineHeight(node) {
            // If the node is a text node, use its parent
            const element = (node.nodeType === win$2.Node.TEXT_NODE) ?
                node.parentElement :
                node;
            return this.textLineHeight ?
                parseInt(this.textLineHeight.toString(), 10) :
                this.renderer.fontMetrics(element || this.svgElement.element).h;
        }
        /**
         * Transform a pseudo HTML AST node tree into an SVG structure. We do as
         * much heavy lifting as we can here, before doing the final processing in
         * the modifyDOM function. The original data is mutated.
         *
         * @private
         *
         * @param {ASTNode[]} nodes The AST nodes
         *
         */
        modifyTree(nodes) {
            const modifyChild = (node, i) => {
                const { attributes = {}, children, style = {}, tagName } = node, styledMode = this.renderer.styledMode;
                // Apply styling to text tags
                if (tagName === 'b' || tagName === 'strong') {
                    if (styledMode) {
                        // eslint-disable-next-line dot-notation
                        attributes['class'] = 'highcharts-strong';
                    }
                    else {
                        style.fontWeight = 'bold';
                    }
                }
                else if (tagName === 'i' || tagName === 'em') {
                    if (styledMode) {
                        // eslint-disable-next-line dot-notation
                        attributes['class'] = 'highcharts-emphasized';
                    }
                    else {
                        style.fontStyle = 'italic';
                    }
                }
                // Modify styling
                if (style && style.color) {
                    style.fill = style.color;
                }
                // Handle breaks
                if (tagName === 'br') {
                    attributes['class'] = 'highcharts-br'; // eslint-disable-line dot-notation
                    node.textContent = '\u200B'; // zero-width space
                    // Trim whitespace off the beginning of new lines
                    const nextNode = nodes[i + 1];
                    if (nextNode && nextNode.textContent) {
                        nextNode.textContent =
                            nextNode.textContent.replace(/^ +/gm, '');
                    }
                    // If an anchor has direct text node children, the text is unable to
                    // wrap because there is no `getSubStringLength` function on the
                    // element. Therefore we need to wrap the child text node or nodes
                    // in a tspan. #16173.
                }
                else if (tagName === 'a' &&
                    children &&
                    children.some((child) => child.tagName === '#text')) {
                    node.children = [{ children, tagName: 'tspan' }];
                }
                if (tagName !== '#text' && tagName !== 'a') {
                    node.tagName = 'tspan';
                }
                extend$3(node, { attributes, style });
                // Recurse
                if (children) {
                    children
                        .filter((c) => c.tagName !== '#text')
                        .forEach(modifyChild);
                }
            };
            nodes.forEach(modifyChild);
            fireEvent$2(this.svgElement, 'afterModifyTree', { nodes });
        }
        /*
         * Truncate the text node contents to a given length. Used when the css
         * width is set. If the `textOverflow` is `ellipsis`, the text is truncated
         * character by character to the given length. If not, the text is
         * word-wrapped line by line.
         */
        truncate(textNode, text, words, startAt, width, getString) {
            const svgElement = this.svgElement;
            const { renderer, rotation } = svgElement;
            // Cache the lengths to avoid checking the same twice
            const lengths = [];
            // Word wrap cannot be truncated to shorter than one word, ellipsis
            // text can be completely blank.
            let minIndex = words ? 1 : 0;
            let maxIndex = (text || words || '').length;
            let currentIndex = maxIndex;
            let str;
            let actualWidth;
            const getSubStringLength = function (charEnd, concatenatedEnd) {
                // charEnd is used when finding the character-by-character
                // break for ellipsis, concatenatedEnd is used for word-by-word
                // break for word wrapping.
                const end = concatenatedEnd || charEnd;
                const parentNode = textNode.parentNode;
                if (parentNode && typeof lengths[end] === 'undefined') {
                    // Modern browsers
                    if (parentNode.getSubStringLength) {
                        // Fails with DOM exception on unit-tests/legend/members
                        // of unknown reason. Desired width is 0, text content
                        // is "5" and end is 1.
                        try {
                            lengths[end] = startAt +
                                parentNode.getSubStringLength(0, words ? end + 1 : end);
                        }
                        catch (e) {
                        }
                    }
                }
                return lengths[end];
            };
            svgElement.rotation = 0; // discard rotation when computing box
            actualWidth = getSubStringLength(textNode.textContent.length);
            if (startAt + actualWidth > width) {
                // Do a binary search for the index where to truncate the text
                while (minIndex <= maxIndex) {
                    currentIndex = Math.ceil((minIndex + maxIndex) / 2);
                    // When checking words for word-wrap, we need to build the
                    // string and measure the subStringLength at the concatenated
                    // word length.
                    if (words) {
                        str = getString(words, currentIndex);
                    }
                    actualWidth = getSubStringLength(currentIndex, str && str.length - 1);
                    if (minIndex === maxIndex) {
                        // Complete
                        minIndex = maxIndex + 1;
                    }
                    else if (actualWidth > width) {
                        // Too large. Set max index to current.
                        maxIndex = currentIndex - 1;
                    }
                    else {
                        // Within width. Set min index to current.
                        minIndex = currentIndex;
                    }
                }
                // If max index was 0 it means the shortest possible text was also
                // too large. For ellipsis that means only the ellipsis, while for
                // word wrap it means the whole first word.
                if (maxIndex === 0) {
                    // Remove ellipsis
                    textNode.textContent = '';
                    // If the new text length is one less than the original, we don't
                    // need the ellipsis
                }
                else if (!(text && maxIndex === text.length - 1)) {
                    textNode.textContent = str || getString(text || words, currentIndex);
                }
            }
            // When doing line wrapping, prepare for the next line by removing the
            // items from this line.
            if (words) {
                words.splice(0, currentIndex);
            }
            svgElement.actualWidth = actualWidth;
            svgElement.rotation = rotation; // Apply rotation again.
        }
        /*
         * Un-escape HTML entities based on the public `renderer.escapes` list
         *
         * @private
         *
         * @param {string} inputStr The string to unescape
         * @param {Array<string>} [except] Exceptions
         *
         * @return {string} The processed string
         */
        unescapeEntities(inputStr, except) {
            objectEach$2(this.renderer.escapes, function (value, key) {
                if (!except || except.indexOf(value) === -1) {
                    inputStr = inputStr.toString().replace(new RegExp(value, 'g'), key);
                }
            });
            return inputStr;
        }
    }

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { charts: charts$1, deg2rad, doc: doc$1, isFirefox, isMS, isWebKit, noop: noop$1, SVG_NS, symbolSizes, win: win$1 } = H;
    const { addEvent: addEvent$1, attr: attr$1, createElement: createElement$1, css: css$1, defined: defined$2, destroyObjectProperties, extend: extend$2, isArray: isArray$2, isNumber: isNumber$2, isObject: isObject$1, isString: isString$1, merge: merge$2, pick: pick$2, pInt: pInt$1, uniqueKey: uniqueKey$1 } = Utilities;
    /* *
     *
     *  Variables
     *
     * */
    let hasInternalReferenceBug;
    /* *
     *
     *  Class
     *
     * */
    /* eslint-disable no-invalid-this, valid-jsdoc */
    /**
     * Allows direct access to the Highcharts rendering layer in order to draw
     * primitive shapes like circles, rectangles, paths or text directly on a chart,
     * or independent from any chart. The SVGRenderer represents a wrapper object
     * for SVG in modern browsers.
     *
     * An existing chart's renderer can be accessed through {@link Chart.renderer}.
     * The renderer can also be used completely decoupled from a chart.
     *
     * @sample highcharts/members/renderer-on-chart
     *         Annotating a chart programmatically.
     * @sample highcharts/members/renderer-basic
     *         Independent SVG drawing.
     *
     * @example
     * // Use directly without a chart object.
     * let renderer = new Highcharts.Renderer(parentNode, 600, 400);
     *
     * @class
     * @name Highcharts.SVGRenderer
     *
     * @param {Highcharts.HTMLDOMElement} container
     *        Where to put the SVG in the web page.
     *
     * @param {number} width
     *        The width of the SVG.
     *
     * @param {number} height
     *        The height of the SVG.
     *
     * @param {Highcharts.CSSObject} [style]
     *        The box style, if not in styleMode
     *
     * @param {boolean} [forExport=false]
     *        Whether the rendered content is intended for export.
     *
     * @param {boolean} [allowHTML=true]
     *        Whether the renderer is allowed to include HTML text, which will be
     *        projected on top of the SVG.
     *
     * @param {boolean} [styledMode=false]
     *        Whether the renderer belongs to a chart that is in styled mode.
     *        If it does, it will avoid setting presentational attributes in
     *        some cases, but not when set explicitly through `.attr` and `.css`
     *        etc.
     */
    class SVGRenderer {
        /* *
         *
         *  Constructors
         *
         * */
        constructor(container, width, height, style, forExport, allowHTML, styledMode) {
            /* *
             *
             *  Properties
             *
             * */
            this.alignedObjects = void 0;
            /**
             * The root `svg` node of the renderer.
             *
             * @name Highcharts.SVGRenderer#box
             * @type {Highcharts.SVGDOMElement}
             */
            this.box = void 0;
            /**
             * The wrapper for the root `svg` node of the renderer.
             *
             * @name Highcharts.SVGRenderer#boxWrapper
             * @type {Highcharts.SVGElement}
             */
            this.boxWrapper = void 0;
            this.cache = void 0;
            this.cacheKeys = void 0;
            this.chartIndex = void 0;
            /**
             * A pointer to the `defs` node of the root SVG.
             *
             * @name Highcharts.SVGRenderer#defs
             * @type {Highcharts.SVGElement}
             */
            this.defs = void 0;
            this.globalAnimation = void 0;
            this.gradients = void 0;
            this.height = void 0;
            this.imgCount = void 0;
            this.style = void 0;
            /**
             * Page url used for internal references.
             *
             * @private
             * @name Highcharts.SVGRenderer#url
             * @type {string}
             */
            this.url = void 0;
            this.width = void 0;
            this.init(container, width, height, style, forExport, allowHTML, styledMode);
        }
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Initialize the SVGRenderer. Overridable initializer function that takes
         * the same parameters as the constructor.
         *
         * @function Highcharts.SVGRenderer#init
         *
         * @param {Highcharts.HTMLDOMElement} container
         * Where to put the SVG in the web page.
         *
         * @param {number} width
         * The width of the SVG.
         *
         * @param {number} height
         * The height of the SVG.
         *
         * @param {Highcharts.CSSObject} [style]
         * The box style, if not in styleMode
         *
         * @param {boolean} [forExport=false]
         * Whether the rendered content is intended for export.
         *
         * @param {boolean} [allowHTML=true]
         * Whether the renderer is allowed to include HTML text, which will be
         * projected on top of the SVG.
         *
         * @param {boolean} [styledMode=false]
         * Whether the renderer belongs to a chart that is in styled mode. If it
         * does, it will avoid setting presentational attributes in some cases, but
         * not when set explicitly through `.attr` and `.css` etc.
         */
        init(container, width, height, style, forExport, allowHTML, styledMode) {
            const renderer = this, boxWrapper = renderer
                .createElement('svg')
                .attr({
                version: '1.1',
                'class': 'highcharts-root'
            }), element = boxWrapper.element;
            if (!styledMode) {
                boxWrapper.css(this.getStyle(style));
            }
            container.appendChild(element);
            // Always use ltr on the container, otherwise text-anchor will be
            // flipped and text appear outside labels, buttons, tooltip etc (#3482)
            attr$1(container, 'dir', 'ltr');
            // For browsers other than IE, add the namespace attribute (#1978)
            if (container.innerHTML.indexOf('xmlns') === -1) {
                attr$1(element, 'xmlns', this.SVG_NS);
            }
            this.box = element;
            this.boxWrapper = boxWrapper;
            renderer.alignedObjects = [];
            this.url = this.getReferenceURL();
            // Add description
            const desc = this.createElement('desc').add();
            desc.element.appendChild(doc$1.createTextNode('Created with Highcharts 11.1.0'));
            renderer.defs = this.createElement('defs').add();
            renderer.allowHTML = allowHTML;
            renderer.forExport = forExport;
            renderer.styledMode = styledMode;
            renderer.gradients = {}; // Object where gradient SvgElements are stored
            renderer.cache = {}; // Cache for numerical bounding boxes
            renderer.cacheKeys = [];
            renderer.imgCount = 0;
            renderer.rootFontSize = boxWrapper.getStyle('font-size');
            renderer.setSize(width, height, false);
            // Issue 110 workaround:
            // In Firefox, if a div is positioned by percentage, its pixel position
            // may land between pixels. The container itself doesn't display this,
            // but an SVG element inside this container will be drawn at subpixel
            // precision. In order to draw sharp lines, this must be compensated
            // for. This doesn't seem to work inside iframes though (like in
            // jsFiddle).
            let subPixelFix, rect;
            if (isFirefox && container.getBoundingClientRect) {
                subPixelFix = function () {
                    css$1(container, { left: 0, top: 0 });
                    rect = container.getBoundingClientRect();
                    css$1(container, {
                        left: (Math.ceil(rect.left) - rect.left) + 'px',
                        top: (Math.ceil(rect.top) - rect.top) + 'px'
                    });
                };
                // run the fix now
                subPixelFix();
                // run it on resize
                renderer.unSubPixelFix = addEvent$1(win$1, 'resize', subPixelFix);
            }
        }
        /**
         * General method for adding a definition to the SVG `defs` tag. Can be used
         * for gradients, fills, filters etc. Styled mode only. A hook for adding
         * general definitions to the SVG's defs tag. Definitions can be referenced
         * from the CSS by its `id`. Read more in
         * [gradients, shadows and patterns](https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns).
         * Styled mode only.
         *
         * @function Highcharts.SVGRenderer#definition
         *
         * @param {Highcharts.ASTNode} def
         * A serialized form of an SVG definition, including children.
         *
         * @return {Highcharts.SVGElement}
         * The inserted node.
         */
        definition(def) {
            const ast = new AST([def]);
            return ast.addToDOM(this.defs.element);
        }
        /**
         * Get the prefix needed for internal URL references to work in certain
         * cases. Some older browser versions had a bug where internal url
         * references in SVG attributes, on the form `url(#some-id)`, would fail if
         * a base tag was present in the page. There were also issues with
         * `history.pushState` related to this prefix.
         *
         * Related issues: #24, #672, #1070, #5244.
         *
         * The affected browsers are:
         * - Chrome <= 53 (May 2018)
         * - Firefox <= 51 (January 2017)
         * - Safari/Mac <= 12.1 (2018 or 2019)
         * - Safari/iOS <= 13
         *
         * @todo Remove this hack when time has passed. All the affected browsers
         * are evergreens, so it is increasingly unlikely that users are affected by
         * the bug.
         *
         * @return {string}
         * The prefix to use. An empty string for modern browsers.
         */
        getReferenceURL() {
            if ((isFirefox || isWebKit) &&
                doc$1.getElementsByTagName('base').length) {
                // Detect if a clip path is taking effect by performing a hit test
                // outside the clipped area. If the hit element is the rectangle
                // that was supposed to be clipped, the bug is present. This only
                // has to be performed once per page load, so we store the result
                // locally in the module.
                if (!defined$2(hasInternalReferenceBug)) {
                    const id = uniqueKey$1();
                    const ast = new AST([{
                            tagName: 'svg',
                            attributes: {
                                width: 8,
                                height: 8
                            },
                            children: [{
                                    tagName: 'defs',
                                    children: [{
                                            tagName: 'clipPath',
                                            attributes: {
                                                id
                                            },
                                            children: [{
                                                    tagName: 'rect',
                                                    attributes: {
                                                        width: 4,
                                                        height: 4
                                                    }
                                                }]
                                        }]
                                }, {
                                    tagName: 'rect',
                                    attributes: {
                                        id: 'hitme',
                                        width: 8,
                                        height: 8,
                                        'clip-path': `url(#${id})`,
                                        fill: 'rgba(0,0,0,0.001)'
                                    }
                                }]
                        }]);
                    const svg = ast.addToDOM(doc$1.body);
                    css$1(svg, {
                        position: 'fixed',
                        top: 0,
                        left: 0,
                        zIndex: 9e5
                    });
                    const hitElement = doc$1.elementFromPoint(6, 6);
                    hasInternalReferenceBug = (hitElement && hitElement.id) === 'hitme';
                    doc$1.body.removeChild(svg);
                }
                if (hasInternalReferenceBug) {
                    return win$1.location.href
                        .split('#')[0] // remove the hash
                        .replace(/<[^>]*>/g, '') // wing cut HTML
                        // escape parantheses and quotes
                        .replace(/([\('\)])/g, '\\$1')
                        // replace spaces (needed for Safari only)
                        .replace(/ /g, '%20');
                }
            }
            return '';
        }
        /**
         * Get the global style setting for the renderer.
         *
         * @private
         * @function Highcharts.SVGRenderer#getStyle
         *
         * @param {Highcharts.CSSObject} style
         * Style settings.
         *
         * @return {Highcharts.CSSObject}
         * The style settings mixed with defaults.
         */
        getStyle(style) {
            this.style = extend$2({
                fontFamily: 'Helvetica, Arial, sans-serif',
                fontSize: '1rem'
            }, style);
            return this.style;
        }
        /**
         * Apply the global style on the renderer, mixed with the default styles.
         *
         * @function Highcharts.SVGRenderer#setStyle
         *
         * @param {Highcharts.CSSObject} style
         * CSS to apply.
         */
        setStyle(style) {
            this.boxWrapper.css(this.getStyle(style));
        }
        /**
         * Detect whether the renderer is hidden. This happens when one of the
         * parent elements has `display: none`. Used internally to detect when we
         * needto render preliminarily in another div to get the text bounding boxes
         * right.
         *
         * @function Highcharts.SVGRenderer#isHidden
         *
         * @return {boolean}
         * True if it is hidden.
         */
        isHidden() {
            return !this.boxWrapper.getBBox().width;
        }
        /**
         * Destroys the renderer and its allocated members.
         *
         * @function Highcharts.SVGRenderer#destroy
         *
         * @return {null}
         * Pass through value.
         */
        destroy() {
            const renderer = this, rendererDefs = renderer.defs;
            renderer.box = null;
            renderer.boxWrapper = renderer.boxWrapper.destroy();
            // Call destroy on all gradient elements
            destroyObjectProperties(renderer.gradients || {});
            renderer.gradients = null;
            renderer.defs = rendererDefs.destroy();
            // Remove sub pixel fix handler (#982)
            if (renderer.unSubPixelFix) {
                renderer.unSubPixelFix();
            }
            renderer.alignedObjects = null;
            return null;
        }
        /**
         * Create a wrapper for an SVG element. Serves as a factory for
         * {@link SVGElement}, but this function is itself mostly called from
         * primitive factories like {@link SVGRenderer#path}, {@link
         * SVGRenderer#rect} or {@link SVGRenderer#text}.
         *
         * @function Highcharts.SVGRenderer#createElement
         *
         * @param {string} nodeName
         * The node name, for example `rect`, `g` etc.
         *
         * @return {Highcharts.SVGElement}
         * The generated SVGElement.
         */
        createElement(nodeName) {
            const wrapper = new this.Element();
            wrapper.init(this, nodeName);
            return wrapper;
        }
        /**
         * Get converted radial gradient attributes according to the radial
         * reference. Used internally from the {@link SVGElement#colorGradient}
         * function.
         *
         * @private
         * @function Highcharts.SVGRenderer#getRadialAttr
         */
        getRadialAttr(radialReference, gradAttr) {
            return {
                cx: (radialReference[0] - radialReference[2] / 2) +
                    (gradAttr.cx || 0) * radialReference[2],
                cy: (radialReference[1] - radialReference[2] / 2) +
                    (gradAttr.cy || 0) * radialReference[2],
                r: (gradAttr.r || 0) * radialReference[2]
            };
        }
        /**
         * Create a drop shadow definition and return its id
         *
         * @private
         * @function Highcharts.SVGRenderer#shadowDefinition
         *
         * @param {boolean|Highcharts.ShadowOptionsObject} [shadowOptions] The
         *        shadow options. If `true`, the default options are applied
         */
        shadowDefinition(shadowOptions) {
            const id = [
                `highcharts-drop-shadow-${this.chartIndex}`,
                ...Object.keys(shadowOptions)
                    .map((key) => shadowOptions[key])
            ].join('-').replace(/[^a-z0-9\-]/g, ''), options = merge$2({
                color: '#000000',
                offsetX: 1,
                offsetY: 1,
                opacity: 0.15,
                width: 5
            }, shadowOptions);
            if (!this.defs.element.querySelector(`#${id}`)) {
                this.definition({
                    tagName: 'filter',
                    attributes: {
                        id
                    },
                    children: [{
                            tagName: 'feDropShadow',
                            attributes: {
                                dx: options.offsetX,
                                dy: options.offsetY,
                                'flood-color': options.color,
                                // Tuned and modified to keep a preserve compatibility
                                // with the old settings
                                'flood-opacity': Math.min(options.opacity * 5, 1),
                                stdDeviation: options.width / 2
                            }
                        }]
                });
            }
            return id;
        }
        /**
         * Parse a simple HTML string into SVG tspans. Called internally when text
         * is set on an SVGElement. The function supports a subset of HTML tags, CSS
         * text features like `width`, `text-overflow`, `white-space`, and also
         * attributes like `href` and `style`.
         *
         * @private
         * @function Highcharts.SVGRenderer#buildText
         *
         * @param {Highcharts.SVGElement} wrapper
         * The parent SVGElement.
         */
        buildText(wrapper) {
            new TextBuilder(wrapper).buildSVG();
        }
        /**
         * Returns white for dark colors and black for bright colors, based on W3C's
         * definition of [Relative luminance](
         * https://www.w3.org/WAI/GL/wiki/Relative_luminance).
         *
         * @function Highcharts.SVGRenderer#getContrast
         *
         * @param {Highcharts.ColorString} color
         * The color to get the contrast for.
         *
         * @return {Highcharts.ColorString}
         * The contrast color, either `#000000` or `#FFFFFF`.
         */
        getContrast(color) {
            // #6216, #17273
            const rgba = Color.parse(color).rgba
                .map((b8) => {
                const c = b8 / 255;
                return c <= 0.03928 ?
                    c / 12.92 :
                    Math.pow((c + 0.055) / 1.055, 2.4);
            });
            // Relative luminance
            const l = 0.2126 * rgba[0] + 0.7152 * rgba[1] + 0.0722 * rgba[2];
            // Use white or black based on which provides more contrast
            return 1.05 / (l + 0.05) > (l + 0.05) / 0.05 ? '#FFFFFF' : '#000000';
        }
        /**
         * Create a button with preset states.
         *
         * @function Highcharts.SVGRenderer#button
         *
         * @param {string} text
         * The text or HTML to draw.
         *
         * @param {number} x
         * The x position of the button's left side.
         *
         * @param {number} y
         * The y position of the button's top side.
         *
         * @param {Highcharts.EventCallbackFunction<Highcharts.SVGElement>} callback
         * The function to execute on button click or touch.
         *
         * @param {Highcharts.SVGAttributes} [theme]
         * SVG attributes for the normal state.
         *
         * @param {Highcharts.SVGAttributes} [hoverState]
         * SVG attributes for the hover state.
         *
         * @param {Highcharts.SVGAttributes} [selectState]
         * SVG attributes for the pressed state.
         *
         * @param {Highcharts.SVGAttributes} [disabledState]
         * SVG attributes for the disabled state.
         *
         * @param {Highcharts.SymbolKeyValue} [shape=rect]
         * The shape type.
         *
         * @param {boolean} [useHTML=false]
         * Whether to use HTML to render the label.
         *
         * @return {Highcharts.SVGElement}
         * The button element.
         */
        button(text, x, y, callback, theme = {}, hoverState, selectState, disabledState, shape, useHTML) {
            const label = this.label(text, x, y, shape, void 0, void 0, useHTML, void 0, 'button'), styledMode = this.styledMode, states = theme.states || {};
            let curState = 0;
            theme = merge$2(theme);
            delete theme.states;
            const normalStyle = merge$2({
                color: "#333333" /* Palette.neutralColor80 */,
                cursor: 'pointer',
                fontSize: '0.8em',
                fontWeight: 'normal'
            }, theme.style);
            delete theme.style;
            // Remove stylable attributes. Pass in the ButtonThemeObject and get the
            // SVGAttributes subset back.
            let normalState = AST.filterUserAttributes(theme);
            // Default, non-stylable attributes
            label.attr(merge$2({ padding: 8, r: 2 }, normalState));
            // Presentational. The string type is a mistake, it is just for
            // compliance with SVGAttribute and is not used in button theme.
            let hoverStyle, selectStyle, disabledStyle;
            if (!styledMode) {
                // Normal state - prepare the attributes
                normalState = merge$2({
                    fill: "#f7f7f7" /* Palette.neutralColor3 */,
                    stroke: "#cccccc" /* Palette.neutralColor20 */,
                    'stroke-width': 1
                }, normalState);
                // Hover state
                hoverState = merge$2(normalState, {
                    fill: "#e6e6e6" /* Palette.neutralColor10 */
                }, AST.filterUserAttributes(hoverState || states.hover || {}));
                hoverStyle = hoverState.style;
                delete hoverState.style;
                // Pressed state
                selectState = merge$2(normalState, {
                    fill: "#e6e9ff" /* Palette.highlightColor10 */,
                    style: {
                        color: "#000000" /* Palette.neutralColor100 */,
                        fontWeight: 'bold'
                    }
                }, AST.filterUserAttributes(selectState || states.select || {}));
                selectStyle = selectState.style;
                delete selectState.style;
                // Disabled state
                disabledState = merge$2(normalState, {
                    style: {
                        color: "#cccccc" /* Palette.neutralColor20 */
                    }
                }, AST.filterUserAttributes(disabledState || states.disabled || {}));
                disabledStyle = disabledState.style;
                delete disabledState.style;
            }
            // Add the events. IE9 and IE10 need mouseover and mouseout to function
            // (#667).
            addEvent$1(label.element, isMS ? 'mouseover' : 'mouseenter', function () {
                if (curState !== 3) {
                    label.setState(1);
                }
            });
            addEvent$1(label.element, isMS ? 'mouseout' : 'mouseleave', function () {
                if (curState !== 3) {
                    label.setState(curState);
                }
            });
            label.setState = function (state) {
                // Hover state is temporary, don't record it
                if (state !== 1) {
                    label.state = curState = state;
                }
                // Update visuals
                label
                    .removeClass(/highcharts-button-(normal|hover|pressed|disabled)/)
                    .addClass('highcharts-button-' +
                    ['normal', 'hover', 'pressed', 'disabled'][state || 0]);
                if (!styledMode) {
                    label
                        .attr([
                        normalState,
                        hoverState,
                        selectState,
                        disabledState
                    ][state || 0]);
                    const css = [
                        normalStyle,
                        hoverStyle,
                        selectStyle,
                        disabledStyle
                    ][state || 0];
                    if (isObject$1(css)) {
                        label.css(css);
                    }
                }
            };
            // Presentational attributes
            if (!styledMode) {
                label
                    .attr(normalState)
                    .css(extend$2({ cursor: 'default' }, normalStyle));
                // HTML labels don't need to handle pointer events because click and
                // mouseenter/mouseleave is bound to the underlying <g> element.
                // Should this be reconsidered, we need more complex logic to share
                // events between the <g> and its <div> counterpart, and avoid
                // triggering mouseenter/mouseleave when hovering from one to the
                // other (#17440).
                if (useHTML) {
                    label.text.css({ pointerEvents: 'none' });
                }
            }
            return label
                .on('touchstart', (e) => e.stopPropagation())
                .on('click', function (e) {
                if (curState !== 3) {
                    callback.call(label, e);
                }
            });
        }
        /**
         * Make a straight line crisper by not spilling out to neighbour pixels.
         *
         * @function Highcharts.SVGRenderer#crispLine
         *
         * @param {Highcharts.SVGPathArray} points
         *        The original points on the format `[['M', 0, 0], ['L', 100, 0]]`.
         *
         * @param {number} width
         *        The width of the line.
         *
         * @param {string} [roundingFunction=round]
         *        The rounding function name on the `Math` object, can be one of
         *        `round`, `floor` or `ceil`.
         *
         * @return {Highcharts.SVGPathArray}
         *         The original points array, but modified to render crisply.
         */
        crispLine(points, width, roundingFunction = 'round') {
            const start = points[0];
            const end = points[1];
            // Normalize to a crisp line
            if (defined$2(start[1]) && start[1] === end[1]) {
                // Substract due to #1129. Now bottom and left axis gridlines behave
                // the same.
                start[1] = end[1] =
                    Math[roundingFunction](start[1]) - (width % 2 / 2);
            }
            if (defined$2(start[2]) && start[2] === end[2]) {
                start[2] = end[2] =
                    Math[roundingFunction](start[2]) + (width % 2 / 2);
            }
            return points;
        }
        /**
         * Draw a path, wraps the SVG `path` element.
         *
         * @sample highcharts/members/renderer-path-on-chart/
         *         Draw a path in a chart
         * @sample highcharts/members/renderer-path/
         *         Draw a path independent from a chart
         *
         * @example
         * let path = renderer.path(['M', 10, 10, 'L', 30, 30, 'z'])
         *     .attr({ stroke: '#ff00ff' })
         *     .add();
         *
         * @function Highcharts.SVGRenderer#path
         *
         * @param {Highcharts.SVGPathArray} [path]
         * An SVG path definition in array form.
         *
         * @return {Highcharts.SVGElement}
         * The generated wrapper element.
         *
         */ /**
        * Draw a path, wraps the SVG `path` element.
        *
        * @function Highcharts.SVGRenderer#path
        *
        * @param {Highcharts.SVGAttributes} [attribs]
        * The initial attributes.
        *
        * @return {Highcharts.SVGElement}
        * The generated wrapper element.
        */
        path(path) {
            const attribs = (this.styledMode ? {} : {
                fill: 'none'
            });
            if (isArray$2(path)) {
                attribs.d = path;
            }
            else if (isObject$1(path)) { // attributes
                extend$2(attribs, path);
            }
            return this.createElement('path').attr(attribs);
        }
        /**
         * Draw a circle, wraps the SVG `circle` element.
         *
         * @sample highcharts/members/renderer-circle/
         *         Drawing a circle
         *
         * @function Highcharts.SVGRenderer#circle
         *
         * @param {number} [x]
         * The center x position.
         *
         * @param {number} [y]
         * The center y position.
         *
         * @param {number} [r]
         * The radius.
         *
         * @return {Highcharts.SVGElement}
         * The generated wrapper element.
         */ /**
        * Draw a circle, wraps the SVG `circle` element.
        *
        * @function Highcharts.SVGRenderer#circle
        *
        * @param {Highcharts.SVGAttributes} [attribs]
        * The initial attributes.
        *
        * @return {Highcharts.SVGElement}
        * The generated wrapper element.
        */
        circle(x, y, r) {
            const attribs = (isObject$1(x) ?
                x :
                typeof x === 'undefined' ? {} : { x: x, y: y, r: r }), wrapper = this.createElement('circle');
            // Setting x or y translates to cx and cy
            wrapper.xSetter = wrapper.ySetter = function (value, key, element) {
                element.setAttribute('c' + key, value);
            };
            return wrapper.attr(attribs);
        }
        /**
         * Draw and return an arc.
         *
         * @sample highcharts/members/renderer-arc/
         *         Drawing an arc
         *
         * @function Highcharts.SVGRenderer#arc
         *
         * @param {number} [x=0]
         * Center X position.
         *
         * @param {number} [y=0]
         * Center Y position.
         *
         * @param {number} [r=0]
         * The outer radius' of the arc.
         *
         * @param {number} [innerR=0]
         * Inner radius like used in donut charts.
         *
         * @param {number} [start=0]
         * The starting angle of the arc in radians, where 0 is to the right and
         * `-Math.PI/2` is up.
         *
         * @param {number} [end=0]
         * The ending angle of the arc in radians, where 0 is to the right and
         * `-Math.PI/2` is up.
         *
         * @return {Highcharts.SVGElement}
         * The generated wrapper element.
         */ /**
        * Draw and return an arc. Overloaded function that takes arguments object.
        *
        * @function Highcharts.SVGRenderer#arc
        *
        * @param {Highcharts.SVGAttributes} attribs
        * Initial SVG attributes.
        *
        * @return {Highcharts.SVGElement}
        * The generated wrapper element.
        */
        arc(x, y, r, innerR, start, end) {
            let options;
            if (isObject$1(x)) {
                options = x;
                y = options.y;
                r = options.r;
                innerR = options.innerR;
                start = options.start;
                end = options.end;
                x = options.x;
            }
            else {
                options = { innerR, start, end };
            }
            // Arcs are defined as symbols for the ability to set
            // attributes in attr and animate
            const arc = this.symbol('arc', x, y, r, r, options);
            arc.r = r; // #959
            return arc;
        }
        /**
         * Draw and return a rectangle.
         *
         * @function Highcharts.SVGRenderer#rect
         *
         * @param {number} [x]
         * Left position.
         *
         * @param {number} [y]
         * Top position.
         *
         * @param {number} [width]
         * Width of the rectangle.
         *
         * @param {number} [height]
         * Height of the rectangle.
         *
         * @param {number} [r]
         * Border corner radius.
         *
         * @param {number} [strokeWidth]
         * A stroke width can be supplied to allow crisp drawing.
         *
         * @return {Highcharts.SVGElement}
         * The generated wrapper element.
         */ /**
        * Draw and return a rectangle.
        *
        * @sample highcharts/members/renderer-rect-on-chart/
        *         Draw a rectangle in a chart
        * @sample highcharts/members/renderer-rect/
        *         Draw a rectangle independent from a chart
        *
        * @function Highcharts.SVGRenderer#rect
        *
        * @param {Highcharts.SVGAttributes} [attributes]
        * General SVG attributes for the rectangle.
        *
        * @return {Highcharts.SVGElement}
        * The generated wrapper element.
        */
        rect(x, y, width, height, r, strokeWidth) {
            const attribs = (isObject$1(x) ?
                x :
                typeof x === 'undefined' ?
                    {} :
                    {
                        x,
                        y,
                        r,
                        width: Math.max(width || 0, 0),
                        height: Math.max(height || 0, 0)
                    }), wrapper = this.createElement('rect');
            if (!this.styledMode) {
                if (typeof strokeWidth !== 'undefined') {
                    attribs['stroke-width'] = strokeWidth;
                    extend$2(attribs, wrapper.crisp(attribs));
                }
                attribs.fill = 'none';
            }
            wrapper.rSetter = function (value, _key, element) {
                wrapper.r = value;
                attr$1(element, {
                    rx: value,
                    ry: value
                });
            };
            wrapper.rGetter = function () {
                return wrapper.r || 0;
            };
            return wrapper.attr(attribs);
        }
        /**
         * Draw and return a rectangle with advanced corner rounding options.
         *
         * @function Highcharts.SVGRenderer#roundedRect
         *
         * @param {Highcharts.SVGAttributes} attribs
         *      Attributes
         * @return {Highcharts.SVGElement}
         * The generated wrapper element.
         */
        roundedRect(attribs) {
            return this.symbol('roundedRect').attr(attribs);
        }
        /**
         * Resize the {@link SVGRenderer#box} and re-align all aligned child
         * elements.
         *
         * @sample highcharts/members/renderer-g/
         *         Show and hide grouped objects
         *
         * @function Highcharts.SVGRenderer#setSize
         *
         * @param {number} width
         * The new pixel width.
         *
         * @param {number} height
         * The new pixel height.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animate=true]
         * Whether and how to animate.
         */
        setSize(width, height, animate) {
            const renderer = this;
            renderer.width = width;
            renderer.height = height;
            renderer.boxWrapper.animate({
                width: width,
                height: height
            }, {
                step: function () {
                    this.attr({
                        viewBox: '0 0 ' + this.attr('width') + ' ' +
                            this.attr('height')
                    });
                },
                duration: pick$2(animate, true) ? void 0 : 0
            });
            renderer.alignElements();
        }
        /**
         * Create and return an svg group element. Child
         * {@link Highcharts.SVGElement} objects are added to the group by using the
         * group as the first parameter in {@link Highcharts.SVGElement#add|add()}.
         *
         * @function Highcharts.SVGRenderer#g
         *
         * @param {string} [name]
         *        The group will be given a class name of `highcharts-{name}`. This
         *        can be used for styling and scripting.
         *
         * @return {Highcharts.SVGElement}
         *         The generated wrapper element.
         */
        g(name) {
            const elem = this.createElement('g');
            return name ?
                elem.attr({ 'class': 'highcharts-' + name }) :
                elem;
        }
        /**
         * Display an image.
         *
         * @sample highcharts/members/renderer-image-on-chart/
         *         Add an image in a chart
         * @sample highcharts/members/renderer-image/
         *         Add an image independent of a chart
         *
         * @function Highcharts.SVGRenderer#image
         *
         * @param {string} href
         *        The image source.
         *
         * @param {number} [x]
         *        The X position.
         *
         * @param {number} [y]
         *        The Y position.
         *
         * @param {number} [width]
         *        The image width. If omitted, it defaults to the image file width.
         *
         * @param {number} [height]
         *        The image height. If omitted it defaults to the image file
         *        height.
         *
         * @param {Function} [onload]
         *        Event handler for image load.
         *
         * @return {Highcharts.SVGElement}
         *         The generated wrapper element.
         */
        image(href, x, y, width, height, onload) {
            const attribs = { preserveAspectRatio: 'none' };
            // Optional properties (#11756)
            if (isNumber$2(x)) {
                attribs.x = x;
            }
            if (isNumber$2(y)) {
                attribs.y = y;
            }
            if (isNumber$2(width)) {
                attribs.width = width;
            }
            if (isNumber$2(height)) {
                attribs.height = height;
            }
            const elemWrapper = this.createElement('image').attr(attribs), onDummyLoad = function (e) {
                elemWrapper.attr({ href });
                onload.call(elemWrapper, e);
            };
            // Add load event if supplied
            if (onload) {
                // We have to use a dummy HTML image since IE support for SVG image
                // load events is very buggy. First set a transparent src, wait for
                // dummy to load, and then add the real src to the SVG image.
                elemWrapper.attr({
                    /* eslint-disable-next-line max-len */
                    href: 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=='
                });
                const dummy = new win$1.Image();
                addEvent$1(dummy, 'load', onDummyLoad);
                dummy.src = href;
                if (dummy.complete) {
                    onDummyLoad({});
                }
            }
            else {
                elemWrapper.attr({ href });
            }
            return elemWrapper;
        }
        /**
         * Draw a symbol out of pre-defined shape paths from
         * {@link SVGRenderer#symbols}.
         * It is used in Highcharts for point makers, which cake a `symbol` option,
         * and label and button backgrounds like in the tooltip and stock flags.
         *
         * @function Highcharts.SVGRenderer#symbol
         *
         * @param {string} symbol
         * The symbol name.
         *
         * @param {number} [x]
         * The X coordinate for the top left position.
         *
         * @param {number} [y]
         * The Y coordinate for the top left position.
         *
         * @param {number} [width]
         * The pixel width.
         *
         * @param {number} [height]
         * The pixel height.
         *
         * @param {Highcharts.SymbolOptionsObject} [options]
         * Additional options, depending on the actual symbol drawn.
         *
         * @return {Highcharts.SVGElement}
         * SVG symbol.
         */
        symbol(symbol, x, y, width, height, options) {
            const ren = this, imageRegex = /^url\((.*?)\)$/, isImage = imageRegex.test(symbol), sym = (!isImage && (this.symbols[symbol] ? symbol : 'circle')), 
            // get the symbol definition function
            symbolFn = (sym && this.symbols[sym]);
            let obj, path, imageSrc, centerImage;
            if (symbolFn) {
                // Check if there's a path defined for this symbol
                if (typeof x === 'number') {
                    path = symbolFn.call(this.symbols, Math.round(x || 0), Math.round(y || 0), width || 0, height || 0, options);
                }
                obj = this.path(path);
                if (!ren.styledMode) {
                    obj.attr('fill', 'none');
                }
                // expando properties for use in animate and attr
                extend$2(obj, {
                    symbolName: (sym || void 0),
                    x: x,
                    y: y,
                    width: width,
                    height: height
                });
                if (options) {
                    extend$2(obj, options);
                }
                // Image symbols
            }
            else if (isImage) {
                imageSrc = symbol.match(imageRegex)[1];
                // Create the image synchronously, add attribs async
                const img = obj = this.image(imageSrc);
                // The image width is not always the same as the symbol width. The
                // image may be centered within the symbol, as is the case when
                // image shapes are used as label backgrounds, for example in flags.
                img.imgwidth = pick$2(options && options.width, symbolSizes[imageSrc] && symbolSizes[imageSrc].width);
                img.imgheight = pick$2(options && options.height, symbolSizes[imageSrc] && symbolSizes[imageSrc].height);
                /**
                 * Set the size and position
                 */
                centerImage = (obj) => obj.attr({
                    width: obj.width,
                    height: obj.height
                });
                /**
                 * Width and height setters that take both the image's physical size
                 * and the label size into consideration, and translates the image
                 * to center within the label.
                 */
                ['width', 'height'].forEach(function (key) {
                    img[key + 'Setter'] = function (value, key) {
                        this[key] = value;
                        const { alignByTranslate, element, width, height, imgwidth, imgheight } = this;
                        let imgSize = this['img' + key];
                        if (defined$2(imgSize)) {
                            let scale = 1;
                            // Scale and center the image within its container.
                            // The name `backgroundSize` is taken from the CSS spec,
                            // but the value `within` is made up. Other possible
                            // values in the spec, `cover` and `contain`, can be
                            // implemented if needed.
                            if (options &&
                                options.backgroundSize === 'within' &&
                                width &&
                                height) {
                                scale = Math.min(width / imgwidth, height / imgheight);
                                imgSize = Math.round(imgSize * scale);
                                // Update both width and height to keep the ratio
                                // correct (#17315)
                                attr$1(element, {
                                    width: Math.round(imgwidth * scale),
                                    height: Math.round(imgheight * scale)
                                });
                            }
                            else if (element) {
                                element.setAttribute(key, imgSize);
                            }
                            if (!alignByTranslate) {
                                this.translate(((width || 0) - (imgwidth * scale)) / 2, ((height || 0) - (imgheight * scale)) / 2);
                            }
                        }
                    };
                });
                if (defined$2(x)) {
                    img.attr({
                        x: x,
                        y: y
                    });
                }
                img.isImg = true;
                if (defined$2(img.imgwidth) && defined$2(img.imgheight)) {
                    centerImage(img);
                }
                else {
                    // Initialize image to be 0 size so export will still function
                    // if there's no cached sizes.
                    img.attr({ width: 0, height: 0 });
                    // Create a dummy JavaScript image to get the width and height.
                    createElement$1('img', {
                        onload: function () {
                            const chart = charts$1[ren.chartIndex];
                            // Special case for SVGs on IE11, the width is not
                            // accessible until the image is part of the DOM
                            // (#2854).
                            if (this.width === 0) {
                                css$1(this, {
                                    position: 'absolute',
                                    top: '-999em'
                                });
                                doc$1.body.appendChild(this);
                            }
                            // Center the image
                            symbolSizes[imageSrc] = {
                                width: this.width,
                                height: this.height
                            };
                            img.imgwidth = this.width;
                            img.imgheight = this.height;
                            if (img.element) {
                                centerImage(img);
                            }
                            // Clean up after #2854 workaround.
                            if (this.parentNode) {
                                this.parentNode.removeChild(this);
                            }
                            // Fire the load event when all external images are
                            // loaded
                            ren.imgCount--;
                            if (!ren.imgCount && chart && !chart.hasLoaded) {
                                chart.onload();
                            }
                        },
                        src: imageSrc
                    });
                    this.imgCount++;
                }
            }
            return obj;
        }
        /**
         * Define a clipping rectangle. The clipping rectangle is later applied
         * to {@link SVGElement} objects through the {@link SVGElement#clip}
         * function.
         *
         * @example
         * let circle = renderer.circle(100, 100, 100)
         *     .attr({ fill: 'red' })
         *     .add();
         * let clipRect = renderer.clipRect(100, 100, 100, 100);
         *
         * // Leave only the lower right quarter visible
         * circle.clip(clipRect);
         *
         * @function Highcharts.SVGRenderer#clipRect
         *
         * @param {number} [x]
         *
         * @param {number} [y]
         *
         * @param {number} [width]
         *
         * @param {number} [height]
         *
         * @return {Highcharts.ClipRectElement}
         *         A clipping rectangle.
         */
        clipRect(x, y, width, height) {
            const 
            // Add a hyphen at the end to avoid confusion in testing indexes
            // -1 and -10, -11 etc (#6550)
            id = uniqueKey$1() + '-', clipPath = this.createElement('clipPath').attr({
                id: id
            }).add(this.defs), wrapper = this.rect(x, y, width, height, 0).add(clipPath);
            wrapper.id = id;
            wrapper.clipPath = clipPath;
            wrapper.count = 0;
            return wrapper;
        }
        /**
         * Draw text. The text can contain a subset of HTML, like spans and anchors
         * and some basic text styling of these. For more advanced features like
         * border and background, use {@link Highcharts.SVGRenderer#label} instead.
         * To update the text after render, run `text.attr({ text: 'New text' })`.
         *
         * @sample highcharts/members/renderer-text-on-chart/
         *         Annotate the chart freely
         * @sample highcharts/members/renderer-on-chart/
         *         Annotate with a border and in response to the data
         * @sample highcharts/members/renderer-text/
         *         Formatted text
         *
         * @function Highcharts.SVGRenderer#text
         *
         * @param {string} [str]
         * The text of (subset) HTML to draw.
         *
         * @param {number} [x]
         * The x position of the text's lower left corner.
         *
         * @param {number} [y]
         * The y position of the text's lower left corner.
         *
         * @param {boolean} [useHTML=false]
         * Use HTML to render the text.
         *
         * @return {Highcharts.SVGElement}
         * The text object.
         */
        text(str, x, y, useHTML) {
            const renderer = this, attribs = {};
            if (useHTML && (renderer.allowHTML || !renderer.forExport)) {
                return renderer.html(str, x, y);
            }
            attribs.x = Math.round(x || 0); // X always needed for line-wrap logic
            if (y) {
                attribs.y = Math.round(y);
            }
            if (defined$2(str)) {
                attribs.text = str;
            }
            const wrapper = renderer.createElement('text').attr(attribs);
            if (!useHTML || (renderer.forExport && !renderer.allowHTML)) {
                wrapper.xSetter = function (value, key, element) {
                    const tspans = element.getElementsByTagName('tspan'), parentVal = element.getAttribute(key);
                    for (let i = 0, tspan; i < tspans.length; i++) {
                        tspan = tspans[i];
                        // If the x values are equal, the tspan represents a line
                        // break
                        if (tspan.getAttribute(key) === parentVal) {
                            tspan.setAttribute(key, value);
                        }
                    }
                    element.setAttribute(key, value);
                };
            }
            return wrapper;
        }
        /**
         * Utility to return the baseline offset and total line height from the font
         * size.
         *
         * @function Highcharts.SVGRenderer#fontMetrics
         *
         * @param {Highcharts.SVGElement|Highcharts.SVGDOMElement|number} [element]
         *        The element to inspect for a current font size. If a number is
         *        given, it's used as a fall back for direct font size in pixels.
         *
         * @return {Highcharts.FontMetricsObject}
         *         The font metrics.
         */
        fontMetrics(element) {
            const f = pInt$1(SVGElement.prototype.getStyle.call(element, 'font-size') || 0);
            // Empirical values found by comparing font size and bounding box
            // height. Applies to the default font family.
            // https://jsfiddle.net/highcharts/7xvn7/
            const h = f < 24 ? f + 3 : Math.round(f * 1.2), b = Math.round(h * 0.8);
            return {
                // Line height
                h,
                // Baseline
                b,
                // Font size
                f
            };
        }
        /**
         * Correct X and Y positioning of a label for rotation (#1764).
         *
         * @private
         * @function Highcharts.SVGRenderer#rotCorr
         */
        rotCorr(baseline, rotation, alterY) {
            let y = baseline;
            if (rotation && alterY) {
                y = Math.max(y * Math.cos(rotation * deg2rad), 4);
            }
            return {
                x: (-baseline / 3) * Math.sin(rotation * deg2rad),
                y: y
            };
        }
        /**
         * Compatibility function to convert the legacy one-dimensional path array
         * into an array of segments.
         *
         * It is used in maps to parse the `path` option, and in SVGRenderer.dSetter
         * to support legacy paths from demos.
         *
         * @private
         * @function Highcharts.SVGRenderer#pathToSegments
         */
        pathToSegments(path) {
            const ret = [];
            const segment = [];
            const commandLength = {
                A: 8,
                C: 7,
                H: 2,
                L: 3,
                M: 3,
                Q: 5,
                S: 5,
                T: 3,
                V: 2
            };
            // Short, non-typesafe parsing of the one-dimensional array. It splits
            // the path on any string. This is not type checked against the tuple
            // types, but is shorter, and doesn't require specific checks for any
            // command type in SVG.
            for (let i = 0; i < path.length; i++) {
                // Command skipped, repeat previous or insert L/l for M/m
                if (isString$1(segment[0]) &&
                    isNumber$2(path[i]) &&
                    segment.length === commandLength[(segment[0].toUpperCase())]) {
                    path.splice(i, 0, segment[0].replace('M', 'L').replace('m', 'l'));
                }
                // Split on string
                if (typeof path[i] === 'string') {
                    if (segment.length) {
                        ret.push(segment.slice(0));
                    }
                    segment.length = 0;
                }
                segment.push(path[i]);
            }
            ret.push(segment.slice(0));
            return ret;
            /*
            // Fully type-safe version where each tuple type is checked. The
            // downside is filesize and a lack of flexibility for unsupported
            // commands
            const ret: SVGPath = [],
                commands = {
                    A: 7,
                    C: 6,
                    H: 1,
                    L: 2,
                    M: 2,
                    Q: 4,
                    S: 4,
                    T: 2,
                    V: 1,
                    Z: 0
                };

            let i = 0,
                lastI = 0,
                lastCommand;

            while (i < path.length) {
                const item = path[i];

                let command;

                if (typeof item === 'string') {
                    command = item;
                    i += 1;
                } else {
                    command = lastCommand || 'M';
                }

                // Upper case
                const commandUC = command.toUpperCase();

                if (commandUC in commands) {

                    // No numeric parameters
                    if (command === 'Z' || command === 'z') {
                        ret.push([command]);

                    // One numeric parameter
                    } else {
                        const val0 = path[i];
                        if (typeof val0 === 'number') {

                            // Horizontal line to
                            if (command === 'H' || command === 'h') {
                                ret.push([command, val0]);
                                i += 1;

                            // Vertical line to
                            } else if (command === 'V' || command === 'v') {
                                ret.push([command, val0]);
                                i += 1;

                            // Two numeric parameters
                            } else {
                                const val1 = path[i + 1];
                                if (typeof val1 === 'number') {
                                    // lineTo
                                    if (command === 'L' || command === 'l') {
                                        ret.push([command, val0, val1]);
                                        i += 2;

                                    // moveTo
                                    } else if (command === 'M' || command === 'm') {
                                        ret.push([command, val0, val1]);
                                        i += 2;

                                    // Smooth quadratic bezier
                                    } else if (command === 'T' || command === 't') {
                                        ret.push([command, val0, val1]);
                                        i += 2;

                                    // Four numeric parameters
                                    } else {
                                        const val2 = path[i + 2],
                                            val3 = path[i + 3];
                                        if (
                                            typeof val2 === 'number' &&
                                            typeof val3 === 'number'
                                        ) {
                                            // Quadratic bezier to
                                            if (
                                                command === 'Q' ||
                                                command === 'q'
                                            ) {
                                                ret.push([
                                                    command,
                                                    val0,
                                                    val1,
                                                    val2,
                                                    val3
                                                ]);
                                                i += 4;

                                            // Smooth cubic bezier to
                                            } else if (
                                                command === 'S' ||
                                                command === 's'
                                            ) {
                                                ret.push([
                                                    command,
                                                    val0,
                                                    val1,
                                                    val2,
                                                    val3
                                                ]);
                                                i += 4;

                                            // Six numeric parameters
                                            } else {
                                                const val4 = path[i + 4],
                                                    val5 = path[i + 5];

                                                if (
                                                    typeof val4 === 'number' &&
                                                    typeof val5 === 'number'
                                                ) {
                                                    // Curve to
                                                    if (
                                                        command === 'C' ||
                                                        command === 'c'
                                                    ) {
                                                        ret.push([
                                                            command,
                                                            val0,
                                                            val1,
                                                            val2,
                                                            val3,
                                                            val4,
                                                            val5
                                                        ]);
                                                        i += 6;

                                                    // Seven numeric parameters
                                                    } else {
                                                        const val6 = path[i + 6];

                                                        // Arc to
                                                        if (
                                                            typeof val6 ===
                                                            'number' &&
                                                            (
                                                                command === 'A' ||
                                                                command === 'a'
                                                            )
                                                        ) {
                                                            ret.push([
                                                                command,
                                                                val0,
                                                                val1,
                                                                val2,
                                                                val3,
                                                                val4,
                                                                val5,
                                                                val6
                                                            ]);
                                                            i += 7;

                                                        }

                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                            }
                        }
                    }
                }

                // An unmarked command following a moveTo is a lineTo
                lastCommand = command === 'M' ? 'L' : command;

                if (i === lastI) {
                    break;
                }
                lastI = i;
            }
            return ret;
            */
        }
        /**
         * Draw a label, which is an extended text element with support for border
         * and background. Highcharts creates a `g` element with a text and a `path`
         * or `rect` inside, to make it behave somewhat like a HTML div. Border and
         * background are set through `stroke`, `stroke-width` and `fill` attributes
         * using the {@link Highcharts.SVGElement#attr|attr} method. To update the
         * text after render, run `label.attr({ text: 'New text' })`.
         *
         * @sample highcharts/members/renderer-label-on-chart/
         *         A label on the chart
         *
         * @function Highcharts.SVGRenderer#label
         *
         * @param {string} str
         *        The initial text string or (subset) HTML to render.
         *
         * @param {number} x
         *        The x position of the label's left side.
         *
         * @param {number} [y]
         *        The y position of the label's top side or baseline, depending on
         *        the `baseline` parameter.
         *
         * @param {string} [shape='rect']
         *        The shape of the label's border/background, if any. Defaults to
         *        `rect`. Other possible values are `callout` or other shapes
         *        defined in {@link Highcharts.SVGRenderer#symbols}.
         *
         * @param {number} [anchorX]
         *        In case the `shape` has a pointer, like a flag, this is the
         *        coordinates it should be pinned to.
         *
         * @param {number} [anchorY]
         *        In case the `shape` has a pointer, like a flag, this is the
         *        coordinates it should be pinned to.
         *
         * @param {boolean} [useHTML=false]
         *        Whether to use HTML to render the label.
         *
         * @param {boolean} [baseline=false]
         *        Whether to position the label relative to the text baseline,
         *        like {@link Highcharts.SVGRenderer#text|renderer.text}, or to the
         *        upper border of the rectangle.
         *
         * @param {string} [className]
         *        Class name for the group.
         *
         * @return {Highcharts.SVGElement}
         *         The generated label.
         */
        label(str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
            return new SVGLabel(this, str, x, y, shape, anchorX, anchorY, useHTML, baseline, className);
        }
        /**
         * Re-align all aligned elements.
         *
         * @private
         * @function Highcharts.SVGRenderer#alignElements
         */
        alignElements() {
            this.alignedObjects.forEach((el) => el.align());
        }
    }
    extend$2(SVGRenderer.prototype, {
        /**
         * A pointer to the renderer's associated Element class.
         *
         * @name Highcharts.SVGRenderer#Element
         * @type {Highcharts.SVGElement}
         */
        Element: SVGElement,
        SVG_NS,
        /**
         * A collection of characters mapped to HTML entities. When `useHTML` on an
         * element is true, these entities will be rendered correctly by HTML. In
         * the SVG pseudo-HTML, they need to be unescaped back to simple characters,
         * so for example `&lt;` will render as `<`.
         *
         * @example
         * // Add support for unescaping quotes
         * Highcharts.SVGRenderer.prototype.escapes['"'] = '&quot;';
         *
         * @name Highcharts.SVGRenderer#escapes
         * @type {Highcharts.Dictionary<string>}
         */
        escapes: {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            "'": '&#39;',
            '"': '&quot;'
        },
        /**
         * An extendable collection of functions for defining symbol paths.
         *
         * @name Highcharts.SVGRenderer#symbols
         * @type {Highcharts.SymbolDictionary}
         */
        symbols: Symbols,
        /**
         * Dummy function for plugins, called every time the renderer is updated.
         * Prior to Highcharts 5, this was used for the canvg renderer.
         *
         * @deprecated
         * @function Highcharts.SVGRenderer#draw
         */
        draw: noop$1
    });
    /* *
     *
     *  Registry
     *
     * */
    RendererRegistry$1.registerRendererType('svg', SVGRenderer, true);

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { animate, animObject: animObject$1, setAnimation } = animationExports;
    const { defaultOptions, defaultTime } = DefaultOptions;
    const { numberFormat } = Templating;
    const { registerEventOptions } = Foundation$1;
    const { charts, doc, marginNames, svg, win } = H;
    const { seriesTypes } = SeriesRegistry$1;
    const { addEvent, attr, createElement, css, defined: defined$1, diffObjects, discardElement, erase, error, extend: extend$1, find, fireEvent: fireEvent$1, getStyle, isArray: isArray$1, isNumber: isNumber$1, isObject, isString, merge: merge$1, objectEach: objectEach$1, pick: pick$1, pInt, relativeLength: relativeLength$1, removeEvent, splat, syncTimeout, uniqueKey } = Utilities;
    /* *
     *
     *  Class
     *
     * */
    /* eslint-disable no-invalid-this, valid-jsdoc */
    /**
     * The Chart class. The recommended constructor is {@link Highcharts#chart}.
     *
     * @example
     * let chart = Highcharts.chart('container', {
     *        title: {
     *               text: 'My chart'
     *        },
     *        series: [{
     *            data: [1, 3, 2, 4]
     *        }]
     * })
     *
     * @class
     * @name Highcharts.Chart
     *
     * @param {string|Highcharts.HTMLDOMElement} [renderTo]
     *        The DOM element to render to, or its id.
     *
     * @param {Highcharts.Options} options
     *        The chart options structure.
     *
     * @param {Highcharts.ChartCallbackFunction} [callback]
     *        Function to run when the chart has loaded and and all external images
     *        are loaded. Defining a
     *        [chart.events.load](https://api.highcharts.com/highcharts/chart.events.load)
     *        handler is equivalent.
     */
    class Chart {
        /**
         * Factory function for basic charts.
         *
         * @example
         * // Render a chart in to div#container
         * let chart = Highcharts.chart('container', {
         *     title: {
         *         text: 'My chart'
         *     },
         *     series: [{
         *         data: [1, 3, 2, 4]
         *     }]
         * });
         *
         * @function Highcharts.chart
         *
         * @param {string|Highcharts.HTMLDOMElement} [renderTo]
         * The DOM element to render to, or its id.
         *
         * @param {Highcharts.Options} options
         * The chart options structure.
         *
         * @param {Highcharts.ChartCallbackFunction} [callback]
         * Function to run when the chart has loaded and and all external images are
         * loaded. Defining a
         * [chart.events.load](https://api.highcharts.com/highcharts/chart.events.load)
         * handler is equivalent.
         *
         * @return {Highcharts.Chart}
         * Returns the Chart object.
         */
        static chart(a, b, c) {
            return new Chart(a, b, c);
        }
        constructor(a, b, c) {
            this.axes = void 0;
            this.axisOffset = void 0;
            this.bounds = void 0;
            this.chartHeight = void 0;
            this.chartWidth = void 0;
            this.clipBox = void 0;
            this.colorCounter = void 0;
            this.container = void 0;
            this.eventOptions = void 0;
            this.index = void 0;
            this.isResizing = void 0;
            this.labelCollectors = void 0;
            this.margin = void 0;
            this.numberFormatter = void 0;
            this.options = void 0;
            this.plotBox = void 0;
            this.plotHeight = void 0;
            this.plotLeft = void 0;
            this.plotTop = void 0;
            this.plotWidth = void 0;
            this.pointCount = void 0;
            this.pointer = void 0;
            this.renderer = void 0;
            this.renderTo = void 0;
            this.series = void 0;
            this.sharedClips = {};
            this.spacing = void 0;
            this.spacingBox = void 0;
            this.symbolCounter = void 0;
            this.time = void 0;
            this.titleOffset = void 0;
            this.userOptions = void 0;
            this.xAxis = void 0;
            this.yAxis = void 0;
            this.zooming = void 0;
            this.getArgs(a, b, c);
        }
        /* *
         *
         *  Functions
         *
         * */
        /**
         * Handle the arguments passed to the constructor.
         *
         * @private
         * @function Highcharts.Chart#getArgs
         *
         * @param {...Array<*>} arguments
         * All arguments for the constructor.
         *
         * @emits Highcharts.Chart#event:init
         * @emits Highcharts.Chart#event:afterInit
         */
        getArgs(a, b, c) {
            // Remove the optional first argument, renderTo, and
            // set it on this.
            if (isString(a) || a.nodeName) {
                this.renderTo = a;
                this.init(b, c);
            }
            else {
                this.init(a, b);
            }
        }
        /**
         * Function setting zoom options after chart init and after chart update.
         * Offers support for deprecated options.
         *
         * @private
         * @function Highcharts.Chart#setZoomOptions
         */
        setZoomOptions() {
            const chart = this, options = chart.options.chart, zooming = options.zooming;
            chart.zooming = Object.assign(Object.assign({}, zooming), { type: pick$1(options.zoomType, zooming.type), key: pick$1(options.zoomKey, zooming.key), pinchType: pick$1(options.pinchType, zooming.pinchType), singleTouch: pick$1(options.zoomBySingleTouch, zooming.singleTouch, false), resetButton: merge$1(zooming.resetButton, options.resetZoomButton) });
        }
        /**
         * Overridable function that initializes the chart. The constructor's
         * arguments are passed on directly.
         *
         * @function Highcharts.Chart#init
         *
         * @param {Highcharts.Options} userOptions
         *        Custom options.
         *
         * @param {Function} [callback]
         *        Function to run when the chart has loaded and and all external
         *        images are loaded.
         *
         *
         * @emits Highcharts.Chart#event:init
         * @emits Highcharts.Chart#event:afterInit
         */
        init(userOptions, callback) {
            // Fire the event with a default function
            fireEvent$1(this, 'init', { args: arguments }, function () {
                const options = merge$1(defaultOptions, userOptions), // do the merge
                optionsChart = options.chart;
                /**
                 * The original options given to the constructor or a chart factory
                 * like {@link Highcharts.chart} and {@link Highcharts.stockChart}.
                 * The original options are shallow copied to avoid mutation. The
                 * copy, `chart.userOptions`, may later be mutated to reflect
                 * updated options throughout the lifetime of the chart.
                 *
                 * For collections, like `series`, `xAxis` and `yAxis`, the chart
                 * user options should always be reflected by the item user option,
                 * so for example the following should always be true:
                 *
                 * `chart.xAxis[0].userOptions === chart.userOptions.xAxis[0]`
                 *
                 * @name Highcharts.Chart#userOptions
                 * @type {Highcharts.Options}
                 */
                this.userOptions = extend$1({}, userOptions);
                this.margin = [];
                this.spacing = [];
                // Pixel data bounds for touch zoom
                this.bounds = { h: {}, v: {} };
                // An array of functions that returns labels that should be
                // considered for anti-collision
                this.labelCollectors = [];
                this.callback = callback;
                this.isResizing = 0;
                /**
                 * The options structure for the chart after merging
                 * {@link #defaultOptions} and {@link #userOptions}. It contains
                 * members for the sub elements like series, legend, tooltip etc.
                 *
                 * @name Highcharts.Chart#options
                 * @type {Highcharts.Options}
                 */
                this.options = options;
                /**
                 * All the axes in the chart.
                 *
                 * @see  Highcharts.Chart.xAxis
                 * @see  Highcharts.Chart.yAxis
                 *
                 * @name Highcharts.Chart#axes
                 * @type {Array<Highcharts.Axis>}
                 */
                this.axes = [];
                /**
                 * All the current series in the chart.
                 *
                 * @name Highcharts.Chart#series
                 * @type {Array<Highcharts.Series>}
                 */
                this.series = [];
                /**
                 * The `Time` object associated with the chart. Since v6.0.5,
                 * time settings can be applied individually for each chart. If
                 * no individual settings apply, the `Time` object is shared by
                 * all instances.
                 *
                 * @name Highcharts.Chart#time
                 * @type {Highcharts.Time}
                 */
                this.time =
                    userOptions.time && Object.keys(userOptions.time).length ?
                        new Time(userOptions.time) :
                        H.time;
                /**
                 * Callback function to override the default function that formats
                 * all the numbers in the chart. Returns a string with the formatted
                 * number.
                 *
                 * @name Highcharts.Chart#numberFormatter
                 * @type {Highcharts.NumberFormatterCallbackFunction}
                 */
                this.numberFormatter = optionsChart.numberFormatter || numberFormat;
                /**
                 * Whether the chart is in styled mode, meaning all presentational
                 * attributes are avoided.
                 *
                 * @name Highcharts.Chart#styledMode
                 * @type {boolean}
                 */
                this.styledMode = optionsChart.styledMode;
                this.hasCartesianSeries = optionsChart.showAxes;
                const chart = this;
                /**
                 * Index position of the chart in the {@link Highcharts#charts}
                 * property.
                 *
                 * @name Highcharts.Chart#index
                 * @type {number}
                 * @readonly
                 */
                chart.index = charts.length; // Add the chart to the global lookup
                charts.push(chart);
                H.chartCount++;
                // Chart event handlers
                registerEventOptions(this, optionsChart);
                /**
                 * A collection of the X axes in the chart.
                 *
                 * @name Highcharts.Chart#xAxis
                 * @type {Array<Highcharts.Axis>}
                 */
                chart.xAxis = [];
                /**
                 * A collection of the Y axes in the chart.
                 *
                 * @name Highcharts.Chart#yAxis
                 * @type {Array<Highcharts.Axis>}
                 *
                 * @todo
                 * Make events official: Fire the event `afterInit`.
                 */
                chart.yAxis = [];
                chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;
                this.setZoomOptions();
                // Fire after init but before first render, before axes and series
                // have been initialized.
                fireEvent$1(chart, 'afterInit');
                chart.firstRender();
            });
        }
        /**
         * Internal function to unitialize an individual series.
         *
         * @private
         * @function Highcharts.Chart#initSeries
         */
        initSeries(options) {
            const chart = this, optionsChart = chart.options.chart, type = (options.type ||
                optionsChart.type), SeriesClass = seriesTypes[type];
            // No such series type
            if (!SeriesClass) {
                error(17, true, chart, { missingModuleFor: type });
            }
            const series = new SeriesClass();
            if (typeof series.init === 'function') {
                series.init(chart, options);
            }
            return series;
        }
        /**
         * Internal function to set data for all series with enabled sorting.
         *
         * @private
         * @function Highcharts.Chart#setSeriesData
         */
        setSeriesData() {
            this.getSeriesOrderByLinks().forEach(function (series) {
                // We need to set data for series with sorting after series init
                if (!series.points && !series.data && series.enabledDataSorting) {
                    series.setData(series.options.data, false);
                }
            });
        }
        /**
         * Sort and return chart series in order depending on the number of linked
         * series.
         *
         * @private
         * @function Highcharts.Series#getSeriesOrderByLinks
         */
        getSeriesOrderByLinks() {
            return this.series.concat().sort(function (a, b) {
                if (a.linkedSeries.length || b.linkedSeries.length) {
                    return b.linkedSeries.length - a.linkedSeries.length;
                }
                return 0;
            });
        }
        /**
         * Order all series or axes above a given index. When series or axes are
         * added and ordered by configuration, only the last series is handled
         * (#248, #1123, #2456, #6112). This function is called on series and axis
         * initialization and destroy.
         *
         * @private
         * @function Highcharts.Chart#orderItems
         * @param {string} coll The collection name
         * @param {number} [fromIndex=0]
         * If this is given, only the series above this index are handled.
         */
        orderItems(coll, fromIndex = 0) {
            const collection = this[coll], 
            // Item options should be reflected in chart.options.series,
            // chart.options.yAxis etc
            optionsArray = this.options[coll] = splat(this.options[coll])
                .slice(), userOptionsArray = this.userOptions[coll] = this.userOptions[coll] ?
                splat(this.userOptions[coll]).slice() :
                [];
            if (this.hasRendered) {
                // Remove all above index
                optionsArray.splice(fromIndex);
                userOptionsArray.splice(fromIndex);
            }
            if (collection) {
                for (let i = fromIndex, iEnd = collection.length; i < iEnd; ++i) {
                    const item = collection[i];
                    if (item) {
                        /**
                         * Contains the series' index in the `Chart.series` array.
                         *
                         * @name Highcharts.Series#index
                         * @type {number}
                         * @readonly
                         */
                        item.index = i;
                        if (item instanceof Series) {
                            item.name = item.getName();
                        }
                        if (!item.options.isInternal) {
                            optionsArray[i] = item.options;
                            userOptionsArray[i] = item.userOptions;
                        }
                    }
                }
            }
        }
        /**
         * Check whether a given point is within the plot area.
         *
         * @function Highcharts.Chart#isInsidePlot
         *
         * @param {number} plotX
         * Pixel x relative to the plot area.
         *
         * @param {number} plotY
         * Pixel y relative to the plot area.
         *
         * @param {Highcharts.ChartIsInsideOptionsObject} [options]
         * Options object.
         *
         * @return {boolean}
         * Returns true if the given point is inside the plot area.
         */
        isInsidePlot(plotX, plotY, options = {}) {
            const { inverted, plotBox, plotLeft, plotTop, scrollablePlotBox } = this;
            let scrollLeft = 0, scrollTop = 0;
            if (options.visiblePlotOnly && this.scrollingContainer) {
                ({ scrollLeft, scrollTop } = this.scrollingContainer);
            }
            const series = options.series, box = (options.visiblePlotOnly && scrollablePlotBox) || plotBox, x = options.inverted ? plotY : plotX, y = options.inverted ? plotX : plotY, e = {
                x,
                y,
                isInsidePlot: true,
                options
            };
            if (!options.ignoreX) {
                const xAxis = (series &&
                    (inverted && !this.polar ? series.yAxis : series.xAxis)) || {
                    pos: plotLeft,
                    len: Infinity
                };
                const chartX = options.paneCoordinates ?
                    xAxis.pos + x : plotLeft + x;
                if (!(chartX >= Math.max(scrollLeft + plotLeft, xAxis.pos) &&
                    chartX <= Math.min(scrollLeft + plotLeft + box.width, xAxis.pos + xAxis.len))) {
                    e.isInsidePlot = false;
                }
            }
            if (!options.ignoreY && e.isInsidePlot) {
                const yAxis = (!inverted && options.axis &&
                    !options.axis.isXAxis && options.axis) || (series && (inverted ? series.xAxis : series.yAxis)) || {
                    pos: plotTop,
                    len: Infinity
                };
                const chartY = options.paneCoordinates ?
                    yAxis.pos + y : plotTop + y;
                if (!(chartY >= Math.max(scrollTop + plotTop, yAxis.pos) &&
                    chartY <= Math.min(scrollTop + plotTop + box.height, yAxis.pos + yAxis.len))) {
                    e.isInsidePlot = false;
                }
            }
            fireEvent$1(this, 'afterIsInsidePlot', e);
            return e.isInsidePlot;
        }
        /**
         * Redraw the chart after changes have been done to the data, axis extremes
         * chart size or chart elements. All methods for updating axes, series or
         * points have a parameter for redrawing the chart. This is `true` by
         * default. But in many cases you want to do more than one operation on the
         * chart before redrawing, for example add a number of points. In those
         * cases it is a waste of resources to redraw the chart for each new point
         * added. So you add the points and call `chart.redraw()` after.
         *
         * @function Highcharts.Chart#redraw
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
         * If or how to apply animation to the redraw. When `undefined`, it applies
         * the animation that is set in the `chart.animation` option.
         *
         * @emits Highcharts.Chart#event:afterSetExtremes
         * @emits Highcharts.Chart#event:beforeRedraw
         * @emits Highcharts.Chart#event:predraw
         * @emits Highcharts.Chart#event:redraw
         * @emits Highcharts.Chart#event:render
         * @emits Highcharts.Chart#event:updatedData
         */
        redraw(animation) {
            fireEvent$1(this, 'beforeRedraw');
            const chart = this, axes = chart.hasCartesianSeries ? chart.axes : chart.colorAxis || [], series = chart.series, pointer = chart.pointer, legend = chart.legend, legendUserOptions = chart.userOptions.legend, renderer = chart.renderer, isHiddenChart = renderer.isHidden(), afterRedraw = [];
            let hasDirtyStacks, hasStackedSeries, i, isDirtyBox = chart.isDirtyBox, redrawLegend = chart.isDirtyLegend, serie;
            renderer.rootFontSize = renderer.boxWrapper.getStyle('font-size');
            // Handle responsive rules, not only on resize (#6130)
            if (chart.setResponsive) {
                chart.setResponsive(false);
            }
            // Set the global animation. When chart.hasRendered is not true, the
            // redraw call comes from a responsive rule and animation should not
            // occur.
            setAnimation(chart.hasRendered ? animation : false, chart);
            if (isHiddenChart) {
                chart.temporaryDisplay();
            }
            // Adjust title layout (reflow multiline text)
            chart.layOutTitles(false);
            // link stacked series
            i = series.length;
            while (i--) {
                serie = series[i];
                if (serie.options.stacking || serie.options.centerInCategory) {
                    hasStackedSeries = true;
                    if (serie.isDirty) {
                        hasDirtyStacks = true;
                        break;
                    }
                }
            }
            if (hasDirtyStacks) { // mark others as dirty
                i = series.length;
                while (i--) {
                    serie = series[i];
                    if (serie.options.stacking) {
                        serie.isDirty = true;
                    }
                }
            }
            // Handle updated data in the series
            series.forEach(function (serie) {
                if (serie.isDirty) {
                    if (serie.options.legendType === 'point') {
                        if (typeof serie.updateTotals === 'function') {
                            serie.updateTotals();
                        }
                        redrawLegend = true;
                    }
                    else if (legendUserOptions &&
                        (legendUserOptions.labelFormatter ||
                            legendUserOptions.labelFormat)) {
                        redrawLegend = true; // #2165
                    }
                }
                if (serie.isDirtyData) {
                    fireEvent$1(serie, 'updatedData');
                }
            });
            // handle added or removed series
            if (redrawLegend && legend && legend.options.enabled) {
                // draw legend graphics
                legend.render();
                chart.isDirtyLegend = false;
            }
            // reset stacks
            if (hasStackedSeries) {
                chart.getStacks();
            }
            // set axes scales
            axes.forEach(function (axis) {
                axis.updateNames();
                axis.setScale();
            });
            chart.getMargins(); // #3098
            // If one axis is dirty, all axes must be redrawn (#792, #2169)
            axes.forEach(function (axis) {
                if (axis.isDirty) {
                    isDirtyBox = true;
                }
            });
            // redraw axes
            axes.forEach(function (axis) {
                // Fire 'afterSetExtremes' only if extremes are set
                const key = axis.min + ',' + axis.max;
                if (axis.extKey !== key) { // #821, #4452
                    axis.extKey = key;
                    // prevent a recursive call to chart.redraw() (#1119)
                    afterRedraw.push(function () {
                        fireEvent$1(axis, 'afterSetExtremes', extend$1(axis.eventArgs, axis.getExtremes())); // #747, #751
                        delete axis.eventArgs;
                    });
                }
                if (isDirtyBox || hasStackedSeries) {
                    axis.redraw();
                }
            });
            // the plot areas size has changed
            if (isDirtyBox) {
                chart.drawChartBox();
            }
            // Fire an event before redrawing series, used by the boost module to
            // clear previous series renderings.
            fireEvent$1(chart, 'predraw');
            // redraw affected series
            series.forEach(function (serie) {
                if ((isDirtyBox || serie.isDirty) && serie.visible) {
                    serie.redraw();
                }
                // Set it here, otherwise we will have unlimited 'updatedData' calls
                // for a hidden series after setData(). Fixes #6012
                serie.isDirtyData = false;
            });
            // move tooltip or reset
            if (pointer) {
                pointer.reset(true);
            }
            // redraw if canvas
            renderer.draw();
            // Fire the events
            fireEvent$1(chart, 'redraw');
            fireEvent$1(chart, 'render');
            if (isHiddenChart) {
                chart.temporaryDisplay(true);
            }
            // Fire callbacks that are put on hold until after the redraw
            afterRedraw.forEach(function (callback) {
                callback.call();
            });
        }
        /**
         * Get an axis, series or point object by `id` as given in the configuration
         * options. Returns `undefined` if no item is found.
         *
         * @sample highcharts/plotoptions/series-id/
         *         Get series by id
         *
         * @function Highcharts.Chart#get
         *
         * @param {string} id
         * The id as given in the configuration options.
         *
         * @return {Highcharts.Axis|Highcharts.Series|Highcharts.Point|undefined}
         * The retrieved item.
         */
        get(id) {
            const series = this.series;
            /**
             * @private
             */
            function itemById(item) {
                return (item.id === id ||
                    (item.options && item.options.id === id));
            }
            let ret = 
            // Search axes
            find(this.axes, itemById) ||
                // Search series
                find(this.series, itemById);
            // Search points
            for (let i = 0; !ret && i < series.length; i++) {
                ret = find(series[i].points || [], itemById);
            }
            return ret;
        }
        /**
         * Create the Axis instances based on the config options.
         *
         * @private
         * @function Highcharts.Chart#getAxes
         * @emits Highcharts.Chart#event:afterGetAxes
         * @emits Highcharts.Chart#event:getAxes
         */
        getAxes() {
            const options = this.options;
            fireEvent$1(this, 'getAxes');
            for (const coll of ['xAxis', 'yAxis']) {
                const arr = options[coll] = splat(options[coll] || {});
                for (const axisOptions of arr) {
                    // eslint-disable-next-line no-new
                    new Axis(this, axisOptions, coll);
                }
            }
            fireEvent$1(this, 'afterGetAxes');
        }
        /**
         * Returns an array of all currently selected points in the chart. Points
         * can be selected by clicking or programmatically by the
         * {@link Highcharts.Point#select}
         * function.
         *
         * @sample highcharts/plotoptions/series-allowpointselect-line/
         *         Get selected points
         *
         * @function Highcharts.Chart#getSelectedPoints
         *
         * @return {Array<Highcharts.Point>}
         *         The currently selected points.
         */
        getSelectedPoints() {
            return this.series.reduce((acc, series) => {
                // For one-to-one points inspect series.data in order to retrieve
                // points outside the visible range (#6445). For grouped data,
                // inspect the generated series.points.
                series.getPointsCollection()
                    .forEach((point) => {
                    if (pick$1(point.selectedStaging, point.selected)) {
                        acc.push(point);
                    }
                });
                return acc;
            }, []);
        }
        /**
         * Returns an array of all currently selected series in the chart. Series
         * can be selected either programmatically by the
         * {@link Highcharts.Series#select}
         * function or by checking the checkbox next to the legend item if
         * [series.showCheckBox](https://api.highcharts.com/highcharts/plotOptions.series.showCheckbox)
         * is true.
         *
         * @sample highcharts/members/chart-getselectedseries/
         *         Get selected series
         *
         * @function Highcharts.Chart#getSelectedSeries
         *
         * @return {Array<Highcharts.Series>}
         *         The currently selected series.
         */
        getSelectedSeries() {
            return this.series.filter(function (serie) {
                return serie.selected;
            });
        }
        /**
         * Set a new title or subtitle for the chart.
         *
         * @sample highcharts/members/chart-settitle/
         *         Set title text and styles
         *
         * @function Highcharts.Chart#setTitle
         *
         * @param {Highcharts.TitleOptions} [titleOptions]
         *        New title options. The title text itself is set by the
         *        `titleOptions.text` property.
         *
         * @param {Highcharts.SubtitleOptions} [subtitleOptions]
         *        New subtitle options. The subtitle text itself is set by the
         *        `subtitleOptions.text` property.
         *
         * @param {boolean} [redraw]
         *        Whether to redraw the chart or wait for a later call to
         *        `chart.redraw()`.
         */
        setTitle(titleOptions, subtitleOptions, redraw) {
            this.applyDescription('title', titleOptions);
            this.applyDescription('subtitle', subtitleOptions);
            // The initial call also adds the caption. On update, chart.update will
            // relay to Chart.setCaption.
            this.applyDescription('caption', void 0);
            this.layOutTitles(redraw);
        }
        /**
         * Apply a title, subtitle or caption for the chart
         *
         * @private
         * @function Highcharts.Chart#applyDescription
         * @param name {string}
         * Either title, subtitle or caption
         * @param {Highcharts.TitleOptions|Highcharts.SubtitleOptions|Highcharts.CaptionOptions|undefined} explicitOptions
         * The options to set, will be merged with default options.
         */
        applyDescription(name, explicitOptions) {
            const chart = this;
            // Merge default options with explicit options
            const options = this.options[name] = merge$1(this.options[name], explicitOptions);
            let elem = this[name];
            if (elem && explicitOptions) {
                this[name] = elem = elem.destroy(); // remove old
            }
            if (options && !elem) {
                elem = this.renderer.text(options.text, 0, 0, options.useHTML)
                    .attr({
                    align: options.align,
                    'class': 'highcharts-' + name,
                    zIndex: options.zIndex || 4
                })
                    .add();
                // Update methods, relay to `applyDescription`
                elem.update = function (updateOptions, redraw) {
                    chart.applyDescription(name, updateOptions);
                    chart.layOutTitles(redraw);
                };
                // Presentational
                if (!this.styledMode) {
                    elem.css(extend$1(name === 'title' ? {
                        // #2944
                        fontSize: this.options.isStock ? '1em' : '1.2em'
                    } : {}, options.style));
                }
                /**
                 * The chart title. The title has an `update` method that allows
                 * modifying the options directly or indirectly via
                 * `chart.update`.
                 *
                 * @sample highcharts/members/title-update/
                 *         Updating titles
                 *
                 * @name Highcharts.Chart#title
                 * @type {Highcharts.TitleObject}
                 */
                /**
                 * The chart subtitle. The subtitle has an `update` method that
                 * allows modifying the options directly or indirectly via
                 * `chart.update`.
                 *
                 * @name Highcharts.Chart#subtitle
                 * @type {Highcharts.SubtitleObject}
                 */
                this[name] = elem;
            }
        }
        /**
         * Internal function to lay out the chart title, subtitle and caption, and
         * cache the full offset height for use in `getMargins`. The result is
         * stored in `this.titleOffset`.
         *
         * @private
         * @function Highcharts.Chart#layOutTitles
         *
         * @param {boolean} [redraw=true]
         * @emits Highcharts.Chart#event:afterLayOutTitles
         */
        layOutTitles(redraw = true) {
            const titleOffset = [0, 0, 0], renderer = this.renderer, spacingBox = this.spacingBox;
            // Lay out the title and the subtitle respectively
            ['title', 'subtitle', 'caption'].forEach(function (key) {
                const title = this[key], titleOptions = (this.options[key]), verticalAlign = titleOptions.verticalAlign || 'top', offset = key === 'title' ?
                    verticalAlign === 'top' ? -3 : 0 :
                    // Floating subtitle (#6574)
                    verticalAlign === 'top' ? titleOffset[0] + 2 : 0;
                if (title) {
                    title
                        .css({
                        width: (titleOptions.width ||
                            spacingBox.width + (titleOptions.widthAdjust || 0)) + 'px'
                    });
                    const baseline = renderer.fontMetrics(title).b, 
                    // Skip the cache for HTML (#3481, #11666)
                    height = Math.round(title.getBBox(titleOptions.useHTML).height);
                    title.align(extend$1({
                        y: verticalAlign === 'bottom' ?
                            baseline :
                            offset + baseline,
                        height
                    }, titleOptions), false, 'spacingBox');
                    if (!titleOptions.floating) {
                        if (verticalAlign === 'top') {
                            titleOffset[0] = Math.ceil(titleOffset[0] +
                                height);
                        }
                        else if (verticalAlign === 'bottom') {
                            titleOffset[2] = Math.ceil(titleOffset[2] +
                                height);
                        }
                    }
                }
            }, this);
            // Handle title.margin and caption.margin
            if (titleOffset[0] &&
                (this.options.title.verticalAlign || 'top') === 'top') {
                titleOffset[0] += this.options.title.margin;
            }
            if (titleOffset[2] &&
                this.options.caption.verticalAlign === 'bottom') {
                titleOffset[2] += this.options.caption.margin;
            }
            const requiresDirtyBox = (!this.titleOffset ||
                this.titleOffset.join(',') !== titleOffset.join(','));
            // Used in getMargins
            this.titleOffset = titleOffset;
            fireEvent$1(this, 'afterLayOutTitles');
            if (!this.isDirtyBox && requiresDirtyBox) {
                this.isDirtyBox = this.isDirtyLegend = requiresDirtyBox;
                // Redraw if necessary (#2719, #2744)
                if (this.hasRendered && redraw && this.isDirtyBox) {
                    this.redraw();
                }
            }
        }
        /**
         * Internal function to get the available size of the container element
         *
         * @private
         * @function Highcharts.Chart#getContainerBox
         */
        getContainerBox() {
            return {
                width: getStyle(this.renderTo, 'width', true) || 0,
                height: getStyle(this.renderTo, 'height', true) || 0
            };
        }
        /**
         * Internal function to get the chart width and height according to options
         * and container size. Sets {@link Chart.chartWidth} and
         * {@link Chart.chartHeight}.
         *
         * @private
         * @function Highcharts.Chart#getChartSize
         */
        getChartSize() {
            const chart = this, optionsChart = chart.options.chart, widthOption = optionsChart.width, heightOption = optionsChart.height, containerBox = chart.getContainerBox();
            /**
             * The current pixel width of the chart.
             *
             * @name Highcharts.Chart#chartWidth
             * @type {number}
             */
            chart.chartWidth = Math.max(// #1393
            0, widthOption || containerBox.width || 600 // #1460
            );
            /**
             * The current pixel height of the chart.
             *
             * @name Highcharts.Chart#chartHeight
             * @type {number}
             */
            chart.chartHeight = Math.max(0, relativeLength$1(heightOption, chart.chartWidth) ||
                (containerBox.height > 1 ? containerBox.height : 400));
            chart.containerBox = containerBox;
        }
        /**
         * If the renderTo element has no offsetWidth, most likely one or more of
         * its parents are hidden. Loop up the DOM tree to temporarily display the
         * parents, then save the original display properties, and when the true
         * size is retrieved, reset them. Used on first render and on redraws.
         *
         * @private
         * @function Highcharts.Chart#temporaryDisplay
         *
         * @param {boolean} [revert]
         * Revert to the saved original styles.
         */
        temporaryDisplay(revert) {
            let node = this.renderTo, tempStyle;
            if (!revert) {
                while (node && node.style) {
                    // When rendering to a detached node, it needs to be temporarily
                    // attached in order to read styling and bounding boxes (#5783,
                    // #7024).
                    if (!doc.body.contains(node) && !node.parentNode) {
                        node.hcOrigDetached = true;
                        doc.body.appendChild(node);
                    }
                    if (getStyle(node, 'display', false) === 'none' ||
                        node.hcOricDetached) {
                        node.hcOrigStyle = {
                            display: node.style.display,
                            height: node.style.height,
                            overflow: node.style.overflow
                        };
                        tempStyle = {
                            display: 'block',
                            overflow: 'hidden'
                        };
                        if (node !== this.renderTo) {
                            tempStyle.height = 0;
                        }
                        css(node, tempStyle);
                        // If it still doesn't have an offset width after setting
                        // display to block, it probably has an !important priority
                        // #2631, 6803
                        if (!node.offsetWidth) {
                            node.style.setProperty('display', 'block', 'important');
                        }
                    }
                    node = node.parentNode;
                    if (node === doc.body) {
                        break;
                    }
                }
            }
            else {
                while (node && node.style) {
                    if (node.hcOrigStyle) {
                        css(node, node.hcOrigStyle);
                        delete node.hcOrigStyle;
                    }
                    if (node.hcOrigDetached) {
                        doc.body.removeChild(node);
                        node.hcOrigDetached = false;
                    }
                    node = node.parentNode;
                }
            }
        }
        /**
         * Set the {@link Chart.container|chart container's} class name, in
         * addition to `highcharts-container`.
         *
         * @function Highcharts.Chart#setClassName
         *
         * @param {string} [className]
         * The additional class name.
         */
        setClassName(className) {
            this.container.className = 'highcharts-container ' + (className || '');
        }
        /**
         * Get the containing element, determine the size and create the inner
         * container div to hold the chart.
         *
         * @private
         * @function Highcharts.Chart#afterGetContainer
         * @emits Highcharts.Chart#event:afterGetContainer
         */
        getContainer() {
            const chart = this, options = chart.options, optionsChart = options.chart, indexAttrName = 'data-highcharts-chart', containerId = uniqueKey();
            let containerStyle, renderTo = chart.renderTo;
            if (!renderTo) {
                chart.renderTo = renderTo =
                    optionsChart.renderTo;
            }
            if (isString(renderTo)) {
                chart.renderTo = renderTo =
                    doc.getElementById(renderTo);
            }
            // Display an error if the renderTo is wrong
            if (!renderTo) {
                error(13, true, chart);
            }
            // If the container already holds a chart, destroy it. The check for
            // hasRendered is there because web pages that are saved to disk from
            // the browser, will preserve the data-highcharts-chart attribute and
            // the SVG contents, but not an interactive chart. So in this case,
            // charts[oldChartIndex] will point to the wrong chart if any (#2609).
            const oldChartIndex = pInt(attr(renderTo, indexAttrName));
            if (isNumber$1(oldChartIndex) &&
                charts[oldChartIndex] &&
                charts[oldChartIndex].hasRendered) {
                charts[oldChartIndex].destroy();
            }
            // Make a reference to the chart from the div
            attr(renderTo, indexAttrName, chart.index);
            // remove previous chart
            renderTo.innerHTML = AST.emptyHTML;
            // If the container doesn't have an offsetWidth, it has or is a child of
            // a node that has display:none. We need to temporarily move it out to a
            // visible state to determine the size, else the legend and tooltips
            // won't render properly. The skipClone option is used in sparklines as
            // a micro optimization, saving about 1-2 ms each chart.
            if (!optionsChart.skipClone && !renderTo.offsetWidth) {
                chart.temporaryDisplay();
            }
            // get the width and height
            chart.getChartSize();
            const chartWidth = chart.chartWidth;
            const chartHeight = chart.chartHeight;
            // Allow table cells and flex-boxes to shrink without the chart blocking
            // them out (#6427)
            css(renderTo, { overflow: 'hidden' });
            // Create the inner container
            if (!chart.styledMode) {
                containerStyle = extend$1({
                    position: 'relative',
                    // needed for context menu (avoidscrollbars) and content
                    // overflow in IE
                    overflow: 'hidden',
                    width: chartWidth + 'px',
                    height: chartHeight + 'px',
                    textAlign: 'left',
                    lineHeight: 'normal',
                    zIndex: 0,
                    '-webkit-tap-highlight-color': 'rgba(0,0,0,0)',
                    userSelect: 'none',
                    'touch-action': 'manipulation',
                    outline: 'none'
                }, optionsChart.style || {});
            }
            /**
             * The containing HTML element of the chart. The container is
             * dynamically inserted into the element given as the `renderTo`
             * parameter in the {@link Highcharts#chart} constructor.
             *
             * @name Highcharts.Chart#container
             * @type {Highcharts.HTMLDOMElement}
             */
            const container = createElement('div', {
                id: containerId
            }, containerStyle, renderTo);
            chart.container = container;
            // cache the cursor (#1650)
            chart._cursor = container.style.cursor;
            // Initialize the renderer
            const Renderer = optionsChart.renderer || !svg ?
                RendererRegistry$1.getRendererType(optionsChart.renderer) :
                SVGRenderer;
            /**
             * The renderer instance of the chart. Each chart instance has only one
             * associated renderer.
             *
             * @name Highcharts.Chart#renderer
             * @type {Highcharts.SVGRenderer}
             */
            chart.renderer = new Renderer(container, chartWidth, chartHeight, void 0, optionsChart.forExport, options.exporting && options.exporting.allowHTML, chart.styledMode);
            chart.containerBox = chart.getContainerBox();
            // Set the initial animation from the options
            setAnimation(void 0, chart);
            chart.setClassName(optionsChart.className);
            if (!chart.styledMode) {
                chart.renderer.setStyle(optionsChart.style);
            }
            else {
                // Initialize definitions
                for (const key in options.defs) { // eslint-disable-line guard-for-in
                    this.renderer.definition(options.defs[key]);
                }
            }
            // Add a reference to the charts index
            chart.renderer.chartIndex = chart.index;
            fireEvent$1(this, 'afterGetContainer');
        }
        /**
         * Calculate margins by rendering axis labels in a preliminary position.
         * Title, subtitle and legend have already been rendered at this stage, but
         * will be moved into their final positions.
         *
         * @private
         * @function Highcharts.Chart#getMargins
         * @emits Highcharts.Chart#event:getMargins
         */
        getMargins(skipAxes) {
            const { spacing, margin, titleOffset } = this;
            this.resetMargins();
            // Adjust for title and subtitle
            if (titleOffset[0] && !defined$1(margin[0])) {
                this.plotTop = Math.max(this.plotTop, titleOffset[0] + spacing[0]);
            }
            if (titleOffset[2] && !defined$1(margin[2])) {
                this.marginBottom = Math.max(this.marginBottom, titleOffset[2] + spacing[2]);
            }
            // Adjust for legend
            if (this.legend && this.legend.display) {
                this.legend.adjustMargins(margin, spacing);
            }
            fireEvent$1(this, 'getMargins');
            if (!skipAxes) {
                this.getAxisMargins();
            }
        }
        /**
         * @private
         * @function Highcharts.Chart#getAxisMargins
         */
        getAxisMargins() {
            const chart = this, 
            // [top, right, bottom, left]
            axisOffset = chart.axisOffset = [0, 0, 0, 0], colorAxis = chart.colorAxis, margin = chart.margin, getOffset = function (axes) {
                axes.forEach(function (axis) {
                    if (axis.visible) {
                        axis.getOffset();
                    }
                });
            };
            // pre-render axes to get labels offset width
            if (chart.hasCartesianSeries) {
                getOffset(chart.axes);
            }
            else if (colorAxis && colorAxis.length) {
                getOffset(colorAxis);
            }
            // Add the axis offsets
            marginNames.forEach(function (m, side) {
                if (!defined$1(margin[side])) {
                    chart[m] += axisOffset[side];
                }
            });
            chart.setChartSize();
        }
        /**
         * Return the current options of the chart, but only those that differ from
         * default options. Items that can be either an object or an array of
         * objects, like `series`, `xAxis` and `yAxis`, are always returned as
         * array.
         *
         * @sample highcharts/members/chart-getoptions
         *
         * @function Highcharts.Chart#getOptions
         *
         * @since 11.1.0
         */
        getOptions() {
            return diffObjects(this.userOptions, defaultOptions);
        }
        /**
         * Reflows the chart to its container. By default, the Resize Observer is
         * attached to the chart's div which allows to reflows the chart
         * automatically to its container, as per the
         * [chart.reflow](https://api.highcharts.com/highcharts/chart.reflow)
         * option.
         *
         * @sample highcharts/chart/events-container/
         *         Pop up and reflow
         *
         * @function Highcharts.Chart#reflow
         *
         * @param {global.Event} [e]
         *        Event arguments. Used primarily when the function is called
         *        internally as a response to window resize.
         */
        reflow(e) {
            const chart = this, optionsChart = chart.options.chart, hasUserSize = (defined$1(optionsChart.width) &&
                defined$1(optionsChart.height)), oldBox = chart.containerBox, containerBox = chart.getContainerBox();
            delete chart.pointer.chartPosition;
            // Width and height checks for display:none. Target is doc in Opera
            // and win in Firefox, Chrome and IE9.
            if (!hasUserSize &&
                !chart.isPrinting &&
                oldBox &&
                // When fired by resize observer inside hidden container
                containerBox.width) {
                if (containerBox.width !== oldBox.width ||
                    containerBox.height !== oldBox.height) {
                    Utilities.clearTimeout(chart.reflowTimeout);
                    // When called from window.resize, e is set, else it's called
                    // directly (#2224)
                    chart.reflowTimeout = syncTimeout(function () {
                        // Set size, it may have been destroyed in the meantime
                        // (#1257)
                        if (chart.container) {
                            chart.setSize(void 0, void 0, false);
                        }
                    }, e ? 100 : 0);
                }
                chart.containerBox = containerBox;
            }
        }
        /**
         * Toggle the event handlers necessary for auto resizing, depending on the
         * `chart.reflow` option.
         *
         * @private
         * @function Highcharts.Chart#setReflow
         */
        setReflow() {
            const chart = this;
            const runReflow = (e) => {
                var _a;
                if (((_a = chart.options) === null || _a === void 0 ? void 0 : _a.chart.reflow) && chart.hasLoaded) {
                    chart.reflow(e);
                }
            };
            if (typeof ResizeObserver === 'function') {
                (new ResizeObserver(runReflow)).observe(chart.renderTo);
                // Fallback for more legacy browser versions.
            }
            else {
                const unbind = addEvent(win, 'resize', runReflow);
                addEvent(this, 'destroy', unbind);
            }
        }
        /**
         * Resize the chart to a given width and height. In order to set the width
         * only, the height argument may be skipped. To set the height only, pass
         * `undefined` for the width.
         *
         * @sample highcharts/members/chart-setsize-button/
         *         Test resizing from buttons
         * @sample highcharts/members/chart-setsize-jquery-resizable/
         *         Add a jQuery UI resizable
         * @sample stock/members/chart-setsize/
         *         Highcharts Stock with UI resizable
         *
         * @function Highcharts.Chart#setSize
         *
         * @param {number|null} [width]
         *        The new pixel width of the chart. Since v4.2.6, the argument can
         *        be `undefined` in order to preserve the current value (when
         *        setting height only), or `null` to adapt to the width of the
         *        containing element.
         *
         * @param {number|null} [height]
         *        The new pixel height of the chart. Since v4.2.6, the argument can
         *        be `undefined` in order to preserve the current value, or `null`
         *        in order to adapt to the height of the containing element.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
         *        Whether and how to apply animation. When `undefined`, it applies
         *        the animation that is set in the `chart.animation` option.
         *
         *
         * @emits Highcharts.Chart#event:endResize
         * @emits Highcharts.Chart#event:resize
         */
        setSize(width, height, animation) {
            const chart = this, renderer = chart.renderer;
            // Handle the isResizing counter
            chart.isResizing += 1;
            // set the animation for the current process
            setAnimation(animation, chart);
            const globalAnimation = renderer.globalAnimation;
            chart.oldChartHeight = chart.chartHeight;
            chart.oldChartWidth = chart.chartWidth;
            if (typeof width !== 'undefined') {
                chart.options.chart.width = width;
            }
            if (typeof height !== 'undefined') {
                chart.options.chart.height = height;
            }
            chart.getChartSize();
            // Resize the container with the global animation applied if enabled
            // (#2503)
            if (!chart.styledMode) {
                (globalAnimation ? animate : css)(chart.container, {
                    width: chart.chartWidth + 'px',
                    height: chart.chartHeight + 'px'
                }, globalAnimation);
            }
            chart.setChartSize(true);
            renderer.setSize(chart.chartWidth, chart.chartHeight, globalAnimation);
            // handle axes
            chart.axes.forEach(function (axis) {
                axis.isDirty = true;
                axis.setScale();
            });
            chart.isDirtyLegend = true; // force legend redraw
            chart.isDirtyBox = true; // force redraw of plot and chart border
            chart.layOutTitles(); // #2857
            chart.getMargins();
            chart.redraw(globalAnimation);
            chart.oldChartHeight = null;
            fireEvent$1(chart, 'resize');
            // Fire endResize and set isResizing back. If animation is disabled,
            // fire without delay
            syncTimeout(function () {
                if (chart) {
                    fireEvent$1(chart, 'endResize', null, function () {
                        chart.isResizing -= 1;
                    });
                }
            }, animObject$1(globalAnimation).duration);
        }
        /**
         * Set the public chart properties. This is done before and after the
         * pre-render to determine margin sizes.
         *
         * @private
         * @function Highcharts.Chart#setChartSize
         * @emits Highcharts.Chart#event:afterSetChartSize
         */
        setChartSize(skipAxes) {
            const chart = this, inverted = chart.inverted, renderer = chart.renderer, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, optionsChart = chart.options.chart, spacing = chart.spacing, clipOffset = chart.clipOffset;
            let plotLeft, plotTop, plotWidth, plotHeight;
            /**
             * The current left position of the plot area in pixels.
             *
             * @name Highcharts.Chart#plotLeft
             * @type {number}
             */
            chart.plotLeft = plotLeft = Math.round(chart.plotLeft);
            /**
             * The current top position of the plot area in pixels.
             *
             * @name Highcharts.Chart#plotTop
             * @type {number}
             */
            chart.plotTop = plotTop = Math.round(chart.plotTop);
            /**
             * The current width of the plot area in pixels.
             *
             * @name Highcharts.Chart#plotWidth
             * @type {number}
             */
            chart.plotWidth = plotWidth = Math.max(0, Math.round(chartWidth - plotLeft - chart.marginRight));
            /**
             * The current height of the plot area in pixels.
             *
             * @name Highcharts.Chart#plotHeight
             * @type {number}
             */
            chart.plotHeight = plotHeight = Math.max(0, Math.round(chartHeight - plotTop - chart.marginBottom));
            chart.plotSizeX = inverted ? plotHeight : plotWidth;
            chart.plotSizeY = inverted ? plotWidth : plotHeight;
            chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;
            // Set boxes used for alignment
            chart.spacingBox = renderer.spacingBox = {
                x: spacing[3],
                y: spacing[0],
                width: chartWidth - spacing[3] - spacing[1],
                height: chartHeight - spacing[0] - spacing[2]
            };
            chart.plotBox = renderer.plotBox = {
                x: plotLeft,
                y: plotTop,
                width: plotWidth,
                height: plotHeight
            };
            const plotBorderWidth = 2 * Math.floor(chart.plotBorderWidth / 2), clipX = Math.ceil(Math.max(plotBorderWidth, clipOffset[3]) / 2), clipY = Math.ceil(Math.max(plotBorderWidth, clipOffset[0]) / 2);
            chart.clipBox = {
                x: clipX,
                y: clipY,
                width: Math.floor(chart.plotSizeX -
                    Math.max(plotBorderWidth, clipOffset[1]) / 2 -
                    clipX),
                height: Math.max(0, Math.floor(chart.plotSizeY -
                    Math.max(plotBorderWidth, clipOffset[2]) / 2 -
                    clipY))
            };
            if (!skipAxes) {
                chart.axes.forEach(function (axis) {
                    axis.setAxisSize();
                    axis.setAxisTranslation();
                });
                renderer.alignElements();
            }
            fireEvent$1(chart, 'afterSetChartSize', { skipAxes: skipAxes });
        }
        /**
         * Initial margins before auto size margins are applied.
         *
         * @private
         * @function Highcharts.Chart#resetMargins
         */
        resetMargins() {
            fireEvent$1(this, 'resetMargins');
            const chart = this, chartOptions = chart.options.chart;
            // Create margin and spacing array
            ['margin', 'spacing'].forEach(function splashArrays(target) {
                const value = chartOptions[target], values = isObject(value) ? value : [value, value, value, value];
                [
                    'Top',
                    'Right',
                    'Bottom',
                    'Left'
                ].forEach(function (sideName, side) {
                    chart[target][side] = pick$1(chartOptions[target + sideName], values[side]);
                });
            });
            // Set margin names like chart.plotTop, chart.plotLeft,
            // chart.marginRight, chart.marginBottom.
            marginNames.forEach(function (m, side) {
                chart[m] = pick$1(chart.margin[side], chart.spacing[side]);
            });
            chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
            chart.clipOffset = [0, 0, 0, 0];
        }
        /**
         * Internal function to draw or redraw the borders and backgrounds for chart
         * and plot area.
         *
         * @private
         * @function Highcharts.Chart#drawChartBox
         * @emits Highcharts.Chart#event:afterDrawChartBox
         */
        drawChartBox() {
            const chart = this, optionsChart = chart.options.chart, renderer = chart.renderer, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, styledMode = chart.styledMode, plotBGImage = chart.plotBGImage, chartBackgroundColor = optionsChart.backgroundColor, plotBackgroundColor = optionsChart.plotBackgroundColor, plotBackgroundImage = optionsChart.plotBackgroundImage, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, plotBox = chart.plotBox, clipRect = chart.clipRect, clipBox = chart.clipBox;
            let chartBackground = chart.chartBackground, plotBackground = chart.plotBackground, plotBorder = chart.plotBorder, chartBorderWidth, mgn, bgAttr, verb = 'animate';
            // Chart area
            if (!chartBackground) {
                chart.chartBackground = chartBackground = renderer.rect()
                    .addClass('highcharts-background')
                    .add();
                verb = 'attr';
            }
            if (!styledMode) {
                // Presentational
                chartBorderWidth = optionsChart.borderWidth || 0;
                mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);
                bgAttr = {
                    fill: chartBackgroundColor || 'none'
                };
                if (chartBorderWidth || chartBackground['stroke-width']) { // #980
                    bgAttr.stroke = optionsChart.borderColor;
                    bgAttr['stroke-width'] = chartBorderWidth;
                }
                chartBackground
                    .attr(bgAttr)
                    .shadow(optionsChart.shadow);
            }
            else {
                chartBorderWidth = mgn = chartBackground.strokeWidth();
            }
            chartBackground[verb]({
                x: mgn / 2,
                y: mgn / 2,
                width: chartWidth - mgn - chartBorderWidth % 2,
                height: chartHeight - mgn - chartBorderWidth % 2,
                r: optionsChart.borderRadius
            });
            // Plot background
            verb = 'animate';
            if (!plotBackground) {
                verb = 'attr';
                chart.plotBackground = plotBackground = renderer.rect()
                    .addClass('highcharts-plot-background')
                    .add();
            }
            plotBackground[verb](plotBox);
            if (!styledMode) {
                // Presentational attributes for the background
                plotBackground
                    .attr({
                    fill: plotBackgroundColor || 'none'
                })
                    .shadow(optionsChart.plotShadow);
                // Create the background image
                if (plotBackgroundImage) {
                    if (!plotBGImage) {
                        chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight).add();
                    }
                    else {
                        if (plotBackgroundImage !== plotBGImage.attr('href')) {
                            plotBGImage.attr('href', plotBackgroundImage);
                        }
                        plotBGImage.animate(plotBox);
                    }
                }
            }
            // Plot clip
            if (!clipRect) {
                chart.clipRect = renderer.clipRect(clipBox);
            }
            else {
                clipRect.animate({
                    width: clipBox.width,
                    height: clipBox.height
                });
            }
            // Plot area border
            verb = 'animate';
            if (!plotBorder) {
                verb = 'attr';
                chart.plotBorder = plotBorder = renderer.rect()
                    .addClass('highcharts-plot-border')
                    .attr({
                    zIndex: 1 // Above the grid
                })
                    .add();
            }
            if (!styledMode) {
                // Presentational
                plotBorder.attr({
                    stroke: optionsChart.plotBorderColor,
                    'stroke-width': optionsChart.plotBorderWidth || 0,
                    fill: 'none'
                });
            }
            plotBorder[verb](plotBorder.crisp({
                x: plotLeft,
                y: plotTop,
                width: plotWidth,
                height: plotHeight
            }, -plotBorder.strokeWidth())); // #3282 plotBorder should be negative;
            // reset
            chart.isDirtyBox = false;
            fireEvent$1(this, 'afterDrawChartBox');
        }
        /**
         * Detect whether a certain chart property is needed based on inspecting its
         * options and series. This mainly applies to the chart.inverted property,
         * and in extensions to the chart.angular and chart.polar properties.
         *
         * @private
         * @function Highcharts.Chart#propFromSeries
         */
        propFromSeries() {
            const chart = this, optionsChart = chart.options.chart, seriesOptions = chart.options.series;
            let i, klass, value;
            /**
             * The flag is set to `true` if a series of the chart is inverted.
             *
             * @name Highcharts.Chart#inverted
             * @type {boolean|undefined}
             */
            ['inverted', 'angular', 'polar'].forEach(function (key) {
                // The default series type's class
                klass = seriesTypes[optionsChart.type];
                // Get the value from available chart-wide properties
                value =
                    // It is set in the options:
                    optionsChart[key] ||
                        // The default series class:
                        (klass && klass.prototype[key]);
                // requires it
                // 4. Check if any the chart's series require it
                i = seriesOptions && seriesOptions.length;
                while (!value && i--) {
                    klass = seriesTypes[seriesOptions[i].type];
                    if (klass && klass.prototype[key]) {
                        value = true;
                    }
                }
                // Set the chart property
                chart[key] = value;
            });
        }
        /**
         * Internal function to link two or more series together, based on the
         * `linkedTo` option. This is done from `Chart.render`, and after
         * `Chart.addSeries` and `Series.remove`.
         *
         * @private
         * @function Highcharts.Chart#linkSeries
         * @emits Highcharts.Chart#event:afterLinkSeries
         */
        linkSeries(isUpdating) {
            const chart = this, chartSeries = chart.series;
            // Reset links
            chartSeries.forEach(function (series) {
                series.linkedSeries.length = 0;
            });
            // Apply new links
            chartSeries.forEach(function (series) {
                let linkedTo = series.options.linkedTo;
                if (isString(linkedTo)) {
                    if (linkedTo === ':previous') {
                        linkedTo = chart.series[series.index - 1];
                    }
                    else {
                        linkedTo = chart.get(linkedTo);
                    }
                    // #3341 avoid mutual linking
                    if (linkedTo && linkedTo.linkedParent !== series) {
                        linkedTo.linkedSeries.push(series);
                        series.linkedParent = linkedTo;
                        if (linkedTo.enabledDataSorting) {
                            series.setDataSortingOptions();
                        }
                        series.visible = pick$1(series.options.visible, linkedTo.options.visible, series.visible); // #3879
                    }
                }
            });
            fireEvent$1(this, 'afterLinkSeries', { isUpdating });
        }
        /**
         * Render series for the chart.
         *
         * @private
         * @function Highcharts.Chart#renderSeries
         */
        renderSeries() {
            this.series.forEach(function (serie) {
                serie.translate();
                serie.render();
            });
        }
        /**
         * Render all graphics for the chart. Runs internally on initialization.
         *
         * @private
         * @function Highcharts.Chart#render
         */
        render() {
            const chart = this, axes = chart.axes, colorAxis = chart.colorAxis, renderer = chart.renderer, renderAxes = function (axes) {
                axes.forEach(function (axis) {
                    if (axis.visible) {
                        axis.render();
                    }
                });
            };
            let correction = 0; // correction for X axis labels
            // Title
            chart.setTitle();
            // Fire an event before the margins are computed. This is where the
            // legend is assigned.
            fireEvent$1(chart, 'beforeMargins');
            // Get stacks
            if (chart.getStacks) {
                chart.getStacks();
            }
            // Get chart margins
            chart.getMargins(true);
            chart.setChartSize();
            // Record preliminary dimensions for later comparison
            const tempWidth = chart.plotWidth;
            axes.some(function (axis) {
                if (axis.horiz &&
                    axis.visible &&
                    axis.options.labels.enabled &&
                    axis.series.length) {
                    // 21 is the most common correction for X axis labels
                    correction = 21;
                    return true;
                }
            });
            // use Math.max to prevent negative plotHeight
            chart.plotHeight = Math.max(chart.plotHeight - correction, 0);
            const tempHeight = chart.plotHeight;
            // Get margins by pre-rendering axes
            axes.forEach(function (axis) {
                axis.setScale();
            });
            chart.getAxisMargins();
            // If the plot area size has changed significantly, calculate tick
            // positions again
            const redoHorizontal = tempWidth / chart.plotWidth > 1.1;
            // Height is more sensitive, use lower threshold
            const redoVertical = tempHeight / chart.plotHeight > 1.05;
            if (redoHorizontal || redoVertical) {
                axes.forEach(function (axis) {
                    if ((axis.horiz && redoHorizontal) ||
                        (!axis.horiz && redoVertical)) {
                        // update to reflect the new margins
                        axis.setTickInterval(true);
                    }
                });
                chart.getMargins(); // second pass to check for new labels
            }
            // Draw the borders and backgrounds
            chart.drawChartBox();
            // Axes
            if (chart.hasCartesianSeries) {
                renderAxes(axes);
            }
            else if (colorAxis && colorAxis.length) {
                renderAxes(colorAxis);
            }
            // The series
            if (!chart.seriesGroup) {
                chart.seriesGroup = renderer.g('series-group')
                    .attr({ zIndex: 3 })
                    .shadow(chart.options.chart.seriesGroupShadow)
                    .add();
            }
            chart.renderSeries();
            // Credits
            chart.addCredits();
            // Handle responsiveness
            if (chart.setResponsive) {
                chart.setResponsive();
            }
            // Set flag
            chart.hasRendered = true;
        }
        /**
         * Set a new credits label for the chart.
         *
         * @sample highcharts/credits/credits-update/
         *         Add and update credits
         *
         * @function Highcharts.Chart#addCredits
         *
         * @param {Highcharts.CreditsOptions} [credits]
         * A configuration object for the new credits.
         */
        addCredits(credits) {
            const chart = this, creds = merge$1(true, this.options.credits, credits);
            if (creds.enabled && !this.credits) {
                /**
                 * The chart's credits label. The label has an `update` method that
                 * allows setting new options as per the
                 * [credits options set](https://api.highcharts.com/highcharts/credits).
                 *
                 * @name Highcharts.Chart#credits
                 * @type {Highcharts.SVGElement}
                 */
                this.credits = this.renderer.text(creds.text + (this.mapCredits || ''), 0, 0)
                    .addClass('highcharts-credits')
                    .on('click', function () {
                    if (creds.href) {
                        win.location.href = creds.href;
                    }
                })
                    .attr({
                    align: creds.position.align,
                    zIndex: 8
                });
                if (!chart.styledMode) {
                    this.credits.css(creds.style);
                }
                this.credits
                    .add()
                    .align(creds.position);
                // Dynamically update
                this.credits.update = function (options) {
                    chart.credits = chart.credits.destroy();
                    chart.addCredits(options);
                };
            }
        }
        /**
         * Remove the chart and purge memory. This method is called internally
         * before adding a second chart into the same container, as well as on
         * window unload to prevent leaks.
         *
         * @sample highcharts/members/chart-destroy/
         *         Destroy the chart from a button
         * @sample stock/members/chart-destroy/
         *         Destroy with Highcharts Stock
         *
         * @function Highcharts.Chart#destroy
         *
         * @emits Highcharts.Chart#event:destroy
         */
        destroy() {
            const chart = this, axes = chart.axes, series = chart.series, container = chart.container, parentNode = container && container.parentNode;
            let i;
            // fire the chart.destoy event
            fireEvent$1(chart, 'destroy');
            // Delete the chart from charts lookup array
            if (chart.renderer.forExport) {
                erase(charts, chart); // #6569
            }
            else {
                charts[chart.index] = void 0;
            }
            H.chartCount--;
            chart.renderTo.removeAttribute('data-highcharts-chart');
            // remove events
            removeEvent(chart);
            // ==== Destroy collections:
            // Destroy axes
            i = axes.length;
            while (i--) {
                axes[i] = axes[i].destroy();
            }
            // Destroy scroller & scroller series before destroying base series
            if (this.scroller && this.scroller.destroy) {
                this.scroller.destroy();
            }
            // Destroy each series
            i = series.length;
            while (i--) {
                series[i] = series[i].destroy();
            }
            // ==== Destroy chart properties:
            [
                'title', 'subtitle', 'chartBackground', 'plotBackground',
                'plotBGImage', 'plotBorder', 'seriesGroup', 'clipRect', 'credits',
                'pointer', 'rangeSelector', 'legend', 'resetZoomButton', 'tooltip',
                'renderer'
            ].forEach(function (name) {
                const prop = chart[name];
                if (prop && prop.destroy) {
                    chart[name] = prop.destroy();
                }
            });
            // Remove container and all SVG, check container as it can break in IE
            // when destroyed before finished loading
            if (container) {
                container.innerHTML = AST.emptyHTML;
                removeEvent(container);
                if (parentNode) {
                    discardElement(container);
                }
            }
            // clean it all up
            objectEach$1(chart, function (val, key) {
                delete chart[key];
            });
        }
        /**
         * Prepare for first rendering after all data are loaded.
         *
         * @private
         * @function Highcharts.Chart#firstRender
         * @emits Highcharts.Chart#event:beforeRender
         */
        firstRender() {
            const chart = this, options = chart.options;
            // Create the container
            chart.getContainer();
            chart.resetMargins();
            chart.setChartSize();
            // Set the common chart properties (mainly invert) from the given series
            chart.propFromSeries();
            // get axes
            chart.getAxes();
            // Initialize the series
            const series = isArray$1(options.series) ? options.series : [];
            options.series = []; // Avoid mutation
            series.forEach(
            // #9680
            function (serieOptions) {
                chart.initSeries(serieOptions);
            });
            chart.linkSeries();
            chart.setSeriesData();
            // Run an event after axes and series are initialized, but before
            // render. At this stage, the series data is indexed and cached in the
            // xData and yData arrays, so we can access those before rendering. Used
            // in Highcharts Stock.
            fireEvent$1(chart, 'beforeRender');
            chart.render();
            chart.pointer.getChartPosition(); // #14973
            // Fire the load event if there are no external images
            if (!chart.renderer.imgCount && !chart.hasLoaded) {
                chart.onload();
            }
            // If the chart was rendered outside the top container, put it back in
            // (#3679)
            chart.temporaryDisplay(true);
        }
        /**
         * Internal function that runs on chart load, async if any images are loaded
         * in the chart. Runs the callbacks and triggers the `load` and `render`
         * events.
         *
         * @private
         * @function Highcharts.Chart#onload
         * @emits Highcharts.Chart#event:load
         * @emits Highcharts.Chart#event:render
         */
        onload() {
            // Run callbacks, first the ones registered by modules, then user's one
            this.callbacks.concat([this.callback]).forEach(function (fn) {
                // Chart destroyed in its own callback (#3600)
                if (fn && typeof this.index !== 'undefined') {
                    fn.apply(this, [this]);
                }
            }, this);
            fireEvent$1(this, 'load');
            fireEvent$1(this, 'render');
            // Set up auto resize, check for not destroyed (#6068)
            if (defined$1(this.index)) {
                this.setReflow();
            }
            this.warnIfA11yModuleNotLoaded();
            // Don't run again
            this.hasLoaded = true;
        }
        /**
         * Emit console warning if the a11y module is not loaded.
         */
        warnIfA11yModuleNotLoaded() {
            const { options, title } = this;
            if (options && !this.accessibility) {
                // Make chart behave as an image with the title as alt text
                this.renderer.boxWrapper.attr({
                    role: 'img',
                    'aria-label': ((title && title.element.textContent) || ''
                    // #17753, < is not allowed in SVG attributes
                    ).replace(/</g, '&lt;')
                });
                if (!(options.accessibility && options.accessibility.enabled === false)) {
                    error('Highcharts warning: Consider including the ' +
                        '"accessibility.js" module to make your chart more ' +
                        'usable for people with disabilities. Set the ' +
                        '"accessibility.enabled" option to false to remove this ' +
                        'warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', false, this);
                }
            }
        }
        /**
         * Add a series to the chart after render time. Note that this method should
         * never be used when adding data synchronously at chart render time, as it
         * adds expense to the calculations and rendering. When adding data at the
         * same time as the chart is initialized, add the series as a configuration
         * option instead. With multiple axes, the `offset` is dynamically adjusted.
         *
         * @sample highcharts/members/chart-addseries/
         *         Add a series from a button
         * @sample stock/members/chart-addseries/
         *         Add a series in Highcharts Stock
         *
         * @function Highcharts.Chart#addSeries
         *
         * @param {Highcharts.SeriesOptionsType} options
         *        The config options for the series.
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart after adding.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
         *        Whether to apply animation, and optionally animation
         *        configuration. When `undefined`, it applies the animation that is
         *        set in the `chart.animation` option.
         *
         * @return {Highcharts.Series}
         *         The newly created series object.
         *
         * @emits Highcharts.Chart#event:addSeries
         * @emits Highcharts.Chart#event:afterAddSeries
         */
        addSeries(options, redraw, animation) {
            const chart = this;
            let series;
            if (options) { // <- not necessary
                redraw = pick$1(redraw, true); // defaults to true
                fireEvent$1(chart, 'addSeries', { options: options }, function () {
                    series = chart.initSeries(options);
                    chart.isDirtyLegend = true;
                    chart.linkSeries();
                    if (series.enabledDataSorting) {
                        // We need to call `setData` after `linkSeries`
                        series.setData(options.data, false);
                    }
                    fireEvent$1(chart, 'afterAddSeries', { series: series });
                    if (redraw) {
                        chart.redraw(animation);
                    }
                });
            }
            return series;
        }
        /**
         * Add an axis to the chart after render time. Note that this method should
         * never be used when adding data synchronously at chart render time, as it
         * adds expense to the calculations and rendering. When adding data at the
         * same time as the chart is initialized, add the axis as a configuration
         * option instead.
         *
         * @sample highcharts/members/chart-addaxis/
         *         Add and remove axes
         *
         * @function Highcharts.Chart#addAxis
         *
         * @param {Highcharts.AxisOptions} options
         *        The axis options.
         *
         * @param {boolean} [isX=false]
         *        Whether it is an X axis or a value axis.
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart after adding.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
         *        Whether and how to apply animation in the redraw. When
         *        `undefined`, it applies the animation that is set in the
         *        `chart.animation` option.
         *
         * @return {Highcharts.Axis}
         *         The newly generated Axis object.
         */
        addAxis(options, isX, redraw, animation) {
            return this.createAxis(isX ? 'xAxis' : 'yAxis', { axis: options, redraw: redraw, animation: animation });
        }
        /**
         * Add a color axis to the chart after render time. Note that this method
         * should never be used when adding data synchronously at chart render time,
         * as it adds expense to the calculations and rendering. When adding data at
         * the same time as the chart is initialized, add the axis as a
         * configuration option instead.
         *
         * @sample highcharts/members/chart-addaxis/
         *         Add and remove axes
         *
         * @function Highcharts.Chart#addColorAxis
         *
         * @param {Highcharts.ColorAxisOptions} options
         *        The axis options.
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart after adding.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
         *        Whether and how to apply animation in the redraw. When
         *        `undefined`, it applies the animation that is set in the
         *        `chart.animation` option.
         *
         * @return {Highcharts.Axis}
         *         The newly generated Axis object.
         */
        addColorAxis(options, redraw, animation) {
            return this.createAxis('colorAxis', { axis: options, redraw: redraw, animation: animation });
        }
        /**
         * Factory for creating different axis types.
         *
         * @private
         * @function Highcharts.Chart#createAxis
         *
         * @param {string} coll
         *        An axis type.
         *
         * @param {...Array<*>} arguments
         *        All arguments for the constructor.
         *
         * @return {Highcharts.Axis}
         *         The newly generated Axis object.
         */
        createAxis(coll, options) {
            const axis = new Axis(this, options.axis, coll);
            if (pick$1(options.redraw, true)) {
                this.redraw(options.animation);
            }
            return axis;
        }
        /**
         * Dim the chart and show a loading text or symbol. Options for the loading
         * screen are defined in {@link
         * https://api.highcharts.com/highcharts/loading|the loading options}.
         *
         * @sample highcharts/members/chart-hideloading/
         *         Show and hide loading from a button
         * @sample highcharts/members/chart-showloading/
         *         Apply different text labels
         * @sample stock/members/chart-show-hide-loading/
         *         Toggle loading in Highcharts Stock
         *
         * @function Highcharts.Chart#showLoading
         *
         * @param {string} [str]
         *        An optional text to show in the loading label instead of the
         *        default one. The default text is set in
         *        [lang.loading](https://api.highcharts.com/highcharts/lang.loading).
         */
        showLoading(str) {
            const chart = this, options = chart.options, loadingOptions = options.loading, setLoadingSize = function () {
                if (loadingDiv) {
                    css(loadingDiv, {
                        left: chart.plotLeft + 'px',
                        top: chart.plotTop + 'px',
                        width: chart.plotWidth + 'px',
                        height: chart.plotHeight + 'px'
                    });
                }
            };
            let loadingDiv = chart.loadingDiv, loadingSpan = chart.loadingSpan;
            // create the layer at the first call
            if (!loadingDiv) {
                chart.loadingDiv = loadingDiv = createElement('div', {
                    className: 'highcharts-loading highcharts-loading-hidden'
                }, null, chart.container);
            }
            if (!loadingSpan) {
                chart.loadingSpan = loadingSpan = createElement('span', { className: 'highcharts-loading-inner' }, null, loadingDiv);
                addEvent(chart, 'redraw', setLoadingSize); // #1080
            }
            loadingDiv.className = 'highcharts-loading';
            // Update text
            AST.setElementHTML(loadingSpan, pick$1(str, options.lang.loading, ''));
            if (!chart.styledMode) {
                // Update visuals
                css(loadingDiv, extend$1(loadingOptions.style, {
                    zIndex: 10
                }));
                css(loadingSpan, loadingOptions.labelStyle);
                // Show it
                if (!chart.loadingShown) {
                    css(loadingDiv, {
                        opacity: 0,
                        display: ''
                    });
                    animate(loadingDiv, {
                        opacity: loadingOptions.style.opacity || 0.5
                    }, {
                        duration: loadingOptions.showDuration || 0
                    });
                }
            }
            chart.loadingShown = true;
            setLoadingSize();
        }
        /**
         * Hide the loading layer.
         *
         * @see Highcharts.Chart#showLoading
         *
         * @sample highcharts/members/chart-hideloading/
         *         Show and hide loading from a button
         * @sample stock/members/chart-show-hide-loading/
         *         Toggle loading in Highcharts Stock
         *
         * @function Highcharts.Chart#hideLoading
         */
        hideLoading() {
            const options = this.options, loadingDiv = this.loadingDiv;
            if (loadingDiv) {
                loadingDiv.className =
                    'highcharts-loading highcharts-loading-hidden';
                if (!this.styledMode) {
                    animate(loadingDiv, {
                        opacity: 0
                    }, {
                        duration: options.loading.hideDuration || 100,
                        complete: function () {
                            css(loadingDiv, { display: 'none' });
                        }
                    });
                }
            }
            this.loadingShown = false;
        }
        /**
         * A generic function to update any element of the chart. Elements can be
         * enabled and disabled, moved, re-styled, re-formatted etc.
         *
         * A special case is configuration objects that take arrays, for example
         * [xAxis](https://api.highcharts.com/highcharts/xAxis),
         * [yAxis](https://api.highcharts.com/highcharts/yAxis) or
         * [series](https://api.highcharts.com/highcharts/series). For these
         * collections, an `id` option is used to map the new option set to an
         * existing object. If an existing object of the same id is not found, the
         * corresponding item is updated. So for example, running `chart.update`
         * with a series item without an id, will cause the existing chart's series
         * with the same index in the series array to be updated. When the
         * `oneToOne` parameter is true, `chart.update` will also take care of
         * adding and removing items from the collection. Read more under the
         * parameter description below.
         *
         * Note that when changing series data, `chart.update` may mutate the passed
         * data options.
         *
         * See also the
         * [responsive option set](https://api.highcharts.com/highcharts/responsive).
         * Switching between `responsive.rules` basically runs `chart.update` under
         * the hood.
         *
         * @sample highcharts/members/chart-update/
         *         Update chart geometry
         *
         * @function Highcharts.Chart#update
         *
         * @param {Highcharts.Options} options
         *        A configuration object for the new chart options.
         *
         * @param {boolean} [redraw=true]
         *        Whether to redraw the chart.
         *
         * @param {boolean} [oneToOne=false]
         *        When `true`, the `series`, `xAxis`, `yAxis` and `annotations`
         *        collections will be updated one to one, and items will be either
         *        added or removed to match the new updated options. For example,
         *        if the chart has two series and we call `chart.update` with a
         *        configuration containing three series, one will be added. If we
         *        call `chart.update` with one series, one will be removed. Setting
         *        an empty `series` array will remove all series, but leaving out
         *        the`series` property will leave all series untouched. If the
         *        series have id's, the new series options will be matched by id,
         *        and the remaining ones removed.
         *
         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]
         *        Whether to apply animation, and optionally animation
         *        configuration. When `undefined`, it applies the animation that is
         *        set in the `chart.animation` option.
         *
         * @emits Highcharts.Chart#event:update
         * @emits Highcharts.Chart#event:afterUpdate
         */
        update(options, redraw, oneToOne, animation) {
            const chart = this, adders = {
                credits: 'addCredits',
                title: 'setTitle',
                subtitle: 'setSubtitle',
                caption: 'setCaption'
            }, isResponsiveOptions = options.isResponsiveOptions, itemsForRemoval = [];
            let updateAllAxes, updateAllSeries, runSetSize;
            fireEvent$1(chart, 'update', { options: options });
            // If there are responsive rules in action, undo the responsive rules
            // before we apply the updated options and replay the responsive rules
            // on top from the chart.redraw function (#9617).
            if (!isResponsiveOptions) {
                chart.setResponsive(false, true);
            }
            options = diffObjects(options, chart.options);
            chart.userOptions = merge$1(chart.userOptions, options);
            // If the top-level chart option is present, some special updates are
            // required
            const optionsChart = options.chart;
            if (optionsChart) {
                merge$1(true, chart.options.chart, optionsChart);
                // Add support for deprecated zooming options like zoomType, #17861
                this.setZoomOptions();
                // Setter function
                if ('className' in optionsChart) {
                    chart.setClassName(optionsChart.className);
                }
                if ('inverted' in optionsChart ||
                    'polar' in optionsChart ||
                    'type' in optionsChart) {
                    // Parse options.chart.inverted and options.chart.polar together
                    // with the available series.
                    chart.propFromSeries();
                    updateAllAxes = true;
                }
                if ('alignTicks' in optionsChart) { // #6452
                    updateAllAxes = true;
                }
                if ('events' in optionsChart) {
                    // Chart event handlers
                    registerEventOptions(this, optionsChart);
                }
                objectEach$1(optionsChart, function (val, key) {
                    if (chart.propsRequireUpdateSeries.indexOf('chart.' + key) !==
                        -1) {
                        updateAllSeries = true;
                    }
                    // Only dirty box
                    if (chart.propsRequireDirtyBox.indexOf(key) !== -1) {
                        chart.isDirtyBox = true;
                    }
                    // Chart setSize
                    if (chart.propsRequireReflow.indexOf(key) !== -1) {
                        if (isResponsiveOptions) {
                            chart.isDirtyBox = true;
                        }
                        else {
                            runSetSize = true;
                        }
                    }
                });
                if (!chart.styledMode && optionsChart.style) {
                    chart.renderer.setStyle(chart.options.chart.style || {});
                }
            }
            // Moved up, because tooltip needs updated plotOptions (#6218)
            if (!chart.styledMode && options.colors) {
                this.options.colors = options.colors;
            }
            if (options.time) {
                // Maintaining legacy global time. If the chart is instanciated
                // first with global time, then updated with time options, we need
                // to create a new Time instance to avoid mutating the global time
                // (#10536).
                if (this.time === defaultTime) {
                    this.time = new Time(options.time);
                }
                // If we're updating, the time class is different from other chart
                // classes (chart.legend, chart.tooltip etc) in that it doesn't know
                // about the chart. The other chart[something].update functions also
                // set the chart.options[something]. For the time class however we
                // need to update the chart options separately. #14230.
                merge$1(true, chart.options.time, options.time);
            }
            // Some option stuctures correspond one-to-one to chart objects that
            // have update methods, for example
            // options.credits => chart.credits
            // options.legend => chart.legend
            // options.title => chart.title
            // options.tooltip => chart.tooltip
            // options.subtitle => chart.subtitle
            // options.mapNavigation => chart.mapNavigation
            // options.navigator => chart.navigator
            // options.scrollbar => chart.scrollbar
            objectEach$1(options, function (val, key) {
                if (chart[key] &&
                    typeof chart[key].update === 'function') {
                    chart[key].update(val, false);
                    // If a one-to-one object does not exist, look for an adder function
                }
                else if (typeof chart[adders[key]] === 'function') {
                    chart[adders[key]](val);
                    // Else, just merge the options. For nodes like loading, noData,
                    // plotOptions
                }
                else if (key !== 'colors' &&
                    chart.collectionsWithUpdate.indexOf(key) === -1) {
                    merge$1(true, chart.options[key], options[key]);
                }
                if (key !== 'chart' &&
                    chart.propsRequireUpdateSeries.indexOf(key) !== -1) {
                    updateAllSeries = true;
                }
            });
            // Setters for collections. For axes and series, each item is referred
            // by an id. If the id is not found, it defaults to the corresponding
            // item in the collection, so setting one series without an id, will
            // update the first series in the chart. Setting two series without
            // an id will update the first and the second respectively (#6019)
            // chart.update and responsive.
            this.collectionsWithUpdate.forEach(function (coll) {
                if (options[coll]) {
                    splat(options[coll]).forEach(function (newOptions, i) {
                        const hasId = defined$1(newOptions.id);
                        let item;
                        // Match by id
                        if (hasId) {
                            item = chart.get(newOptions.id);
                        }
                        // No match by id found, match by index instead
                        if (!item && chart[coll]) {
                            item = chart[coll][pick$1(newOptions.index, i)];
                            // Check if we grabbed an item with an exising but
                            // different id (#13541). Check that the item in this
                            // position is not internal (navigator).
                            if (item && ((hasId && defined$1(item.options.id)) ||
                                item.options.isInternal)) {
                                item = void 0;
                            }
                        }
                        if (item && item.coll === coll) {
                            item.update(newOptions, false);
                            if (oneToOne) {
                                item.touched = true;
                            }
                        }
                        // If oneToOne and no matching item is found, add one
                        if (!item && oneToOne && chart.collectionsWithInit[coll]) {
                            chart.collectionsWithInit[coll][0].apply(chart, 
                            // [newOptions, ...extraArguments, redraw=false]
                            [
                                newOptions
                            ].concat(
                            // Not all initializers require extra args
                            chart.collectionsWithInit[coll][1] || []).concat([
                                false
                            ])).touched = true;
                        }
                    });
                    // Add items for removal
                    if (oneToOne) {
                        chart[coll].forEach(function (item) {
                            if (!item.touched && !item.options.isInternal) {
                                itemsForRemoval.push(item);
                            }
                            else {
                                delete item.touched;
                            }
                        });
                    }
                }
            });
            itemsForRemoval.forEach(function (item) {
                if (item.chart && item.remove) { // #9097, avoid removing twice
                    item.remove(false);
                }
            });
            if (updateAllAxes) {
                chart.axes.forEach(function (axis) {
                    axis.update({}, false);
                });
            }
            // Certain options require the whole series structure to be thrown away
            // and rebuilt
            if (updateAllSeries) {
                chart.getSeriesOrderByLinks().forEach(function (series) {
                    // Avoid removed navigator series
                    if (series.chart) {
                        series.update({}, false);
                    }
                }, this);
            }
            // Update size. Redraw is forced.
            const newWidth = optionsChart && optionsChart.width;
            const newHeight = optionsChart && (isString(optionsChart.height) ?
                relativeLength$1(optionsChart.height, newWidth || chart.chartWidth) :
                optionsChart.height);
            if (
            // In this case, run chart.setSize with newWidth and newHeight which
            // are undefined, only for reflowing chart elements because margin
            // or spacing has been set (#8190)
            runSetSize ||
                // In this case, the size is actually set
                (isNumber$1(newWidth) && newWidth !== chart.chartWidth) ||
                (isNumber$1(newHeight) && newHeight !== chart.chartHeight)) {
                chart.setSize(newWidth, newHeight, animation);
            }
            else if (pick$1(redraw, true)) {
                chart.redraw(animation);
            }
            fireEvent$1(chart, 'afterUpdate', {
                options: options,
                redraw: redraw,
                animation: animation
            });
        }
        /**
         * Shortcut to set the subtitle options. This can also be done from {@link
         * Chart#update} or {@link Chart#setTitle}.
         *
         * @function Highcharts.Chart#setSubtitle
         *
         * @param {Highcharts.SubtitleOptions} options
         *        New subtitle options. The subtitle text itself is set by the
         *        `options.text` property.
         */
        setSubtitle(options, redraw) {
            this.applyDescription('subtitle', options);
            this.layOutTitles(redraw);
        }
        /**
         * Set the caption options. This can also be done from {@link
         * Chart#update}.
         *
         * @function Highcharts.Chart#setCaption
         *
         * @param {Highcharts.CaptionOptions} options
         *        New caption options. The caption text itself is set by the
         *        `options.text` property.
         */
        setCaption(options, redraw) {
            this.applyDescription('caption', options);
            this.layOutTitles(redraw);
        }
        /**
         * Display the zoom button, so users can reset zoom to the default view
         * settings.
         *
         * @function Highcharts.Chart#showResetZoom
         *
         * @emits Highcharts.Chart#event:afterShowResetZoom
         * @emits Highcharts.Chart#event:beforeShowResetZoom
         */
        showResetZoom() {
            const chart = this, lang = defaultOptions.lang, btnOptions = chart.zooming.resetButton, theme = btnOptions.theme, alignTo = (btnOptions.relativeTo === 'chart' ||
                btnOptions.relativeTo === 'spacingBox' ?
                null :
                'scrollablePlotBox');
            /**
             * @private
             */
            function zoomOut() {
                chart.zoomOut();
            }
            fireEvent$1(this, 'beforeShowResetZoom', null, function () {
                chart.resetZoomButton = chart.renderer
                    .button(lang.resetZoom, null, null, zoomOut, theme)
                    .attr({
                    align: btnOptions.position.align,
                    title: lang.resetZoomTitle
                })
                    .addClass('highcharts-reset-zoom')
                    .add()
                    .align(btnOptions.position, false, alignTo);
            });
            fireEvent$1(this, 'afterShowResetZoom');
        }
        /**
         * Zoom the chart out after a user has zoomed in. See also
         * [Axis.setExtremes](/class-reference/Highcharts.Axis#setExtremes).
         *
         * @function Highcharts.Chart#zoomOut
         *
         * @emits Highcharts.Chart#event:selection
         */
        zoomOut() {
            fireEvent$1(this, 'selection', { resetSelection: true }, this.zoom);
        }
        /**
         * Zoom into a given portion of the chart given by axis coordinates.
         *
         * @private
         * @function Highcharts.Chart#zoom
         * @param {Highcharts.SelectEventObject} event
         */
        zoom(event) {
            const chart = this, pointer = chart.pointer;
            let displayButton = false, hasZoomed;
            // If zoom is called with no arguments, reset the axes
            if (!event || event.resetSelection) {
                chart.axes.forEach(function (axis) {
                    hasZoomed = axis.zoom();
                });
                pointer.initiated = false; // #6804
            }
            else { // else, zoom in on all axes
                event.xAxis.concat(event.yAxis).forEach(function (axisData) {
                    const axis = axisData.axis, isXAxis = axis.isXAxis;
                    // don't zoom more than minRange
                    if (pointer[isXAxis ? 'zoomX' : 'zoomY'] &&
                        (defined$1(pointer.mouseDownX) &&
                            defined$1(pointer.mouseDownY) &&
                            chart.isInsidePlot(pointer.mouseDownX - chart.plotLeft, pointer.mouseDownY - chart.plotTop, { axis })) || !defined$1(chart.inverted ? pointer.mouseDownX : pointer.mouseDownY)) {
                        hasZoomed = axis.zoom(axisData.min, axisData.max);
                        if (axis.displayBtn) {
                            displayButton = true;
                        }
                    }
                });
            }
            // Show or hide the Reset zoom button
            const resetZoomButton = chart.resetZoomButton;
            if (displayButton && !resetZoomButton) {
                chart.showResetZoom();
            }
            else if (!displayButton && isObject(resetZoomButton)) {
                chart.resetZoomButton = resetZoomButton.destroy();
            }
            // Redraw
            if (hasZoomed) {
                chart.redraw(pick$1(chart.options.chart.animation, event && event.animation, chart.pointCount < 100));
            }
        }
        /**
         * Pan the chart by dragging the mouse across the pane. This function is
         * called on mouse move, and the distance to pan is computed from chartX
         * compared to the first chartX position in the dragging operation.
         *
         * @private
         * @function Highcharts.Chart#pan
         * @param {Highcharts.PointerEventObject} e
         * @param {string} panning
         */
        pan(e, panning) {
            const chart = this, hoverPoints = chart.hoverPoints, panningOptions = (typeof panning === 'object' ?
                panning :
                {
                    enabled: panning,
                    type: 'x'
                }), chartOptions = chart.options.chart;
            if (chartOptions && chartOptions.panning) {
                chartOptions.panning = panningOptions;
            }
            const type = panningOptions.type;
            let doRedraw;
            fireEvent$1(this, 'pan', { originalEvent: e }, function () {
                // remove active points for shared tooltip
                if (hoverPoints) {
                    hoverPoints.forEach(function (point) {
                        point.setState();
                    });
                }
                let axes = chart.xAxis;
                if (type === 'xy') {
                    axes = axes.concat(chart.yAxis);
                }
                else if (type === 'y') {
                    axes = chart.yAxis;
                }
                const nextMousePos = {};
                axes.forEach(function (axis) {
                    if (!axis.options.panningEnabled || axis.options.isInternal) {
                        return;
                    }
                    const horiz = axis.horiz, mousePos = e[horiz ? 'chartX' : 'chartY'], mouseDown = horiz ? 'mouseDownX' : 'mouseDownY', startPos = chart[mouseDown], halfPointRange = axis.minPointOffset || 0, pointRangeDirection = (axis.reversed && !chart.inverted) ||
                        (!axis.reversed && chart.inverted) ?
                        -1 :
                        1, extremes = axis.getExtremes(), panMin = axis.toValue(startPos - mousePos, true) +
                        halfPointRange * pointRangeDirection, panMax = axis.toValue(startPos + axis.len - mousePos, true) -
                        ((halfPointRange * pointRangeDirection) ||
                            (axis.isXAxis && axis.pointRangePadding) ||
                            0), flipped = panMax < panMin, hasVerticalPanning = axis.hasVerticalPanning();
                    let newMin = flipped ? panMax : panMin, newMax = flipped ? panMin : panMax, panningState = axis.panningState, spill;
                    // General calculations of panning state.
                    // This is related to using vertical panning. (#11315).
                    if (hasVerticalPanning &&
                        !axis.isXAxis && (!panningState || panningState.isDirty)) {
                        axis.series.forEach(function (series) {
                            const processedData = series.getProcessedData(true), dataExtremes = series.getExtremes(processedData.yData, true);
                            if (!panningState) {
                                panningState = {
                                    startMin: Number.MAX_VALUE,
                                    startMax: -Number.MAX_VALUE
                                };
                            }
                            if (isNumber$1(dataExtremes.dataMin) &&
                                isNumber$1(dataExtremes.dataMax)) {
                                panningState.startMin = Math.min(pick$1(series.options.threshold, Infinity), dataExtremes.dataMin, panningState.startMin);
                                panningState.startMax = Math.max(pick$1(series.options.threshold, -Infinity), dataExtremes.dataMax, panningState.startMax);
                            }
                        });
                    }
                    const paddedMin = Math.min(pick$1(panningState && panningState.startMin, extremes.dataMin), halfPointRange ?
                        extremes.min :
                        axis.toValue(axis.toPixels(extremes.min) -
                            axis.minPixelPadding));
                    const paddedMax = Math.max(pick$1(panningState && panningState.startMax, extremes.dataMax), halfPointRange ?
                        extremes.max :
                        axis.toValue(axis.toPixels(extremes.max) +
                            axis.minPixelPadding));
                    axis.panningState = panningState;
                    // It is not necessary to calculate extremes on ordinal axis,
                    // because they are already calculated, so we don't want to
                    // override them.
                    if (!axis.isOrdinal) {
                        // If the new range spills over, either to the min or max,
                        // adjust the new range.
                        spill = paddedMin - newMin;
                        if (spill > 0) {
                            newMax += spill;
                            newMin = paddedMin;
                        }
                        spill = newMax - paddedMax;
                        if (spill > 0) {
                            newMax = paddedMax;
                            newMin -= spill;
                        }
                        // Set new extremes if they are actually new
                        if (axis.series.length &&
                            newMin !== extremes.min &&
                            newMax !== extremes.max &&
                            newMin >= paddedMin &&
                            newMax <= paddedMax) {
                            axis.setExtremes(newMin, newMax, false, false, { trigger: 'pan' });
                            if (!chart.resetZoomButton &&
                                // Show reset zoom button only when both newMin and
                                // newMax values are between padded axis range.
                                newMin !== paddedMin &&
                                newMax !== paddedMax &&
                                type.match('y')) {
                                chart.showResetZoom();
                                axis.displayBtn = false;
                            }
                            doRedraw = true;
                        }
                        // set new reference for next run:
                        nextMousePos[mouseDown] = mousePos;
                    }
                });
                objectEach$1(nextMousePos, (pos, down) => {
                    chart[down] = pos;
                });
                if (doRedraw) {
                    chart.redraw(false);
                }
                css(chart.container, { cursor: 'move' });
            });
        }
    }
    extend$1(Chart.prototype, {
        // Hook for adding callbacks in modules
        callbacks: [],
        /**
         * These collections (arrays) implement `Chart.addSomethig` method used in
         * chart.update() to create new object in the collection. Equivalent for
         * deleting is resolved by simple `Somethig.remove()`.
         *
         * Note: We need to define these references after initializers are bound to
         * chart's prototype.
         *
         * @private
         */
        collectionsWithInit: {
            // collectionName: [ initializingMethod, [extraArguments] ]
            xAxis: [Chart.prototype.addAxis, [true]],
            yAxis: [Chart.prototype.addAxis, [false]],
            series: [Chart.prototype.addSeries]
        },
        /**
         * These collections (arrays) implement update() methods with support for
         * one-to-one option.
         * @private
         */
        collectionsWithUpdate: [
            'xAxis',
            'yAxis',
            'series'
        ],
        /**
         * These properties cause isDirtyBox to be set to true when updating. Can be
         * extended from plugins.
         * @private
         */
        propsRequireDirtyBox: [
            'backgroundColor',
            'borderColor',
            'borderWidth',
            'borderRadius',
            'plotBackgroundColor',
            'plotBackgroundImage',
            'plotBorderColor',
            'plotBorderWidth',
            'plotShadow',
            'shadow'
        ],
        /**
         * These properties require a full reflow of chart elements, best
         * implemented through running `Chart.setSize` internally (#8190).
         * @private
         */
        propsRequireReflow: [
            'margin',
            'marginTop',
            'marginRight',
            'marginBottom',
            'marginLeft',
            'spacing',
            'spacingTop',
            'spacingRight',
            'spacingBottom',
            'spacingLeft'
        ],
        /**
         * These properties cause all series to be updated when updating. Can be
         * extended from plugins.
         * @private
         */
        propsRequireUpdateSeries: [
            'chart.inverted',
            'chart.polar',
            'chart.ignoreHiddenSeries',
            'chart.type',
            'colors',
            'plotOptions',
            'time',
            'tooltip'
        ]
    });

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    /* *
     *
     *  API Options
     *
     * */
    /**
     * Column series display one column per value along an X axis.
     *
     * @sample {highcharts} highcharts/demo/column-basic/
     *         Column chart
     * @sample {highstock} stock/demo/column/
     *         Column chart
     *
     * @extends      plotOptions.line
     * @excluding    connectEnds, connectNulls, gapSize, gapUnit, linecap,
     *               lineWidth, marker, step, useOhlcData
     * @product      highcharts highstock
     * @optionparent plotOptions.column
     */
    const ColumnSeriesDefaults = {
        /**
         * The corner radius of the border surrounding each column or bar. A number
         * signifies pixels. A percentage string, like for example `50%`, signifies
         * a relative size. For columns this is relative to the column width, for
         * pies it is relative to the radius and the inner radius.
         *
         * @sample  {highcharts} highcharts/plotoptions/column-borderradius/
         *          Rounded columns
         * @sample  highcharts/plotoptions/series-border-radius
         *          Column and pie with rounded border
         *
         * @type    {number|string|Highcharts.BorderRadiusOptionsObject}
         * @product highcharts highstock gantt
         */
        borderRadius: 3,
        /**
         * When using automatic point colors pulled from the global
         * [colors](colors) or series-specific
         * [plotOptions.column.colors](series.colors) collections, this option
         * determines whether the chart should receive one color per series or
         * one color per point.
         *
         * In styled mode, the `colors` or `series.colors` arrays are not
         * supported, and instead this option gives the points individual color
         * class names on the form `highcharts-color-{n}`.
         *
         * @see [series colors](#plotOptions.column.colors)
         *
         * @sample {highcharts} highcharts/plotoptions/column-colorbypoint-false/
         *         False by default
         * @sample {highcharts} highcharts/plotoptions/column-colorbypoint-true/
         *         True
         *
         * @type      {boolean}
         * @default   false
         * @since     2.0
         * @product   highcharts highstock gantt
         * @apioption plotOptions.column.colorByPoint
         */
        /**
         * A series specific or series type specific color set to apply instead
         * of the global [colors](#colors) when [colorByPoint](
         * #plotOptions.column.colorByPoint) is true.
         *
         * @type      {Array<Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject>}
         * @since     3.0
         * @product   highcharts highstock gantt
         * @apioption plotOptions.column.colors
         */
        /**
         * When `true`, the columns will center in the category, ignoring null
         * or missing points. When `false`, space will be reserved for null or
         * missing points.
         *
         * @sample {highcharts} highcharts/series-column/centerincategory/
         *         Center in category
         *
         * @since   8.0.1
         * @product highcharts highstock gantt
         */
        centerInCategory: false,
        /**
         * Padding between each value groups, in x axis units.
         *
         * @sample {highcharts} highcharts/plotoptions/column-grouppadding-default/
         *         0.2 by default
         * @sample {highcharts} highcharts/plotoptions/column-grouppadding-none/
         *         No group padding - all columns are evenly spaced
         *
         * @product highcharts highstock gantt
         */
        groupPadding: 0.2,
        /**
         * Whether to group non-stacked columns or to let them render
         * independent of each other. Non-grouped columns will be laid out
         * individually and overlap each other.
         *
         * @sample {highcharts} highcharts/plotoptions/column-grouping-false/
         *         Grouping disabled
         * @sample {highstock} highcharts/plotoptions/column-grouping-false/
         *         Grouping disabled
         *
         * @type      {boolean}
         * @default   true
         * @since     2.3.0
         * @product   highcharts highstock gantt
         * @apioption plotOptions.column.grouping
         */
        /** @ignore-option */
        marker: null,
        /**
         * The maximum allowed pixel width for a column, translated to the
         * height of a bar in a bar chart. This prevents the columns from
         * becoming too wide when there is a small number of points in the
         * chart.
         *
         * @see [pointWidth](#plotOptions.column.pointWidth)
         *
         * @sample {highcharts} highcharts/plotoptions/column-maxpointwidth-20/
         *         Limited to 50
         * @sample {highstock} highcharts/plotoptions/column-maxpointwidth-20/
         *         Limited to 50
         *
         * @type      {number}
         * @since     4.1.8
         * @product   highcharts highstock gantt
         * @apioption plotOptions.column.maxPointWidth
         */
        /**
         * Padding between each column or bar, in x axis units.
         *
         * @sample {highcharts} highcharts/plotoptions/column-pointpadding-default/
         *         0.1 by default
         * @sample {highcharts} highcharts/plotoptions/column-pointpadding-025/
         *          0.25
         * @sample {highcharts} highcharts/plotoptions/column-pointpadding-none/
         *         0 for tightly packed columns
         *
         * @product highcharts highstock gantt
         */
        pointPadding: 0.1,
        /**
         * A pixel value specifying a fixed width for each column or bar point.
         * When set to `undefined`, the width is calculated from the
         * `pointPadding` and `groupPadding`. The width effects the dimension
         * that is not based on the point value. For column series it is the
         * hoizontal length and for bar series it is the vertical length.
         *
         * @see [maxPointWidth](#plotOptions.column.maxPointWidth)
         *
         * @sample {highcharts} highcharts/plotoptions/column-pointwidth-20/
         *         20px wide columns regardless of chart width or the amount of
         *         data points
         *
         * @type      {number}
         * @since     1.2.5
         * @product   highcharts highstock gantt
         * @apioption plotOptions.column.pointWidth
         */
        /**
         * A pixel value specifying a fixed width for the column or bar.
         * Overrides pointWidth on the series.
         *
         * @see [series.pointWidth](#plotOptions.column.pointWidth)
         *
         * @type      {number}
         * @default   undefined
         * @since     7.0.0
         * @product   highcharts highstock gantt
         * @apioption series.column.data.pointWidth
         */
        /**
         * The minimal height for a column or width for a bar. By default,
         * 0 values are not shown. To visualize a 0 (or close to zero) point,
         * set the minimal point length to a pixel value like 3\. In stacked
         * column charts, minPointLength might not be respected for tightly
         * packed values.
         *
         * @sample {highcharts} highcharts/plotoptions/column-minpointlength/
         *         Zero base value
         * @sample {highcharts} highcharts/plotoptions/column-minpointlength-pos-and-neg/
         *         Positive and negative close to zero values
         *
         * @product highcharts highstock gantt
         */
        minPointLength: 0,
        /**
         * When the series contains less points than the crop threshold, all
         * points are drawn, event if the points fall outside the visible plot
         * area at the current zoom. The advantage of drawing all points
         * (including markers and columns), is that animation is performed on
         * updates. On the other hand, when the series contains more points than
         * the crop threshold, the series data is cropped to only contain points
         * that fall within the plot area. The advantage of cropping away
         * invisible points is to increase performance on large series.
         *
         * @product highcharts highstock gantt
         */
        cropThreshold: 50,
        /**
         * The X axis range that each point is valid for. This determines the
         * width of the column. On a categorized axis, the range will be 1
         * by default (one category unit). On linear and datetime axes, the
         * range will be computed as the distance between the two closest data
         * points.
         *
         * The default `null` means it is computed automatically, but this
         * option can be used to override the automatic value.
         *
         * This option is set by default to 1 if data sorting is enabled.
         *
         * @sample {highcharts} highcharts/plotoptions/column-pointrange/
         *         Set the point range to one day on a data set with one week
         *         between the points
         *
         * @type    {number|null}
         * @since   2.3
         * @product highcharts highstock gantt
         */
        pointRange: null,
        states: {
            /**
             * Options for the hovered point. These settings override the normal
             * state options when a point is moused over or touched.
             *
             * @extends   plotOptions.series.states.hover
             * @excluding halo, lineWidth, lineWidthPlus, marker
             * @product   highcharts highstock gantt
             */
            hover: {
                /** @ignore-option */
                halo: false,
                /**
                 * A specific border color for the hovered point. Defaults to
                 * inherit the normal state border color.
                 *
                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @product   highcharts gantt
                 * @apioption plotOptions.column.states.hover.borderColor
                 */
                /**
                 * A specific color for the hovered point.
                 *
                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @product   highcharts gantt
                 * @apioption plotOptions.column.states.hover.color
                 */
                /**
                 * How much to brighten the point on interaction. Requires the
                 * main color to be defined in hex or rgb(a) format.
                 *
                 * In styled mode, the hover brightening is by default replaced
                 * with a fill-opacity set in the `.highcharts-point:hover`
                 * rule.
                 *
                 * @sample {highcharts} highcharts/plotoptions/column-states-hover-brightness/
                 *         Brighten by 0.5
                 *
                 * @product highcharts highstock gantt
                 */
                brightness: 0.1
            },
            /**
             * Options for the selected point. These settings override the
             * normal state options when a point is selected.
             *
             * @extends   plotOptions.series.states.select
             * @excluding halo, lineWidth, lineWidthPlus, marker
             * @product   highcharts highstock gantt
             */
            select: {
                /**
                 * A specific color for the selected point.
                 *
                 * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @default #cccccc
                 * @product highcharts highstock gantt
                 */
                color: "#cccccc" /* Palette.neutralColor20 */,
                /**
                 * A specific border color for the selected point.
                 *
                 * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @default #000000
                 * @product highcharts highstock gantt
                 */
                borderColor: "#000000" /* Palette.neutralColor100 */
            }
        },
        dataLabels: {
            align: void 0,
            verticalAlign: void 0,
            /**
             * The y position offset of the label relative to the point in
             * pixels.
             *
             * @type {number}
             */
            y: void 0
        },
        // false doesn't work well: https://jsfiddle.net/highcharts/hz8fopan/14/
        /** @ignore-option */
        startFromThreshold: true,
        stickyTracking: false,
        tooltip: {
            distance: 6
        },
        /**
         * The Y axis value to serve as the base for the columns, for
         * distinguishing between values above and below a threshold. If `null`,
         * the columns extend from the padding Y axis minimum.
         *
         * @type    {number|null}
         * @since   2.0
         * @product highcharts
         */
        threshold: 0,
        /**
         * The width of the border surrounding each column or bar. Defaults to
         * `1` when there is room for a border, but to `0` when the columns are
         * so dense that a border would cover the next column.
         *
         * In styled mode, the stroke width can be set with the
         * `.highcharts-point` rule.
         *
         * @sample {highcharts} highcharts/plotoptions/column-borderwidth/
         *         2px black border
         *
         * @type      {number}
         * @default   undefined
         * @product   highcharts highstock gantt
         * @apioption plotOptions.column.borderWidth
         */
        /**
         * The color of the border surrounding each column or bar.
         *
         * In styled mode, the border stroke can be set with the
         * `.highcharts-point` rule.
         *
         * @sample {highcharts} highcharts/plotoptions/column-bordercolor/
         *         Dark gray border
         *
         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
         * @default   #ffffff
         * @product   highcharts highstock gantt
         */
        borderColor: "#ffffff" /* Palette.backgroundColor */
    };

    /* *
     *
     *  (c) 2010-2021 Torstein Honsi
     *
     *  License: www.highcharts.com/license
     *
     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!
     *
     * */
    const { animObject } = animationExports;
    const { parse: color } = Color;
    const { hasTouch, noop } = H;
    const { clamp, defined, extend, fireEvent, isArray, isNumber, merge, pick, objectEach, relativeLength } = Utilities;
    /* *
     *
     *  Class
     *
     * */
    /**
     * The column series type.
     *
     * @private
     * @class
     * @name Highcharts.seriesTypes.column
     *
     * @augments Highcharts.Series
     */
    class ColumnSeries extends Series {
        constructor() {
            /* *
             *
             *  Static Properties
             *
             * */
            super(...arguments);
            /* *
             *
             *  Properties
             *
             * */
            this.borderWidth = void 0;
            this.data = void 0;
            this.group = void 0;
            this.options = void 0;
            this.points = void 0;
            /* eslint-enable valid-jsdoc */
        }
        /* *
         *
         *  Functions
         *
         * */
        /* eslint-disable valid-jsdoc */
        /**
         * Animate the column heights one by one from zero.
         *
         * @private
         * @function Highcharts.seriesTypes.column#animate
         *
         * @param {boolean} init
         *        Whether to initialize the animation or run it
         */
        animate(init) {
            const series = this, yAxis = this.yAxis, yAxisPos = yAxis.pos, options = series.options, inverted = this.chart.inverted, attr = {}, translateProp = inverted ?
                'translateX' :
                'translateY';
            let translateStart, translatedThreshold;
            if (init) {
                attr.scaleY = 0.001;
                translatedThreshold = clamp(yAxis.toPixels(options.threshold), yAxisPos, yAxisPos + yAxis.len);
                if (inverted) {
                    attr.translateX = translatedThreshold - yAxis.len;
                }
                else {
                    attr.translateY = translatedThreshold;
                }
                // apply finnal clipping (used in Highcharts Stock) (#7083)
                // animation is done by scaleY, so cliping is for panes
                if (series.clipBox) {
                    series.setClip();
                }
                series.group.attr(attr);
            }
            else { // run the animation
                translateStart = Number(series.group.attr(translateProp));
                series.group.animate({ scaleY: 1 }, extend(animObject(series.options.animation), {
                    // Do the scale synchronously to ensure smooth
                    // updating (#5030, #7228)
                    step: function (val, fx) {
                        if (series.group) {
                            attr[translateProp] = translateStart +
                                fx.pos * (yAxisPos - translateStart);
                            series.group.attr(attr);
                        }
                    }
                }));
            }
        }
        /**
         * Initialize the series. Extends the basic Series.init method by
         * marking other series of the same type as dirty.
         *
         * @private
         * @function Highcharts.seriesTypes.column#init
         */
        init(chart, options) {
            super.init.apply(this, arguments);
            const series = this;
            chart = series.chart;
            // if the series is added dynamically, force redraw of other
            // series affected by a new column
            if (chart.hasRendered) {
                chart.series.forEach(function (otherSeries) {
                    if (otherSeries.type === series.type) {
                        otherSeries.isDirty = true;
                    }
                });
            }
        }
        /**
         * Return the width and x offset of the columns adjusted for grouping,
         * groupPadding, pointPadding, pointWidth etc.
         *
         * @private
         * @function Highcharts.seriesTypes.column#getColumnMetrics
         */
        getColumnMetrics() {
            const series = this, options = series.options, xAxis = series.xAxis, yAxis = series.yAxis, reversedStacks = xAxis.options.reversedStacks, 
            // Keep backward compatibility: reversed xAxis had reversed
            // stacks
            reverseStacks = (xAxis.reversed && !reversedStacks) ||
                (!xAxis.reversed && reversedStacks), stackGroups = {};
            let stackKey, columnCount = 0;
            // Get the total number of column type series. This is called on
            // every series. Consider moving this logic to a chart.orderStacks()
            // function and call it on init, addSeries and removeSeries
            if (options.grouping === false) {
                columnCount = 1;
            }
            else {
                series.chart.series.forEach(function (otherSeries) {
                    const otherYAxis = otherSeries.yAxis, otherOptions = otherSeries.options;
                    let columnIndex;
                    if (otherSeries.type === series.type &&
                        (otherSeries.visible ||
                            !series.chart.options.chart.ignoreHiddenSeries) &&
                        yAxis.len === otherYAxis.len &&
                        yAxis.pos === otherYAxis.pos) { // #642, #2086
                        if (otherOptions.stacking &&
                            otherOptions.stacking !== 'group') {
                            stackKey = otherSeries.stackKey;
                            if (typeof stackGroups[stackKey] ===
                                'undefined') {
                                stackGroups[stackKey] = columnCount++;
                            }
                            columnIndex = stackGroups[stackKey];
                        }
                        else if (otherOptions.grouping !== false) { // #1162
                            columnIndex = columnCount++;
                        }
                        otherSeries.columnIndex = columnIndex;
                    }
                });
            }
            const categoryWidth = Math.min(Math.abs(xAxis.transA) * ((xAxis.ordinal && xAxis.ordinal.slope) ||
                options.pointRange ||
                xAxis.closestPointRange ||
                xAxis.tickInterval ||
                1), // #2610
            xAxis.len // #1535
            ), groupPadding = categoryWidth * options.groupPadding, groupWidth = categoryWidth - 2 * groupPadding, pointOffsetWidth = groupWidth / (columnCount || 1), pointWidth = Math.min(options.maxPointWidth || xAxis.len, pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))), pointPadding = (pointOffsetWidth - pointWidth) / 2, 
            // #1251, #3737
            colIndex = (series.columnIndex || 0) + (reverseStacks ? 1 : 0), pointXOffset = pointPadding +
                (groupPadding +
                    colIndex * pointOffsetWidth -
                    (categoryWidth / 2)) * (reverseStacks ? -1 : 1);
            // Save it for reading in linked series (Error bars particularly)
            series.columnMetrics = {
                width: pointWidth,
                offset: pointXOffset,
                paddedWidth: pointOffsetWidth,
                columnCount
            };
            return series.columnMetrics;
        }
        /**
         * Make the columns crisp. The edges are rounded to the nearest full
         * pixel.
         *
         * @private
         * @function Highcharts.seriesTypes.column#crispCol
         */
        crispCol(x, y, w, h) {
            this.chart; const borderWidth = this.borderWidth, xCrisp = -(borderWidth % 2 ? 0.5 : 0);
            let right, yCrisp = borderWidth % 2 ? 0.5 : 1;
            // Horizontal. We need to first compute the exact right edge, then
            // round it and compute the width from there.
            if (this.options.crisp) {
                right = Math.round(x + w) + xCrisp;
                x = Math.round(x) + xCrisp;
                w = right - x;
            }
            // Vertical
            const bottom = Math.round(y + h) + yCrisp, fromTop = Math.abs(y) <= 0.5 && bottom > 0.5; // #4504, #4656
            y = Math.round(y) + yCrisp;
            h = bottom - y;
            // Top edges are exceptions
            if (fromTop && h) { // #5146
                y -= 1;
                h += 1;
            }
            return {
                x: x,
                y: y,
                width: w,
                height: h
            };
        }
        /**
         * Adjust for missing columns, according to the `centerInCategory`
         * option. Missing columns are either single points or stacks where the
         * point or points are either missing or null.
         *
         * @private
         * @function Highcharts.seriesTypes.column#adjustForMissingColumns
         * @param {number} x
         * The x coordinate of the column, left side
         *
         * @param {number} pointWidth
         * The pointWidth, already computed upstream
         *
         * @param {Highcharts.ColumnPoint} point
         * The point instance
         *
         * @param {Highcharts.ColumnMetricsObject} metrics
         * The series-wide column metrics
         *
         * @return {number}
         * The adjusted x position, or the original if not adjusted
         */
        adjustForMissingColumns(x, pointWidth, point, metrics) {
            const stacking = this.options.stacking;
            if (!point.isNull && metrics.columnCount > 1) {
                const reversedStacks = this.yAxis.options.reversedStacks;
                let indexInCategory = 0, totalInCategory = reversedStacks ? 0 : -metrics.columnCount;
                // Loop over all the stacks on the Y axis. When stacking is enabled,
                // these are real point stacks. When stacking is not enabled, but
                // `centerInCategory` is true, there is one stack handling the
                // grouping of points in each category. This is done in the
                // `setGroupedPoints` function.
                objectEach(this.yAxis.stacking && this.yAxis.stacking.stacks, (stack) => {
                    if (typeof point.x === 'number') {
                        const stackItem = stack[point.x.toString()];
                        if (stackItem) {
                            const pointValues = stackItem.points[this.index];
                            // If true `stacking` is enabled, count the total
                            // number of non-null stacks in the category, and
                            // note which index this point is within those
                            // stacks.
                            if (stacking) {
                                if (pointValues) {
                                    indexInCategory = totalInCategory;
                                }
                                if (stackItem.hasValidPoints) {
                                    reversedStacks ? // #16169
                                        totalInCategory++ : totalInCategory--;
                                }
                                // If `stacking` is not enabled, look for the index
                            }
                            else if (isArray(pointValues)) {
                                // If there are multiple points with the same X
                                // then gather all series in category, and
                                // assign index
                                let seriesIndexes = Object
                                    .keys(stackItem.points)
                                    .filter((pointKey) => 
                                // Filter out duplicate X's
                                !pointKey.match(',') &&
                                    // Filter out null points
                                    stackItem.points[pointKey] &&
                                    stackItem.points[pointKey].length > 1)
                                    .map(parseFloat)
                                    .sort((a, b) => b - a);
                                indexInCategory = seriesIndexes.indexOf(this.index);
                                totalInCategory = seriesIndexes.length;
                            }
                        }
                    }
                });
                // Compute the adjusted x position
                const boxWidth = (totalInCategory - 1) * metrics.paddedWidth +
                    pointWidth;
                x = (point.plotX || 0) + boxWidth / 2 - pointWidth -
                    indexInCategory * metrics.paddedWidth;
            }
            return x;
        }
        /**
         * Translate each point to the plot area coordinate system and find
         * shape positions
         *
         * @private
         * @function Highcharts.seriesTypes.column#translate
         */
        translate() {
            const series = this, chart = series.chart, options = series.options, dense = series.dense =
                series.closestPointRange * series.xAxis.transA < 2, borderWidth = series.borderWidth = pick(options.borderWidth, dense ? 0 : 1 // #3635
            ), xAxis = series.xAxis, yAxis = series.yAxis, threshold = options.threshold, minPointLength = pick(options.minPointLength, 5), metrics = series.getColumnMetrics(), seriesPointWidth = metrics.width, seriesXOffset = series.pointXOffset = metrics.offset, dataMin = series.dataMin, dataMax = series.dataMax;
            // postprocessed for border width
            let seriesBarW = series.barW =
                Math.max(seriesPointWidth, 1 + 2 * borderWidth), translatedThreshold = series.translatedThreshold =
                yAxis.getThreshold(threshold);
            if (chart.inverted) {
                translatedThreshold -= 0.5; // #3355
            }
            // When the pointPadding is 0, we want the columns to be packed
            // tightly, so we allow individual columns to have individual sizes.
            // When pointPadding is greater, we strive for equal-width columns
            // (#2694).
            if (options.pointPadding) {
                seriesBarW = Math.ceil(seriesBarW);
            }
            Series.prototype.translate.apply(series);
            // Record the new values
            series.points.forEach(function (point) {
                const yBottom = pick(point.yBottom, translatedThreshold), safeDistance = 999 + Math.abs(yBottom), plotX = point.plotX || 0, 
                // Don't draw too far outside plot area (#1303, #2241,
                // #4264)
                plotY = clamp(point.plotY, -safeDistance, yAxis.len + safeDistance); point.stackBox;
                let up, barY = Math.min(plotY, yBottom), barH = Math.max(plotY, yBottom) - barY, pointWidth = seriesPointWidth, barX = plotX + seriesXOffset, barW = seriesBarW;
                // Handle options.minPointLength
                if (minPointLength && Math.abs(barH) < minPointLength) {
                    barH = minPointLength;
                    up = (!yAxis.reversed && !point.negative) ||
                        (yAxis.reversed && point.negative);
                    // Reverse zeros if there's no positive value in the series
                    // in visible range (#7046)
                    if (isNumber(threshold) &&
                        isNumber(dataMax) &&
                        point.y === threshold &&
                        dataMax <= threshold &&
                        // and if there's room for it (#7311)
                        (yAxis.min || 0) < threshold &&
                        // if all points are the same value (i.e zero) not draw
                        // as negative points (#10646), but only if there's room
                        // for it (#14876)
                        (dataMin !== dataMax || (yAxis.max || 0) <= threshold)) {
                        up = !up;
                        point.negative = !point.negative;
                    }
                    // If stacked...
                    barY = (Math.abs(barY - translatedThreshold) > minPointLength ?
                        // ...keep position
                        yBottom - minPointLength :
                        // #1485, #4051
                        translatedThreshold -
                            (up ? minPointLength : 0));
                }
                // Handle point.options.pointWidth
                // @todo Handle grouping/stacking too. Calculate offset properly
                if (defined(point.options.pointWidth)) {
                    pointWidth = barW =
                        Math.ceil(point.options.pointWidth);
                    barX -= Math.round((pointWidth - seriesPointWidth) / 2);
                }
                // Adjust for null or missing points
                if (options.centerInCategory) {
                    barX = series.adjustForMissingColumns(barX, pointWidth, point, metrics);
                }
                // Cache for access in polar
                point.barX = barX;
                point.pointWidth = pointWidth;
                // Fix the tooltip on center of grouped columns (#1216, #424,
                // #3648)
                point.tooltipPos = chart.inverted ?
                    [
                        clamp(yAxis.len + yAxis.pos - chart.plotLeft - plotY, yAxis.pos - chart.plotLeft, yAxis.len + yAxis.pos - chart.plotLeft),
                        xAxis.len + xAxis.pos - chart.plotTop - barX - barW / 2,
                        barH
                    ] :
                    [
                        xAxis.left - chart.plotLeft + barX + barW / 2,
                        clamp(plotY + yAxis.pos -
                            chart.plotTop, yAxis.pos - chart.plotTop, yAxis.len + yAxis.pos - chart.plotTop),
                        barH
                    ];
                // Register shape type and arguments to be used in drawPoints. Allow
                // `shapeType` defined on `pointClass` level.
                point.shapeType = series.pointClass.prototype.shapeType ||
                    'roundedRect';
                point.shapeArgs = series.crispCol(barX, 
                // #3169, drilldown from null must have a position to work from.
                // #6585, dataLabel should be placed on xAxis, not floating in
                // the middle of the chart.
                point.isNull ? translatedThreshold : barY, barW, point.isNull ? 0 : barH);
            });
            // Fire a specific event after column translate. We could instead apply
            // all the column logic in an `afterTranslate` event handler, but there
            // are so many other series types that use the column translation, that
            // it is more convenient to have a specific event for it.
            fireEvent(this, 'afterColumnTranslate');
        }
        /**
         * Columns have no graph
         *
         * @private
         * @function Highcharts.seriesTypes.column#drawGraph
         */
        drawGraph() {
            this.group[this.dense ? 'addClass' : 'removeClass']('highcharts-dense-data');
        }
        /**
         * Get presentational attributes
         *
         * @private
         * @function Highcharts.seriesTypes.column#pointAttribs
         */
        pointAttribs(point, state) {
            const options = this.options, p2o = this.pointAttrToOptions || {}, strokeOption = p2o.stroke || 'borderColor', strokeWidthOption = p2o['stroke-width'] || 'borderWidth';
            let stateOptions, zone, brightness, fill = (point && point.color) || this.color, 
            // set to fill when borderColor null:
            stroke = ((point && point[strokeOption]) ||
                options[strokeOption] ||
                fill), dashstyle = (point && point.options.dashStyle) || options.dashStyle, strokeWidth = (point && point[strokeWidthOption]) ||
                options[strokeWidthOption] ||
                this[strokeWidthOption] || 0, opacity = pick(point && point.opacity, options.opacity, 1);
            // Handle zone colors
            if (point && this.zones.length) {
                zone = point.getZone();
                // When zones are present, don't use point.color (#4267).
                // Changed order (#6527), added support for colorAxis (#10670)
                fill = (point.options.color ||
                    (zone && (zone.color || point.nonZonedColor)) ||
                    this.color);
                if (zone) {
                    stroke = zone.borderColor || stroke;
                    dashstyle = zone.dashStyle || dashstyle;
                    strokeWidth = zone.borderWidth || strokeWidth;
                }
            }
            // Select or hover states
            if (state && point) {
                stateOptions = merge(options.states[state], 
                // #6401
                point.options.states &&
                    point.options.states[state] ||
                    {});
                brightness = stateOptions.brightness;
                fill =
                    stateOptions.color || (typeof brightness !== 'undefined' &&
                        color(fill)
                            .brighten(stateOptions.brightness)
                            .get()) || fill;
                stroke = stateOptions[strokeOption] || stroke;
                strokeWidth =
                    stateOptions[strokeWidthOption] || strokeWidth;
                dashstyle = stateOptions.dashStyle || dashstyle;
                opacity = pick(stateOptions.opacity, opacity);
            }
            const ret = {
                fill: fill,
                stroke: stroke,
                'stroke-width': strokeWidth,
                opacity: opacity
            };
            if (dashstyle) {
                ret.dashstyle = dashstyle;
            }
            return ret;
        }
        /**
         * Draw the columns. For bars, the series.group is rotated, so the same
         * coordinates apply for columns and bars. This method is inherited by
         * scatter series.
         *
         * @private
         * @function Highcharts.seriesTypes.column#drawPoints
         */
        drawPoints(points = this.points) {
            const series = this, chart = this.chart, options = series.options, renderer = chart.renderer, animationLimit = options.animationLimit || 250;
            let shapeArgs;
            // draw the columns
            points.forEach(function (point) {
                const plotY = point.plotY;
                let graphic = point.graphic, hasGraphic = !!graphic, verb = graphic && chart.pointCount < animationLimit ?
                    'animate' : 'attr';
                if (isNumber(plotY) && point.y !== null) {
                    shapeArgs = point.shapeArgs;
                    // When updating a series between 2d and 3d or cartesian and
                    // polar, the shape type changes.
                    if (graphic && point.hasNewShapeType()) {
                        graphic = graphic.destroy();
                    }
                    // Set starting position for point sliding animation.
                    if (series.enabledDataSorting) {
                        point.startXPos = series.xAxis.reversed ?
                            -(shapeArgs ? (shapeArgs.width || 0) : 0) :
                            series.xAxis.width;
                    }
                    if (!graphic) {
                        point.graphic = graphic =
                            renderer[point.shapeType](shapeArgs)
                                .add(point.group || series.group);
                        if (graphic &&
                            series.enabledDataSorting &&
                            chart.hasRendered &&
                            chart.pointCount < animationLimit) {
                            graphic.attr({
                                x: point.startXPos
                            });
                            hasGraphic = true;
                            verb = 'animate';
                        }
                    }
                    if (graphic && hasGraphic) { // update
                        graphic[verb](merge(shapeArgs));
                    }
                    // Presentational
                    if (!chart.styledMode) {
                        graphic[verb](series.pointAttribs(point, (point.selected && 'select')))
                            .shadow(point.allowShadow !== false && options.shadow);
                    }
                    if (graphic) {
                        graphic.addClass(point.getClassName(), true);
                        graphic.attr({
                            visibility: point.visible ? 'inherit' : 'hidden'
                        });
                    }
                }
                else if (graphic) {
                    point.graphic = graphic.destroy(); // #1269
                }
            });
        }
        /**
         * Draw the tracker for a point.
         * @private
         */
        drawTracker(points = this.points) {
            const series = this, chart = series.chart, pointer = chart.pointer, onMouseOver = function (e) {
                const point = pointer.getPointFromEvent(e);
                // undefined on graph in scatterchart
                if (typeof point !== 'undefined' &&
                    series.options.enableMouseTracking) {
                    pointer.isDirectTouch = true;
                    point.onMouseOver(e);
                }
            };
            let dataLabels;
            // Add reference to the point
            points.forEach(function (point) {
                dataLabels = (isArray(point.dataLabels) ?
                    point.dataLabels :
                    (point.dataLabel ? [point.dataLabel] : []));
                if (point.graphic) {
                    point.graphic.element.point = point;
                }
                dataLabels.forEach(function (dataLabel) {
                    if (dataLabel.div) {
                        dataLabel.div.point = point;
                    }
                    else {
                        dataLabel.element.point = point;
                    }
                });
            });
            // Add the event listeners, we need to do this only once
            if (!series._hasTracking) {
                series.trackerGroups.forEach(function (key) {
                    if (series[key]) {
                        // we don't always have dataLabelsGroup
                        series[key]
                            .addClass('highcharts-tracker')
                            .on('mouseover', onMouseOver)
                            .on('mouseout', function (e) {
                            pointer.onTrackerMouseOut(e);
                        });
                        if (hasTouch) {
                            series[key].on('touchstart', onMouseOver);
                        }
                        if (!chart.styledMode && series.options.cursor) {
                            series[key]
                                .css({ cursor: series.options.cursor });
                        }
                    }
                });
                series._hasTracking = true;
            }
            fireEvent(this, 'afterDrawTracker');
        }
        /**
         * Remove this series from the chart
         *
         * @private
         * @function Highcharts.seriesTypes.column#remove
         */
        remove() {
            const series = this, chart = series.chart;
            // column and bar series affects other series of the same type
            // as they are either stacked or grouped
            if (chart.hasRendered) {
                chart.series.forEach(function (otherSeries) {
                    if (otherSeries.type === series.type) {
                        otherSeries.isDirty = true;
                    }
                });
            }
            Series.prototype.remove.apply(series, arguments);
        }
    }
    ColumnSeries.defaultOptions = merge(Series.defaultOptions, ColumnSeriesDefaults);
    extend(ColumnSeries.prototype, {
        cropShoulder: 0,
        // When tooltip is not shared, this series (and derivatives) requires
        // direct touch/hover. KD-tree does not apply.
        directTouch: true,
        getSymbol: noop,
        // use separate negative stacks, unlike area stacks where a negative
        // point is substracted from previous (#1910)
        negStacks: true,
        trackerGroups: ['group', 'dataLabelsGroup']
    });
    SeriesRegistry$1.registerSeriesType('column', ColumnSeries);

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    var highchartsExports = {};
    var highcharts = {
      get exports(){ return highchartsExports; },
      set exports(v){ highchartsExports = v; },
    };

    /*
     Highcharts JS v11.1.0 (2023-06-05)

     (c) 2009-2021 Torstein Honsi

     License: www.highcharts.com/license
    */

    (function (module) {
    (function(U,M){module.exports?(M["default"]=M,module.exports=U.document?M(U):M):(U.Highcharts&&U.Highcharts.error(16,!0),U.Highcharts=M(U));})("undefined"!==typeof window?window:commonjsGlobal,function(U){function M(a,y,I,L){a.hasOwnProperty(y)||(a[y]=L.apply(null,I),"function"===typeof CustomEvent&&U.dispatchEvent(new CustomEvent("HighchartsModuleLoaded",{detail:{path:y,module:a[y]}})));}
    	var a={};M(a,"Core/Globals.js",[],function(){var a;(function(a){a.SVG_NS="http://www.w3.org/2000/svg";a.product="Highcharts";a.version="11.1.0";a.win="undefined"!==typeof U?U:{};a.doc=a.win.document;a.svg=a.doc&&a.doc.createElementNS&&!!a.doc.createElementNS(a.SVG_NS,"svg").createSVGRect;a.userAgent=a.win.navigator&&a.win.navigator.userAgent||"";a.isChrome=-1!==a.userAgent.indexOf("Chrome");a.isFirefox=-1!==a.userAgent.indexOf("Firefox");a.isMS=/(edge|msie|trident)/i.test(a.userAgent)&&!a.win.opera;
    	a.isSafari=!a.isChrome&&-1!==a.userAgent.indexOf("Safari");a.isTouchDevice=/(Mobile|Android|Windows Phone)/.test(a.userAgent);a.isWebKit=-1!==a.userAgent.indexOf("AppleWebKit");a.deg2rad=2*Math.PI/360;a.hasBidiBug=a.isFirefox&&4>parseInt(a.userAgent.split("Firefox/")[1],10);a.hasTouch=!!a.win.TouchEvent;a.marginNames=["plotTop","marginRight","marginBottom","plotLeft"];a.noop=function(){};a.supportsPassiveEvents=function(){let x=!1;if(!a.isMS){const y=Object.defineProperty({},"passive",{get:function(){x=
    	!0;}});a.win.addEventListener&&a.win.removeEventListener&&(a.win.addEventListener("testPassive",a.noop,y),a.win.removeEventListener("testPassive",a.noop,y));}return x}();a.charts=[];a.dateFormats={};a.seriesTypes={};a.symbolSizes={};a.chartCount=0;})(a||(a={}));return a});M(a,"Core/Utilities.js",[a["Core/Globals.js"]],function(a){function x(c,b,f,k){const n=b?"Highcharts error":"Highcharts warning";32===c&&(c=`${n}: Deprecated member`);const r=u(c);let e=r?`${n} #${c}: www.highcharts.com/errors/${c}/`:
    	c.toString();if("undefined"!==typeof k){let c="";r&&(e+="?");E(k,function(b,n){c+=`\n - ${n}: ${b}`;r&&(e+=encodeURI(n)+"="+encodeURI(b));});e+=c;}d(a,"displayError",{chart:f,code:c,message:e,params:k},function(){if(b)throw Error(e);q.console&&-1===x.messages.indexOf(e)&&console.warn(e);});x.messages.push(e);}function I(c,b){return parseInt(c,b||10)}function L(c){return "string"===typeof c}function C(c){c=Object.prototype.toString.call(c);return "[object Array]"===c||"[object Array Iterator]"===c}function z(c,
    	b){return !!c&&"object"===typeof c&&(!b||!C(c))}function H(c){return z(c)&&"number"===typeof c.nodeType}function B(c){const b=c&&c.constructor;return !(!z(c,!0)||H(c)||!b||!b.name||"Object"===b.name)}function u(c){return "number"===typeof c&&!isNaN(c)&&Infinity>c&&-Infinity<c}function v(c){return "undefined"!==typeof c&&null!==c}function l(c,b,f){const n=L(b)&&!v(f);let d;const k=(b,f)=>{v(b)?c.setAttribute(f,b):n?(d=c.getAttribute(f))||"class"!==f||(d=c.getAttribute(f+"Name")):c.removeAttribute(f);};
    	L(b)?k(f,b):E(b,k);return d}function p(c){return C(c)?c:[c]}function t(c,b){let n;c||(c={});for(n in b)c[n]=b[n];return c}function m(){const c=arguments,b=c.length;for(let n=0;n<b;n++){const b=c[n];if("undefined"!==typeof b&&null!==b)return b}}function h(c,b){a.isMS&&!a.svg&&b&&v(b.opacity)&&(b.filter=`alpha(opacity=${100*b.opacity})`);t(c.style,b);}function g(c){return Math.pow(10,Math.floor(Math.log(c)/Math.LN10))}function e(c,b){return 1E14<c?c:parseFloat(c.toPrecision(b||14))}function w(c,b,f){let n;
    	if("width"===b)return b=Math.min(c.offsetWidth,c.scrollWidth),f=c.getBoundingClientRect&&c.getBoundingClientRect().width,f<b&&f>=b-1&&(b=Math.floor(f)),Math.max(0,b-(w(c,"padding-left",!0)||0)-(w(c,"padding-right",!0)||0));if("height"===b)return Math.max(0,Math.min(c.offsetHeight,c.scrollHeight)-(w(c,"padding-top",!0)||0)-(w(c,"padding-bottom",!0)||0));if(c=q.getComputedStyle(c,void 0))n=c.getPropertyValue(b),m(f,"opacity"!==b)&&(n=I(n));return n}function E(c,b,f){for(const n in c)Object.hasOwnProperty.call(c,
    	n)&&b.call(f||c[n],c[n],n,c);}function F(c,b,f){function n(b,n){const f=c.removeEventListener;f&&f.call(c,b,n,!1);}function d(f){let d,K;c.nodeName&&(b?(d={},d[b]=!0):d=f,E(d,function(c,b){if(f[b])for(K=f[b].length;K--;)n(b,f[b][K].fn);}));}var k="function"===typeof c&&c.prototype||c;if(Object.hasOwnProperty.call(k,"hcEvents")){const c=k.hcEvents;b?(k=c[b]||[],f?(c[b]=k.filter(function(c){return f!==c.fn}),n(b,f)):(d(c),c[b]=[])):(d(c),delete k.hcEvents);}}function d(c,b,f,d){f=f||{};if(r.createEvent&&
    	(c.dispatchEvent||c.fireEvent&&c!==a)){var n=r.createEvent("Events");n.initEvent(b,!0,!0);f=t(n,f);c.dispatchEvent?c.dispatchEvent(f):c.fireEvent(b,f);}else if(c.hcEvents){f.target||t(f,{preventDefault:function(){f.defaultPrevented=!0;},target:c,type:b});n=[];let d=c,K=!1;for(;d.hcEvents;)Object.hasOwnProperty.call(d,"hcEvents")&&d.hcEvents[b]&&(n.length&&(K=!0),n.unshift.apply(n,d.hcEvents[b])),d=Object.getPrototypeOf(d);K&&n.sort((c,b)=>c.order-b.order);n.forEach(b=>{!1===b.fn.call(c,f)&&f.preventDefault();});}d&&
    	!f.defaultPrevented&&d.call(c,f);}const {charts:k,doc:r,win:q}=a;(x||(x={})).messages=[];Math.easeInOutSine=function(c){return -.5*(Math.cos(Math.PI*c)-1)};var G=Array.prototype.find?function(c,b){return c.find(b)}:function(c,b){let f;const n=c.length;for(f=0;f<n;f++)if(b(c[f],f))return c[f]};E({map:"map",each:"forEach",grep:"filter",reduce:"reduce",some:"some"},function(c,b){a[b]=function(f){x(32,!1,void 0,{[`Highcharts.${b}`]:`use Array.${c}`});return Array.prototype[c].apply(f,[].slice.call(arguments,
    	1))};});let b;const f=function(){const c=Math.random().toString(36).substring(2,9)+"-";let f=0;return function(){return "highcharts-"+(b?"":c)+f++}}();q.jQuery&&(q.jQuery.fn.highcharts=function(){const c=[].slice.call(arguments);if(this[0])return c[0]?(new (a[L(c[0])?c.shift():"Chart"])(this[0],c[0],c[1]),this):k[l(this[0],"data-highcharts-chart")]});G={addEvent:function(c,b,f,d={}){var n="function"===typeof c&&c.prototype||c;Object.hasOwnProperty.call(n,"hcEvents")||(n.hcEvents={});n=n.hcEvents;a.Point&&
    	c instanceof a.Point&&c.series&&c.series.chart&&(c.series.chart.runTrackerClick=!0);const k=c.addEventListener;k&&k.call(c,b,f,a.supportsPassiveEvents?{passive:void 0===d.passive?-1!==b.indexOf("touch"):d.passive,capture:!1}:!1);n[b]||(n[b]=[]);n[b].push({fn:f,order:"number"===typeof d.order?d.order:Infinity});n[b].sort((c,b)=>c.order-b.order);return function(){F(c,b,f);}},arrayMax:function(c){let b=c.length,f=c[0];for(;b--;)c[b]>f&&(f=c[b]);return f},arrayMin:function(c){let b=c.length,f=c[0];for(;b--;)c[b]<
    	f&&(f=c[b]);return f},attr:l,clamp:function(c,b,f){return c>b?c<f?c:f:b},clearTimeout:function(c){v(c)&&clearTimeout(c);},correctFloat:e,createElement:function(c,b,f,d,K){c=r.createElement(c);b&&t(c,b);K&&h(c,{padding:"0",border:"none",margin:"0"});f&&h(c,f);d&&d.appendChild(c);return c},css:h,defined:v,destroyObjectProperties:function(c,b){E(c,function(f,n){f&&f!==b&&f.destroy&&f.destroy();delete c[n];});},diffObjects:function(c,b,f,d){function n(b,c,K,k){const A=f?c:b;E(b,function(f,q){if(!k&&d&&-1<
    	d.indexOf(q)&&c[q]){f=p(f);K[q]=[];for(let b=0;b<Math.max(f.length,c[q].length);b++)c[q][b]&&(void 0===f[b]?K[q][b]=c[q][b]:(K[q][b]={},n(f[b],c[q][b],K[q][b],k+1)));}else if(z(f,!0)&&!f.nodeType)K[q]=C(f)?[]:{},n(f,c[q]||{},K[q],k+1),0!==Object.keys(K[q]).length||"colorAxis"===q&&0===k||delete K[q];else if(b[q]!==c[q]||q in b&&!(q in c))K[q]=A[q];});}const k={};n(c,b,k,0);return k},discardElement:function(b){b&&b.parentElement&&b.parentElement.removeChild(b);},erase:function(b,f){let c=b.length;for(;c--;)if(b[c]===
    	f){b.splice(c,1);break}},error:x,extend:t,extendClass:function(b,f){const c=function(){};c.prototype=new b;t(c.prototype,f);return c},find:G,fireEvent:d,getClosestDistance:function(b,f){const c=!f;let d,k,q;b.forEach(b=>{if(1<b.length)for(q=b.length-1;0<q;q--)k=b[q]-b[q-1],0>k&&!c?(null===f||void 0===f?void 0:f(),f=void 0):k&&("undefined"===typeof d||k<d)&&(d=k);});return d},getMagnitude:g,getNestedProperty:function(b,f){for(b=b.split(".");b.length&&v(f);){const c=b.shift();if("undefined"===typeof c||
    	"__proto__"===c)return;if("this"===c){let b;z(f)&&(b=f["@this"]);return null!==b&&void 0!==b?b:f}f=f[c];if(!v(f)||"function"===typeof f||"number"===typeof f.nodeType||f===q)return}return f},getStyle:w,inArray:function(b,f,d){x(32,!1,void 0,{"Highcharts.inArray":"use Array.indexOf"});return f.indexOf(b,d)},insertItem:function(b,f){const c=b.options.index,d=f.length;let n;for(n=b.options.isInternal?d:0;n<d+1;n++)if(!f[n]||u(c)&&c<m(f[n].options.index,f[n]._i)||f[n].options.isInternal){f.splice(n,0,
    	b);break}return n},isArray:C,isClass:B,isDOMElement:H,isFunction:function(b){return "function"===typeof b},isNumber:u,isObject:z,isString:L,keys:function(b){x(32,!1,void 0,{"Highcharts.keys":"use Object.keys"});return Object.keys(b)},merge:function(){let b,f=arguments,d={};const k=function(b,c){"object"!==typeof b&&(b={});E(c,function(f,d){"__proto__"!==d&&"constructor"!==d&&(!z(f,!0)||B(f)||H(f)?b[d]=c[d]:b[d]=k(b[d]||{},f));});return b};!0===f[0]&&(d=f[1],f=Array.prototype.slice.call(f,2));const K=
    	f.length;for(b=0;b<K;b++)d=k(d,f[b]);return d},normalizeTickInterval:function(b,f,d,k,K){let c=b;d=m(d,g(b));const n=b/d;f||(f=K?[1,1.2,1.5,2,2.5,3,4,5,6,8,10]:[1,2,2.5,5,10],!1===k&&(1===d?f=f.filter(function(b){return 0===b%1}):.1>=d&&(f=[1/d])));for(k=0;k<f.length&&!(c=f[k],K&&c*d>=b||!K&&n<=(f[k]+(f[k+1]||f[k]))/2);k++);return c=e(c*d,-Math.round(Math.log(.001)/Math.LN10))},objectEach:E,offset:function(b){const c=r.documentElement;b=b.parentElement||b.parentNode?b.getBoundingClientRect():{top:0,
    	left:0,width:0,height:0};return {top:b.top+(q.pageYOffset||c.scrollTop)-(c.clientTop||0),left:b.left+(q.pageXOffset||c.scrollLeft)-(c.clientLeft||0),width:b.width,height:b.height}},pad:function(b,f,d){return Array((f||2)+1-String(b).replace("-","").length).join(d||"0")+b},pick:m,pInt:I,pushUnique:function(b,f){return 0>b.indexOf(f)&&!!b.push(f)},relativeLength:function(b,f,d){return /%$/.test(b)?f*parseFloat(b)/100+(d||0):parseFloat(b)},removeEvent:F,splat:p,stableSort:function(b,f){const c=b.length;
    	let d,k;for(k=0;k<c;k++)b[k].safeI=k;b.sort(function(b,c){d=f(b,c);return 0===d?b.safeI-c.safeI:d});for(k=0;k<c;k++)delete b[k].safeI;},syncTimeout:function(b,f,d){if(0<f)return setTimeout(b,f,d);b.call(0,d);return -1},timeUnits:{millisecond:1,second:1E3,minute:6E4,hour:36E5,day:864E5,week:6048E5,month:24192E5,year:314496E5},uniqueKey:f,useSerialIds:function(c){return b=m(c,b)},wrap:function(b,f,d){const c=b[f];b[f]=function(){const b=arguments,f=this;return d.apply(this,[function(){return c.apply(f,
    	arguments.length?arguments:b)}].concat([].slice.call(arguments)))};}};return G});M(a,"Core/Chart/ChartDefaults.js",[],function(){return {alignThresholds:!1,panning:{enabled:!1,type:"x"},styledMode:!1,borderRadius:0,colorCount:10,allowMutatingData:!0,ignoreHiddenSeries:!0,spacing:[10,10,15,10],resetZoomButton:{theme:{zIndex:6},position:{align:"right",x:-10,y:10}},reflow:!0,type:"line",zooming:{singleTouch:!1,resetButton:{theme:{zIndex:6},position:{align:"right",x:-10,y:10}}},width:null,height:null,
    	borderColor:"#334eff",backgroundColor:"#ffffff",plotBorderColor:"#cccccc"}});M(a,"Core/Color/Color.js",[a["Core/Globals.js"],a["Core/Utilities.js"]],function(a,y){const {isNumber:x,merge:L,pInt:C}=y;class z{static parse(a){return a?new z(a):z.None}constructor(x){this.rgba=[NaN,NaN,NaN,NaN];this.input=x;const B=a.Color;if(B&&B!==z)return new B(x);this.init(x);}init(a){let B;let u;if("object"===typeof a&&"undefined"!==typeof a.stops)this.stops=a.stops.map(l=>new z(l[1]));else if("string"===typeof a){this.input=
    	a=z.names[a.toLowerCase()]||a;if("#"===a.charAt(0)){var v=a.length;var l=parseInt(a.substr(1),16);7===v?B=[(l&16711680)>>16,(l&65280)>>8,l&255,1]:4===v&&(B=[(l&3840)>>4|(l&3840)>>8,(l&240)>>4|l&240,(l&15)<<4|l&15,1]);}if(!B)for(l=z.parsers.length;l--&&!B;)u=z.parsers[l],(v=u.regex.exec(a))&&(B=u.parse(v));}B&&(this.rgba=B);}get(a){const B=this.input,u=this.rgba;if("object"===typeof B&&"undefined"!==typeof this.stops){const v=L(B);v.stops=[].slice.call(v.stops);this.stops.forEach((l,p)=>{v.stops[p]=[v.stops[p][0],
    	l.get(a)];});return v}return u&&x(u[0])?"rgb"===a||!a&&1===u[3]?"rgb("+u[0]+","+u[1]+","+u[2]+")":"a"===a?`${u[3]}`:"rgba("+u.join(",")+")":B}brighten(a){const B=this.rgba;if(this.stops)this.stops.forEach(function(u){u.brighten(a);});else if(x(a)&&0!==a)for(let u=0;3>u;u++)B[u]+=C(255*a),0>B[u]&&(B[u]=0),255<B[u]&&(B[u]=255);return this}setOpacity(a){this.rgba[3]=a;return this}tweenTo(a,B){const u=this.rgba,v=a.rgba;if(!x(u[0])||!x(v[0]))return a.input||"none";a=1!==v[3]||1!==u[3];return (a?"rgba(":
    	"rgb(")+Math.round(v[0]+(u[0]-v[0])*(1-B))+","+Math.round(v[1]+(u[1]-v[1])*(1-B))+","+Math.round(v[2]+(u[2]-v[2])*(1-B))+(a?","+(v[3]+(u[3]-v[3])*(1-B)):"")+")"}}z.names={white:"#ffffff",black:"#000000"};z.parsers=[{regex:/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,parse:function(a){return [C(a[1]),C(a[2]),C(a[3]),parseFloat(a[4],10)]}},{regex:/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,parse:function(a){return [C(a[1]),C(a[2]),
    	C(a[3]),1]}}];z.None=new z("");return z});M(a,"Core/Color/Palettes.js",[],function(){return {colors:"#2caffe #544fc5 #00e272 #fe6a35 #6b8abc #d568fb #2ee0ca #fa4b42 #feb56a #91e8e1".split(" ")}});M(a,"Core/Time.js",[a["Core/Globals.js"],a["Core/Utilities.js"]],function(a,y){const {win:x}=a,{defined:L,error:C,extend:z,isObject:H,merge:B,objectEach:u,pad:v,pick:l,splat:p,timeUnits:t}=y,m=a.isSafari&&x.Intl&&x.Intl.DateTimeFormat.prototype.formatRange,h=a.isSafari&&x.Intl&&!x.Intl.DateTimeFormat.prototype.formatRange;
    	class g{constructor(e){this.options={};this.variableTimezone=this.useUTC=!1;this.Date=x.Date;this.getTimezoneOffset=this.timezoneOffsetFunction();this.update(e);}get(e,g){if(this.variableTimezone||this.timezoneOffset){const h=g.getTime(),m=h-this.getTimezoneOffset(g);g.setTime(m);e=g["getUTC"+e]();g.setTime(h);return e}return this.useUTC?g["getUTC"+e]():g["get"+e]()}set(e,g,h){if(this.variableTimezone||this.timezoneOffset){if("Milliseconds"===e||"Seconds"===e||"Minutes"===e&&0===this.getTimezoneOffset(g)%
    	36E5)return g["setUTC"+e](h);var w=this.getTimezoneOffset(g);w=g.getTime()-w;g.setTime(w);g["setUTC"+e](h);e=this.getTimezoneOffset(g);w=g.getTime()+e;return g.setTime(w)}return this.useUTC||m&&"FullYear"===e?g["setUTC"+e](h):g["set"+e](h)}update(e={}){const g=l(e.useUTC,!0);this.options=e=B(!0,this.options,e);this.Date=e.Date||x.Date||Date;this.timezoneOffset=(this.useUTC=g)&&e.timezoneOffset||void 0;this.getTimezoneOffset=this.timezoneOffsetFunction();this.variableTimezone=g&&!(!e.getTimezoneOffset&&
    	!e.timezone);}makeTime(e,g,m,p,d,k){let r,q,w;this.useUTC?(r=this.Date.UTC.apply(0,arguments),q=this.getTimezoneOffset(r),r+=q,w=this.getTimezoneOffset(r),q!==w?r+=w-q:q-36E5!==this.getTimezoneOffset(r-36E5)||h||(r-=36E5)):r=(new this.Date(e,g,l(m,1),l(p,0),l(d,0),l(k,0))).getTime();return r}timezoneOffsetFunction(){const e=this,g=this.options,h=g.getTimezoneOffset,m=g.moment||x.moment;if(!this.useUTC)return function(d){return 6E4*(new Date(d.toString())).getTimezoneOffset()};if(g.timezone){if(m)return function(d){return 6E4*
    	-m.tz(d,g.timezone).utcOffset()};C(25);}return this.useUTC&&h?function(d){return 6E4*h(d.valueOf())}:function(){return 6E4*(e.timezoneOffset||0)}}dateFormat(e,g,h){if(!L(g)||isNaN(g))return a.defaultOptions.lang&&a.defaultOptions.lang.invalidDate||"";e=l(e,"%Y-%m-%d %H:%M:%S");const m=this;var d=new this.Date(g);const k=this.get("Hours",d),r=this.get("Day",d),q=this.get("Date",d),w=this.get("Month",d),b=this.get("FullYear",d),f=a.defaultOptions.lang,c=f&&f.weekdays,n=f&&f.shortWeekdays;d=z({a:n?n[r]:
    	c[r].substr(0,3),A:c[r],d:v(q),e:v(q,2," "),w:r,b:f.shortMonths[w],B:f.months[w],m:v(w+1),o:w+1,y:b.toString().substr(2,2),Y:b,H:v(k),k,I:v(k%12||12),l:k%12||12,M:v(this.get("Minutes",d)),p:12>k?"AM":"PM",P:12>k?"am":"pm",S:v(d.getSeconds()),L:v(Math.floor(g%1E3),3)},a.dateFormats);u(d,function(b,c){for(;-1!==e.indexOf("%"+c);)e=e.replace("%"+c,"function"===typeof b?b.call(m,g):b);});return h?e.substr(0,1).toUpperCase()+e.substr(1):e}resolveDTLFormat(e){return H(e,!0)?e:(e=p(e),{main:e[0],from:e[1],
    	to:e[2]})}getTimeTicks(e,g,h,m){const d=this,k=[],r={};var q=new d.Date(g);const w=e.unitRange,b=e.count||1;let f;m=l(m,1);if(L(g)){d.set("Milliseconds",q,w>=t.second?0:b*Math.floor(d.get("Milliseconds",q)/b));w>=t.second&&d.set("Seconds",q,w>=t.minute?0:b*Math.floor(d.get("Seconds",q)/b));w>=t.minute&&d.set("Minutes",q,w>=t.hour?0:b*Math.floor(d.get("Minutes",q)/b));w>=t.hour&&d.set("Hours",q,w>=t.day?0:b*Math.floor(d.get("Hours",q)/b));w>=t.day&&d.set("Date",q,w>=t.month?1:Math.max(1,b*Math.floor(d.get("Date",
    	q)/b)));if(w>=t.month){d.set("Month",q,w>=t.year?0:b*Math.floor(d.get("Month",q)/b));var c=d.get("FullYear",q);}w>=t.year&&d.set("FullYear",q,c-c%b);w===t.week&&(c=d.get("Day",q),d.set("Date",q,d.get("Date",q)-c+m+(c<m?-7:0)));c=d.get("FullYear",q);m=d.get("Month",q);const n=d.get("Date",q),e=d.get("Hours",q);g=q.getTime();!d.variableTimezone&&d.useUTC||!L(h)||(f=h-g>4*t.month||d.getTimezoneOffset(g)!==d.getTimezoneOffset(h));g=q.getTime();for(q=1;g<h;)k.push(g),g=w===t.year?d.makeTime(c+q*b,0):w===
    	t.month?d.makeTime(c,m+q*b):!f||w!==t.day&&w!==t.week?f&&w===t.hour&&1<b?d.makeTime(c,m,n,e+q*b):g+w*b:d.makeTime(c,m,n+q*b*(w===t.day?1:7)),q++;k.push(g);w<=t.hour&&1E4>k.length&&k.forEach(function(b){0===b%18E5&&"000000000"===d.dateFormat("%H%M%S%L",b)&&(r[b]="day");});}k.info=z(e,{higherRanks:r,totalRange:w*b});return k}getDateFormat(e,g,h,m){const d=this.dateFormat("%m-%d %H:%M:%S.%L",g),k={millisecond:15,second:12,minute:9,hour:6,day:3};let r,q="millisecond";for(r in t){if(e===t.week&&+this.dateFormat("%w",
    	g)===h&&"00:00:00.000"===d.substr(6)){r="week";break}if(t[r]>e){r=q;break}if(k[r]&&d.substr(k[r])!=="01-01 00:00:00.000".substr(k[r]))break;"week"!==r&&(q=r);}return this.resolveDTLFormat(m[r]).main}}return g});M(a,"Core/Defaults.js",[a["Core/Chart/ChartDefaults.js"],a["Core/Color/Color.js"],a["Core/Globals.js"],a["Core/Color/Palettes.js"],a["Core/Time.js"],a["Core/Utilities.js"]],function(a,y,I,L,C,z){const {isTouchDevice:x,svg:B}=I,{merge:u}=z,v={colors:L.colors,symbols:["circle","diamond","square",
    	"triangle","triangle-down"],lang:{loading:"Loading...",months:"January February March April May June July August September October November December".split(" "),shortMonths:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),weekdays:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),decimalPoint:".",numericSymbols:"kMGTPE".split(""),resetZoom:"Reset zoom",resetZoomTitle:"Reset zoom level 1:1",thousandsSep:" "},global:{},time:{Date:void 0,getTimezoneOffset:void 0,timezone:void 0,
    	timezoneOffset:0,useUTC:!0},chart:a,title:{style:{color:"#333333",fontWeight:"bold"},text:"Chart title",align:"center",margin:15,widthAdjust:-44},subtitle:{style:{color:"#666666",fontSize:"0.8em"},text:"",align:"center",widthAdjust:-44},caption:{margin:15,style:{color:"#666666",fontSize:"0.8em"},text:"",align:"left",verticalAlign:"bottom"},plotOptions:{},legend:{enabled:!0,align:"center",alignColumns:!0,className:"highcharts-no-tooltip",layout:"horizontal",itemMarginBottom:2,itemMarginTop:2,labelFormatter:function(){return this.name},
    	borderColor:"#999999",borderRadius:0,navigation:{style:{fontSize:"0.8em"},activeColor:"#0022ff",inactiveColor:"#cccccc"},itemStyle:{color:"#333333",cursor:"pointer",fontSize:"0.8em",textDecoration:"none",textOverflow:"ellipsis"},itemHoverStyle:{color:"#000000"},itemHiddenStyle:{color:"#666666",textDecoration:"line-through"},shadow:!1,itemCheckboxStyle:{position:"absolute",width:"13px",height:"13px"},squareSymbol:!0,symbolPadding:5,verticalAlign:"bottom",x:0,y:0,title:{style:{fontSize:"0.8em",fontWeight:"bold"}}},
    	loading:{labelStyle:{fontWeight:"bold",position:"relative",top:"45%"},style:{position:"absolute",backgroundColor:"#ffffff",opacity:.5,textAlign:"center"}},tooltip:{enabled:!0,animation:B,borderRadius:3,dateTimeLabelFormats:{millisecond:"%A, %e %b, %H:%M:%S.%L",second:"%A, %e %b, %H:%M:%S",minute:"%A, %e %b, %H:%M",hour:"%A, %e %b, %H:%M",day:"%A, %e %b %Y",week:"Week from %A, %e %b %Y",month:"%B %Y",year:"%Y"},footerFormat:"",headerShape:"callout",hideDelay:500,padding:8,shape:"callout",shared:!1,
    	snap:x?25:10,headerFormat:'<span style="font-size: 0.8em">{point.key}</span><br/>',pointFormat:'<span style="color:{point.color}">\u25cf</span> {series.name}: <b>{point.y}</b><br/>',backgroundColor:"#ffffff",borderWidth:void 0,shadow:!0,stickOnContact:!1,style:{color:"#333333",cursor:"default",fontSize:"0.8em"},useHTML:!1},credits:{enabled:!0,href:"https://www.highcharts.com?credits",position:{align:"right",x:-10,verticalAlign:"bottom",y:-5},style:{cursor:"pointer",color:"#999999",fontSize:"0.6em"},
    	text:"Highcharts.com"}};v.chart.styledMode=!1;const l=new C(v.time);a={defaultOptions:v,defaultTime:l,getOptions:function(){return v},setOptions:function(a){u(!0,v,a);if(a.time||a.global)I.time?I.time.update(u(v.global,v.time,a.global,a.time)):I.time=l;return v}};return a});M(a,"Core/Animation/Fx.js",[a["Core/Color/Color.js"],a["Core/Globals.js"],a["Core/Utilities.js"]],function(a,y,I){const {parse:x}=a,{win:C}=y,{isNumber:z,objectEach:H}=I;class B{constructor(a,v,l){this.pos=NaN;this.options=
    	v;this.elem=a;this.prop=l;}dSetter(){var a=this.paths;const v=a&&a[0];a=a&&a[1];const l=this.now||0;let p=[];if(1!==l&&v&&a)if(v.length===a.length&&1>l)for(let t=0;t<a.length;t++){const m=v[t],h=a[t],g=[];for(let e=0;e<h.length;e++){const w=m[e],a=h[e];z(w)&&z(a)&&("A"!==h[0]||4!==e&&5!==e)?g[e]=w+l*(a-w):g[e]=a;}p.push(g);}else p=a;else p=this.toD||[];this.elem.attr("d",p,void 0,!0);}update(){const a=this.elem,v=this.prop,l=this.now,p=this.options.step;if(this[v+"Setter"])this[v+"Setter"]();else a.attr?
    	a.element&&a.attr(v,l,null,!0):a.style[v]=l+this.unit;p&&p.call(a,l,this);}run(a,v,l){const p=this,t=p.options,m=function(e){return m.stopped?!1:p.step(e)},h=C.requestAnimationFrame||function(e){setTimeout(e,13);},g=function(){for(let e=0;e<B.timers.length;e++)B.timers[e]()||B.timers.splice(e--,1);B.timers.length&&h(g);};a!==v||this.elem["forceAnimate:"+this.prop]?(this.startTime=+new Date,this.start=a,this.end=v,this.unit=l,this.now=this.start,this.pos=0,m.elem=this.elem,m.prop=this.prop,m()&&1===B.timers.push(m)&&
    	h(g)):(delete t.curAnim[this.prop],t.complete&&0===Object.keys(t.curAnim).length&&t.complete.call(this.elem));}step(a){const v=+new Date,l=this.options,p=this.elem,t=l.complete,m=l.duration,h=l.curAnim;let g;p.attr&&!p.element?a=!1:a||v>=m+this.startTime?(this.now=this.end,this.pos=1,this.update(),g=h[this.prop]=!0,H(h,function(e){!0!==e&&(g=!1);}),g&&t&&t.call(p),a=!1):(this.pos=l.easing((v-this.startTime)/m),this.now=this.start+(this.end-this.start)*this.pos,this.update(),a=!0);return a}initPath(a,
    	v,l){function p(d,k){for(;d.length<E;){var r=d[0];const q=k[E-d.length];q&&"M"===r[0]&&(d[0]="C"===q[0]?["C",r[1],r[2],r[1],r[2],r[1],r[2]]:["L",r[1],r[2]]);d.unshift(r);g&&(r=d.pop(),d.push(d[d.length-1],r));}}function t(d,k){for(;d.length<E;)if(k=d[Math.floor(d.length/e)-1].slice(),"C"===k[0]&&(k[1]=k[5],k[2]=k[6]),g){const r=d[Math.floor(d.length/e)].slice();d.splice(d.length/2,0,k,r);}else d.push(k);}const m=a.startX,h=a.endX;l=l.slice();const g=a.isArea,e=g?2:1;let w,E,F;v=v&&v.slice();if(!v)return [l,
    	l];if(m&&h&&h.length){for(a=0;a<m.length;a++)if(m[a]===h[0]){w=a;break}else if(m[0]===h[h.length-m.length+a]){w=a;F=!0;break}else if(m[m.length-1]===h[h.length-m.length+a]){w=m.length-a;break}"undefined"===typeof w&&(v=[]);}v.length&&z(w)&&(E=l.length+w*e,F?(p(v,l),t(l,v)):(p(l,v),t(v,l)));return [v,l]}fillSetter(){B.prototype.strokeSetter.apply(this,arguments);}strokeSetter(){this.elem.attr(this.prop,x(this.start).tweenTo(x(this.end),this.pos),void 0,!0);}}B.timers=[];return B});M(a,"Core/Animation/AnimationUtilities.js",
    	[a["Core/Animation/Fx.js"],a["Core/Utilities.js"]],function(a,y){function x(a){return u(a)?v({duration:500,defer:0},a):{duration:a?500:0,defer:0}}function L(l,m){let h=a.timers.length;for(;h--;)a.timers[h].elem!==l||m&&m!==a.timers[h].prop||(a.timers[h].stopped=!0);}const {defined:C,getStyle:z,isArray:H,isNumber:B,isObject:u,merge:v,objectEach:l,pick:p}=y;return {animate:function(p,m,h){let g,e="",w,E,F;u(h)||(F=arguments,h={duration:F[2],easing:F[3],complete:F[4]});B(h.duration)||(h.duration=400);
    	h.easing="function"===typeof h.easing?h.easing:Math[h.easing]||Math.easeInOutSine;h.curAnim=v(m);l(m,function(d,k){L(p,k);E=new a(p,h,k);w=void 0;"d"===k&&H(m.d)?(E.paths=E.initPath(p,p.pathArray,m.d),E.toD=m.d,g=0,w=1):p.attr?g=p.attr(k):(g=parseFloat(z(p,k))||0,"opacity"!==k&&(e="px"));w||(w=d);"string"===typeof w&&w.match("px")&&(w=w.replace(/px/g,""));E.run(g,w,e);});},animObject:x,getDeferredAnimation:function(a,m,h){const g=x(m);let e=0,w=0;(h?[h]:a.series).forEach(h=>{h=x(h.options.animation);
    	e=m&&C(m.defer)?g.defer:Math.max(e,h.duration+h.defer);w=Math.min(g.duration,h.duration);});a.renderer.forExport&&(e=0);return {defer:Math.max(0,e-w),duration:Math.min(e,w)}},setAnimation:function(a,m){m.renderer.globalAnimation=p(a,m.options.chart.animation,!0);},stop:L}});M(a,"Core/Renderer/HTML/AST.js",[a["Core/Globals.js"],a["Core/Utilities.js"]],function(a,y){const {SVG_NS:x,win:L}=a,{attr:C,createElement:z,css:H,error:B,isFunction:u,isString:v,objectEach:l,splat:p}=y;({trustedTypes:y}=L);const t=
    	y&&u(y.createPolicy)&&y.createPolicy("highcharts",{createHTML:e=>e});y=t?t.createHTML(""):"";try{var m=!!(new DOMParser).parseFromString(y,"text/html");}catch(e){m=!1;}const h=m;class g{static filterUserAttributes(e){l(e,(h,m)=>{let a=!0;-1===g.allowedAttributes.indexOf(m)&&(a=!1);-1!==["background","dynsrc","href","lowsrc","src"].indexOf(m)&&(a=v(h)&&g.allowedReferences.some(d=>0===h.indexOf(d)));a||(B(33,!1,void 0,{"Invalid attribute in config":`${m}`}),delete e[m]);v(h)&&e[m]&&(e[m]=h.replace(/</g,
    	"&lt;"));});return e}static parseStyle(e){return e.split(";").reduce((e,g)=>{g=g.split(":").map(d=>d.trim());const h=g.shift();h&&g.length&&(e[h.replace(/-([a-z])/g,d=>d[1].toUpperCase())]=g.join(":"));return e},{})}static setElementHTML(e,h){e.innerHTML=g.emptyHTML;h&&(new g(h)).addToDOM(e);}constructor(e){this.nodes="string"===typeof e?this.parseMarkup(e):e;}addToDOM(e){function h(e,m){let d;p(e).forEach(function(k){var e=k.tagName;const q=k.textContent?a.doc.createTextNode(k.textContent):void 0,w=
    	g.bypassHTMLFiltering;let b;if(e)if("#text"===e)b=q;else if(-1!==g.allowedTags.indexOf(e)||w){e=a.doc.createElementNS("svg"===e?x:m.namespaceURI||x,e);const f=k.attributes||{};l(k,function(b,d){"tagName"!==d&&"attributes"!==d&&"children"!==d&&"style"!==d&&"textContent"!==d&&(f[d]=b);});C(e,w?f:g.filterUserAttributes(f));k.style&&H(e,k.style);q&&e.appendChild(q);h(k.children||[],e);b=e;}else B(33,!1,void 0,{"Invalid tagName in config":e});b&&m.appendChild(b);d=b;});return d}return h(this.nodes,e)}parseMarkup(e){const m=
    	[];e=e.trim().replace(/ style=(["'])/g," data-style=$1");if(h)e=(new DOMParser).parseFromString(t?t.createHTML(e):e,"text/html");else {const g=z("div");g.innerHTML=e;e={body:g};}const a=(e,d)=>{var k=e.nodeName.toLowerCase();const r={tagName:k};"#text"===k&&(r.textContent=e.textContent||"");if(k=e.attributes){const d={};[].forEach.call(k,k=>{"data-style"===k.name?r.style=g.parseStyle(k.value):d[k.name]=k.value;});r.attributes=d;}if(e.childNodes.length){const d=[];[].forEach.call(e.childNodes,k=>{a(k,
    	d);});d.length&&(r.children=d);}d.push(r);};[].forEach.call(e.body.childNodes,e=>a(e,m));return m}}g.allowedAttributes="alt aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill flood-color flood-opacity height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align text-anchor textAnchor textLength title type valign width x x1 x2 xlink:href y y1 y2 zIndex".split(" ");
    	g.allowedReferences="https:// http:// mailto: / ../ ./ #".split(" ");g.allowedTags="a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feDropShadow feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text textPath thead title tbody tspan td th tr u ul #text".split(" ");g.emptyHTML=y;g.bypassHTMLFiltering=
    	!1;return g});M(a,"Core/Templating.js",[a["Core/Defaults.js"],a["Core/Utilities.js"]],function(a,y){function x(h="",g,e){const a=/\{([a-zA-Z0-9:\.,;\-\/<>%_@"'= #\(\)]+)\}/g,l=/\(([a-zA-Z0-9:\.,;\-\/<>%_@"'= ]+)\)/g,v=[],d=/f$/,k=/\.([0-9])/,r=C.lang,q=e&&e.time||z,G=e&&e.numberFormatter||L,b=(b="")=>{let c;return "true"===b?!0:"false"===b?!1:(c=Number(b)).toString()===b?c:B(b,g)};let f,c,n=0,P;for(;null!==(f=a.exec(h));){const b=l.exec(f[1]);b&&(f=b,P=!0);c&&c.isBlock||(c={ctx:g,expression:f[1],
    	find:f[0],isBlock:"#"===f[1].charAt(0),start:f.index,startInner:f.index+f[0].length,length:f[0].length});var D=f[1].split(" ")[0].replace("#","");m[D]&&(c.isBlock&&D===c.fn&&n++,c.fn||(c.fn=D));D="else"===f[1];if(c.isBlock&&c.fn&&(f[1]===`/${c.fn}`||D))if(n)D||n--;else {var K=c.startInner;K=h.substr(K,f.index-K);void 0===c.body?(c.body=K,c.startInner=f.index+f[0].length):c.elseBody=K;c.find+=K+f[0];D||(v.push(c),c=void 0);}else c.isBlock||v.push(c);if(b&&(null===c||void 0===c||!c.isBlock))break}v.forEach(c=>
    	{const {body:f,elseBody:n,expression:K,fn:e}=c;var A;if(e){var a=[c],w=K.split(" ");for(A=m[e].length;A--;)a.unshift(b(w[A+1]));A=m[e].apply(g,a);c.isBlock&&"boolean"===typeof A&&(A=x(A?f:n,g));}else a=K.split(":"),A=b(a.shift()||""),a.length&&"number"===typeof A&&(a=a.join(":"),d.test(a)?(w=parseInt((a.match(k)||["","-1"])[1],10),null!==A&&(A=G(A,w,r.decimalPoint,-1<a.indexOf(",")?r.thousandsSep:""))):A=q.dateFormat(a,A));h=h.replace(c.find,p(A,""));});return P?x(h,g,e):h}function L(h,g,e,a){h=+h||
    	0;g=+g;const m=C.lang;var w=(h.toString().split(".")[1]||"").split("e")[0].length;const d=h.toString().split("e"),k=g;if(-1===g)g=Math.min(w,20);else if(!v(g))g=2;else if(g&&d[1]&&0>d[1]){var r=g+ +d[1];0<=r?(d[0]=(+d[0]).toExponential(r).split("e")[0],g=r):(d[0]=d[0].split(".")[0]||0,h=20>g?(d[0]*Math.pow(10,d[1])).toFixed(g):0,d[1]=0);}r=(Math.abs(d[1]?d[0]:h)+Math.pow(10,-Math.max(g,w)-1)).toFixed(g);w=String(t(r));const q=3<w.length?w.length%3:0;e=p(e,m.decimalPoint);a=p(a,m.thousandsSep);h=(0>
    	h?"-":"")+(q?w.substr(0,q)+a:"");h=0>+d[1]&&!k?"0":h+w.substr(q).replace(/(\d{3})(?=\d)/g,"$1"+a);g&&(h+=e+r.slice(-g));d[1]&&0!==+h&&(h+="e"+d[1]);return h}const {defaultOptions:C,defaultTime:z}=a,{extend:H,getNestedProperty:B,isArray:u,isNumber:v,isObject:l,pick:p,pInt:t}=y,m={add:(h,g)=>h+g,divide:(h,g)=>0!==g?h/g:"",eq:(h,g)=>h==g,each:function(h){const g=arguments[arguments.length-1];return u(h)?h.map((e,a)=>x(g.body,H(l(e)?e:{"@this":e},{"@index":a,"@first":0===a,"@last":a===h.length-1}))).join(""):
    	!1},ge:(h,g)=>h>=g,gt:(h,g)=>h>g,"if":h=>!!h,le:(h,g)=>h<=g,lt:(h,g)=>h<g,multiply:(h,g)=>h*g,ne:(h,g)=>h!=g,subtract:(h,g)=>h-g,unless:h=>!h};return {dateFormat:function(h,g,e){return z.dateFormat(h,g,e)},format:x,helpers:m,numberFormat:L}});M(a,"Core/Renderer/RendererUtilities.js",[a["Core/Utilities.js"]],function(a){const {clamp:x,pick:I,stableSort:L}=a;var C;(function(a){function y(a,u,v){const l=a;var p=l.reducedLen||u,t=(e,g)=>(g.rank||0)-(e.rank||0);const m=(e,g)=>e.target-g.target;let h,g=
    	!0,e=[],w=0;for(h=a.length;h--;)w+=a[h].size;if(w>p){L(a,t);for(w=h=0;w<=p;)w+=a[h].size,h++;e=a.splice(h-1,a.length);}L(a,m);for(a=a.map(e=>({size:e.size,targets:[e.target],align:I(e.align,.5)}));g;){for(h=a.length;h--;)p=a[h],t=(Math.min.apply(0,p.targets)+Math.max.apply(0,p.targets))/2,p.pos=x(t-p.size*p.align,0,u-p.size);h=a.length;for(g=!1;h--;)0<h&&a[h-1].pos+a[h-1].size>a[h].pos&&(a[h-1].size+=a[h].size,a[h-1].targets=a[h-1].targets.concat(a[h].targets),a[h-1].align=.5,a[h-1].pos+a[h-1].size>
    	u&&(a[h-1].pos=u-a[h-1].size),a.splice(h,1),g=!0);}l.push.apply(l,e);h=0;a.some(e=>{let g=0;return (e.targets||[]).some(()=>{l[h].pos=e.pos+g;if("undefined"!==typeof v&&Math.abs(l[h].pos-l[h].target)>v)return l.slice(0,h+1).forEach(d=>delete d.pos),l.reducedLen=(l.reducedLen||u)-.1*u,l.reducedLen>.1*u&&y(l,u,v),!0;g+=l[h].size;h++;return !1})});L(l,m);return l}a.distribute=y;})(C||(C={}));return C});M(a,"Core/Renderer/SVG/SVGElement.js",[a["Core/Animation/AnimationUtilities.js"],a["Core/Color/Color.js"],
    	a["Core/Globals.js"],a["Core/Utilities.js"]],function(a,y,I,L){const {animate:x,animObject:z,stop:H}=a,{deg2rad:B,doc:u,svg:v,SVG_NS:l,win:p}=I,{addEvent:t,attr:m,createElement:h,css:g,defined:e,erase:w,extend:E,fireEvent:F,isArray:d,isFunction:k,isObject:r,isString:q,merge:G,objectEach:b,pick:f,pInt:c,syncTimeout:n,uniqueKey:P}=L;class D{constructor(){this.element=void 0;this.onEvents={};this.opacity=1;this.renderer=void 0;this.SVG_NS=l;}_defaultGetter(b){b=f(this[b+"Value"],this[b],this.element?
    	this.element.getAttribute(b):null,0);/^[\-0-9\.]+$/.test(b)&&(b=parseFloat(b));return b}_defaultSetter(b,c,f){f.setAttribute(c,b);}add(b){const c=this.renderer,f=this.element;let d;b&&(this.parentGroup=b);"undefined"!==typeof this.textStr&&"text"===this.element.nodeName&&c.buildText(this);this.added=!0;if(!b||b.handleZ||this.zIndex)d=this.zIndexSetter();d||(b?b.element:c.box).appendChild(f);if(this.onAdd)this.onAdd();return this}addClass(b,c){const f=c?"":this.attr("class")||"";b=(b||"").split(/ /g).reduce(function(b,
    	c){-1===f.indexOf(c)&&b.push(c);return b},f?[f]:[]).join(" ");b!==f&&this.attr("class",b);return this}afterSetters(){this.doTransform&&(this.updateTransform(),this.doTransform=!1);}align(b,c,d){const k={};var n=this.renderer,e=n.alignedObjects,A;let K,g;if(b){if(this.alignOptions=b,this.alignByTranslate=c,!d||q(d))this.alignTo=A=d||"renderer",w(e,this),e.push(this),d=void 0;}else b=this.alignOptions,c=this.alignByTranslate,A=this.alignTo;d=f(d,n[A],"scrollablePlotBox"===A?n.plotBox:void 0,n);A=b.align;
    	const a=b.verticalAlign;n=(d.x||0)+(b.x||0);e=(d.y||0)+(b.y||0);"right"===A?K=1:"center"===A&&(K=2);K&&(n+=(d.width-(b.width||0))/K);k[c?"translateX":"x"]=Math.round(n);"bottom"===a?g=1:"middle"===a&&(g=2);g&&(e+=(d.height-(b.height||0))/g);k[c?"translateY":"y"]=Math.round(e);this[this.placed?"animate":"attr"](k);this.placed=!0;this.alignAttr=k;return this}alignSetter(b){const c={left:"start",center:"middle",right:"end"};c[b]&&(this.alignValue=b,this.element.setAttribute("text-anchor",c[b]));}animate(c,
    	d,k){const e=z(f(d,this.renderer.globalAnimation,!0));d=e.defer;u.hidden&&(e.duration=0);0!==e.duration?(k&&(e.complete=k),n(()=>{this.element&&x(this,c,e);},d)):(this.attr(c,void 0,k||e.complete),b(c,function(b,c){e.step&&e.step.call(this,b,{prop:c,pos:1,elem:this});},this));return this}applyTextOutline(b){const c=this.element;-1!==b.indexOf("contrast")&&(b=b.replace(/contrast/g,this.renderer.getContrast(c.style.fill)));var f=b.split(" ");b=f[f.length-1];if((f=f[0])&&"none"!==f&&I.svg){this.fakeTS=
    	!0;f=f.replace(/(^[\d\.]+)(.*?)$/g,function(b,c,f){return 2*Number(c)+f});this.removeTextOutline();const d=u.createElementNS(l,"tspan");m(d,{"class":"highcharts-text-outline",fill:b,stroke:b,"stroke-width":f,"stroke-linejoin":"round"});b=c.querySelector("textPath")||c;[].forEach.call(b.childNodes,b=>{const c=b.cloneNode(!0);c.removeAttribute&&["fill","stroke","stroke-width","stroke"].forEach(b=>c.removeAttribute(b));d.appendChild(c);});let k=0;[].forEach.call(b.querySelectorAll("text tspan"),b=>{k+=
    	Number(b.getAttribute("dy"));});f=u.createElementNS(l,"tspan");f.textContent="\u200b";m(f,{x:Number(c.getAttribute("x")),dy:-k});d.appendChild(f);b.insertBefore(d,b.firstChild);}}attr(c,f,d,k){const n=this.element,e=D.symbolCustomAttribs;let A,q,g=this,a,K;"string"===typeof c&&"undefined"!==typeof f&&(A=c,c={},c[A]=f);"string"===typeof c?g=(this[c+"Getter"]||this._defaultGetter).call(this,c,n):(b(c,function(b,f){a=!1;k||H(this,f);this.symbolName&&-1!==e.indexOf(f)&&(q||(this.symbolAttr(c),q=!0),a=!0);
    	!this.rotation||"x"!==f&&"y"!==f||(this.doTransform=!0);a||(K=this[f+"Setter"]||this._defaultSetter,K.call(this,b,f,n));},this),this.afterSetters());d&&d.call(this);return g}clip(b){return this.attr("clip-path",b?"url("+this.renderer.url+"#"+b.id+")":"none")}crisp(b,c){c=c||b.strokeWidth||0;const f=Math.round(c)%2/2;b.x=Math.floor(b.x||this.x||0)+f;b.y=Math.floor(b.y||this.y||0)+f;b.width=Math.floor((b.width||this.width||0)-2*f);b.height=Math.floor((b.height||this.height||0)-2*f);e(b.strokeWidth)&&
    	(b.strokeWidth=c);return b}complexColor(c,f,k){const n=this.renderer;let q,g,A,a,r,K,h,J,m,O,w=[],l;F(this.renderer,"complexColor",{args:arguments},function(){c.radialGradient?g="radialGradient":c.linearGradient&&(g="linearGradient");if(g){A=c[g];r=n.gradients;K=c.stops;m=k.radialReference;d(A)&&(c[g]=A={x1:A[0],y1:A[1],x2:A[2],y2:A[3],gradientUnits:"userSpaceOnUse"});"radialGradient"===g&&m&&!e(A.gradientUnits)&&(a=A,A=G(A,n.getRadialAttr(m,a),{gradientUnits:"userSpaceOnUse"}));b(A,function(b,c){"id"!==
    	c&&w.push(c,b);});b(K,function(b){w.push(b);});w=w.join(",");if(r[w])O=r[w].attr("id");else {A.id=O=P();const b=r[w]=n.createElement(g).attr(A).add(n.defs);b.radAttr=a;b.stops=[];K.forEach(function(c){0===c[1].indexOf("rgba")?(q=y.parse(c[1]),h=q.get("rgb"),J=q.get("a")):(h=c[1],J=1);c=n.createElement("stop").attr({offset:c[0],"stop-color":h,"stop-opacity":J}).add(b);b.stops.push(c);});}l="url("+n.url+"#"+O+")";k.setAttribute(f,l);k.gradient=w;c.toString=function(){return l};}});}css(f){const d=this.styles,
    	k={},n=this.element;let e,q=!d;d&&b(f,function(b,c){d&&d[c]!==b&&(k[c]=b,q=!0);});if(q){d&&(f=E(d,k));null===f.width||"auto"===f.width?delete this.textWidth:"text"===n.nodeName.toLowerCase()&&f.width&&(e=this.textWidth=c(f.width));this.styles=f;e&&!v&&this.renderer.forExport&&delete f.width;const b=G(f);n.namespaceURI===this.SVG_NS&&(["textOutline","textOverflow","width"].forEach(c=>b&&delete b[c]),b.color&&(b.fill=b.color));g(n,b);}this.added&&("text"===this.element.nodeName&&this.renderer.buildText(this),
    	f.textOutline&&this.applyTextOutline(f.textOutline));return this}dashstyleSetter(b){let d=this["stroke-width"];"inherit"===d&&(d=1);if(b=b&&b.toLowerCase()){const k=b.replace("shortdashdotdot","3,1,1,1,1,1,").replace("shortdashdot","3,1,1,1").replace("shortdot","1,1,").replace("shortdash","3,1,").replace("longdash","8,3,").replace(/dot/g,"1,3,").replace("dash","4,3,").replace(/,$/,"").split(",");for(b=k.length;b--;)k[b]=""+c(k[b])*f(d,NaN);b=k.join(",").replace(/NaN/g,"none");this.element.setAttribute("stroke-dasharray",
    	b);}}destroy(){const c=this;var f=c.element||{};const d=c.renderer;var k=f.ownerSVGElement;let n="SPAN"===f.nodeName&&c.parentGroup||void 0;f.onclick=f.onmouseout=f.onmouseover=f.onmousemove=f.point=null;H(c);if(c.clipPath&&k){const b=c.clipPath;[].forEach.call(k.querySelectorAll("[clip-path],[CLIP-PATH]"),function(c){-1<c.getAttribute("clip-path").indexOf(b.element.id)&&c.removeAttribute("clip-path");});c.clipPath=b.destroy();}if(c.stops){for(k=0;k<c.stops.length;k++)c.stops[k].destroy();c.stops.length=
    	0;c.stops=void 0;}for(c.safeRemoveChild(f);n&&n.div&&0===n.div.childNodes.length;)f=n.parentGroup,c.safeRemoveChild(n.div),delete n.div,n=f;c.alignTo&&w(d.alignedObjects,c);b(c,function(b,f){c[f]&&c[f].parentGroup===c&&c[f].destroy&&c[f].destroy();delete c[f];});}dSetter(b,c,f){d(b)&&("string"===typeof b[0]&&(b=this.renderer.pathToSegments(b)),this.pathArray=b,b=b.reduce((b,c,f)=>c&&c.join?(f?b+" ":"")+c.join(" "):(c||"").toString(),""));/(NaN| {2}|^$)/.test(b)&&(b="M 0 0");this[c]!==b&&(f.setAttribute(c,
    	b),this[c]=b);}fadeOut(b){const c=this;c.animate({opacity:0},{duration:f(b,150),complete:function(){c.hide();}});}fillSetter(b,c,f){"string"===typeof b?f.setAttribute(c,b):b&&this.complexColor(b,c,f);}getBBox(b,c){const {alignValue:d,element:n,renderer:q,styles:a,textStr:A}=this,{cache:r,cacheKeys:h}=q;var m=n.namespaceURI===this.SVG_NS;c=f(c,this.rotation,0);var K=q.styledMode?n&&D.prototype.getStyle.call(n,"font-size"):a&&a.fontSize;let J;let N;e(A)&&(N=A.toString(),-1===N.indexOf("<")&&(N=N.replace(/[0-9]/g,
    	"0")),N+=["",q.rootFontSize,K,c,this.textWidth,d,a&&a.textOverflow,a&&a.fontWeight].join());N&&!b&&(J=r[N]);if(!J){if(m||q.forExport){try{var O=this.fakeTS&&function(b){const c=n.querySelector(".highcharts-text-outline");c&&g(c,{display:b});};k(O)&&O("none");J=n.getBBox?E({},n.getBBox()):{width:n.offsetWidth,height:n.offsetHeight,x:0,y:0};k(O)&&O("");}catch(fa){}if(!J||0>J.width)J={x:0,y:0,width:0,height:0};}else J=this.htmlGetBBox();O=J.width;b=J.height;m&&(J.height=b={"11px,17":14,"13px,20":16}[`${K||
	""},${Math.round(b)}`]||b);if(c){m=Number(n.getAttribute("y")||0)-J.y;K={right:1,center:.5}[d||0]||0;var w=c*B,l=(c-90)*B,p=O*Math.cos(w);c=O*Math.sin(w);var G=Math.cos(l);w=Math.sin(l);O=J.x+K*(O-p)+m*G;l=O+p;G=l-b*G;p=G-p;m=J.y+m-K*c+m*w;K=m+c;b=K-b*w;c=b-c;J.x=Math.min(O,l,G,p);J.y=Math.min(m,K,b,c);J.width=Math.max(O,l,G,p)-J.x;J.height=Math.max(m,K,b,c)-J.y;}}if(N&&(""===A||0<J.height)){for(;250<h.length;)delete r[h.shift()];r[N]||h.push(N);r[N]=J;}return J}getStyle(b){return p.getComputedStyle(this.element||
    	this,"").getPropertyValue(b)}hasClass(b){return -1!==(""+this.attr("class")).split(" ").indexOf(b)}hide(){return this.attr({visibility:"hidden"})}htmlGetBBox(){return {height:0,width:0,x:0,y:0}}init(b,c){this.element="span"===c?h(c):u.createElementNS(this.SVG_NS,c);this.renderer=b;F(this,"afterInit");}on(b,c){const {onEvents:f}=this;if(f[b])f[b]();f[b]=t(this.element,b,c);return this}opacitySetter(b,c,f){this.opacity=b=Number(Number(b).toFixed(3));f.setAttribute(c,b);}removeClass(b){return this.attr("class",
    	(""+this.attr("class")).replace(q(b)?new RegExp(`(^| )${b}( |$)`):b," ").replace(/ +/g," ").trim())}removeTextOutline(){const b=this.element.querySelector("tspan.highcharts-text-outline");b&&this.safeRemoveChild(b);}safeRemoveChild(b){const c=b.parentNode;c&&c.removeChild(b);}setRadialReference(b){const c=this.element.gradient&&this.renderer.gradients[this.element.gradient];this.element.radialReference=b;c&&c.radAttr&&c.animate(this.renderer.getRadialAttr(b,c.radAttr));return this}setTextPath(b,c){c=
    	G(!0,{enabled:!0,attributes:{dy:-5,startOffset:"50%",textAnchor:"middle"}},c);const f=this.renderer.url,d=this.text||this,k=d.textPath,{attributes:n,enabled:A}=c;b=b||k&&k.path;k&&k.undo();b&&A?(c=t(d,"afterModifyTree",c=>{if(b&&A){let A=b.attr("id");A||b.attr("id",A=P());var k={x:0,y:0};e(n.dx)&&(k.dx=n.dx,delete n.dx);e(n.dy)&&(k.dy=n.dy,delete n.dy);d.attr(k);this.attr({transform:""});this.box&&(this.box=this.box.destroy());k=c.nodes.slice(0);c.nodes.length=0;c.nodes[0]={tagName:"textPath",attributes:E(n,
    	{"text-anchor":n.textAnchor,href:`${f}#${A}`}),children:k};}}),d.textPath={path:b,undo:c}):(d.attr({dx:0,dy:0}),delete d.textPath);this.added&&(d.textCache="",this.renderer.buildText(d));return this}shadow(b){var c;const {renderer:f}=this,d=G(90===(null===(c=this.parentGroup)||void 0===c?void 0:c.rotation)?{offsetX:-1,offsetY:-1}:{},r(b)?b:{});c=f.shadowDefinition(d);return this.attr({filter:b?`url(${f.url}#${c})`:"none"})}show(b=!0){return this.attr({visibility:b?"inherit":"visible"})}["stroke-widthSetter"](b,
    	c,f){this[c]=b;f.setAttribute(c,b);}strokeWidth(){if(!this.renderer.styledMode)return this["stroke-width"]||0;const b=this.getStyle("stroke-width");let f=0,d;b.indexOf("px")===b.length-2?f=c(b):""!==b&&(d=u.createElementNS(l,"rect"),m(d,{width:b,"stroke-width":0}),this.element.parentNode.appendChild(d),f=d.getBBox().width,d.parentNode.removeChild(d));return f}symbolAttr(b){const c=this;D.symbolCustomAttribs.forEach(function(d){c[d]=f(b[d],c[d]);});c.attr({d:c.renderer.symbols[c.symbolName](c.x,c.y,
    	c.width,c.height,c)});}textSetter(b){b!==this.textStr&&(delete this.textPxLength,this.textStr=b,this.added&&this.renderer.buildText(this));}titleSetter(b){const c=this.element,d=c.getElementsByTagName("title")[0]||u.createElementNS(this.SVG_NS,"title");c.insertBefore?c.insertBefore(d,c.firstChild):c.appendChild(d);d.textContent=String(f(b,"")).replace(/<[^>]*>/g,"").replace(/&lt;/g,"<").replace(/&gt;/g,">");}toFront(){const b=this.element;b.parentNode.appendChild(b);return this}translate(b,c){return this.attr({translateX:b,
    	translateY:c})}updateTransform(){const {element:b,matrix:c,rotation:d=0,scaleX:k,scaleY:n,translateX:q=0,translateY:A=0}=this,g=["translate("+q+","+A+")"];e(c)&&g.push("matrix("+c.join(",")+")");d&&g.push("rotate("+d+" "+f(this.rotationOriginX,b.getAttribute("x"),0)+" "+f(this.rotationOriginY,b.getAttribute("y")||0)+")");(e(k)||e(n))&&g.push("scale("+f(k,1)+" "+f(n,1)+")");g.length&&!(this.text||this).textPath&&b.setAttribute("transform",g.join(" "));}visibilitySetter(b,c,f){"inherit"===b?f.removeAttribute(c):
    	this[c]!==b&&f.setAttribute(c,b);this[c]=b;}xGetter(b){"circle"===this.element.nodeName&&("x"===b?b="cx":"y"===b&&(b="cy"));return this._defaultGetter(b)}zIndexSetter(b,f){var d=this.renderer,k=this.parentGroup;const n=(k||d).element||d.box,q=this.element;d=n===d.box;let A=!1,g;var a=this.added;let r;e(b)?(q.setAttribute("data-z-index",b),b=+b,this[f]===b&&(a=!1)):e(this[f])&&q.removeAttribute("data-z-index");this[f]=b;if(a){(b=this.zIndex)&&k&&(k.handleZ=!0);f=n.childNodes;for(r=f.length-1;0<=r&&
    	!A;r--)if(k=f[r],a=k.getAttribute("data-z-index"),g=!e(a),k!==q)if(0>b&&g&&!d&&!r)n.insertBefore(q,f[r]),A=!0;else if(c(a)<=b||g&&(!e(b)||0<=b))n.insertBefore(q,f[r+1]),A=!0;A||(n.insertBefore(q,f[d?3:0]),A=!0);}return A}}D.symbolCustomAttribs="anchorX anchorY clockwise end height innerR r start width x y".split(" ");D.prototype.strokeSetter=D.prototype.fillSetter;D.prototype.yGetter=D.prototype.xGetter;D.prototype.matrixSetter=D.prototype.rotationOriginXSetter=D.prototype.rotationOriginYSetter=D.prototype.rotationSetter=
    	D.prototype.scaleXSetter=D.prototype.scaleYSetter=D.prototype.translateXSetter=D.prototype.translateYSetter=D.prototype.verticalAlignSetter=function(b,c){this[c]=b;this.doTransform=!0;};return D});M(a,"Core/Renderer/RendererRegistry.js",[a["Core/Globals.js"]],function(a){var x;(function(x){x.rendererTypes={};let y;x.getRendererType=function(a=y){return x.rendererTypes[a]||x.rendererTypes[y]};x.registerRendererType=function(C,z,H){x.rendererTypes[C]=z;if(!y||H)y=C,a.Renderer=z;};})(x||(x={}));return x});
    	M(a,"Core/Renderer/SVG/SVGLabel.js",[a["Core/Renderer/SVG/SVGElement.js"],a["Core/Utilities.js"]],function(a,y){const {defined:x,extend:L,isNumber:C,merge:z,pick:H,removeEvent:B}=y;class u extends a{constructor(a,l,p,t,m,h,g,e,w,E){super();this.paddingRightSetter=this.paddingLeftSetter=this.paddingSetter;this.init(a,"g");this.textStr=l;this.x=p;this.y=t;this.anchorX=h;this.anchorY=g;this.baseline=w;this.className=E;this.addClass("button"===E?"highcharts-no-tooltip":"highcharts-label");E&&this.addClass("highcharts-"+
    	E);this.text=a.text(void 0,0,0,e).attr({zIndex:1});let v;"string"===typeof m&&((v=/^url\((.*?)\)$/.test(m))||this.renderer.symbols[m])&&(this.symbolKey=m);this.bBox=u.emptyBBox;this.padding=3;this.baselineOffset=0;this.needsBox=a.styledMode||v;this.deferredAttr={};this.alignFactor=0;}alignSetter(a){a={left:0,center:.5,right:1}[a];a!==this.alignFactor&&(this.alignFactor=a,this.bBox&&C(this.xSetting)&&this.attr({x:this.xSetting}));}anchorXSetter(a,l){this.anchorX=a;this.boxAttr(l,Math.round(a)-this.getCrispAdjust()-
    	this.xSetting);}anchorYSetter(a,l){this.anchorY=a;this.boxAttr(l,a-this.ySetting);}boxAttr(a,l){this.box?this.box.attr(a,l):this.deferredAttr[a]=l;}css(v){if(v){const a={};v=z(v);u.textProps.forEach(l=>{"undefined"!==typeof v[l]&&(a[l]=v[l],delete v[l]);});this.text.css(a);"fontSize"in a||"fontWeight"in a?this.updateTextPadding():("width"in a||"textOverflow"in a)&&this.updateBoxSize();}return a.prototype.css.call(this,v)}destroy(){B(this.element,"mouseenter");B(this.element,"mouseleave");this.text&&this.text.destroy();
    	this.box&&(this.box=this.box.destroy());a.prototype.destroy.call(this);}fillSetter(a,l){a&&(this.needsBox=!0);this.fill=a;this.boxAttr(l,a);}getBBox(){this.textStr&&0===this.bBox.width&&0===this.bBox.height&&this.updateBoxSize();const a=this.padding,l=H(this.paddingLeft,a);return {width:this.width,height:this.height,x:this.bBox.x-l,y:this.bBox.y-a}}getCrispAdjust(){return this.renderer.styledMode&&this.box?this.box.strokeWidth()%2/2:(this["stroke-width"]?parseInt(this["stroke-width"],10):0)%2/2}heightSetter(a){this.heightSetting=
    	a;}onAdd(){this.text.add(this);this.attr({text:H(this.textStr,""),x:this.x||0,y:this.y||0});this.box&&x(this.anchorX)&&this.attr({anchorX:this.anchorX,anchorY:this.anchorY});}paddingSetter(a,l){C(a)?a!==this[l]&&(this[l]=a,this.updateTextPadding()):this[l]=void 0;}rSetter(a,l){this.boxAttr(l,a);}strokeSetter(a,l){this.stroke=a;this.boxAttr(l,a);}["stroke-widthSetter"](a,l){a&&(this.needsBox=!0);this["stroke-width"]=a;this.boxAttr(l,a);}["text-alignSetter"](a){this.textAlign=a;}textSetter(a){"undefined"!==
    	typeof a&&this.text.attr({text:a});this.updateTextPadding();}updateBoxSize(){var a=this.text;const l={},p=this.padding,t=this.bBox=C(this.widthSetting)&&C(this.heightSetting)&&!this.textAlign||!x(a.textStr)?u.emptyBBox:a.getBBox();this.width=this.getPaddedWidth();this.height=(this.heightSetting||t.height||0)+2*p;const m=this.renderer.fontMetrics(a);this.baselineOffset=p+Math.min((this.text.firstLineMetrics||m).b,t.height||Infinity);this.heightSetting&&(this.baselineOffset+=(this.heightSetting-m.h)/
    	2);this.needsBox&&!a.textPath&&(this.box||(a=this.box=this.symbolKey?this.renderer.symbol(this.symbolKey):this.renderer.rect(),a.addClass(("button"===this.className?"":"highcharts-label-box")+(this.className?" highcharts-"+this.className+"-box":"")),a.add(this)),a=this.getCrispAdjust(),l.x=a,l.y=(this.baseline?-this.baselineOffset:0)+a,l.width=Math.round(this.width),l.height=Math.round(this.height),this.box.attr(L(l,this.deferredAttr)),this.deferredAttr={});}updateTextPadding(){const a=this.text;if(!a.textPath){this.updateBoxSize();
    	const l=this.baseline?0:this.baselineOffset;let p=H(this.paddingLeft,this.padding);x(this.widthSetting)&&this.bBox&&("center"===this.textAlign||"right"===this.textAlign)&&(p+={center:.5,right:1}[this.textAlign]*(this.widthSetting-this.bBox.width));if(p!==a.x||l!==a.y)a.attr("x",p),a.hasBoxWidthChanged&&(this.bBox=a.getBBox(!0)),"undefined"!==typeof l&&a.attr("y",l);a.x=p;a.y=l;}}widthSetter(a){this.widthSetting=C(a)?a:void 0;}getPaddedWidth(){var a=this.padding;const l=H(this.paddingLeft,a);a=H(this.paddingRight,
    	a);return (this.widthSetting||this.bBox.width||0)+l+a}xSetter(a){this.x=a;this.alignFactor&&(a-=this.alignFactor*this.getPaddedWidth(),this["forceAnimate:x"]=!0);this.xSetting=Math.round(a);this.attr("translateX",this.xSetting);}ySetter(a){this.ySetting=this.y=Math.round(a);this.attr("translateY",this.ySetting);}}u.emptyBBox={width:0,height:0,x:0,y:0};u.textProps="color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow whiteSpace width".split(" ");
    	return u});M(a,"Core/Renderer/SVG/Symbols.js",[a["Core/Utilities.js"]],function(a){function x(a,u,v,l,p){const t=[];if(p){const m=p.start||0,h=H(p.r,v);v=H(p.r,l||v);l=(p.end||0)-.001;const g=p.innerR,e=H(p.open,.001>Math.abs((p.end||0)-m-2*Math.PI)),w=Math.cos(m),E=Math.sin(m),F=Math.cos(l),d=Math.sin(l),k=H(p.longArc,.001>l-m-Math.PI?0:1);let r=["A",h,v,0,k,H(p.clockwise,1),a+h*F,u+v*d];r.params={start:m,end:l,cx:a,cy:u};t.push(["M",a+h*w,u+v*E],r);C(g)&&(r=["A",g,g,0,k,C(p.clockwise)?1-p.clockwise:
    	0,a+g*w,u+g*E],r.params={start:l,end:m,cx:a,cy:u},t.push(e?["M",a+g*F,u+g*d]:["L",a+g*F,u+g*d],r));e||t.push(["Z"]);}return t}function I(a,u,v,l,p){return p&&p.r?L(a,u,v,l,p):[["M",a,u],["L",a+v,u],["L",a+v,u+l],["L",a,u+l],["Z"]]}function L(a,u,v,l,p){p=(null===p||void 0===p?void 0:p.r)||0;return [["M",a+p,u],["L",a+v-p,u],["A",p,p,0,0,1,a+v,u+p],["L",a+v,u+l-p],["A",p,p,0,0,1,a+v-p,u+l],["L",a+p,u+l],["A",p,p,0,0,1,a,u+l-p],["L",a,u+p],["A",p,p,0,0,1,a+p,u],["Z"]]}const {defined:C,isNumber:z,pick:H}=
    	a;return {arc:x,callout:function(a,u,v,l,p){const t=Math.min(p&&p.r||0,v,l),m=t+6,h=p&&p.anchorX;p=p&&p.anchorY||0;const g=L(a,u,v,l,{r:t});if(!z(h))return g;a+h>=v?p>u+m&&p<u+l-m?g.splice(3,1,["L",a+v,p-6],["L",a+v+6,p],["L",a+v,p+6],["L",a+v,u+l-t]):g.splice(3,1,["L",a+v,l/2],["L",h,p],["L",a+v,l/2],["L",a+v,u+l-t]):0>=a+h?p>u+m&&p<u+l-m?g.splice(7,1,["L",a,p+6],["L",a-6,p],["L",a,p-6],["L",a,u+t]):g.splice(7,1,["L",a,l/2],["L",h,p],["L",a,l/2],["L",a,u+t]):p&&p>l&&h>a+m&&h<a+v-m?g.splice(5,1,["L",
    	h+6,u+l],["L",h,u+l+6],["L",h-6,u+l],["L",a+t,u+l]):p&&0>p&&h>a+m&&h<a+v-m&&g.splice(1,1,["L",h-6,u],["L",h,u-6],["L",h+6,u],["L",v-t,u]);return g},circle:function(a,u,v,l){return x(a+v/2,u+l/2,v/2,l/2,{start:.5*Math.PI,end:2.5*Math.PI,open:!1})},diamond:function(a,u,v,l){return [["M",a+v/2,u],["L",a+v,u+l/2],["L",a+v/2,u+l],["L",a,u+l/2],["Z"]]},rect:I,roundedRect:L,square:I,triangle:function(a,u,v,l){return [["M",a+v/2,u],["L",a+v,u+l],["L",a,u+l],["Z"]]},"triangle-down":function(a,u,v,l){return [["M",
    	a,u],["L",a+v,u],["L",a+v/2,u+l],["Z"]]}}});M(a,"Core/Renderer/SVG/TextBuilder.js",[a["Core/Renderer/HTML/AST.js"],a["Core/Globals.js"],a["Core/Utilities.js"]],function(a,y,I){const {doc:x,SVG_NS:C,win:z}=y,{attr:H,extend:B,fireEvent:u,isString:v,objectEach:l,pick:p}=I;class t{constructor(a){const h=a.styles;this.renderer=a.renderer;this.svgElement=a;this.width=a.textWidth;this.textLineHeight=h&&h.lineHeight;this.textOutline=h&&h.textOutline;this.ellipsis=!(!h||"ellipsis"!==h.textOverflow);this.noWrap=
    	!(!h||"nowrap"!==h.whiteSpace);}buildSVG(){const m=this.svgElement,h=m.element;var g=m.renderer,e=p(m.textStr,"").toString();const w=-1!==e.indexOf("<"),l=h.childNodes;g=!m.added&&g.box;const t=/<br.*?>/g;var d=[e,this.ellipsis,this.noWrap,this.textLineHeight,this.textOutline,m.getStyle("font-size"),this.width].join();if(d!==m.textCache){m.textCache=d;delete m.actualWidth;for(d=l.length;d--;)h.removeChild(l[d]);w||this.ellipsis||this.width||m.textPath||-1!==e.indexOf(" ")&&(!this.noWrap||t.test(e))?
    	""!==e&&(g&&g.appendChild(h),e=new a(e),this.modifyTree(e.nodes),e.addToDOM(h),this.modifyDOM(),this.ellipsis&&-1!==(h.textContent||"").indexOf("\u2026")&&m.attr("title",this.unescapeEntities(m.textStr||"",["&lt;","&gt;"])),g&&g.removeChild(h)):h.appendChild(x.createTextNode(this.unescapeEntities(e)));v(this.textOutline)&&m.applyTextOutline&&m.applyTextOutline(this.textOutline);}}modifyDOM(){const a=this.svgElement,h=H(a.element,"x");a.firstLineMetrics=void 0;let g;for(;g=a.element.firstChild;)if(/^[\s\u200B]*$/.test(g.textContent||
    	" "))a.element.removeChild(g);else break;[].forEach.call(a.element.querySelectorAll("tspan.highcharts-br"),(e,d)=>{e.nextSibling&&e.previousSibling&&(0===d&&1===e.previousSibling.nodeType&&(a.firstLineMetrics=a.renderer.fontMetrics(e.previousSibling)),H(e,{dy:this.getLineHeight(e.nextSibling),x:h}));});const e=this.width||0;if(e){var w=(g,d)=>{var k=g.textContent||"";const r=k.replace(/([^\^])-/g,"$1- ").split(" ");var q=!this.noWrap&&(1<r.length||1<a.element.childNodes.length);const m=this.getLineHeight(d);
    	let b=0,f=a.actualWidth;if(this.ellipsis)k&&this.truncate(g,k,void 0,0,Math.max(0,e-.8*m),(b,f)=>b.substring(0,f)+"\u2026");else if(q){k=[];for(q=[];d.firstChild&&d.firstChild!==g;)q.push(d.firstChild),d.removeChild(d.firstChild);for(;r.length;)r.length&&!this.noWrap&&0<b&&(k.push(g.textContent||""),g.textContent=r.join(" ").replace(/- /g,"-")),this.truncate(g,void 0,r,0===b?f||0:0,e,(b,f)=>r.slice(0,f).join(" ").replace(/- /g,"-")),f=a.actualWidth,b++;q.forEach(b=>{d.insertBefore(b,g);});k.forEach(b=>
    	{d.insertBefore(x.createTextNode(b),g);b=x.createElementNS(C,"tspan");b.textContent="\u200b";H(b,{dy:m,x:h});d.insertBefore(b,g);});}},l=e=>{[].slice.call(e.childNodes).forEach(d=>{d.nodeType===z.Node.TEXT_NODE?w(d,e):(-1!==d.className.baseVal.indexOf("highcharts-br")&&(a.actualWidth=0),l(d));});};l(a.element);}}getLineHeight(a){a=a.nodeType===z.Node.TEXT_NODE?a.parentElement:a;return this.textLineHeight?parseInt(this.textLineHeight.toString(),10):this.renderer.fontMetrics(a||this.svgElement.element).h}modifyTree(a){const h=
    	(g,e)=>{const {attributes:m={},children:l,style:p={},tagName:d}=g,k=this.renderer.styledMode;if("b"===d||"strong"===d)k?m["class"]="highcharts-strong":p.fontWeight="bold";else if("i"===d||"em"===d)k?m["class"]="highcharts-emphasized":p.fontStyle="italic";p&&p.color&&(p.fill=p.color);"br"===d?(m["class"]="highcharts-br",g.textContent="\u200b",(e=a[e+1])&&e.textContent&&(e.textContent=e.textContent.replace(/^ +/gm,""))):"a"===d&&l&&l.some(d=>"#text"===d.tagName)&&(g.children=[{children:l,tagName:"tspan"}]);
    	"#text"!==d&&"a"!==d&&(g.tagName="tspan");B(g,{attributes:m,style:p});l&&l.filter(d=>"#text"!==d.tagName).forEach(h);};a.forEach(h);u(this.svgElement,"afterModifyTree",{nodes:a});}truncate(a,h,g,e,l,p){const m=this.svgElement,{rotation:d}=m,k=[];let r=g?1:0,q=(h||g||"").length,w=q,b,f;const c=function(b,c){b=c||b;if((c=a.parentNode)&&"undefined"===typeof k[b]&&c.getSubStringLength)try{k[b]=e+c.getSubStringLength(0,g?b+1:b);}catch(D){}return k[b]};m.rotation=0;f=c(a.textContent.length);if(e+f>l){for(;r<=
    	q;)w=Math.ceil((r+q)/2),g&&(b=p(g,w)),f=c(w,b&&b.length-1),r===q?r=q+1:f>l?q=w-1:r=w;0===q?a.textContent="":h&&q===h.length-1||(a.textContent=b||p(h||g,w));}g&&g.splice(0,w);m.actualWidth=f;m.rotation=d;}unescapeEntities(a,h){l(this.renderer.escapes,function(g,e){h&&-1!==h.indexOf(g)||(a=a.toString().replace(new RegExp(g,"g"),e));});return a}}return t});M(a,"Core/Renderer/SVG/SVGRenderer.js",[a["Core/Renderer/HTML/AST.js"],a["Core/Color/Color.js"],a["Core/Globals.js"],a["Core/Renderer/RendererRegistry.js"],
    	a["Core/Renderer/SVG/SVGElement.js"],a["Core/Renderer/SVG/SVGLabel.js"],a["Core/Renderer/SVG/Symbols.js"],a["Core/Renderer/SVG/TextBuilder.js"],a["Core/Utilities.js"]],function(a,y,I,L,C,z,H,B,u){const {charts:v,deg2rad:l,doc:p,isFirefox:t,isMS:m,isWebKit:h,noop:g,SVG_NS:e,symbolSizes:w,win:E}=I,{addEvent:F,attr:d,createElement:k,css:r,defined:q,destroyObjectProperties:G,extend:b,isArray:f,isNumber:c,isObject:n,isString:P,merge:D,pick:K,pInt:x,uniqueKey:T}=u;let Z;class V{constructor(b,c,f,d,a,k,
    	n){this.width=this.url=this.style=this.imgCount=this.height=this.gradients=this.globalAnimation=this.defs=this.chartIndex=this.cacheKeys=this.cache=this.boxWrapper=this.box=this.alignedObjects=void 0;this.init(b,c,f,d,a,k,n);}init(b,c,f,a,k,n,J){const A=this.createElement("svg").attr({version:"1.1","class":"highcharts-root"}),e=A.element;J||A.css(this.getStyle(a));b.appendChild(e);d(b,"dir","ltr");-1===b.innerHTML.indexOf("xmlns")&&d(e,"xmlns",this.SVG_NS);this.box=e;this.boxWrapper=A;this.alignedObjects=
    	[];this.url=this.getReferenceURL();this.createElement("desc").add().element.appendChild(p.createTextNode("Created with Highcharts 11.1.0"));this.defs=this.createElement("defs").add();this.allowHTML=n;this.forExport=k;this.styledMode=J;this.gradients={};this.cache={};this.cacheKeys=[];this.imgCount=0;this.rootFontSize=A.getStyle("font-size");this.setSize(c,f,!1);let q;t&&b.getBoundingClientRect&&(c=function(){r(b,{left:0,top:0});q=b.getBoundingClientRect();r(b,{left:Math.ceil(q.left)-q.left+"px",top:Math.ceil(q.top)-
    	q.top+"px"});},c(),this.unSubPixelFix=F(E,"resize",c));}definition(b){return (new a([b])).addToDOM(this.defs.element)}getReferenceURL(){if((t||h)&&p.getElementsByTagName("base").length){if(!q(Z)){var b=T();b=(new a([{tagName:"svg",attributes:{width:8,height:8},children:[{tagName:"defs",children:[{tagName:"clipPath",attributes:{id:b},children:[{tagName:"rect",attributes:{width:4,height:4}}]}]},{tagName:"rect",attributes:{id:"hitme",width:8,height:8,"clip-path":`url(#${b})`,fill:"rgba(0,0,0,0.001)"}}]}])).addToDOM(p.body);
    	r(b,{position:"fixed",top:0,left:0,zIndex:9E5});const c=p.elementFromPoint(6,6);Z="hitme"===(c&&c.id);p.body.removeChild(b);}if(Z)return E.location.href.split("#")[0].replace(/<[^>]*>/g,"").replace(/([\('\)])/g,"\\$1").replace(/ /g,"%20")}return ""}getStyle(c){return this.style=b({fontFamily:"Helvetica, Arial, sans-serif",fontSize:"1rem"},c)}setStyle(b){this.boxWrapper.css(this.getStyle(b));}isHidden(){return !this.boxWrapper.getBBox().width}destroy(){const b=this.defs;this.box=null;this.boxWrapper=this.boxWrapper.destroy();
    	G(this.gradients||{});this.gradients=null;this.defs=b.destroy();this.unSubPixelFix&&this.unSubPixelFix();return this.alignedObjects=null}createElement(b){const c=new this.Element;c.init(this,b);return c}getRadialAttr(b,c){return {cx:b[0]-b[2]/2+(c.cx||0)*b[2],cy:b[1]-b[2]/2+(c.cy||0)*b[2],r:(c.r||0)*b[2]}}shadowDefinition(b){const c=[`highcharts-drop-shadow-${this.chartIndex}`,...Object.keys(b).map(c=>b[c])].join("-").replace(/[^a-z0-9\-]/g,""),f=D({color:"#000000",offsetX:1,offsetY:1,opacity:.15,
    	width:5},b);this.defs.element.querySelector(`#${c}`)||this.definition({tagName:"filter",attributes:{id:c},children:[{tagName:"feDropShadow",attributes:{dx:f.offsetX,dy:f.offsetY,"flood-color":f.color,"flood-opacity":Math.min(5*f.opacity,1),stdDeviation:f.width/2}}]});return c}buildText(b){(new B(b)).buildSVG();}getContrast(b){b=y.parse(b).rgba.map(b=>{b/=255;return .03928>=b?b/12.92:Math.pow((b+.055)/1.055,2.4)});b=.2126*b[0]+.7152*b[1]+.0722*b[2];return 1.05/(b+.05)>(b+.05)/.05?"#FFFFFF":"#000000"}button(c,
    	f,d,k,e={},q,J,g,r,h){const A=this.label(c,f,d,r,void 0,void 0,h,void 0,"button"),O=this.styledMode;c=e.states||{};let N=0;e=D(e);delete e.states;const l=D({color:"#333333",cursor:"pointer",fontSize:"0.8em",fontWeight:"normal"},e.style);delete e.style;let w=a.filterUserAttributes(e);A.attr(D({padding:8,r:2},w));let p,G,R;O||(w=D({fill:"#f7f7f7",stroke:"#cccccc","stroke-width":1},w),q=D(w,{fill:"#e6e6e6"},a.filterUserAttributes(q||c.hover||{})),p=q.style,delete q.style,J=D(w,{fill:"#e6e9ff",style:{color:"#000000",
    	fontWeight:"bold"}},a.filterUserAttributes(J||c.select||{})),G=J.style,delete J.style,g=D(w,{style:{color:"#cccccc"}},a.filterUserAttributes(g||c.disabled||{})),R=g.style,delete g.style);F(A.element,m?"mouseover":"mouseenter",function(){3!==N&&A.setState(1);});F(A.element,m?"mouseout":"mouseleave",function(){3!==N&&A.setState(N);});A.setState=function(b){1!==b&&(A.state=N=b);A.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-"+["normal","hover","pressed",
    	"disabled"][b||0]);O||(A.attr([w,q,J,g][b||0]),b=[l,p,G,R][b||0],n(b)&&A.css(b));};O||(A.attr(w).css(b({cursor:"default"},l)),h&&A.text.css({pointerEvents:"none"}));return A.on("touchstart",b=>b.stopPropagation()).on("click",function(b){3!==N&&k.call(A,b);})}crispLine(b,c,f="round"){const d=b[0],a=b[1];q(d[1])&&d[1]===a[1]&&(d[1]=a[1]=Math[f](d[1])-c%2/2);q(d[2])&&d[2]===a[2]&&(d[2]=a[2]=Math[f](d[2])+c%2/2);return b}path(c){const d=this.styledMode?{}:{fill:"none"};f(c)?d.d=c:n(c)&&b(d,c);return this.createElement("path").attr(d)}circle(b,
    	c,f){b=n(b)?b:"undefined"===typeof b?{}:{x:b,y:c,r:f};c=this.createElement("circle");c.xSetter=c.ySetter=function(b,c,f){f.setAttribute("c"+c,b);};return c.attr(b)}arc(b,c,f,d,a,k){n(b)?(d=b,c=d.y,f=d.r,b=d.x):d={innerR:d,start:a,end:k};b=this.symbol("arc",b,c,f,f,d);b.r=f;return b}rect(c,f,a,k,e,q){c=n(c)?c:"undefined"===typeof c?{}:{x:c,y:f,r:e,width:Math.max(a||0,0),height:Math.max(k||0,0)};const A=this.createElement("rect");this.styledMode||("undefined"!==typeof q&&(c["stroke-width"]=q,b(c,A.crisp(c))),
    	c.fill="none");A.rSetter=function(b,c,f){A.r=b;d(f,{rx:b,ry:b});};A.rGetter=function(){return A.r||0};return A.attr(c)}roundedRect(b){return this.symbol("roundedRect").attr(b)}setSize(b,c,f){this.width=b;this.height=c;this.boxWrapper.animate({width:b,height:c},{step:function(){this.attr({viewBox:"0 0 "+this.attr("width")+" "+this.attr("height")});},duration:K(f,!0)?void 0:0});this.alignElements();}g(b){const c=this.createElement("g");return b?c.attr({"class":"highcharts-"+b}):c}image(b,f,d,a,k,n){const A=
    	{preserveAspectRatio:"none"};c(f)&&(A.x=f);c(d)&&(A.y=d);c(a)&&(A.width=a);c(k)&&(A.height=k);const e=this.createElement("image").attr(A);f=function(c){e.attr({href:b});n.call(e,c);};n?(e.attr({href:"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="}),d=new E.Image,F(d,"load",f),d.src=b,d.complete&&f({})):e.attr({href:b});return e}symbol(c,f,a,n,e,g){const A=this,h=/^url\((.*?)\)$/,O=h.test(c),m=!O&&(this.symbols[c]?c:"circle"),l=m&&this.symbols[m];let D,G,P,t;if(l)"number"===
    	typeof f&&(G=l.call(this.symbols,Math.round(f||0),Math.round(a||0),n||0,e||0,g)),D=this.path(G),A.styledMode||D.attr("fill","none"),b(D,{symbolName:m||void 0,x:f,y:a,width:n,height:e}),g&&b(D,g);else if(O){P=c.match(h)[1];const b=D=this.image(P);b.imgwidth=K(g&&g.width,w[P]&&w[P].width);b.imgheight=K(g&&g.height,w[P]&&w[P].height);t=b=>b.attr({width:b.width,height:b.height});["width","height"].forEach(function(c){b[c+"Setter"]=function(b,c){this[c]=b;const {alignByTranslate:f,element:a,width:k,height:A,
    	imgwidth:n,imgheight:e}=this;b=this["img"+c];if(q(b)){let J=1;g&&"within"===g.backgroundSize&&k&&A?(J=Math.min(k/n,A/e),d(a,{width:Math.round(n*J),height:Math.round(e*J)})):a&&a.setAttribute(c,b);f||this.translate(((k||0)-n*J)/2,((A||0)-e*J)/2);}};});q(f)&&b.attr({x:f,y:a});b.isImg=!0;q(b.imgwidth)&&q(b.imgheight)?t(b):(b.attr({width:0,height:0}),k("img",{onload:function(){const c=v[A.chartIndex];0===this.width&&(r(this,{position:"absolute",top:"-999em"}),p.body.appendChild(this));w[P]={width:this.width,
    	height:this.height};b.imgwidth=this.width;b.imgheight=this.height;b.element&&t(b);this.parentNode&&this.parentNode.removeChild(this);A.imgCount--;if(!A.imgCount&&c&&!c.hasLoaded)c.onload();},src:P}),this.imgCount++);}return D}clipRect(b,c,f,d){const a=T()+"-",k=this.createElement("clipPath").attr({id:a}).add(this.defs);b=this.rect(b,c,f,d,0).add(k);b.id=a;b.clipPath=k;b.count=0;return b}text(b,c,f,d){const a={};if(d&&(this.allowHTML||!this.forExport))return this.html(b,c,f);a.x=Math.round(c||0);f&&
    	(a.y=Math.round(f));q(b)&&(a.text=b);b=this.createElement("text").attr(a);if(!d||this.forExport&&!this.allowHTML)b.xSetter=function(b,c,f){const d=f.getElementsByTagName("tspan"),a=f.getAttribute(c);for(let f=0,k;f<d.length;f++)k=d[f],k.getAttribute(c)===a&&k.setAttribute(c,b);f.setAttribute(c,b);};return b}fontMetrics(b){b=x(C.prototype.getStyle.call(b,"font-size")||0);const c=24>b?b+3:Math.round(1.2*b);return {h:c,b:Math.round(.8*c),f:b}}rotCorr(b,c,f){let d=b;c&&f&&(d=Math.max(d*Math.cos(c*l),4));
    	return {x:-b/3*Math.sin(c*l),y:d}}pathToSegments(b){const f=[],d=[],a={A:8,C:7,H:2,L:3,M:3,Q:5,S:5,T:3,V:2};for(let k=0;k<b.length;k++)P(d[0])&&c(b[k])&&d.length===a[d[0].toUpperCase()]&&b.splice(k,0,d[0].replace("M","L").replace("m","l")),"string"===typeof b[k]&&(d.length&&f.push(d.slice(0)),d.length=0),d.push(b[k]);f.push(d.slice(0));return f}label(b,c,f,d,a,k,n,e,q){return new z(this,b,c,f,d,a,k,n,e,q)}alignElements(){this.alignedObjects.forEach(b=>b.align());}}b(V.prototype,{Element:C,SVG_NS:e,
    	escapes:{"&":"&amp;","<":"&lt;",">":"&gt;","'":"&#39;",'"':"&quot;"},symbols:H,draw:g});L.registerRendererType("svg",V,!0);return V});M(a,"Core/Renderer/HTML/HTMLElement.js",[a["Core/Globals.js"],a["Core/Renderer/SVG/SVGElement.js"],a["Core/Utilities.js"]],function(a,y,I){const {isFirefox:x,isMS:C,isWebKit:z,win:H}=a,{css:B,defined:u,extend:v,pick:l,pInt:p}=I,t=[];class m extends y{static compose(a){if(I.pushUnique(t,a)){const g=m.prototype,e=a.prototype;e.getSpanCorrection=g.getSpanCorrection;
    	e.htmlCss=g.htmlCss;e.htmlGetBBox=g.htmlGetBBox;e.htmlUpdateTransform=g.htmlUpdateTransform;e.setSpanRotation=g.setSpanRotation;}return a}getSpanCorrection(a,g,e){this.xCorr=-a*e;this.yCorr=-g;}htmlCss(a){const g="SPAN"===this.element.tagName&&a&&"width"in a,e=l(g&&a.width,void 0);let h;g&&(delete a.width,this.textWidth=e,h=!0);a&&"ellipsis"===a.textOverflow&&(a.whiteSpace="nowrap",a.overflow="hidden");this.styles=v(this.styles,a);B(this.element,a);h&&this.htmlUpdateTransform();return this}htmlGetBBox(){const a=
    	this.element;return {x:a.offsetLeft,y:a.offsetTop,width:a.offsetWidth,height:a.offsetHeight}}htmlUpdateTransform(){if(this.added){var a=this.renderer,g=this.element,e=this.x||0,m=this.y||0,l=this.textAlign||"left",t={left:0,center:.5,right:1}[l],d=this.styles,k=d&&d.whiteSpace;B(g,{marginLeft:this.translateX||0,marginTop:this.translateY||0});if("SPAN"===g.tagName){d=this.rotation;const q=this.textWidth&&p(this.textWidth),h=[d,l,g.innerHTML,this.textWidth,this.textAlign].join();let b=!1;if(q!==this.oldTextWidth){if(this.textPxLength)var r=
    	this.textPxLength;else B(g,{width:"",whiteSpace:k||"nowrap"}),r=g.offsetWidth;(q>this.oldTextWidth||r>q)&&(/[ \-]/.test(g.textContent||g.innerText)||"ellipsis"===g.style.textOverflow)&&(B(g,{width:r>q||d?q+"px":"auto",display:"block",whiteSpace:k||"normal"}),this.oldTextWidth=q,b=!0);}this.hasBoxWidthChanged=b;h!==this.cTT&&(a=a.fontMetrics(g).b,!u(d)||d===(this.oldRotation||0)&&l===this.oldAlign||this.setSpanRotation(d,t,a),this.getSpanCorrection(!u(d)&&this.textPxLength||g.offsetWidth,a,t,d,l));
    	B(g,{left:e+(this.xCorr||0)+"px",top:m+(this.yCorr||0)+"px"});this.cTT=h;this.oldRotation=d;this.oldAlign=l;}}else this.alignOnAdd=!0;}setSpanRotation(a,g,e){const h={},m=C&&!/Edge/.test(H.navigator.userAgent)?"-ms-transform":z?"-webkit-transform":x?"MozTransform":H.opera?"-o-transform":void 0;m&&(h[m]=h.transform="rotate("+a+"deg)",h[m+(x?"Origin":"-origin")]=h.transformOrigin=100*g+"% "+e+"px",B(this.element,h));}}return m});M(a,"Core/Renderer/HTML/HTMLRenderer.js",[a["Core/Renderer/HTML/AST.js"],
    	a["Core/Renderer/SVG/SVGElement.js"],a["Core/Renderer/SVG/SVGRenderer.js"],a["Core/Utilities.js"]],function(a,y,I,L){const {attr:x,createElement:z,extend:H,pick:B}=L,u=[];class v extends I{static compose(a){L.pushUnique(u,a)&&(a.prototype.html=v.prototype.html);return a}html(l,p,t){const m=this.createElement("span"),h=m.element,g=m.renderer,e=function(a,e){["opacity","visibility"].forEach(function(g){a[g+"Setter"]=function(d,k,r){const q=a.div?a.div.style:e;y.prototype[g+"Setter"].call(this,d,k,r);
    	q&&(q[k]=d);};});a.addedSetters=!0;};m.textSetter=function(e){e!==this.textStr&&(delete this.bBox,delete this.oldTextWidth,a.setElementHTML(this.element,B(e,"")),this.textStr=e,m.doTransform=!0);};e(m,m.element.style);m.xSetter=m.ySetter=m.alignSetter=m.rotationSetter=function(a,e){"align"===e?m.alignValue=m.textAlign=a:m[e]=a;m.doTransform=!0;};m.afterSetters=function(){this.doTransform&&(this.htmlUpdateTransform(),this.doTransform=!1);};m.attr({text:l,x:Math.round(p),y:Math.round(t)}).css({position:"absolute"});
    	g.styledMode||m.css({fontFamily:this.style.fontFamily,fontSize:this.style.fontSize});h.style.whiteSpace="nowrap";m.css=m.htmlCss;m.add=function(a){const l=g.box.parentNode,w=[];let d;if(this.parentGroup=a){if(d=a.div,!d){for(;a;)w.push(a),a=a.parentGroup;w.reverse().forEach(function(a){function k(f,c){a[c]=f;"translateX"===c?b.left=f+"px":b.top=f+"px";a.doTransform=!0;}const q=x(a.element,"class"),g=a.styles||{};d=a.div=a.div||z("div",q?{className:q}:void 0,{position:"absolute",left:(a.translateX||
    	0)+"px",top:(a.translateY||0)+"px",display:a.display,opacity:a.opacity,visibility:a.visibility},d||l);const b=d.style;H(a,{classSetter:function(b){return function(c){this.element.setAttribute("class",c);b.className=c;}}(d),css:function(f){m.css.call(a,f);["cursor","pointerEvents"].forEach(c=>{f[c]&&(b[c]=f[c]);});return a},on:function(){w[0].div&&m.on.apply({element:w[0].div,onEvents:a.onEvents},arguments);return a},translateXSetter:k,translateYSetter:k});a.addedSetters||e(a);a.css(g);});}}else d=l;d.appendChild(h);
    	m.added=!0;m.alignOnAdd&&m.htmlUpdateTransform();return m};return m}}return v});M(a,"Core/Axis/AxisDefaults.js",[],function(){var a;(function(a){a.defaultXAxisOptions={alignTicks:!0,allowDecimals:void 0,panningEnabled:!0,zIndex:2,zoomEnabled:!0,dateTimeLabelFormats:{millisecond:{main:"%H:%M:%S.%L",range:!1},second:{main:"%H:%M:%S",range:!1},minute:{main:"%H:%M",range:!1},hour:{main:"%H:%M",range:!1},day:{main:"%e %b"},week:{main:"%e %b"},month:{main:"%b '%y"},year:{main:"%Y"}},endOnTick:!1,gridLineDashStyle:"Solid",
    	gridZIndex:1,labels:{autoRotation:void 0,autoRotationLimit:80,distance:15,enabled:!0,indentation:10,overflow:"justify",padding:5,reserveSpace:void 0,rotation:void 0,staggerLines:0,step:0,useHTML:!1,zIndex:7,style:{color:"#333333",cursor:"default",fontSize:"0.8em"}},maxPadding:.01,minorGridLineDashStyle:"Solid",minorTickLength:2,minorTickPosition:"outside",minorTicksPerMajor:5,minPadding:.01,offset:void 0,opposite:!1,reversed:void 0,reversedStacks:!1,showEmpty:!0,showFirstLabel:!0,showLastLabel:!0,
    	startOfWeek:1,startOnTick:!1,tickLength:10,tickPixelInterval:100,tickmarkPlacement:"between",tickPosition:"outside",title:{align:"middle",rotation:0,useHTML:!1,x:0,y:0,style:{color:"#666666",fontSize:"0.8em"}},type:"linear",uniqueNames:!0,visible:!0,minorGridLineColor:"#f2f2f2",minorGridLineWidth:1,minorTickColor:"#999999",lineColor:"#333333",lineWidth:1,gridLineColor:"#e6e6e6",gridLineWidth:void 0,tickColor:"#333333"};a.defaultYAxisOptions={reversedStacks:!0,endOnTick:!0,maxPadding:.05,minPadding:.05,
    	tickPixelInterval:72,showLastLabel:!0,labels:{x:void 0},startOnTick:!0,title:{rotation:270,text:"Values"},stackLabels:{animation:{},allowOverlap:!1,enabled:!1,crop:!0,overflow:"justify",formatter:function(){const {numberFormatter:a}=this.axis.chart;return a(this.total||0,-1)},style:{color:"#000000",fontSize:"0.7em",fontWeight:"bold",textOutline:"1px contrast"}},gridLineWidth:1,lineWidth:0};a.defaultLeftAxisOptions={title:{rotation:270}};a.defaultRightAxisOptions={title:{rotation:90}};a.defaultBottomAxisOptions=
    	{labels:{autoRotation:[-45]},margin:15,title:{rotation:0}};a.defaultTopAxisOptions={labels:{autoRotation:[-45]},margin:15,title:{rotation:0}};})(a||(a={}));return a});M(a,"Core/Foundation.js",[a["Core/Utilities.js"]],function(a){const {addEvent:x,isFunction:I,objectEach:L,removeEvent:C}=a;var z;(function(a){a.registerEventOptions=function(a,u){a.eventOptions=a.eventOptions||{};L(u.events,function(v,l){a.eventOptions[l]!==v&&(a.eventOptions[l]&&(C(a,l,a.eventOptions[l]),delete a.eventOptions[l]),I(v)&&
    	(a.eventOptions[l]=v,x(a,l,v,{order:0})));});};})(z||(z={}));return z});M(a,"Core/Axis/Tick.js",[a["Core/Templating.js"],a["Core/Globals.js"],a["Core/Utilities.js"]],function(a,y,I){const {deg2rad:x}=y,{clamp:C,correctFloat:z,defined:H,destroyObjectProperties:B,extend:u,fireEvent:v,isNumber:l,merge:p,objectEach:t,pick:m}=I;class h{constructor(a,e,h,m,l){this.isNewLabel=this.isNew=!0;this.axis=a;this.pos=e;this.type=h||"";this.parameters=l||{};this.tickmarkOffset=this.parameters.tickmarkOffset;this.options=
    	this.parameters.options;v(this,"init");h||m||this.addLabel();}addLabel(){const g=this,e=g.axis;var h=e.options;const p=e.chart;var t=e.categories;const d=e.logarithmic,k=e.names,r=g.pos,q=m(g.options&&g.options.labels,h.labels);var G=e.tickPositions;const b=r===G[0],f=r===G[G.length-1],c=(!q.step||1===q.step)&&1===e.tickInterval;G=G.info;let n=g.label,P,D,K;t=this.parameters.category||(t?m(t[r],k[r],r):r);d&&l(t)&&(t=z(d.lin2log(t)));e.dateTime&&(G?(D=p.time.resolveDTLFormat(h.dateTimeLabelFormats[!h.grid&&
    	G.higherRanks[r]||G.unitName]),P=D.main):l(t)&&(P=e.dateTime.getXDateFormat(t,h.dateTimeLabelFormats||{})));g.isFirst=b;g.isLast=f;const x={axis:e,chart:p,dateTimeLabelFormat:P,isFirst:b,isLast:f,pos:r,tick:g,tickPositionInfo:G,value:t};v(this,"labelFormat",x);const B=b=>q.formatter?q.formatter.call(b,b):q.format?(b.text=e.defaultLabelFormatter.call(b,b),a.format(q.format,b,p)):e.defaultLabelFormatter.call(b,b);h=B.call(x,x);const y=D&&D.list;g.shortenLabel=y?function(){for(K=0;K<y.length;K++)if(u(x,
    	{dateTimeLabelFormat:y[K]}),n.attr({text:B.call(x,x)}),n.getBBox().width<e.getSlotWidth(g)-2*q.padding)return;n.attr({text:""});}:void 0;c&&e._addedPlotLB&&g.moveLabel(h,q);H(n)||g.movedLabel?n&&n.textStr!==h&&!c&&(!n.textWidth||q.style.width||n.styles.width||n.css({width:null}),n.attr({text:h}),n.textPxLength=n.getBBox().width):(g.label=n=g.createLabel({x:0,y:0},h,q),g.rotation=0);}createLabel(a,e,h){const g=this.axis,m=g.chart;if(a=H(e)&&h.enabled?m.renderer.text(e,a.x,a.y,h.useHTML).add(g.labelGroup):
    	null)m.styledMode||a.css(p(h.style)),a.textPxLength=a.getBBox().width;return a}destroy(){B(this,this.axis);}getPosition(a,e,h,m){const g=this.axis,d=g.chart,k=m&&d.oldChartHeight||d.chartHeight;a={x:a?z(g.translate(e+h,void 0,void 0,m)+g.transB):g.left+g.offset+(g.opposite?(m&&d.oldChartWidth||d.chartWidth)-g.right-g.left:0),y:a?k-g.bottom+g.offset-(g.opposite?g.height:0):z(k-g.translate(e+h,void 0,void 0,m)-g.transB)};a.y=C(a.y,-1E5,1E5);v(this,"afterGetPosition",{pos:a});return a}getLabelPosition(a,
    	e,h,l,p,d,k,r){const q=this.axis,g=q.transA,b=q.isLinked&&q.linkedParent?q.linkedParent.reversed:q.reversed,f=q.staggerLines,c=q.tickRotCorr||{x:0,y:0},n=l||q.reserveSpaceDefault?0:-q.labelOffset*("center"===q.labelAlign?.5:1),w=p.distance,D={};h=0===q.side?h.rotation?-w:-h.getBBox().height:2===q.side?c.y+w:Math.cos(h.rotation*x)*(c.y-h.getBBox(!1,0).height/2);H(p.y)&&(h=0===q.side&&q.horiz?p.y+h:p.y);a=a+m(p.x,[0,1,0,-1][q.side]*w)+n+c.x-(d&&l?d*g*(b?-1:1):0);e=e+h-(d&&!l?d*g*(b?1:-1):0);f&&(l=k/
    	(r||1)%f,q.opposite&&(l=f-l-1),e+=q.labelOffset/f*l);D.x=a;D.y=Math.round(e);v(this,"afterGetLabelPosition",{pos:D,tickmarkOffset:d,index:k});return D}getLabelSize(){return this.label?this.label.getBBox()[this.axis.horiz?"height":"width"]:0}getMarkPath(a,e,h,m,l,d){return d.crispLine([["M",a,e],["L",a+(l?0:-h),e+(l?h:0)]],m)}handleOverflow(a){const e=this.axis,g=e.options.labels,h=a.x;var l=e.chart.chartWidth,d=e.chart.spacing;const k=m(e.labelLeft,Math.min(e.pos,d[3]));d=m(e.labelRight,Math.max(e.isRadial?
    	0:e.pos+e.len,l-d[1]));const r=this.label,q=this.rotation,p={left:0,center:.5,right:1}[e.labelAlign||r.attr("align")],b=r.getBBox().width,f=e.getSlotWidth(this),c={};let n=f,t=1,D;if(q||"justify"!==g.overflow)0>q&&h-p*b<k?D=Math.round(h/Math.cos(q*x)-k):0<q&&h+p*b>d&&(D=Math.round((l-h)/Math.cos(q*x)));else if(l=h+(1-p)*b,h-p*b<k?n=a.x+n*(1-p)-k:l>d&&(n=d-a.x+n*p,t=-1),n=Math.min(f,n),n<f&&"center"===e.labelAlign&&(a.x+=t*(f-n-p*(f-Math.min(b,n)))),b>n||e.autoRotation&&(r.styles||{}).width)D=n;D&&
    	(this.shortenLabel?this.shortenLabel():(c.width=Math.floor(D)+"px",(g.style||{}).textOverflow||(c.textOverflow="ellipsis"),r.css(c)));}moveLabel(a,e){const g=this;var h=g.label;const m=g.axis;let d=!1;h&&h.textStr===a?(g.movedLabel=h,d=!0,delete g.label):t(m.ticks,function(k){d||k.isNew||k===g||!k.label||k.label.textStr!==a||(g.movedLabel=k.label,d=!0,k.labelPos=g.movedLabel.xy,delete k.label);});d||!g.labelPos&&!h||(h=g.labelPos||h.xy,g.movedLabel=g.createLabel(h,a,e),g.movedLabel&&g.movedLabel.attr({opacity:0}));}render(a,
    	e,h){var g=this.axis,l=g.horiz,d=this.pos,k=m(this.tickmarkOffset,g.tickmarkOffset);d=this.getPosition(l,d,k,e);k=d.x;const r=d.y;g=l&&k===g.pos+g.len||!l&&r===g.pos?-1:1;l=m(h,this.label&&this.label.newOpacity,1);h=m(h,1);this.isActive=!0;this.renderGridLine(e,h,g);this.renderMark(d,h,g);this.renderLabel(d,e,l,a);this.isNew=!1;v(this,"afterRender");}renderGridLine(a,e,h){const g=this.axis,l=g.options,d={},k=this.pos,r=this.type,q=m(this.tickmarkOffset,g.tickmarkOffset),p=g.chart.renderer;let b=this.gridLine,
    	f=l.gridLineWidth,c=l.gridLineColor,n=l.gridLineDashStyle;"minor"===this.type&&(f=l.minorGridLineWidth,c=l.minorGridLineColor,n=l.minorGridLineDashStyle);b||(g.chart.styledMode||(d.stroke=c,d["stroke-width"]=f||0,d.dashstyle=n),r||(d.zIndex=1),a&&(e=0),this.gridLine=b=p.path().attr(d).addClass("highcharts-"+(r?r+"-":"")+"grid-line").add(g.gridGroup));if(b&&(h=g.getPlotLinePath({value:k+q,lineWidth:b.strokeWidth()*h,force:"pass",old:a,acrossPanes:!1})))b[a||this.isNew?"attr":"animate"]({d:h,opacity:e});}renderMark(a,
    	e,h){const g=this.axis;var l=g.options;const d=g.chart.renderer,k=this.type,r=g.tickSize(k?k+"Tick":"tick"),q=a.x;a=a.y;const p=m(l["minor"!==k?"tickWidth":"minorTickWidth"],!k&&g.isXAxis?1:0);l=l["minor"!==k?"tickColor":"minorTickColor"];let b=this.mark;const f=!b;r&&(g.opposite&&(r[0]=-r[0]),b||(this.mark=b=d.path().addClass("highcharts-"+(k?k+"-":"")+"tick").add(g.axisGroup),g.chart.styledMode||b.attr({stroke:l,"stroke-width":p})),b[f?"attr":"animate"]({d:this.getMarkPath(q,a,r[0],b.strokeWidth()*
    	h,g.horiz,d),opacity:e}));}renderLabel(a,e,h,p){var g=this.axis;const d=g.horiz,k=g.options,r=this.label,q=k.labels,t=q.step;g=m(this.tickmarkOffset,g.tickmarkOffset);const b=a.x;a=a.y;let f=!0;r&&l(b)&&(r.xy=a=this.getLabelPosition(b,a,r,d,q,g,p,t),this.isFirst&&!this.isLast&&!k.showFirstLabel||this.isLast&&!this.isFirst&&!k.showLastLabel?f=!1:!d||q.step||q.rotation||e||0===h||this.handleOverflow(a),t&&p%t&&(f=!1),f&&l(a.y)?(a.opacity=h,r[this.isNewLabel?"attr":"animate"](a).show(!0),this.isNewLabel=
    	!1):(r.hide(),this.isNewLabel=!0));}replaceMovedLabel(){const a=this.label,e=this.axis;a&&!this.isNew&&(a.animate({opacity:0},void 0,a.destroy),delete this.label);e.isDirty=!0;this.label=this.movedLabel;delete this.movedLabel;}}return h});M(a,"Core/Axis/Axis.js",[a["Core/Animation/AnimationUtilities.js"],a["Core/Axis/AxisDefaults.js"],a["Core/Color/Color.js"],a["Core/Defaults.js"],a["Core/Foundation.js"],a["Core/Globals.js"],a["Core/Axis/Tick.js"],a["Core/Utilities.js"]],function(a,y,I,L,C,z,H,B){const {animObject:u}=
    	a,{defaultOptions:v}=L,{registerEventOptions:l}=C,{deg2rad:p}=z,{arrayMax:t,arrayMin:m,clamp:h,correctFloat:g,defined:e,destroyObjectProperties:w,erase:x,error:F,extend:d,fireEvent:k,getClosestDistance:r,insertItem:q,isArray:G,isNumber:b,isString:f,merge:c,normalizeTickInterval:n,objectEach:P,pick:D,relativeLength:K,removeEvent:X,splat:T,syncTimeout:Z}=B,V=(b,c)=>n(c,void 0,void 0,D(b.options.allowDecimals,.5>c||void 0!==b.tickAmount),!!b.tickAmount);class Y{constructor(b,c,f){this.zoomEnabled=this.width=
    	this.visible=this.userOptions=this.translationSlope=this.transB=this.transA=this.top=this.ticks=this.tickRotCorr=this.tickPositions=this.tickmarkOffset=this.tickInterval=this.tickAmount=this.side=this.series=this.right=this.positiveValuesOnly=this.pos=this.pointRangePadding=this.pointRange=this.plotLinesAndBandsGroups=this.plotLinesAndBands=this.paddedTicks=this.overlap=this.options=this.offset=this.names=this.minPixelPadding=this.minorTicks=this.minorTickInterval=this.min=this.maxLabelLength=this.max=
    	this.len=this.left=this.labelFormatter=this.labelEdge=this.isLinked=this.index=this.height=this.hasVisibleSeries=this.hasNames=this.eventOptions=this.coll=this.closestPointRange=this.chart=this.bottom=this.alternateBands=void 0;this.init(b,c,f);}init(c,f,a=this.coll){const d="xAxis"===a;this.chart=c;this.horiz=this.isZAxis||(c.inverted?!d:d);this.isXAxis=d;this.coll=a;k(this,"init",{userOptions:f});this.opposite=D(f.opposite,this.opposite);this.side=D(f.side,this.side,this.horiz?this.opposite?0:2:
    	this.opposite?1:3);this.setOptions(f);a=this.options;const A=a.labels,n=a.type;this.userOptions=f;this.minPixelPadding=0;this.reversed=D(a.reversed,this.reversed);this.visible=a.visible;this.zoomEnabled=a.zoomEnabled;this.hasNames="category"===n||!0===a.categories;this.categories=a.categories||(this.hasNames?[]:void 0);this.names||(this.names=[],this.names.keys={});this.plotLinesAndBandsGroups={};this.positiveValuesOnly=!!this.logarithmic;this.isLinked=e(a.linkedTo);this.ticks={};this.labelEdge=[];
    	this.minorTicks={};this.plotLinesAndBands=[];this.alternateBands={};this.len=0;this.minRange=this.userMinRange=a.minRange||a.maxZoom;this.range=a.range;this.offset=a.offset||0;this.min=this.max=null;f=D(a.crosshair,T(c.options.tooltip.crosshairs)[d?0:1]);this.crosshair=!0===f?{}:f;-1===c.axes.indexOf(this)&&(d?c.axes.splice(c.xAxis.length,0,this):c.axes.push(this),q(this,c[this.coll]));c.orderItems(this.coll);this.series=this.series||[];c.inverted&&!this.isZAxis&&d&&"undefined"===typeof this.reversed&&
    	(this.reversed=!0);this.labelRotation=b(A.rotation)?A.rotation:void 0;l(this,a);k(this,"afterInit");}setOptions(b){this.options=c(y.defaultXAxisOptions,"yAxis"===this.coll&&y.defaultYAxisOptions,[y.defaultTopAxisOptions,y.defaultRightAxisOptions,y.defaultBottomAxisOptions,y.defaultLeftAxisOptions][this.side],c(v[this.coll],b));k(this,"afterSetOptions",{userOptions:b});}defaultLabelFormatter(c){var f=this.axis;({numberFormatter:c}=this.chart);const a=b(this.value)?this.value:NaN,d=f.chart.time,k=this.dateTimeLabelFormat;
    	var n=v.lang;const A=n.numericSymbols;n=n.numericSymbolMagnitude||1E3;const e=f.logarithmic?Math.abs(a):f.tickInterval;let q=A&&A.length,g;if(f.categories)g=`${this.value}`;else if(k)g=d.dateFormat(k,a);else if(q&&1E3<=e)for(;q--&&"undefined"===typeof g;)f=Math.pow(n,q+1),e>=f&&0===10*a%f&&null!==A[q]&&0!==a&&(g=c(a/f,-1)+A[q]);"undefined"===typeof g&&(g=1E4<=Math.abs(a)?c(a,-1):c(a,-1,void 0,""));return g}getSeriesExtremes(){const c=this,f=c.chart;let a;k(this,"getSeriesExtremes",null,function(){c.hasVisibleSeries=
    	!1;c.dataMin=c.dataMax=c.threshold=null;c.softThreshold=!c.isXAxis;c.series.forEach(function(d){if(d.visible||!f.options.chart.ignoreHiddenSeries){var k=d.options;let f=k.threshold,n,A;c.hasVisibleSeries=!0;c.positiveValuesOnly&&0>=f&&(f=null);if(c.isXAxis)(k=d.xData)&&k.length&&(k=c.logarithmic?k.filter(b=>0<b):k,a=d.getXExtremes(k),n=a.min,A=a.max,b(n)||n instanceof Date||(k=k.filter(b),a=d.getXExtremes(k),n=a.min,A=a.max),k.length&&(c.dataMin=Math.min(D(c.dataMin,n),n),c.dataMax=Math.max(D(c.dataMax,
    	A),A)));else if(d=d.applyExtremes(),b(d.dataMin)&&(n=d.dataMin,c.dataMin=Math.min(D(c.dataMin,n),n)),b(d.dataMax)&&(A=d.dataMax,c.dataMax=Math.max(D(c.dataMax,A),A)),e(f)&&(c.threshold=f),!k.softThreshold||c.positiveValuesOnly)c.softThreshold=!1;}});});k(this,"afterGetSeriesExtremes");}translate(c,f,a,d,k,n){const e=this.linkedParent||this,A=d&&e.old?e.old.min:e.min;if(!b(A))return NaN;const q=e.minPixelPadding;k=(e.isOrdinal||e.brokenAxis&&e.brokenAxis.hasBreaks||e.logarithmic&&k)&&e.lin2val;let J=
    	1,h=0;d=d&&e.old?e.old.transA:e.transA;d||(d=e.transA);a&&(J*=-1,h=e.len);e.reversed&&(J*=-1,h-=J*(e.sector||e.len));f?(n=(c*J+h-q)/d+A,k&&(n=e.lin2val(n))):(k&&(c=e.val2lin(c)),c=J*(c-A)*d,n=(e.isRadial?c:g(c))+h+J*q+(b(n)?d*n:0));return n}toPixels(b,c){return this.translate(b,!1,!this.horiz,void 0,!0)+(c?0:this.pos)}toValue(b,c){return this.translate(b-(c?0:this.pos),!0,!this.horiz,void 0,!0)}getPlotLinePath(c){function f(b,c,f){"pass"!==t&&(b<c||b>f)&&(t?b=h(b,c,f):K=!0);return b}const a=this,
    	d=a.chart,n=a.left,e=a.top,A=c.old,q=c.value,g=c.lineWidth,r=A&&d.oldChartHeight||d.chartHeight,m=A&&d.oldChartWidth||d.chartWidth,l=a.transB;let p=c.translatedValue,t=c.force,P,w,R,Q,K;c={value:q,lineWidth:g,old:A,force:t,acrossPanes:c.acrossPanes,translatedValue:p};k(this,"getPlotLinePath",c,function(c){p=D(p,a.translate(q,void 0,void 0,A));p=h(p,-1E5,1E5);P=R=Math.round(p+l);w=Q=Math.round(r-p-l);b(p)?a.horiz?(w=e,Q=r-a.bottom,P=R=f(P,n,n+a.width)):(P=n,R=m-a.right,w=Q=f(w,e,e+a.height)):(K=!0,
    	t=!1);c.path=K&&!t?null:d.renderer.crispLine([["M",P,w],["L",R,Q]],g||1);});return c.path}getLinearTickPositions(b,c,f){const a=g(Math.floor(c/b)*b);f=g(Math.ceil(f/b)*b);const d=[];let k,n;g(a+b)===a&&(n=20);if(this.single)return [c];for(c=a;c<=f;){d.push(c);c=g(c+b,n);if(c===k)break;k=c;}return d}getMinorTickInterval(){const b=this.options;return !0===b.minorTicks?D(b.minorTickInterval,"auto"):!1===b.minorTicks?null:b.minorTickInterval}getMinorTickPositions(){var b=this.options;const c=this.tickPositions,
    	f=this.minorTickInterval;var a=this.pointRangePadding||0;const d=this.min-a;a=this.max+a;const k=a-d;let n=[];if(k&&k/f<this.len/3){const k=this.logarithmic;if(k)this.paddedTicks.forEach(function(b,c,a){c&&n.push.apply(n,k.getLogTickPositions(f,a[c-1],a[c],!0));});else if(this.dateTime&&"auto"===this.getMinorTickInterval())n=n.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(f),d,a,b.startOfWeek));else for(b=d+(c[0]-d)%f;b<=a&&b!==n[0];b+=f)n.push(b);}0!==n.length&&this.trimTicks(n);
    	return n}adjustForMinRange(){const b=this.options,c=this.logarithmic;let f=this.min;var a=this.max;let d,k;if(this.isXAxis&&"undefined"===typeof this.minRange&&!c)if(e(b.min)||e(b.max)||e(b.floor)||e(b.ceiling))this.minRange=null;else {var n=r(this.series.map(b=>{var c;return (b.xIncrement?null===(c=b.xData)||void 0===c?void 0:c.slice(0,2):b.xData)||[]}))||0;this.minRange=Math.min(5*n,this.dataMax-this.dataMin);}a-f<this.minRange&&(n=this.dataMax-this.dataMin>=this.minRange,k=this.minRange,a=(k-a+f)/
    	2,d=[f-a,D(b.min,f-a)],n&&(d[2]=c?c.log2lin(this.dataMin):this.dataMin),f=t(d),a=[f+k,D(b.max,f+k)],n&&(a[2]=c?c.log2lin(this.dataMax):this.dataMax),a=m(a),a-f<k&&(d[0]=a-k,d[1]=D(b.min,a-k),f=t(d)));this.min=f;this.max=a;}getClosest(){let b,c;if(this.categories)c=1;else {const f=[];this.series.forEach(function(b){var a;const d=b.closestPointRange,k=b.visible||!b.chart.options.chart.ignoreHiddenSeries;1===(null===(a=b.xData)||void 0===a?void 0:a.length)?f.push(b.xData[0]):!b.noSharedTooltip&&e(d)&&
    	k&&(c=e(c)?Math.min(c,d):d);});f.length&&(f.sort((b,c)=>b-c),b=r([f]));}return b&&c?Math.min(b,c):b||c}nameToX(b){const c=G(this.options.categories),f=c?this.categories:this.names;let a=b.options.x,d;b.series.requireSorting=!1;e(a)||(a=this.options.uniqueNames&&f?c?f.indexOf(b.name):D(f.keys[b.name],-1):b.series.autoIncrement());-1===a?!c&&f&&(d=f.length):d=a;"undefined"!==typeof d?(this.names[d]=b.name,this.names.keys[b.name]=d):b.x&&(d=b.x);return d}updateNames(){const b=this,c=this.names;0<c.length&&
    	(Object.keys(c.keys).forEach(function(b){delete c.keys[b];}),c.length=0,this.minRange=this.userMinRange,(this.series||[]).forEach(function(c){c.xIncrement=null;if(!c.points||c.isDirtyData)b.max=Math.max(b.max,c.xData.length-1),c.processData(),c.generatePoints();c.data.forEach(function(f,a){let d;f&&f.options&&"undefined"!==typeof f.name&&(d=b.nameToX(f),"undefined"!==typeof d&&d!==f.x&&(f.x=d,c.xData[a]=d));});}));}setAxisTranslation(){const b=this,c=b.max-b.min;var a=b.linkedParent;const d=!!b.categories,
    	n=b.isXAxis;let e=b.axisPointRange||0,q,g=0,h=0,r=b.transA;if(n||d||e)q=b.getClosest(),a?(g=a.minPointOffset,h=a.pointRangePadding):b.series.forEach(function(c){const a=d?1:n?D(c.options.pointRange,q,0):b.axisPointRange||0,k=c.options.pointPlacement;e=Math.max(e,a);if(!b.single||d)c=c.is("xrange")?!n:n,g=Math.max(g,c&&f(k)?0:a/2),h=Math.max(h,c&&"on"===k?0:a);}),a=b.ordinal&&b.ordinal.slope&&q?b.ordinal.slope/q:1,b.minPointOffset=g*=a,b.pointRangePadding=h*=a,b.pointRange=Math.min(e,b.single&&d?1:
    	c),n&&q&&(b.closestPointRange=q);b.translationSlope=b.transA=r=b.staticScale||b.len/(c+h||1);b.transB=b.horiz?b.left:b.bottom;b.minPixelPadding=r*g;k(this,"afterSetAxisTranslation");}minFromRange(){return this.max-this.range}setTickInterval(c){var f=this.chart;const a=this.logarithmic,d=this.options,n=this.isXAxis,q=this.isLinked,h=d.tickPixelInterval,A=this.categories,r=this.softThreshold;let m=d.maxPadding,l=d.minPadding;let p=b(d.tickInterval)&&0<=d.tickInterval?d.tickInterval:void 0,t=b(this.threshold)?
    	this.threshold:null,P,w,K;this.dateTime||A||q||this.getTickAmount();w=D(this.userMin,d.min);K=D(this.userMax,d.max);if(q){this.linkedParent=f[this.coll][d.linkedTo];var R=this.linkedParent.getExtremes();this.min=D(R.min,R.dataMin);this.max=D(R.max,R.dataMax);d.type!==this.linkedParent.options.type&&F(11,1,f);}else r&&e(t)&&(this.dataMin>=t?(R=t,l=0):this.dataMax<=t&&(P=t,m=0)),this.min=D(w,R,this.dataMin),this.max=D(K,P,this.dataMax);a&&(this.positiveValuesOnly&&!c&&0>=Math.min(this.min,D(this.dataMin,
    	this.min))&&F(10,1,f),this.min=g(a.log2lin(this.min),16),this.max=g(a.log2lin(this.max),16));this.range&&e(this.max)&&(this.userMin=this.min=w=Math.max(this.dataMin,this.minFromRange()),this.userMax=K=this.max,this.range=null);k(this,"foundExtremes");this.beforePadding&&this.beforePadding();this.adjustForMinRange();!b(this.userMin)&&b(d.softMin)&&d.softMin<this.min&&(this.min=w=d.softMin);!b(this.userMax)&&b(d.softMax)&&d.softMax>this.max&&(this.max=K=d.softMax);!(A||this.axisPointRange||this.stacking&&
    	this.stacking.usePercentage||q)&&e(this.min)&&e(this.max)&&(f=this.max-this.min)&&(!e(w)&&l&&(this.min-=f*l),!e(K)&&m&&(this.max+=f*m));!b(this.userMin)&&b(d.floor)&&(this.min=Math.max(this.min,d.floor));!b(this.userMax)&&b(d.ceiling)&&(this.max=Math.min(this.max,d.ceiling));r&&e(this.dataMin)&&(t=t||0,!e(w)&&this.min<t&&this.dataMin>=t?this.min=this.options.minRange?Math.min(t,this.max-this.minRange):t:!e(K)&&this.max>t&&this.dataMax<=t&&(this.max=this.options.minRange?Math.max(t,this.min+this.minRange):
    	t));b(this.min)&&b(this.max)&&!this.chart.polar&&this.min>this.max&&(e(this.options.min)?this.max=this.min:e(this.options.max)&&(this.min=this.max));this.tickInterval=this.min===this.max||"undefined"===typeof this.min||"undefined"===typeof this.max?1:q&&this.linkedParent&&!p&&h===this.linkedParent.options.tickPixelInterval?p=this.linkedParent.tickInterval:D(p,this.tickAmount?(this.max-this.min)/Math.max(this.tickAmount-1,1):void 0,A?1:(this.max-this.min)*h/Math.max(this.len,h));if(n&&!c){const b=
    	this.min!==(this.old&&this.old.min)||this.max!==(this.old&&this.old.max);this.series.forEach(function(c){c.forceCrop=c.forceCropping&&c.forceCropping();c.processData(b);});k(this,"postProcessData",{hasExtremesChanged:b});}this.setAxisTranslation();k(this,"initialAxisTranslation");this.pointRange&&!p&&(this.tickInterval=Math.max(this.pointRange,this.tickInterval));c=D(d.minTickInterval,this.dateTime&&!this.series.some(b=>b.noSharedTooltip)?this.closestPointRange:0);!p&&this.tickInterval<c&&(this.tickInterval=
    	c);this.dateTime||this.logarithmic||p||(this.tickInterval=V(this,this.tickInterval));this.tickAmount||(this.tickInterval=this.unsquish());this.setTickPositions();}setTickPositions(){var c=this.options;const f=c.tickPositions,a=c.tickPositioner;var d=this.getMinorTickInterval(),n=this.hasVerticalPanning(),q="colorAxis"===this.coll;const g=(q||!n)&&c.startOnTick;n=(q||!n)&&c.endOnTick;q=[];let h;this.tickmarkOffset=this.categories&&"between"===c.tickmarkPlacement&&1===this.tickInterval?.5:0;this.minorTickInterval=
    	"auto"===d&&this.tickInterval?this.tickInterval/c.minorTicksPerMajor:d;this.single=this.min===this.max&&e(this.min)&&!this.tickAmount&&(parseInt(this.min,10)===this.min||!1!==c.allowDecimals);if(f)q=f.slice();else if(b(this.min)&&b(this.max)){if(this.ordinal&&this.ordinal.positions||!((this.max-this.min)/this.tickInterval>Math.max(2*this.len,200)))if(this.dateTime)q=this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval,c.units),this.min,this.max,c.startOfWeek,this.ordinal&&this.ordinal.positions,
    	this.closestPointRange,!0);else if(this.logarithmic)q=this.logarithmic.getLogTickPositions(this.tickInterval,this.min,this.max);else for(d=c=this.tickInterval;d<=2*c;)if(q=this.getLinearTickPositions(this.tickInterval,this.min,this.max),this.tickAmount&&q.length>this.tickAmount)this.tickInterval=V(this,d*=1.1);else break;else q=[this.min,this.max],F(19,!1,this.chart);q.length>this.len&&(q=[q[0],q[q.length-1]],q[0]===q[1]&&(q.length=1));a&&(this.tickPositions=q,(h=a.apply(this,[this.min,this.max]))&&
    	(q=h));}this.tickPositions=q;this.paddedTicks=q.slice(0);this.trimTicks(q,g,n);!this.isLinked&&b(this.min)&&b(this.max)&&(this.single&&2>q.length&&!this.categories&&!this.series.some(b=>b.is("heatmap")&&"between"===b.options.pointPlacement)&&(this.min-=.5,this.max+=.5),f||h||this.adjustTickAmount());k(this,"afterSetTickPositions");}trimTicks(b,c,f){const a=b[0],d=b[b.length-1],n=!this.isOrdinal&&this.minPointOffset||0;k(this,"trimTicks");if(!this.isLinked){if(c&&-Infinity!==a)this.min=a;else for(;this.min-
    	n>b[0];)b.shift();if(f)this.max=d;else for(;this.max+n<b[b.length-1];)b.pop();0===b.length&&e(a)&&!this.options.tickPositions&&b.push((d+a)/2);}}alignToOthers(){const c=this,f=[this],a=c.options,d="yAxis"===this.coll&&this.chart.options.chart.alignThresholds,k=[];let n;c.thresholdAlignment=void 0;if((!1!==this.chart.options.chart.alignTicks&&a.alignTicks||d)&&!1!==a.startOnTick&&!1!==a.endOnTick&&!c.logarithmic){const b=b=>{const {horiz:c,options:f}=b;return [c?f.left:f.top,f.width,f.height,f.pane].join()},
    	a=b(this);this.chart[this.coll].forEach(function(d){const {series:k}=d;k.length&&k.some(b=>b.visible)&&d!==c&&b(d)===a&&(n=!0,f.push(d));});}if(n&&d){f.forEach(f=>{f=f.getThresholdAlignment(c);b(f)&&k.push(f);});const a=1<k.length?k.reduce((b,c)=>b+c,0)/k.length:void 0;f.forEach(b=>{b.thresholdAlignment=a;});}return n}getThresholdAlignment(c){(!b(this.dataMin)||this!==c&&this.series.some(b=>b.isDirty||b.isDirtyData))&&this.getSeriesExtremes();if(b(this.threshold))return c=h((this.threshold-(this.dataMin||
    	0))/((this.dataMax||0)-(this.dataMin||0)),0,1),this.options.reversed&&(c=1-c),c}getTickAmount(){const b=this.options,c=b.tickPixelInterval;let f=b.tickAmount;!e(b.tickInterval)&&!f&&this.len<c&&!this.isRadial&&!this.logarithmic&&b.startOnTick&&b.endOnTick&&(f=2);!f&&this.alignToOthers()&&(f=Math.ceil(this.len/c)+1);4>f&&(this.finalTickAmt=f,f=5);this.tickAmount=f;}adjustTickAmount(){const c=this,{finalTickAmt:f,max:a,min:d,options:k,tickPositions:n,tickAmount:q,thresholdAlignment:h}=c,r=n&&n.length;
    	var m=D(c.threshold,c.softThreshold?0:null);var l=c.tickInterval;let p;b(h)&&(p=.5>h?Math.ceil(h*(q-1)):Math.floor(h*(q-1)),k.reversed&&(p=q-1-p));if(c.hasData()&&b(d)&&b(a)){const h=()=>{c.transA*=(r-1)/(q-1);c.min=k.startOnTick?n[0]:Math.min(d,n[0]);c.max=k.endOnTick?n[n.length-1]:Math.max(a,n[n.length-1]);};if(b(p)&&b(c.threshold)){for(;n[p]!==m||n.length!==q||n[0]>d||n[n.length-1]<a;){n.length=0;for(n.push(c.threshold);n.length<q;)void 0===n[p]||n[p]>c.threshold?n.unshift(g(n[0]-l)):n.push(g(n[n.length-
    	1]+l));if(l>8*c.tickInterval)break;l*=2;}h();}else if(r<q){for(;n.length<q;)n.length%2||d===m?n.push(g(n[n.length-1]+l)):n.unshift(g(n[0]-l));h();}if(e(f)){for(l=m=n.length;l--;)(3===f&&1===l%2||2>=f&&0<l&&l<m-1)&&n.splice(l,1);c.finalTickAmt=void 0;}}}setScale(){let b=!1,c=!1;this.series.forEach(function(f){b=b||f.isDirtyData||f.isDirty;c=c||f.xAxis&&f.xAxis.isDirty||!1;});this.setAxisSize();const f=this.len!==(this.old&&this.old.len);f||b||c||this.isLinked||this.forceRedraw||this.userMin!==(this.old&&
    	this.old.userMin)||this.userMax!==(this.old&&this.old.userMax)||this.alignToOthers()?(this.stacking&&(this.stacking.resetStacks(),this.stacking.buildStacks()),this.forceRedraw=!1,this.userMinRange||(this.minRange=void 0),this.getSeriesExtremes(),this.setTickInterval(),this.isDirty||(this.isDirty=f||this.min!==(this.old&&this.old.min)||this.max!==(this.old&&this.old.max))):this.stacking&&this.stacking.cleanStacks();b&&this.panningState&&(this.panningState.isDirty=!0);k(this,"afterSetScale");}setExtremes(b,
    	c,f,a,n){const e=this,q=e.chart;f=D(f,!0);e.series.forEach(function(b){delete b.kdTree;});n=d(n,{min:b,max:c});k(e,"setExtremes",n,function(){e.userMin=b;e.userMax=c;e.eventArgs=n;f&&q.redraw(a);});}zoom(b,c){const f=this,a=this.dataMin,d=this.dataMax,n=this.options,q=Math.min(a,D(n.min,a)),g=Math.max(d,D(n.max,d));b={newMin:b,newMax:c};k(this,"zoom",b,function(b){let c=b.newMin,n=b.newMax;if(c!==f.min||n!==f.max)f.allowZoomOutside||(e(a)&&(c<q&&(c=q),c>g&&(c=g)),e(d)&&(n<q&&(n=q),n>g&&(n=g))),f.displayBtn=
    	"undefined"!==typeof c||"undefined"!==typeof n,f.setExtremes(c,n,!1,void 0,{trigger:"zoom"});b.zoomed=!0;});return b.zoomed}setAxisSize(){const b=this.chart;var c=this.options;const f=c.offsets||[0,0,0,0],a=this.horiz,d=this.width=Math.round(K(D(c.width,b.plotWidth-f[3]+f[1]),b.plotWidth)),n=this.height=Math.round(K(D(c.height,b.plotHeight-f[0]+f[2]),b.plotHeight)),k=this.top=Math.round(K(D(c.top,b.plotTop+f[0]),b.plotHeight,b.plotTop));c=this.left=Math.round(K(D(c.left,b.plotLeft+f[3]),b.plotWidth,
    	b.plotLeft));this.bottom=b.chartHeight-n-k;this.right=b.chartWidth-d-c;this.len=Math.max(a?d:n,0);this.pos=a?c:k;}getExtremes(){const b=this.logarithmic;return {min:b?g(b.lin2log(this.min)):this.min,max:b?g(b.lin2log(this.max)):this.max,dataMin:this.dataMin,dataMax:this.dataMax,userMin:this.userMin,userMax:this.userMax}}getThreshold(b){var c=this.logarithmic;const f=c?c.lin2log(this.min):this.min;c=c?c.lin2log(this.max):this.max;null===b||-Infinity===b?b=f:Infinity===b?b=c:f>b?b=f:c<b&&(b=c);return this.translate(b,
    	0,1,0,1)}autoLabelAlign(b){const c=(D(b,0)-90*this.side+720)%360;b={align:"center"};k(this,"autoLabelAlign",b,function(b){15<c&&165>c?b.align="right":195<c&&345>c&&(b.align="left");});return b.align}tickSize(b){const c=this.options,f=D(c["tick"===b?"tickWidth":"minorTickWidth"],"tick"===b&&this.isXAxis&&!this.categories?1:0);let a=c["tick"===b?"tickLength":"minorTickLength"],d;f&&a&&("inside"===c[b+"Position"]&&(a=-a),d=[a,f]);b={tickSize:d};k(this,"afterTickSize",b);return b.tickSize}labelMetrics(){const b=
    	this.chart.renderer;var c=this.ticks;c=c[Object.keys(c)[0]]||{};return this.chart.renderer.fontMetrics(c.label||c.movedLabel||b.box)}unsquish(){const c=this.options.labels;var f=this.horiz;const a=this.tickInterval,d=this.len/(((this.categories?1:0)+this.max-this.min)/a),n=c.rotation,k=.75*this.labelMetrics().h,e=Math.max(this.max-this.min,0),q=function(b){let c=b/(d||1);c=1<c?Math.ceil(c):1;c*a>e&&Infinity!==b&&Infinity!==d&&e&&(c=Math.ceil(e/a));return g(c*a)};let h=a,r,l=Number.MAX_VALUE,m;if(f){if(c.staggerLines||
    	(b(n)?m=[n]:d<c.autoRotationLimit&&(m=c.autoRotation)),m){let b;for(const c of m)if(c===n||c&&-90<=c&&90>=c)f=q(Math.abs(k/Math.sin(p*c))),b=f+Math.abs(c/360),b<l&&(l=b,r=c,h=f);}}else h=q(k);this.autoRotation=m;this.labelRotation=D(r,b(n)?n:0);return c.step?a:h}getSlotWidth(c){const f=this.chart,a=this.horiz,d=this.options.labels,n=Math.max(this.tickPositions.length-(this.categories?0:1),1),k=f.margin[3];if(c&&b(c.slotWidth))return c.slotWidth;if(a&&2>d.step)return d.rotation?0:(this.staggerLines||
    	1)*this.len/n;if(!a){c=d.style.width;if(void 0!==c)return parseInt(String(c),10);if(k)return k-f.spacing[3]}return .33*f.chartWidth}renderUnsquish(){const b=this.chart,c=b.renderer,a=this.tickPositions,d=this.ticks,n=this.options.labels,k=n.style,e=this.horiz,q=this.getSlotWidth();var g=Math.max(1,Math.round(q-2*n.padding));const h={},r=this.labelMetrics(),m=k.textOverflow;let l,p,D=0;f(n.rotation)||(h.rotation=n.rotation||0);a.forEach(function(b){b=d[b];b.movedLabel&&b.replaceMovedLabel();b&&b.label&&
    	b.label.textPxLength>D&&(D=b.label.textPxLength);});this.maxLabelLength=D;if(this.autoRotation)D>g&&D>r.h?h.rotation=this.labelRotation:this.labelRotation=0;else if(q&&(l=g,!m))for(p="clip",g=a.length;!e&&g--;){var t=a[g];if(t=d[t].label)t.styles&&"ellipsis"===t.styles.textOverflow?t.css({textOverflow:"clip"}):t.textPxLength>q&&t.css({width:q+"px"}),t.getBBox().height>this.len/a.length-(r.h-r.f)&&(t.specificTextOverflow="ellipsis");}h.rotation&&(l=D>.5*b.chartHeight?.33*b.chartHeight:D,m||(p="ellipsis"));
    	if(this.labelAlign=n.align||this.autoLabelAlign(this.labelRotation))h.align=this.labelAlign;a.forEach(function(b){const c=(b=d[b])&&b.label,f=k.width,a={};c&&(c.attr(h),b.shortenLabel?b.shortenLabel():l&&!f&&"nowrap"!==k.whiteSpace&&(l<c.textPxLength||"SPAN"===c.element.tagName)?(a.width=l+"px",m||(a.textOverflow=c.specificTextOverflow||p),c.css(a)):c.styles&&c.styles.width&&!a.width&&!f&&c.css({width:null}),delete c.specificTextOverflow,b.rotation=h.rotation);},this);this.tickRotCorr=c.rotCorr(r.b,
    	this.labelRotation||0,0!==this.side);}hasData(){return this.series.some(function(b){return b.hasData()})||this.options.showEmpty&&e(this.min)&&e(this.max)}addTitle(b){const f=this.chart.renderer,a=this.horiz,d=this.opposite,n=this.options.title,k=this.chart.styledMode;let e;this.axisTitle||((e=n.textAlign)||(e=(a?{low:"left",middle:"center",high:"right"}:{low:d?"right":"left",middle:"center",high:d?"left":"right"})[n.align]),this.axisTitle=f.text(n.text||"",0,0,n.useHTML).attr({zIndex:7,rotation:n.rotation,
    	align:e}).addClass("highcharts-axis-title"),k||this.axisTitle.css(c(n.style)),this.axisTitle.add(this.axisGroup),this.axisTitle.isNew=!0);k||n.style.width||this.isRadial||this.axisTitle.css({width:this.len+"px"});this.axisTitle[b?"show":"hide"](b);}generateTick(b){const c=this.ticks;c[b]?c[b].addLabel():c[b]=new H(this,b);}getOffset(){const c=this,{chart:f,horiz:a,options:d,side:n,ticks:q,tickPositions:g,coll:h,axisParent:r}=c,m=f.renderer,l=f.inverted&&!c.isZAxis?[1,0,3,2][n]:n;var p=c.hasData();const t=
    	d.title;var w=d.labels;const K=b(d.crossing);var G=f.axisOffset;const R=f.clipOffset,Q=[-1,1,1,-1][n],v=d.className;let ja,u=0,x;var E=0;let F=0;c.showAxis=ja=p||d.showEmpty;c.staggerLines=c.horiz&&w.staggerLines||void 0;if(!c.axisGroup){const b=(b,c,f)=>m.g(b).attr({zIndex:f}).addClass(`highcharts-${h.toLowerCase()}${c} `+(this.isRadial?`highcharts-radial-axis${c} `:"")+(v||"")).add(r);c.gridGroup=b("grid","-grid",d.gridZIndex);c.axisGroup=b("axis","",d.zIndex);c.labelGroup=b("axis-labels","-labels",
    	w.zIndex);}p||c.isLinked?(g.forEach(function(b){c.generateTick(b);}),c.renderUnsquish(),c.reserveSpaceDefault=0===n||2===n||{1:"left",3:"right"}[n]===c.labelAlign,D(w.reserveSpace,K?!1:null,"center"===c.labelAlign?!0:null,c.reserveSpaceDefault)&&g.forEach(function(b){F=Math.max(q[b].getLabelSize(),F);}),c.staggerLines&&(F*=c.staggerLines),c.labelOffset=F*(c.opposite?-1:1)):P(q,function(b,c){b.destroy();delete q[c];});t&&t.text&&!1!==t.enabled&&(c.addTitle(ja),ja&&!K&&!1!==t.reserveSpace&&(c.titleOffset=
    	u=c.axisTitle.getBBox()[a?"height":"width"],x=t.offset,E=e(x)?0:D(t.margin,a?5:10)));c.renderLine();c.offset=Q*D(d.offset,G[n]?G[n]+(d.margin||0):0);c.tickRotCorr=c.tickRotCorr||{x:0,y:0};p=0===n?-c.labelMetrics().h:2===n?c.tickRotCorr.y:0;E=Math.abs(F)+E;F&&(E=E-p+Q*(a?D(w.y,c.tickRotCorr.y+Q*w.distance):D(w.x,Q*w.distance)));c.axisTitleMargin=D(x,E);c.getMaxLabelDimensions&&(c.maxLabelDimensions=c.getMaxLabelDimensions(q,g));"colorAxis"!==h&&(w=this.tickSize("tick"),G[n]=Math.max(G[n],(c.axisTitleMargin||
    	0)+u+Q*c.offset,E,g&&g.length&&w?w[0]+Q*c.offset:0),G=!c.axisLine||d.offset?0:2*Math.floor(c.axisLine.strokeWidth()/2),R[l]=Math.max(R[l],G));k(this,"afterGetOffset");}getLinePath(b){const c=this.chart,f=this.opposite;var a=this.offset;const d=this.horiz,n=this.left+(f?this.width:0)+a;a=c.chartHeight-this.bottom-(f?this.height:0)+a;f&&(b*=-1);return c.renderer.crispLine([["M",d?this.left:n,d?a:this.top],["L",d?c.chartWidth-this.right:n,d?a:c.chartHeight-this.bottom]],b)}renderLine(){this.axisLine||
    	(this.axisLine=this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup),this.chart.styledMode||this.axisLine.attr({stroke:this.options.lineColor,"stroke-width":this.options.lineWidth,zIndex:7}));}getTitlePosition(b){var c=this.horiz,f=this.left;const a=this.top;var d=this.len;const n=this.options.title,e=c?f:a,q=this.opposite,g=this.offset,h=n.x,r=n.y,l=this.chart.renderer.fontMetrics(b);b=b?Math.max(b.getBBox(!1,0).height-l.h-1,0):0;d={low:e+(c?0:d),middle:e+d/2,high:e+(c?d:
    	0)}[n.align];f=(c?a+this.height:f)+(c?1:-1)*(q?-1:1)*(this.axisTitleMargin||0)+[-b,b,l.f,-b][this.side];c={x:c?d+h:f+(q?this.width:0)+g+h,y:c?f+r-(q?this.height:0)+g:d+r};k(this,"afterGetTitlePosition",{titlePosition:c});return c}renderMinorTick(b,c){const f=this.minorTicks;f[b]||(f[b]=new H(this,b,"minor"));c&&f[b].isNew&&f[b].render(null,!0);f[b].render(null,!1,1);}renderTick(b,c,f){const a=this.ticks;if(!this.isLinked||b>=this.min&&b<=this.max||this.grid&&this.grid.isColumn)a[b]||(a[b]=new H(this,
    	b)),f&&a[b].isNew&&a[b].render(c,!0,-1),a[b].render(c);}render(){const c=this,f=c.chart,a=c.logarithmic,d=c.options,n=c.isLinked,e=c.tickPositions,q=c.axisTitle,g=c.ticks,h=c.minorTicks,r=c.alternateBands,l=d.stackLabels,m=d.alternateGridColor;var p=d.crossing;const D=c.tickmarkOffset,t=c.axisLine,w=c.showAxis,K=u(f.renderer.globalAnimation);let Q,G;c.labelEdge.length=0;c.overlap=!1;[g,h,r].forEach(function(b){P(b,function(b){b.isActive=!1;});});if(b(p)){const b=this.isXAxis?f.yAxis[0]:f.xAxis[0],a=
    	[1,-1,-1,1][this.side];b&&(p=b.toPixels(p,!0),c.horiz&&(p=b.len-p),c.offset=a*p);}if(c.hasData()||n){const n=c.chart.hasRendered&&c.old&&b(c.old.min);c.minorTickInterval&&!c.categories&&c.getMinorTickPositions().forEach(function(b){c.renderMinorTick(b,n);});e.length&&(e.forEach(function(b,f){c.renderTick(b,f,n);}),D&&(0===c.min||c.single)&&(g[-1]||(g[-1]=new H(c,-1,null,!0)),g[-1].render(-1)));m&&e.forEach(function(b,d){G="undefined"!==typeof e[d+1]?e[d+1]+D:c.max-D;0===d%2&&b<c.max&&G<=c.max+(f.polar?
    	-D:D)&&(r[b]||(r[b]=new z.PlotLineOrBand(c)),Q=b+D,r[b].options={from:a?a.lin2log(Q):Q,to:a?a.lin2log(G):G,color:m,className:"highcharts-alternate-grid"},r[b].render(),r[b].isActive=!0);});c._addedPlotLB||(c._addedPlotLB=!0,(d.plotLines||[]).concat(d.plotBands||[]).forEach(function(b){c.addPlotBandOrLine(b);}));}[g,h,r].forEach(function(b){const c=[],a=K.duration;P(b,function(b,f){b.isActive||(b.render(f,!1,0),b.isActive=!1,c.push(f));});Z(function(){let f=c.length;for(;f--;)b[c[f]]&&!b[c[f]].isActive&&
    	(b[c[f]].destroy(),delete b[c[f]]);},b!==r&&f.hasRendered&&a?a:0);});t&&(t[t.isPlaced?"animate":"attr"]({d:this.getLinePath(t.strokeWidth())}),t.isPlaced=!0,t[w?"show":"hide"](w));q&&w&&(q[q.isNew?"attr":"animate"](c.getTitlePosition(q)),q.isNew=!1);l&&l.enabled&&c.stacking&&c.stacking.renderStackTotals();c.old={len:c.len,max:c.max,min:c.min,transA:c.transA,userMax:c.userMax,userMin:c.userMin};c.isDirty=!1;k(this,"afterRender");}redraw(){this.visible&&(this.render(),this.plotLinesAndBands.forEach(function(b){b.render();}));
    	this.series.forEach(function(b){b.isDirty=!0;});}getKeepProps(){return this.keepProps||Y.keepProps}destroy(b){const c=this,f=c.plotLinesAndBands,a=this.eventOptions;k(this,"destroy",{keepEvents:b});b||X(c);[c.ticks,c.minorTicks,c.alternateBands].forEach(function(b){w(b);});if(f)for(b=f.length;b--;)f[b].destroy();"axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function(b){c[b]&&(c[b]=c[b].destroy());});for(const b in c.plotLinesAndBandsGroups)c.plotLinesAndBandsGroups[b]=
    	c.plotLinesAndBandsGroups[b].destroy();P(c,function(b,f){-1===c.getKeepProps().indexOf(f)&&delete c[f];});this.eventOptions=a;}drawCrosshair(b,c){const f=this.crosshair;var a=D(f&&f.snap,!0);const n=this.chart;let q,g=this.cross;k(this,"drawCrosshair",{e:b,point:c});b||(b=this.cross&&this.cross.e);if(f&&!1!==(e(c)||!a)){a?e(c)&&(q=D("colorAxis"!==this.coll?c.crosshairPos:null,this.isXAxis?c.plotX:this.len-c.plotY)):q=b&&(this.horiz?b.chartX-this.pos:this.len-b.chartY+this.pos);if(e(q)){var h={value:c&&
    	(this.isXAxis?c.x:D(c.stackY,c.y)),translatedValue:q};n.polar&&d(h,{isCrosshair:!0,chartX:b&&b.chartX,chartY:b&&b.chartY,point:c});h=this.getPlotLinePath(h)||null;}if(!e(h)){this.hideCrosshair();return}a=this.categories&&!this.isRadial;g||(this.cross=g=n.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-"+(a?"category ":"thin ")+(f.className||"")).attr({zIndex:D(f.zIndex,2)}).add(),n.styledMode||(g.attr({stroke:f.color||(a?I.parse("#ccd3ff").setOpacity(.25).get():"#cccccc"),"stroke-width":D(f.width,
    	1)}).css({"pointer-events":"none"}),f.dashStyle&&g.attr({dashstyle:f.dashStyle})));g.show().attr({d:h});a&&!f.width&&g.attr({"stroke-width":this.transA});this.cross.e=b;}else this.hideCrosshair();k(this,"afterDrawCrosshair",{e:b,point:c});}hideCrosshair(){this.cross&&this.cross.hide();k(this,"afterHideCrosshair");}hasVerticalPanning(){const b=this.chart.options.chart.panning;return !!(b&&b.enabled&&/y/.test(b.type))}update(b,f){const a=this.chart;b=c(this.userOptions,b);this.destroy(!0);this.init(a,b);
    	a.isDirtyBox=!0;D(f,!0)&&a.redraw();}remove(b){const c=this.chart,f=this.coll,a=this.series;let d=a.length;for(;d--;)a[d]&&a[d].remove(!1);x(c.axes,this);x(c[f]||[],this);c.orderItems(f);this.destroy();c.isDirtyBox=!0;D(b,!0)&&c.redraw();}setTitle(b,c){this.update({title:b},c);}setCategories(b,c){this.update({categories:b},c);}}Y.defaultOptions=y.defaultXAxisOptions;Y.keepProps="coll extKey hcEvents names series userMax userMin".split(" ");return Y});M(a,"Core/Axis/DateTimeAxis.js",[a["Core/Utilities.js"]],
    	function(a){const {addEvent:x,getMagnitude:I,normalizeTickInterval:L,timeUnits:C}=a;var z;(function(y){function B(){return this.chart.time.getTimeTicks.apply(this.chart.time,arguments)}function u(a){"datetime"!==a.userOptions.type?this.dateTime=void 0:this.dateTime||(this.dateTime=new l(this));}const v=[];y.compose=function(l){a.pushUnique(v,l)&&(l.keepProps.push("dateTime"),l.prototype.getTimeTicks=B,x(l,"init",u));return l};class l{constructor(a){this.axis=a;}normalizeTimeTickInterval(a,l){const m=
    	l||[["millisecond",[1,2,5,10,20,25,50,100,200,500]],["second",[1,2,5,10,15,30]],["minute",[1,2,5,10,15,30]],["hour",[1,2,3,4,6,8,12]],["day",[1,2]],["week",[1,2]],["month",[1,2,3,4,6]],["year",null]];l=m[m.length-1];let h=C[l[0]],g=l[1],e;for(e=0;e<m.length&&!(l=m[e],h=C[l[0]],g=l[1],m[e+1]&&a<=(h*g[g.length-1]+C[m[e+1][0]])/2);e++);h===C.year&&a<5*h&&(g=[1,2,5]);a=L(a/h,g,"year"===l[0]?Math.max(I(a/h),1):1);return {unitRange:h,count:a,unitName:l[0]}}getXDateFormat(a,l){const {axis:m}=this,h=m.chart.time;
    	return m.closestPointRange?h.getDateFormat(m.closestPointRange,a,m.options.startOfWeek,l)||h.resolveDTLFormat(l.year).main:h.resolveDTLFormat(l.day).main}}y.Additions=l;})(z||(z={}));return z});M(a,"Core/Axis/LogarithmicAxis.js",[a["Core/Utilities.js"]],function(a){const {addEvent:x,normalizeTickInterval:I,pick:L}=a;var C;(function(y){function H(a){let l=this.logarithmic;"logarithmic"!==a.userOptions.type?this.logarithmic=void 0:l||(this.logarithmic=new v(this));}function B(){const a=this.logarithmic;
    	a&&(this.lin2val=function(l){return a.lin2log(l)},this.val2lin=function(l){return a.log2lin(l)});}const u=[];y.compose=function(l){a.pushUnique(u,l)&&(l.keepProps.push("logarithmic"),x(l,"init",H),x(l,"afterInit",B));return l};class v{constructor(a){this.axis=a;}getLogTickPositions(a,p,t,m){const h=this.axis;var g=h.len,e=h.options;let l=[];m||(this.minorAutoInterval=void 0);if(.5<=a)a=Math.round(a),l=h.getLinearTickPositions(a,p,t);else if(.08<=a){e=Math.floor(p);let h,w,d,k,r;for(g=.3<a?[1,2,4]:.15<
    	a?[1,2,4,6,8]:[1,2,3,4,5,6,7,8,9];e<t+1&&!r;e++)for(w=g.length,h=0;h<w&&!r;h++)d=this.log2lin(this.lin2log(e)*g[h]),d>p&&(!m||k<=t)&&"undefined"!==typeof k&&l.push(k),k>t&&(r=!0),k=d;}else p=this.lin2log(p),t=this.lin2log(t),a=m?h.getMinorTickInterval():e.tickInterval,a=L("auto"===a?null:a,this.minorAutoInterval,e.tickPixelInterval/(m?5:1)*(t-p)/((m?g/h.tickPositions.length:g)||1)),a=I(a),l=h.getLinearTickPositions(a,p,t).map(this.log2lin),m||(this.minorAutoInterval=a/5);m||(h.tickInterval=a);return l}lin2log(a){return Math.pow(10,
    	a)}log2lin(a){return Math.log(a)/Math.LN10}}y.Additions=v;})(C||(C={}));return C});M(a,"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js",[a["Core/Utilities.js"]],function(a){const {erase:x,extend:I,isNumber:L}=a;var C;(function(y){function H(a){return this.addPlotBandOrLine(a,"plotBands")}function B(a,e){const g=this.userOptions;let l=new h(this,a);this.visible&&(l=l.render());if(l){this._addedPlotLB||(this._addedPlotLB=!0,(g.plotLines||[]).concat(g.plotBands||[]).forEach(a=>{this.addPlotBandOrLine(a);}));
    	if(e){const h=g[e]||[];h.push(a);g[e]=h;}this.plotLinesAndBands.push(l);}return l}function u(a){return this.addPlotBandOrLine(a,"plotLines")}function v(a,e,h=this.options){const g=this.getPlotLinePath({value:e,force:!0,acrossPanes:h.acrossPanes}),l=[],d=this.horiz;e=!L(this.min)||!L(this.max)||a<this.min&&e<this.min||a>this.max&&e>this.max;a=this.getPlotLinePath({value:a,force:!0,acrossPanes:h.acrossPanes});h=1;let k;if(a&&g)for(e&&(k=a.toString()===g.toString(),h=0),e=0;e<a.length;e+=2){const r=a[e],
    	q=a[e+1],m=g[e],b=g[e+1];"M"!==r[0]&&"L"!==r[0]||"M"!==q[0]&&"L"!==q[0]||"M"!==m[0]&&"L"!==m[0]||"M"!==b[0]&&"L"!==b[0]||(d&&m[1]===r[1]?(m[1]+=h,b[1]+=h):d||m[2]!==r[2]||(m[2]+=h,b[2]+=h),l.push(["M",r[1],r[2]],["L",q[1],q[2]],["L",b[1],b[2]],["L",m[1],m[2]],["Z"]));l.isFlat=k;}return l}function l(a){this.removePlotBandOrLine(a);}function p(a){const e=this.plotLinesAndBands,g=this.options,h=this.userOptions;if(e){let l=e.length;for(;l--;)e[l].id===a&&e[l].destroy();[g.plotLines||[],h.plotLines||[],
    	g.plotBands||[],h.plotBands||[]].forEach(function(d){for(l=d.length;l--;)(d[l]||{}).id===a&&x(d,d[l]);});}}function t(a){this.removePlotBandOrLine(a);}const m=[];let h;y.compose=function(g,e){h||(h=g);a.pushUnique(m,e)&&I(e.prototype,{addPlotBand:H,addPlotLine:u,addPlotBandOrLine:B,getPlotBandPath:v,removePlotBand:l,removePlotLine:t,removePlotBandOrLine:p});return e};})(C||(C={}));return C});M(a,"Core/Axis/PlotLineOrBand/PlotLineOrBand.js",[a["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"],a["Core/Utilities.js"]],
    	function(a,y){const {arrayMax:x,arrayMin:L,defined:C,destroyObjectProperties:z,erase:H,fireEvent:B,merge:u,objectEach:v,pick:l}=y;class p{static compose(l){return a.compose(p,l)}constructor(a,l){this.axis=a;l&&(this.options=l,this.id=l.id);}render(){B(this,"render");const a=this,m=a.axis,h=m.horiz;var g=m.logarithmic;const e=a.options,p=e.color,x=l(e.zIndex,0),F=e.events,d={},k=m.chart.renderer;let r=e.label,q=a.label,G=e.to,b=e.from,f=e.value,c=a.svgElem;var n=[];const P=C(b)&&C(G);n=C(f);const D=
    	!c,K={"class":"highcharts-plot-"+(P?"band ":"line ")+(e.className||"")};let X=P?"bands":"lines";g&&(b=g.log2lin(b),G=g.log2lin(G),f=g.log2lin(f));m.chart.styledMode||(n?(K.stroke=p||"#999999",K["stroke-width"]=l(e.width,1),e.dashStyle&&(K.dashstyle=e.dashStyle)):P&&(K.fill=p||"#e6e9ff",e.borderWidth&&(K.stroke=e.borderColor,K["stroke-width"]=e.borderWidth)));d.zIndex=x;X+="-"+x;(g=m.plotLinesAndBandsGroups[X])||(m.plotLinesAndBandsGroups[X]=g=k.g("plot-"+X).attr(d).add());D&&(a.svgElem=c=k.path().attr(K).add(g));
    	if(n)n=m.getPlotLinePath({value:f,lineWidth:c.strokeWidth(),acrossPanes:e.acrossPanes});else if(P)n=m.getPlotBandPath(b,G,e);else return;!a.eventsAdded&&F&&(v(F,function(b,f){c.on(f,function(b){F[f].apply(a,[b]);});}),a.eventsAdded=!0);(D||!c.d)&&n&&n.length?c.attr({d:n}):c&&(n?(c.show(),c.animate({d:n})):c.d&&(c.hide(),q&&(a.label=q=q.destroy())));r&&(C(r.text)||C(r.formatter))&&n&&n.length&&0<m.width&&0<m.height&&!n.isFlat?(r=u({align:h&&P&&"center",x:h?!P&&4:10,verticalAlign:!h&&P&&"middle",y:h?
    	P?16:10:P?6:-4,rotation:h&&!P&&90},r),this.renderLabel(r,n,P,x)):q&&q.hide();return a}renderLabel(a,l,h,g){const e=this.axis;var m=e.chart.renderer;let p=this.label;p||(this.label=p=m.text(this.getLabelText(a),0,0,a.useHTML).attr({align:a.textAlign||a.align,rotation:a.rotation,"class":"highcharts-plot-"+(h?"band":"line")+"-label "+(a.className||""),zIndex:g}).add(),e.chart.styledMode||p.css(u({fontSize:"0.8em",textOverflow:"ellipsis"},a.style)));g=l.xBounds||[l[0][1],l[1][1],h?l[2][1]:l[0][1]];l=
    	l.yBounds||[l[0][2],l[1][2],h?l[2][2]:l[0][2]];h=L(g);m=L(l);p.align(a,!1,{x:h,y:m,width:x(g)-h,height:x(l)-m});p.alignValue&&"left"!==p.alignValue||(a=a.clip?e.width:e.chart.chartWidth,p.css({width:(90===p.rotation?e.height-(p.alignAttr.y-e.top):a-(p.alignAttr.x-e.left))+"px"}));p.show(!0);}getLabelText(a){return C(a.formatter)?a.formatter.call(this):a.text}destroy(){H(this.axis.plotLinesAndBands,this);delete this.axis;z(this);}}return p});M(a,"Core/Tooltip.js",[a["Core/Templating.js"],a["Core/Globals.js"],
    	a["Core/Renderer/RendererUtilities.js"],a["Core/Renderer/RendererRegistry.js"],a["Core/Utilities.js"]],function(a,y,I,L,C){const {format:x}=a,{doc:H,isSafari:B}=y,{distribute:u}=I,{addEvent:v,clamp:l,css:p,discardElement:t,extend:m,fireEvent:h,isArray:g,isNumber:e,isString:w,merge:E,pick:F,splat:d,syncTimeout:k}=C;class r{constructor(a,d){this.allowShared=!0;this.container=void 0;this.crosshairs=[];this.distance=0;this.isHidden=!0;this.isSticky=!1;this.now={};this.options={};this.outside=!1;this.chart=
    	a;this.init(a,d);}bodyFormatter(a){return a.map(function(a){const b=a.series.tooltipOptions;return (b[(a.point.formatPrefix||"point")+"Formatter"]||a.point.tooltipFormatter).call(a.point,b[(a.point.formatPrefix||"point")+"Format"]||"")})}cleanSplit(a){this.chart.series.forEach(function(d){const b=d&&d.tt;b&&(!b.isActive||a?d.tt=b.destroy():b.isActive=!1);});}defaultFormatter(a){const k=this.points||d(this);let b;b=[a.tooltipFooterHeaderFormatter(k[0])];b=b.concat(a.bodyFormatter(k));b.push(a.tooltipFooterHeaderFormatter(k[0],
    	!0));return b}destroy(){this.label&&(this.label=this.label.destroy());this.split&&(this.cleanSplit(!0),this.tt&&(this.tt=this.tt.destroy()));this.renderer&&(this.renderer=this.renderer.destroy(),t(this.container));C.clearTimeout(this.hideTimer);C.clearTimeout(this.tooltipTimeout);}getAnchor(a,k){var b=this.chart;const f=b.pointer,c=b.inverted,n=b.plotTop;b=b.plotLeft;a=d(a);a[0].series&&a[0].series.yAxis&&!a[0].series.yAxis.options.reversedStacks&&(a=a.slice().reverse());if(this.followPointer&&k)"undefined"===
    	typeof k.chartX&&(k=f.normalize(k)),a=[k.chartX-b,k.chartY-n];else if(a[0].tooltipPos)a=a[0].tooltipPos;else {let f=0,d=0;a.forEach(function(b){if(b=b.pos(!0))f+=b[0],d+=b[1];});f/=a.length;d/=a.length;this.shared&&1<a.length&&k&&(c?f=k.chartX:d=k.chartY);a=[f-b,d-n];}return a.map(Math.round)}getClassName(a,d,b){const f=a.series,c=f.options;return [this.options.className,"highcharts-label",b&&"highcharts-tooltip-header",d?"highcharts-tooltip-box":"highcharts-tooltip",!b&&"highcharts-color-"+F(a.colorIndex,
    	f.colorIndex),c&&c.className].filter(w).join(" ")}getLabel(){const a=this,d=this.chart.styledMode,b=this.options,f=this.split&&this.allowShared,c=b.style.pointerEvents||(this.shouldStickOnContact()?"auto":"none");let n,k=this.chart.renderer;if(this.label){var e=!this.label.hasClass("highcharts-label");(!f&&e||f&&!e)&&this.destroy();}if(!this.label){if(this.outside){e=this.chart.options.chart.style;const b=L.getRendererType();this.container=n=y.doc.createElement("div");n.className="highcharts-tooltip-container";
    	p(n,{position:"absolute",top:"1px",pointerEvents:c,zIndex:Math.max(this.options.style.zIndex||0,(e&&e.zIndex||0)+3)});y.doc.body.appendChild(n);this.renderer=k=new b(n,0,0,e,void 0,void 0,k.styledMode);}f?this.label=k.g("tooltip"):(this.label=k.label("",0,0,b.shape,void 0,void 0,b.useHTML,void 0,"tooltip").attr({padding:b.padding,r:b.borderRadius}),d||this.label.attr({fill:b.backgroundColor,"stroke-width":b.borderWidth||0}).css(b.style).css({pointerEvents:c}));if(a.outside){const b=this.label,{xSetter:c,
    	ySetter:f}=b;b.xSetter=function(f){c.call(b,a.distance);n.style.left=f+"px";};b.ySetter=function(c){f.call(b,a.distance);n.style.top=c+"px";};}this.label.attr({zIndex:8}).shadow(b.shadow).add();}return this.label}getPlayingField(){const {body:a,documentElement:d}=H,{chart:b,distance:f,outside:c}=this;return {width:c?Math.max(a.scrollWidth,d.scrollWidth,a.offsetWidth,d.offsetWidth,d.clientWidth)-2*f:b.chartWidth,height:c?Math.max(a.scrollHeight,d.scrollHeight,a.offsetHeight,d.offsetHeight,d.clientHeight):
    	b.chartHeight}}getPosition(a,d,b){const f=this.chart,c=this.distance,n={},k=f.inverted&&b.h||0,e=this.outside;var q=this.getPlayingField();const g=q.width,h=q.height,r=f.pointer.getChartPosition();q=n=>{const k="x"===n;return [n,k?g:h,k?a:d].concat(e?[k?a*r.scaleX:d*r.scaleY,k?r.left-c+(b.plotX+f.plotLeft)*r.scaleX:r.top-c+(b.plotY+f.plotTop)*r.scaleY,0,k?g:h]:[k?a:d,k?b.plotX+f.plotLeft:b.plotY+f.plotTop,k?f.plotLeft:f.plotTop,k?f.plotLeft+f.plotWidth:f.plotTop+f.plotHeight])};let l=q("y"),m=q("x"),
    	p;q=!!b.negative;!f.polar&&f.hoverSeries&&f.hoverSeries.yAxis&&f.hoverSeries.yAxis.reversed&&(q=!q);const t=!this.followPointer&&F(b.ttBelow,!f.inverted===q),w=function(b,a,f,d,q,g,h){const l=e?"y"===b?c*r.scaleY:c*r.scaleX:c,m=(f-d)/2,p=d<q-c,J=q+c+d<a,D=q-l-f+m;q=q+l-m;if(t&&J)n[b]=q;else if(!t&&p)n[b]=D;else if(p)n[b]=Math.min(h-d,0>D-k?D:D-k);else if(J)n[b]=Math.max(g,q+k+f>a?q:q+k);else return !1},G=function(b,a,f,d,k){let e;k<c||k>a-c?e=!1:n[b]=k<f/2?1:k>a-d/2?a-d-2:k-f/2;return e},v=function(b){const c=
    	l;l=m;m=c;p=b;},J=function(){!1!==w.apply(0,l)?!1!==G.apply(0,m)||p||(v(!0),J()):p?n.x=n.y=0:(v(!0),J());};(f.inverted||1<this.len)&&v();J();return n}hide(a){const d=this;C.clearTimeout(this.hideTimer);a=F(a,this.options.hideDelay);this.isHidden||(this.hideTimer=k(function(){d.getLabel().fadeOut(a?void 0:a);d.isHidden=!0;},a));}init(a,d){this.chart=a;this.options=d;this.crosshairs=[];this.now={x:0,y:0};this.isHidden=!0;this.split=d.split&&!a.inverted&&!a.polar;this.shared=d.shared||this.split;this.outside=
    	F(d.outside,!(!a.scrollablePixelsX&&!a.scrollablePixelsY));}shouldStickOnContact(a){return !(this.followPointer||!this.options.stickOnContact||a&&!this.chart.pointer.inClass(a.target,"highcharts-tooltip"))}move(a,d,b,f){const c=this,n=c.now,k=!1!==c.options.animation&&!c.isHidden&&(1<Math.abs(a-n.x)||1<Math.abs(d-n.y)),e=c.followPointer||1<c.len;m(n,{x:k?(2*n.x+a)/3:a,y:k?(n.y+d)/2:d,anchorX:e?void 0:k?(2*n.anchorX+b)/3:b,anchorY:e?void 0:k?(n.anchorY+f)/2:f});c.getLabel().attr(n);c.drawTracker();k&&
    	(C.clearTimeout(this.tooltipTimeout),this.tooltipTimeout=setTimeout(function(){c&&c.move(a,d,b,f);},32));}refresh(a,k){const b=this.chart,f=this.options,c=b.pointer,n=d(a),e=n[0],q=[];var r=f.format,l=f.formatter||this.defaultFormatter;const m=this.shared,p=b.styledMode;let t={};if(f.enabled&&e.series){C.clearTimeout(this.hideTimer);this.allowShared=!(!g(a)&&a.series&&a.series.noSharedTooltip);this.followPointer=!this.split&&e.series.tooltipOptions.followPointer;a=this.getAnchor(a,k);var v=a[0],G=a[1];
    	m&&this.allowShared?(c.applyInactiveState(n),n.forEach(function(b){b.setState("hover");q.push(b.getLabelConfig());}),t=e.getLabelConfig(),t.points=q):t=e.getLabelConfig();this.len=q.length;r=w(r)?x(r,t,b):l.call(t,this);l=e.series;this.distance=F(l.tooltipOptions.distance,16);if(!1===r)this.hide();else {if(this.split&&this.allowShared)this.renderSplit(r,n);else {let d=v,g=G;k&&c.isDirectTouch&&(d=k.chartX-b.plotLeft,g=k.chartY-b.plotTop);if(b.polar||!1===l.options.clip||n.some(b=>c.isDirectTouch||b.series.shouldShowTooltip(d,
    	g)))k=this.getLabel(),f.style.width&&!p||k.css({width:(this.outside?this.getPlayingField():b.spacingBox).width+"px"}),k.attr({text:r&&r.join?r.join(""):r}),k.addClass(this.getClassName(e),!0),p||k.attr({stroke:f.borderColor||e.color||l.color||"#666666"}),this.updatePosition({plotX:v,plotY:G,negative:e.negative,ttBelow:e.ttBelow,h:a[2]||0});else {this.hide();return}}this.isHidden&&this.label&&this.label.attr({opacity:1}).show();this.isHidden=!1;}h(this,"refresh");}}renderSplit(a,d){function b(b,c,a,d,
    	n=!0){a?(c=S?0:z,b=l(b-d/2,J.left,J.right-d-(f.outside?W:0))):(c-=da,b=n?b-d-x:b+x,b=l(b,n?b:J.left,J.right));return {x:b,y:c}}const f=this,{chart:c,chart:{chartWidth:n,chartHeight:k,plotHeight:e,plotLeft:g,plotTop:h,pointer:q,scrollablePixelsY:r=0,scrollablePixelsX:p,scrollingContainer:{scrollLeft:t,scrollTop:v}={scrollLeft:0,scrollTop:0},styledMode:G},distance:x,options:E,options:{positioner:y}}=f,J=f.outside&&"number"!==typeof p?H.documentElement.getBoundingClientRect():{left:t,right:t+n,top:v,
    	bottom:v+k},N=f.getLabel(),O=this.renderer||c.renderer,S=!(!c.xAxis[0]||!c.xAxis[0].opposite),{left:W,top:ha}=q.getChartPosition();let da=h+v,C=0,z=e-r;w(a)&&(a=[!1,a]);a=a.slice(0,d.length+1).reduce(function(c,a,n){if(!1!==a&&""!==a){n=d[n-1]||{isHeader:!0,plotX:d[0].plotX,plotY:e,series:{}};const D=n.isHeader;var k=D?f:n.series,q;{var r=n;a=a.toString();var m=k.tt;const {isHeader:b,series:c}=r;m||(m={padding:E.padding,r:E.borderRadius},G||(m.fill=E.backgroundColor,m["stroke-width"]=null!==(q=E.borderWidth)&&
    	void 0!==q?q:1),m=O.label("",0,0,E[b?"headerShape":"shape"],void 0,void 0,E.useHTML).addClass(f.getClassName(r,!0,b)).attr(m).add(N));m.isActive=!0;m.attr({text:a});G||m.css(E.style).attr({stroke:E.borderColor||r.color||c.color||"#333333"});q=m;}q=k.tt=q;r=q.getBBox();k=r.width+q.strokeWidth();D&&(C=r.height,z+=C,S&&(da-=C));{const {isHeader:b,plotX:c=0,plotY:f=0,series:d}=n;if(b){a=g+c;var p=h+e/2;}else {const {xAxis:b,yAxis:n}=d;a=b.pos+l(c,-x,b.len+x);d.shouldShowTooltip(0,n.pos-h+f,{ignoreX:!0})&&
    	(p=n.pos+f);}a=l(a,J.left-x,J.right+x);p={anchorX:a,anchorY:p};}const {anchorX:t,anchorY:Q}=p;"number"===typeof Q?(p=r.height+1,r=y?y.call(f,k,p,n):b(t,Q,D,k),c.push({align:y?0:void 0,anchorX:t,anchorY:Q,boxWidth:k,point:n,rank:F(r.rank,D?1:0),size:p,target:r.y,tt:q,x:r.x})):q.isActive=!1;}return c},[]);!y&&a.some(b=>{var {outside:c}=f;c=(c?W:0)+b.anchorX;return c<J.left&&c+b.boxWidth<J.right?!0:c<W-J.left+b.boxWidth&&J.right-c>c})&&(a=a.map(c=>{const {x:a,y:f}=b(c.anchorX,c.anchorY,c.point.isHeader,
    	c.boxWidth,!1);return m(c,{target:f,x:a})}));f.cleanSplit();u(a,z);var ca=W,L=W;a.forEach(function(b){const {x:c,boxWidth:a,isHeader:d}=b;d||(f.outside&&W+c<ca&&(ca=W+c),!d&&f.outside&&ca+a>L&&(L=W+c));});a.forEach(function(b){const {x:c,anchorX:a,anchorY:d,pos:n,point:{isHeader:k}}=b,e={visibility:"undefined"===typeof n?"hidden":"inherit",x:c,y:(n||0)+da,anchorX:a,anchorY:d};if(f.outside&&c<a){const b=W-ca;0<b&&(k||(e.x=c+b,e.anchorX=a+b),k&&(e.x=(L-ca)/2,e.anchorX=a+b));}b.tt.attr(e);});const {container:R,
    	outside:Q,renderer:la}=f;if(Q&&R&&la){const {width:b,height:c,x:a,y:f}=N.getBBox();la.setSize(b+a,c+f,!1);R.style.left=ca+"px";R.style.top=ha+"px";}B&&N.attr({opacity:1===N.opacity?.999:1});}drawTracker(){if(this.shouldStickOnContact()){var a=this.chart,d=this.label,b=this.shared?a.hoverPoints:a.hoverPoint;if(d&&b){var f={x:0,y:0,width:0,height:0};b=this.getAnchor(b);var c=d.getBBox();b[0]+=a.plotLeft-d.translateX;b[1]+=a.plotTop-d.translateY;f.x=Math.min(0,b[0]);f.y=Math.min(0,b[1]);f.width=0>b[0]?
    	Math.max(Math.abs(b[0]),c.width-b[0]):Math.max(Math.abs(b[0]),c.width);f.height=0>b[1]?Math.max(Math.abs(b[1]),c.height-Math.abs(b[1])):Math.max(Math.abs(b[1]),c.height);this.tracker?this.tracker.attr(f):(this.tracker=d.renderer.rect(f).addClass("highcharts-tracker").add(d),a.styledMode||this.tracker.attr({fill:"rgba(0,0,0,0)"}));}}else this.tracker&&(this.tracker=this.tracker.destroy());}styledModeFormat(a){return a.replace('style="font-size: 0.8em"','class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g,
    	'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"')}tooltipFooterHeaderFormatter(a,d){const b=a.series,f=b.tooltipOptions;var c=b.xAxis;const n=c&&c.dateTime;c={isFooter:d,labelConfig:a};let k=f.xDateFormat,g=f[d?"footerFormat":"headerFormat"];h(this,"headerFormatter",c,function(c){n&&!k&&e(a.key)&&(k=n.getXDateFormat(a.key,f.dateTimeLabelFormats));n&&k&&(a.point&&a.point.tooltipDateKeys||["key"]).forEach(function(b){g=g.replace("{point."+b+"}","{point."+
    	b+":"+k+"}");});b.chart.styledMode&&(g=this.styledModeFormat(g));c.text=x(g,{point:a,series:b},this.chart);});return c.text}update(a){this.destroy();this.init(this.chart,E(!0,this.options,a));}updatePosition(a){const {chart:d,distance:b,options:f}=this;var c=d.pointer;const n=this.getLabel(),{left:k,top:e,scaleX:g,scaleY:h}=c.getChartPosition();c=(f.positioner||this.getPosition).call(this,n.width,n.height,a);let q=(a.plotX||0)+d.plotLeft;a=(a.plotY||0)+d.plotTop;let r;if(this.outside){f.positioner&&
    	(c.x+=k-b,c.y+=e-b);r=(f.borderWidth||0)+2*b;this.renderer.setSize(n.width+r,n.height+r,!1);if(1!==g||1!==h)p(this.container,{transform:`scale(${g}, ${h})`}),q*=g,a*=h;q+=k-c.x;a+=e-c.y;}this.move(Math.round(c.x),Math.round(c.y||0),q,a);}}(function(a){const d=[];a.compose=function(b){C.pushUnique(d,b)&&v(b,"afterInit",function(){const b=this.chart;b.options.tooltip&&(b.tooltip=new a(b,b.options.tooltip));});};})(r||(r={}));return r});M(a,"Core/Series/Point.js",[a["Core/Renderer/HTML/AST.js"],a["Core/Animation/AnimationUtilities.js"],
    	a["Core/Defaults.js"],a["Core/Templating.js"],a["Core/Utilities.js"]],function(a,y,I,L,C){const {animObject:x}=y,{defaultOptions:H}=I,{format:B}=L,{addEvent:u,defined:v,erase:l,extend:p,fireEvent:t,getNestedProperty:m,isArray:h,isFunction:g,isNumber:e,isObject:w,merge:E,objectEach:F,pick:d,syncTimeout:k,removeEvent:r,uniqueKey:q}=C;class G{constructor(){this.category=void 0;this.destroyed=!1;this.formatPrefix="point";this.id=void 0;this.isNull=!1;this.percentage=this.options=this.name=void 0;this.selected=
    	!1;this.total=this.shapeArgs=this.series=void 0;this.visible=!0;this.x=void 0;}animateBeforeDestroy(){const b=this,a={x:b.startXPos,opacity:0},c=b.getGraphicalProps();c.singular.forEach(function(c){b[c]=b[c].animate("dataLabel"===c?{x:b[c].startXPos,y:b[c].startYPos,opacity:0}:a);});c.plural.forEach(function(c){b[c].forEach(function(c){c.element&&c.animate(p({x:b.startXPos},c.startYPos?{x:c.startXPos,y:c.startYPos}:{}));});});}applyOptions(b,a){const c=this.series,f=c.options.pointValKey||c.pointValKey;
    	b=G.prototype.optionsToObject.call(this,b);p(this,b);this.options=this.options?p(this.options,b):b;b.group&&delete this.group;b.dataLabels&&delete this.dataLabels;f&&(this.y=G.prototype.getNestedProperty.call(this,f));this.formatPrefix=(this.isNull=this.isValid&&!this.isValid())?"null":"point";this.selected&&(this.state="select");"name"in this&&"undefined"===typeof a&&c.xAxis&&c.xAxis.hasNames&&(this.x=c.xAxis.nameToX(this));"undefined"===typeof this.x&&c?this.x="undefined"===typeof a?c.autoIncrement():
    	a:e(b.x)&&c.options.relativeXValue&&(this.x=c.autoIncrement(b.x));return this}destroy(){if(!this.destroyed){const a=this;var b=a.series;const c=b.chart;b=b.options.dataSorting;const d=c.hoverPoints,e=x(a.series.chart.renderer.globalAnimation),g=()=>{if(a.graphic||a.graphics||a.dataLabel||a.dataLabels)r(a),a.destroyElements();for(const b in a)delete a[b];};a.legendItem&&c.legend.destroyItem(a);d&&(a.setState(),l(d,a),d.length||(c.hoverPoints=null));if(a===c.hoverPoint)a.onMouseOut();b&&b.enabled?(this.animateBeforeDestroy(),
    	k(g,e.duration)):g();c.pointCount--;}this.destroyed=!0;}destroyElements(b){const a=this;b=a.getGraphicalProps(b);b.singular.forEach(function(b){a[b]=a[b].destroy();});b.plural.forEach(function(b){a[b].forEach(function(b){b&&b.element&&b.destroy();});delete a[b];});}firePointEvent(b,a,c){const f=this,d=this.series.options;(d.point.events[b]||f.options&&f.options.events&&f.options.events[b])&&f.importEvents();"click"===b&&d.allowPointSelect&&(c=function(b){f.select&&f.select(null,b.ctrlKey||b.metaKey||b.shiftKey);});
    	t(f,b,a,c);}getClassName(){return "highcharts-point"+(this.selected?" highcharts-point-select":"")+(this.negative?" highcharts-negative":"")+(this.isNull?" highcharts-null-point":"")+("undefined"!==typeof this.colorIndex?" highcharts-color-"+this.colorIndex:"")+(this.options.className?" "+this.options.className:"")+(this.zone&&this.zone.className?" "+this.zone.className.replace("highcharts-negative",""):"")}getGraphicalProps(b){const a=this,c=[],d={singular:[],plural:[]};let k,e;b=b||{graphic:1,dataLabel:1};
    	b.graphic&&c.push("graphic");b.dataLabel&&c.push("dataLabel","dataLabelPath","dataLabelUpper","connector");for(e=c.length;e--;)k=c[e],a[k]&&d.singular.push(k);["graphic","dataLabel","connector"].forEach(function(c){const f=c+"s";b[c]&&a[f]&&d.plural.push(f);});return d}getLabelConfig(){return {x:this.category,y:this.y,color:this.color,colorIndex:this.colorIndex,key:this.name||this.category,series:this.series,point:this,percentage:this.percentage,total:this.total||this.stackTotal}}getNestedProperty(b){if(b)return 0===
    	b.indexOf("custom.")?m(b,this.options):this[b]}getZone(){var b=this.series;const a=b.zones;b=b.zoneAxis||"y";let c,d=0;for(c=a[d];this[b]>=c.value;)c=a[++d];this.nonZonedColor||(this.nonZonedColor=this.color);this.color=c&&c.color&&!this.options.color?c.color:this.nonZonedColor;return c}hasNewShapeType(){return (this.graphic&&(this.graphic.symbolName||this.graphic.element.nodeName))!==this.shapeType}init(b,a,c){this.series=b;this.applyOptions(a,c);this.id=v(this.id)?this.id:q();this.resolveColor();
    	b.chart.pointCount++;t(this,"afterInit");return this}isValid(){return null!==this.x&&e(this.y)}optionsToObject(b){var a=this.series;const c=a.options.keys,d=c||a.pointArrayMap||["y"],k=d.length;let g={},q=0,r=0;if(e(b)||null===b)g[d[0]]=b;else if(h(b))for(!c&&b.length>k&&(a=typeof b[0],"string"===a?g.name=b[0]:"number"===a&&(g.x=b[0]),q++);r<k;)c&&"undefined"===typeof b[q]||(0<d[r].indexOf(".")?G.prototype.setNestedProperty(g,b[q],d[r]):g[d[r]]=b[q]),q++,r++;else "object"===typeof b&&(g=b,b.dataLabels&&
    	(a._hasPointLabels=!0),b.marker&&(a._hasPointMarkers=!0));return g}pos(b,a=this.plotY){if(!this.destroyed){const {plotX:c,series:f}=this,{chart:d,xAxis:k,yAxis:g}=f;let h=0,q=0;if(e(c)&&e(a))return b&&(h=k?k.pos:d.plotLeft,q=g?g.pos:d.plotTop),d.inverted&&k&&g?[g.len-a+q,k.len-c+h]:[c+h,a+q]}}resolveColor(){const b=this.series;var a=b.chart.styledMode;let c;var k=b.chart.options.chart.colorCount;delete this.nonZonedColor;b.options.colorByPoint?(a||(k=b.options.colors||b.chart.options.colors,c=k[b.colorCounter],
    	k=k.length),a=b.colorCounter,b.colorCounter++,b.colorCounter===k&&(b.colorCounter=0)):(a||(c=b.color),a=b.colorIndex);this.colorIndex=d(this.options.colorIndex,a);this.color=d(this.options.color,c);}setNestedProperty(b,a,c){c.split(".").reduce(function(b,c,f,d){b[c]=d.length-1===f?a:w(b[c],!0)?b[c]:{};return b[c]},b);return b}shouldDraw(){return !this.isNull}tooltipFormatter(b){const a=this.series,c=a.tooltipOptions,k=d(c.valueDecimals,""),e=c.valuePrefix||"",g=c.valueSuffix||"";a.chart.styledMode&&
    	(b=a.chart.tooltip.styledModeFormat(b));(a.pointArrayMap||["y"]).forEach(function(c){c="{point."+c;if(e||g)b=b.replace(RegExp(c+"}","g"),e+c+"}"+g);b=b.replace(RegExp(c+"}","g"),c+":,."+k+"f}");});return B(b,{point:this,series:this.series},a.chart)}update(b,a,c,k){function f(){n.applyOptions(b);var f=g&&n.hasMockGraphic;f=null===n.y?!f:f;g&&f&&(n.graphic=g.destroy(),delete n.hasMockGraphic);w(b,!0)&&(g&&g.element&&b&&b.marker&&"undefined"!==typeof b.marker.symbol&&(n.graphic=g.destroy()),b&&b.dataLabels&&
    	n.dataLabel&&(n.dataLabel=n.dataLabel.destroy()),n.connector&&(n.connector=n.connector.destroy()));r=n.index;e.updateParallelArrays(n,r);q.data[r]=w(q.data[r],!0)||w(b,!0)?n.options:d(b,q.data[r]);e.isDirty=e.isDirtyData=!0;!e.fixedBox&&e.hasCartesianSeries&&(h.isDirtyBox=!0);"point"===q.legendType&&(h.isDirtyLegend=!0);a&&h.redraw(c);}const n=this,e=n.series,g=n.graphic,h=e.chart,q=e.options;let r;a=d(a,!0);!1===k?f():n.firePointEvent("update",{options:b},f);}remove(b,a){this.series.removePoint(this.series.data.indexOf(this),
    	b,a);}select(b,a){const c=this,f=c.series,k=f.chart;this.selectedStaging=b=d(b,!c.selected);c.firePointEvent(b?"select":"unselect",{accumulate:a},function(){c.selected=c.options.selected=b;f.options.data[f.data.indexOf(c)]=c.options;c.setState(b&&"select");a||k.getSelectedPoints().forEach(function(b){const a=b.series;b.selected&&b!==c&&(b.selected=b.options.selected=!1,a.options.data[a.data.indexOf(b)]=b.options,b.setState(k.hoverPoints&&a.options.inactiveOtherPoints?"inactive":""),b.firePointEvent("unselect"));});});
    	delete this.selectedStaging;}onMouseOver(b){const a=this.series.chart,c=a.pointer;b=b?c.normalize(b):c.getChartCoordinatesFromPoint(this,a.inverted);c.runPointActions(b,this);}onMouseOut(){const b=this.series.chart;this.firePointEvent("mouseOut");this.series.options.inactiveOtherPoints||(b.hoverPoints||[]).forEach(function(b){b.setState();});b.hoverPoints=b.hoverPoint=null;}importEvents(){if(!this.hasImportedEvents){const b=this,a=E(b.series.options.point,b.options).events;b.events=a;F(a,function(c,a){g(c)&&
    	u(b,a,c);});this.hasImportedEvents=!0;}}setState(b,f){const c=this.series;var k=this.state,g=c.options.states[b||"normal"]||{},h=H.plotOptions[c.type].marker&&c.options.marker;const q=h&&!1===h.enabled,r=h&&h.states&&h.states[b||"normal"]||{},l=!1===r.enabled,m=this.marker||{},w=c.chart,v=h&&c.markerAttribs;let G=c.halo;var u;let x;var E=c.stateMarkerGraphic;b=b||"";if(!(b===this.state&&!f||this.selected&&"select"!==b||!1===g.enabled||b&&(l||q&&!1===r.enabled)||b&&m.states&&m.states[b]&&!1===m.states[b].enabled)){this.state=
    	b;v&&(u=c.markerAttribs(this,b));if(this.graphic&&!this.hasMockGraphic){k&&this.graphic.removeClass("highcharts-point-"+k);b&&this.graphic.addClass("highcharts-point-"+b);if(!w.styledMode){k=c.pointAttribs(this,b);x=d(w.options.chart.animation,g.animation);const a=k.opacity;c.options.inactiveOtherPoints&&e(a)&&((this.dataLabels||[]).forEach(function(b){b&&!b.hasClass("highcharts-data-label-hidden")&&b.animate({opacity:a},x);}),this.connector&&this.connector.animate({opacity:a},x));this.graphic.animate(k,
    	x);}u&&this.graphic.animate(u,d(w.options.chart.animation,r.animation,h.animation));E&&E.hide();}else {if(b&&r){h=m.symbol||c.symbol;E&&E.currentSymbol!==h&&(E=E.destroy());if(u)if(E)E[f?"animate":"attr"]({x:u.x,y:u.y});else h&&(c.stateMarkerGraphic=E=w.renderer.symbol(h,u.x,u.y,u.width,u.height).add(c.markerGroup),E.currentSymbol=h);!w.styledMode&&E&&"inactive"!==this.state&&E.attr(c.pointAttribs(this,b));}E&&(E[b&&this.isInside?"show":"hide"](),E.element.point=this,E.addClass(this.getClassName(),!0));}g=
    	g.halo;u=(E=this.graphic||E)&&E.visibility||"inherit";g&&g.size&&E&&"hidden"!==u&&!this.isCluster?(G||(c.halo=G=w.renderer.path().add(E.parentGroup)),G.show()[f?"animate":"attr"]({d:this.haloPath(g.size)}),G.attr({"class":"highcharts-halo highcharts-color-"+d(this.colorIndex,c.colorIndex)+(this.className?" "+this.className:""),visibility:u,zIndex:-1}),G.point=this,w.styledMode||G.attr(p({fill:this.color||c.color,"fill-opacity":g.opacity},a.filterUserAttributes(g.attributes||{})))):G&&G.point&&G.point.haloPath&&
    	G.animate({d:G.point.haloPath(0)},null,G.hide);t(this,"afterSetState",{state:b});}}haloPath(b){const a=this.pos();return a?this.series.chart.renderer.symbols.circle(Math.floor(a[0])-b,a[1]-b,2*b,2*b):[]}}return G});M(a,"Core/Pointer.js",[a["Core/Color/Color.js"],a["Core/Globals.js"],a["Core/Utilities.js"]],function(a,y,I){const {parse:x}=a,{charts:C,noop:z}=y,{addEvent:H,attr:B,css:u,defined:v,extend:l,find:p,fireEvent:t,isNumber:m,isObject:h,objectEach:g,offset:e,pick:w,splat:E}=I;class F{constructor(a,
    	k){this.lastValidTouch={};this.pinchDown=[];this.runChartClick=!1;this.eventsToUnbind=[];this.chart=a;this.hasDragged=!1;this.options=k;this.init(a,k);}applyInactiveState(a){let d=[],e;(a||[]).forEach(function(a){e=a.series;d.push(e);e.linkedParent&&d.push(e.linkedParent);e.linkedSeries&&(d=d.concat(e.linkedSeries));e.navigatorSeries&&d.push(e.navigatorSeries);});this.chart.series.forEach(function(a){-1===d.indexOf(a)?a.setState("inactive",!0):a.options.inactiveOtherPoints&&a.setAllPointsToState("inactive");});}destroy(){const a=
    	this;this.eventsToUnbind.forEach(a=>a());this.eventsToUnbind=[];y.chartCount||(F.unbindDocumentMouseUp&&(F.unbindDocumentMouseUp=F.unbindDocumentMouseUp()),F.unbindDocumentTouchEnd&&(F.unbindDocumentTouchEnd=F.unbindDocumentTouchEnd()));clearInterval(a.tooltipTimeout);g(a,function(d,e){a[e]=void 0;});}getSelectionMarkerAttrs(a,k){const d={args:{chartX:a,chartY:k},attrs:{},shapeType:"rect"};t(this,"getSelectionMarkerAttrs",d,d=>{const {chart:e,mouseDownX:b=0,mouseDownY:f=0,zoomHor:c,zoomVert:n}=this;
    	d=d.attrs;let g;d.x=e.plotLeft;d.y=e.plotTop;d.width=c?1:e.plotWidth;d.height=n?1:e.plotHeight;c&&(g=a-b,d.width=Math.abs(g),d.x=(0<g?0:g)+b);n&&(g=k-f,d.height=Math.abs(g),d.y=(0<g?0:g)+f);});return d}drag(a){const d=this.chart,e=d.options.chart;var g=d.plotLeft;const l=d.plotTop,b=d.plotWidth,f=d.plotHeight,c=this.mouseDownX||0,n=this.mouseDownY||0,m=h(e.panning)?e.panning&&e.panning.enabled:e.panning,p=e.panKey&&a[e.panKey+"Key"];let t=a.chartX,w=a.chartY,v=this.selectionMarker;if(!v||!v.touch)if(t<
    	g?t=g:t>g+b&&(t=g+b),w<l?w=l:w>l+f&&(w=l+f),this.hasDragged=Math.sqrt(Math.pow(c-t,2)+Math.pow(n-w,2)),10<this.hasDragged){g=d.isInsidePlot(c-g,n-l,{visiblePlotOnly:!0});const {shapeType:b,attrs:f}=this.getSelectionMarkerAttrs(t,w);!d.hasCartesianSeries&&!d.mapView||!this.zoomX&&!this.zoomY||!g||p||v||(this.selectionMarker=v=d.renderer[b](),v.attr({"class":"highcharts-selection-marker",zIndex:7}).add(),d.styledMode||v.attr({fill:e.selectionMarkerFill||x("#334eff").setOpacity(.25).get()}));v&&v.attr(f);
    	g&&!v&&m&&d.pan(a,e.panning);}}dragStart(a){const d=this.chart;d.mouseIsDown=a.type;d.cancelClick=!1;d.mouseDownX=this.mouseDownX=a.chartX;d.mouseDownY=this.mouseDownY=a.chartY;}getSelectionBox(a){const d={args:{marker:a},result:{}};t(this,"getSelectionBox",d,d=>{d.result={x:a.attr?+a.attr("x"):a.x,y:a.attr?+a.attr("y"):a.y,width:a.attr?a.attr("width"):a.width,height:a.attr?a.attr("height"):a.height};});return d.result}drop(a){const d=this,e=this.chart,g=this.hasPinched;if(this.selectionMarker){const {x:k,
    	y:b,width:f,height:c}=this.getSelectionBox(this.selectionMarker),n={originalEvent:a,xAxis:[],yAxis:[],x:k,y:b,width:f,height:c};let h=!!e.mapView;if(this.hasDragged||g)e.axes.forEach(function(e){if(e.zoomEnabled&&v(e.min)&&(g||d[{xAxis:"zoomX",yAxis:"zoomY"}[e.coll]])&&m(k)&&m(b)&&m(f)&&m(c)){var q=e.horiz;const d="touchend"===a.type?e.minPixelPadding:0,g=e.toValue((q?k:b)+d);q=e.toValue((q?k+f:b+c)-d);n[e.coll].push({axis:e,min:Math.min(g,q),max:Math.max(g,q)});h=!0;}}),h&&t(e,"selection",n,function(b){e.zoom(l(b,
    	g?{animation:!1}:null));});m(e.index)&&(this.selectionMarker=this.selectionMarker.destroy());g&&this.scaleGroups();}e&&m(e.index)&&(u(e.container,{cursor:e._cursor}),e.cancelClick=10<this.hasDragged,e.mouseIsDown=this.hasDragged=this.hasPinched=!1,this.pinchDown=[]);}findNearestKDPoint(a,k,e){let d;a.forEach(function(a){var b=!(a.noSharedTooltip&&k)&&0>a.options.findNearestPointBy.indexOf("y");a=a.searchPoint(e,b);if((b=h(a,!0)&&a.series)&&!(b=!h(d,!0))){{b=d.distX-a.distX;const f=d.dist-a.dist,c=(a.series.group&&
    	a.series.group.zIndex)-(d.series.group&&d.series.group.zIndex);b=0!==b&&k?b:0!==f?f:0!==c?c:d.series.index>a.series.index?-1:1;}b=0<b;}b&&(d=a);});return d}getChartCoordinatesFromPoint(a,k){var d=a.series;const e=d.xAxis;d=d.yAxis;const g=a.shapeArgs;if(e&&d){let b=w(a.clientX,a.plotX),f=a.plotY||0;a.isNode&&g&&m(g.x)&&m(g.y)&&(b=g.x,f=g.y);return k?{chartX:d.len+d.pos-f,chartY:e.len+e.pos-b}:{chartX:b+e.pos,chartY:f+d.pos}}if(g&&g.x&&g.y)return {chartX:g.x,chartY:g.y}}getChartPosition(){if(this.chartPosition)return this.chartPosition;
    	var {container:a}=this.chart;const k=e(a);this.chartPosition={left:k.left,top:k.top,scaleX:1,scaleY:1};const g=a.offsetWidth;a=a.offsetHeight;2<g&&2<a&&(this.chartPosition.scaleX=k.width/g,this.chartPosition.scaleY=k.height/a);return this.chartPosition}getCoordinates(a){const d={xAxis:[],yAxis:[]};this.chart.axes.forEach(function(k){d[k.isXAxis?"xAxis":"yAxis"].push({axis:k,value:k.toValue(a[k.horiz?"chartX":"chartY"])});});return d}getHoverData(a,k,e,g,l,b){const f=[];g=!(!g||!a);const c=function(b){return b.visible&&
    	!(!l&&b.directTouch)&&w(b.options.enableMouseTracking,!0)};let d,q={chartX:b?b.chartX:void 0,chartY:b?b.chartY:void 0,shared:l};t(this,"beforeGetHoverData",q);d=k&&!k.stickyTracking?[k]:e.filter(b=>b.stickyTracking&&(q.filter||c)(b));const r=g||!b?a:this.findNearestKDPoint(d,l,b);k=r&&r.series;r&&(l&&!k.noSharedTooltip?(d=e.filter(function(b){return q.filter?q.filter(b):c(b)&&!b.noSharedTooltip}),d.forEach(function(b){let c=p(b.points,function(b){return b.x===r.x&&!b.isNull});h(c)&&(b.boosted&&b.boost&&
    	(c=b.boost.getPoint(c)),f.push(c));})):f.push(r));q={hoverPoint:r};t(this,"afterGetHoverData",q);return {hoverPoint:q.hoverPoint,hoverSeries:k,hoverPoints:f}}getPointFromEvent(a){a=a.target;let d;for(;a&&!d;)d=a.point,a=a.parentNode;return d}onTrackerMouseOut(a){a=a.relatedTarget;const d=this.chart.hoverSeries;this.isDirectTouch=!1;if(!(!d||!a||d.stickyTracking||this.inClass(a,"highcharts-tooltip")||this.inClass(a,"highcharts-series-"+d.index)&&this.inClass(a,"highcharts-tracker")))d.onMouseOut();}inClass(a,
    	k){let d;for(;a;){if(d=B(a,"class")){if(-1!==d.indexOf(k))return !0;if(-1!==d.indexOf("highcharts-container"))return !1}a=a.parentElement;}}init(a,k){this.options=k;this.chart=a;this.runChartClick=!(!k.chart.events||!k.chart.events.click);this.pinchDown=[];this.lastValidTouch={};this.setDOMEvents();t(this,"afterInit");}normalize(a,k){var d=a.touches,e=d?d.length?d.item(0):w(d.changedTouches,a.changedTouches)[0]:a;k||(k=this.getChartPosition());d=e.pageX-k.left;e=e.pageY-k.top;d/=k.scaleX;e/=k.scaleY;
    	return l(a,{chartX:Math.round(d),chartY:Math.round(e)})}onContainerClick(a){const d=this.chart,e=d.hoverPoint;a=this.normalize(a);const g=d.plotLeft,h=d.plotTop;d.cancelClick||(e&&this.inClass(a.target,"highcharts-tracker")?(t(e.series,"click",l(a,{point:e})),d.hoverPoint&&e.firePointEvent("click",a)):(l(a,this.getCoordinates(a)),d.isInsidePlot(a.chartX-g,a.chartY-h,{visiblePlotOnly:!0})&&t(d,"click",a)));}onContainerMouseDown(a){const d=1===((a.buttons||a.button)&1);a=this.normalize(a);if(y.isFirefox&&
    	0!==a.button)this.onContainerMouseMove(a);if("undefined"===typeof a.button||d)this.zoomOption(a),d&&a.preventDefault&&a.preventDefault(),this.dragStart(a);}onContainerMouseLeave(a){const d=C[w(F.hoverChartIndex,-1)];a=this.normalize(a);d&&a.relatedTarget&&!this.inClass(a.relatedTarget,"highcharts-tooltip")&&(d.pointer.reset(),d.pointer.chartPosition=void 0);}onContainerMouseEnter(a){delete this.chartPosition;}onContainerMouseMove(a){const d=this.chart,e=d.tooltip;a=this.normalize(a);this.setHoverChartIndex();
    	("mousedown"===d.mouseIsDown||this.touchSelect(a))&&this.drag(a);d.openMenu||!this.inClass(a.target,"highcharts-tracker")&&!d.isInsidePlot(a.chartX-d.plotLeft,a.chartY-d.plotTop,{visiblePlotOnly:!0})||e&&e.shouldStickOnContact(a)||(this.inClass(a.target,"highcharts-no-tooltip")?this.reset(!1,0):this.runPointActions(a));}onDocumentTouchEnd(a){const d=C[w(F.hoverChartIndex,-1)];d&&d.pointer.drop(a);}onContainerTouchMove(a){if(this.touchSelect(a))this.onContainerMouseMove(a);else this.touch(a);}onContainerTouchStart(a){if(this.touchSelect(a))this.onContainerMouseDown(a);
    	else this.zoomOption(a),this.touch(a,!0);}onDocumentMouseMove(a){const d=this.chart,e=d.tooltip,g=this.chartPosition;a=this.normalize(a,g);!g||d.isInsidePlot(a.chartX-d.plotLeft,a.chartY-d.plotTop,{visiblePlotOnly:!0})||e&&e.shouldStickOnContact(a)||this.inClass(a.target,"highcharts-tracker")||this.reset();}onDocumentMouseUp(a){const d=C[w(F.hoverChartIndex,-1)];d&&d.pointer.drop(a);}pinch(a){const d=this,e=d.chart,g=d.pinchDown,h=a.touches||[],b=h.length,f=d.lastValidTouch,c=d.hasZoom,n={},m=1===b&&
    	(d.inClass(a.target,"highcharts-tracker")&&e.runTrackerClick||d.runChartClick),p={};var v=d.chart.tooltip;v=1===b&&w(v&&v.options.followTouchMove,!0);let u=d.selectionMarker;1<b?d.initiated=!0:v&&(d.initiated=!1);c&&d.initiated&&!m&&!1!==a.cancelable&&a.preventDefault();[].map.call(h,function(b){return d.normalize(b)});"touchstart"===a.type?([].forEach.call(h,function(b,a){g[a]={chartX:b.chartX,chartY:b.chartY};}),f.x=[g[0].chartX,g[1]&&g[1].chartX],f.y=[g[0].chartY,g[1]&&g[1].chartY],e.axes.forEach(function(b){if(b.zoomEnabled){const a=
    	e.bounds[b.horiz?"h":"v"],c=b.minPixelPadding,f=b.toPixels(Math.min(w(b.options.min,b.dataMin),b.dataMin)),d=b.toPixels(Math.max(w(b.options.max,b.dataMax),b.dataMax)),n=Math.max(f,d);a.min=Math.min(b.pos,Math.min(f,d)-c);a.max=Math.max(b.pos+b.len,n+c);}}),d.res=!0):v?this.runPointActions(d.normalize(a)):g.length&&(t(e,"touchpan",{originalEvent:a},()=>{u||(d.selectionMarker=u=l({destroy:z,touch:!0},e.plotBox));d.pinchTranslate(g,h,n,u,p,f);d.hasPinched=c;d.scaleGroups(n,p);}),d.res&&(d.res=!1,this.reset(!1,
    	0)));}pinchTranslate(a,e,g,h,l,b){this.zoomHor&&this.pinchTranslateDirection(!0,a,e,g,h,l,b);this.zoomVert&&this.pinchTranslateDirection(!1,a,e,g,h,l,b);}pinchTranslateDirection(a,e,g,h,l,b,f,c){const d=this.chart,k=a?"x":"y",q=a?"X":"Y",m="chart"+q,r=a?"width":"height",p=d["plot"+(a?"Left":"Top")],t=d.inverted,w=d.bounds[a?"h":"v"],v=1===e.length,u=e[0][m],x=!v&&e[1][m];e=function(){"number"===typeof N&&20<Math.abs(u-x)&&(F=c||Math.abs(J-N)/Math.abs(u-x));E=(p-J)/F+u;G=d["plot"+(a?"Width":"Height")]/
    	F;};let G,E,F=c||1,J=g[0][m],N=!v&&g[1][m],O;e();g=E;g<w.min?(g=w.min,O=!0):g+G>w.max&&(g=w.max-G,O=!0);O?(J-=.8*(J-f[k][0]),"number"===typeof N&&(N-=.8*(N-f[k][1])),e()):f[k]=[J,N];t||(b[k]=E-p,b[r]=G);b=t?1/F:F;l[r]=G;l[k]=g;h[t?a?"scaleY":"scaleX":"scale"+q]=F;h["translate"+q]=b*p+(J-b*u);}reset(a,e){const d=this.chart,k=d.hoverSeries,g=d.hoverPoint,b=d.hoverPoints,f=d.tooltip,c=f&&f.shared?b:g;a&&c&&E(c).forEach(function(b){b.series.isCartesian&&"undefined"===typeof b.plotX&&(a=!1);});if(a)f&&c&&
    	E(c).length&&(f.refresh(c),f.shared&&b?b.forEach(function(b){b.setState(b.state,!0);b.series.isCartesian&&(b.series.xAxis.crosshair&&b.series.xAxis.drawCrosshair(null,b),b.series.yAxis.crosshair&&b.series.yAxis.drawCrosshair(null,b));}):g&&(g.setState(g.state,!0),d.axes.forEach(function(b){b.crosshair&&g.series[b.coll]===b&&b.drawCrosshair(null,g);})));else {if(g)g.onMouseOut();b&&b.forEach(function(b){b.setState();});if(k)k.onMouseOut();f&&f.hide(e);this.unDocMouseMove&&(this.unDocMouseMove=this.unDocMouseMove());
    	d.axes.forEach(function(b){b.hideCrosshair();});this.hoverX=d.hoverPoints=d.hoverPoint=null;}}runPointActions(a,e,g){const d=this.chart,k=d.tooltip&&d.tooltip.options.enabled?d.tooltip:void 0,b=k?k.shared:!1;let f=e||d.hoverPoint,c=f&&f.series||d.hoverSeries;e=this.getHoverData(f,c,d.series,(!a||"touchmove"!==a.type)&&(!!e||c&&c.directTouch&&this.isDirectTouch),b,a);f=e.hoverPoint;c=e.hoverSeries;const n=e.hoverPoints;e=c&&c.tooltipOptions.followPointer&&!c.tooltipOptions.split;const h=b&&c&&!c.noSharedTooltip;
    	if(f&&(g||f!==d.hoverPoint||k&&k.isHidden)){(d.hoverPoints||[]).forEach(function(b){-1===n.indexOf(b)&&b.setState();});if(d.hoverSeries!==c)c.onMouseOver();this.applyInactiveState(n);(n||[]).forEach(function(b){b.setState("hover");});d.hoverPoint&&d.hoverPoint.firePointEvent("mouseOut");if(!f.series)return;d.hoverPoints=n;d.hoverPoint=f;f.firePointEvent("mouseOver",void 0,()=>{k&&f&&k.refresh(h?n:f,a);});}else e&&k&&!k.isHidden&&(g=k.getAnchor([{}],a),d.isInsidePlot(g[0],g[1],{visiblePlotOnly:!0})&&k.updatePosition({plotX:g[0],
    	plotY:g[1]}));this.unDocMouseMove||(this.unDocMouseMove=H(d.container.ownerDocument,"mousemove",function(b){const a=C[F.hoverChartIndex];if(a)a.pointer.onDocumentMouseMove(b);}),this.eventsToUnbind.push(this.unDocMouseMove));d.axes.forEach(function(b){const c=w((b.crosshair||{}).snap,!0);let f;c&&((f=d.hoverPoint)&&f.series[b.coll]===b||(f=p(n,a=>a.series&&a.series[b.coll]===b)));f||!c?b.drawCrosshair(a,f):b.hideCrosshair();});}scaleGroups(a,e){const d=this.chart;d.series.forEach(function(k){const g=
    	a||k.getPlotBox();k.group&&(k.xAxis&&k.xAxis.zoomEnabled||d.mapView)&&(k.group.attr(g),k.markerGroup&&(k.markerGroup.attr(g),k.markerGroup.clip(e?d.clipRect:null)),k.dataLabelsGroup&&k.dataLabelsGroup.attr(g));});d.clipRect.attr(e||d.clipBox);}setDOMEvents(){const a=this.chart.container,e=a.ownerDocument;a.onmousedown=this.onContainerMouseDown.bind(this);a.onmousemove=this.onContainerMouseMove.bind(this);a.onclick=this.onContainerClick.bind(this);this.eventsToUnbind.push(H(a,"mouseenter",this.onContainerMouseEnter.bind(this)));
    	this.eventsToUnbind.push(H(a,"mouseleave",this.onContainerMouseLeave.bind(this)));F.unbindDocumentMouseUp||(F.unbindDocumentMouseUp=H(e,"mouseup",this.onDocumentMouseUp.bind(this)));let g=this.chart.renderTo.parentElement;for(;g&&"BODY"!==g.tagName;)this.eventsToUnbind.push(H(g,"scroll",()=>{delete this.chartPosition;})),g=g.parentElement;y.hasTouch&&(this.eventsToUnbind.push(H(a,"touchstart",this.onContainerTouchStart.bind(this),{passive:!1})),this.eventsToUnbind.push(H(a,"touchmove",this.onContainerTouchMove.bind(this),
    	{passive:!1})),F.unbindDocumentTouchEnd||(F.unbindDocumentTouchEnd=H(e,"touchend",this.onDocumentTouchEnd.bind(this),{passive:!1})));}setHoverChartIndex(){const a=this.chart,e=y.charts[w(F.hoverChartIndex,-1)];if(e&&e!==a)e.pointer.onContainerMouseLeave({relatedTarget:a.container});e&&e.mouseIsDown||(F.hoverChartIndex=a.index);}touch(a,e){const d=this.chart;let g;this.setHoverChartIndex();1===a.touches.length?(a=this.normalize(a),(d.isInsidePlot(a.chartX-d.plotLeft,a.chartY-d.plotTop,{visiblePlotOnly:!0}))&&
    	!d.openMenu?(e&&this.runPointActions(a),"touchmove"===a.type&&(e=this.pinchDown,g=e[0]?4<=Math.sqrt(Math.pow(e[0].chartX-a.chartX,2)+Math.pow(e[0].chartY-a.chartY,2)):!1),w(g,!0)&&this.pinch(a)):e&&this.reset()):2===a.touches.length&&this.pinch(a);}touchSelect(a){return !(!this.chart.zooming.singleTouch||!a.touches||1!==a.touches.length)}zoomOption(a){const d=this.chart,e=d.inverted;var g=d.zooming.type||"";/touch/.test(a.type)&&(g=w(d.zooming.pinchType,g));this.zoomX=a=/x/.test(g);this.zoomY=g=/y/.test(g);
    	this.zoomHor=a&&!e||g&&e;this.zoomVert=g&&!e||a&&e;this.hasZoom=a||g;}}(function(a){const d=[],e=[];a.compose=function(d){I.pushUnique(e,d)&&H(d,"beforeRender",function(){this.pointer=new a(this,this.options);});};a.dissolve=function(){for(let a=0,e=d.length;a<e;++a)d[a]();d.length=0;};})(F||(F={}));return F});M(a,"Core/Legend/Legend.js",[a["Core/Animation/AnimationUtilities.js"],a["Core/Templating.js"],a["Core/Globals.js"],a["Core/Series/Point.js"],a["Core/Renderer/RendererUtilities.js"],a["Core/Utilities.js"]],
    	function(a,y,I,L,C,z){const {animObject:x,setAnimation:B}=a,{format:u}=y,{marginNames:v}=I,{distribute:l}=C,{addEvent:p,createElement:t,css:m,defined:h,discardElement:g,find:e,fireEvent:w,isNumber:E,merge:F,pick:d,relativeLength:k,stableSort:r,syncTimeout:q}=z;class G{constructor(b,a){this.allItems=[];this.contentGroup=this.box=void 0;this.display=!1;this.group=void 0;this.offsetWidth=this.maxLegendWidth=this.maxItemWidth=this.legendWidth=this.legendHeight=this.lastLineHeight=this.lastItemY=this.itemY=
    	this.itemX=this.itemMarginTop=this.itemMarginBottom=this.itemHeight=this.initialItemY=0;this.options=void 0;this.padding=0;this.pages=[];this.proximate=!1;this.scrollGroup=void 0;this.widthOption=this.totalItemWidth=this.titleHeight=this.symbolWidth=this.symbolHeight=0;this.chart=b;this.init(b,a);}init(b,a){this.chart=b;this.setOptions(a);a.enabled&&(this.render(),p(this.chart,"endResize",function(){this.legend.positionCheckboxes();}),p(this.chart,"render",()=>{this.proximate&&(this.proximatePositions(),
    	this.positionItems());}));}setOptions(b){const a=d(b.padding,8);this.options=b;this.chart.styledMode||(this.itemStyle=b.itemStyle,this.itemHiddenStyle=F(this.itemStyle,b.itemHiddenStyle));this.itemMarginTop=b.itemMarginTop;this.itemMarginBottom=b.itemMarginBottom;this.padding=a;this.initialItemY=a-5;this.symbolWidth=d(b.symbolWidth,16);this.pages=[];this.proximate="proximate"===b.layout&&!this.chart.inverted;this.baseline=void 0;}update(b,a){const c=this.chart;this.setOptions(F(!0,this.options,b));this.destroy();
    	c.isDirtyLegend=c.isDirtyBox=!0;d(a,!0)&&c.redraw();w(this,"afterUpdate");}colorizeItem(b,a){const {group:c,label:f,line:d,symbol:e}=b.legendItem||{};if(c)c[a?"removeClass":"addClass"]("highcharts-legend-item-hidden");if(!this.chart.styledMode){const {itemHiddenStyle:c}=this,g=c.color,k=a?b.color||g:g,n=b.options&&b.options.marker;let h={fill:k};null===f||void 0===f?void 0:f.css(F(a?this.itemStyle:c));null===d||void 0===d?void 0:d.attr({stroke:k});e&&(n&&e.isMarker&&(h=b.pointAttribs(),a||(h.stroke=
    	h.fill=g)),e.attr(h));}w(this,"afterColorizeItem",{item:b,visible:a});}positionItems(){this.allItems.forEach(this.positionItem,this);this.chart.isResizing||this.positionCheckboxes();}positionItem(b){const {group:a,x:c=0,y:d=0}=b.legendItem||{};var e=this.options,g=e.symbolPadding;const k=!e.rtl;e=b.checkbox;a&&a.element&&(g={translateX:k?c:this.legendWidth-c-2*g-4,translateY:d},a[h(a.translateY)?"animate":"attr"](g,void 0,()=>{w(this,"afterPositionItem",{item:b});}));e&&(e.x=c,e.y=d);}destroyItem(b){const a=
    	b.checkbox,c=b.legendItem||{};for(const b of ["group","label","line","symbol"])c[b]&&(c[b]=c[b].destroy());a&&g(a);b.legendItem=void 0;}destroy(){for(const b of this.getAllItems())this.destroyItem(b);for(const b of "clipRect up down pager nav box title group".split(" "))this[b]&&(this[b]=this[b].destroy());this.display=null;}positionCheckboxes(){const b=this.group&&this.group.alignAttr,a=this.clipHeight||this.legendHeight,c=this.titleHeight;let d;b&&(d=b.translateY,this.allItems.forEach(function(f){const e=
    	f.checkbox;let g;e&&(g=d+c+e.y+(this.scrollOffset||0)+3,m(e,{left:b.translateX+f.checkboxOffset+e.x-20+"px",top:g+"px",display:this.proximate||g>d-6&&g<d+a-6?"":"none"}));},this));}renderTitle(){var b=this.options;const a=this.padding,c=b.title;let d=0;c.text&&(this.title||(this.title=this.chart.renderer.label(c.text,a-3,a-4,void 0,void 0,void 0,b.useHTML,void 0,"legend-title").attr({zIndex:1}),this.chart.styledMode||this.title.css(c.style),this.title.add(this.group)),c.width||this.title.css({width:this.maxLegendWidth+
    	"px"}),b=this.title.getBBox(),d=b.height,this.offsetWidth=b.width,this.contentGroup.attr({translateY:d}));this.titleHeight=d;}setText(b){const a=this.options;b.legendItem.label.attr({text:a.labelFormat?u(a.labelFormat,b,this.chart):a.labelFormatter.call(b)});}renderItem(b){const a=b.legendItem=b.legendItem||{};var c=this.chart,e=c.renderer;const g=this.options,k=this.symbolWidth,h=g.symbolPadding||0,l=this.itemStyle,m=this.itemHiddenStyle,q="horizontal"===g.layout?d(g.itemDistance,20):0,r=!g.rtl,p=
    	!b.series,t=!p&&b.series.drawLegendSymbol?b.series:b;var w=t.options;const v=this.createCheckboxForItem&&w&&w.showCheckbox,u=g.useHTML,x=b.options.className;let J=a.label;w=k+h+q+(v?20:0);J||(a.group=e.g("legend-item").addClass("highcharts-"+t.type+"-series highcharts-color-"+b.colorIndex+(x?" "+x:"")+(p?" highcharts-series-"+b.index:"")).attr({zIndex:1}).add(this.scrollGroup),a.label=J=e.text("",r?k+h:-h,this.baseline||0,u),c.styledMode||J.css(F(b.visible?l:m)),J.attr({align:r?"left":"right",zIndex:2}).add(a.group),
    	this.baseline||(this.fontMetrics=e.fontMetrics(J),this.baseline=this.fontMetrics.f+3+this.itemMarginTop,J.attr("y",this.baseline),this.symbolHeight=d(g.symbolHeight,this.fontMetrics.f),g.squareSymbol&&(this.symbolWidth=d(g.symbolWidth,Math.max(this.symbolHeight,16)),w=this.symbolWidth+h+q+(v?20:0),r&&J.attr("x",this.symbolWidth+h))),t.drawLegendSymbol(this,b),this.setItemEvents&&this.setItemEvents(b,J,u));v&&!b.checkbox&&this.createCheckboxForItem&&this.createCheckboxForItem(b);this.colorizeItem(b,
    	b.visible);!c.styledMode&&l.width||J.css({width:(g.itemWidth||this.widthOption||c.spacingBox.width)-w+"px"});this.setText(b);c=J.getBBox();e=this.fontMetrics&&this.fontMetrics.h||0;b.itemWidth=b.checkboxOffset=g.itemWidth||a.labelWidth||c.width+w;this.maxItemWidth=Math.max(this.maxItemWidth,b.itemWidth);this.totalItemWidth+=b.itemWidth;this.itemHeight=b.itemHeight=Math.round(a.labelHeight||(c.height>1.5*e?c.height:e));}layoutItem(b){var a=this.options;const c=this.padding,e="horizontal"===a.layout,
    	g=b.itemHeight,k=this.itemMarginBottom,h=this.itemMarginTop,l=e?d(a.itemDistance,20):0,m=this.maxLegendWidth;a=a.alignColumns&&this.totalItemWidth>m?this.maxItemWidth:b.itemWidth;const q=b.legendItem||{};e&&this.itemX-c+a>m&&(this.itemX=c,this.lastLineHeight&&(this.itemY+=h+this.lastLineHeight+k),this.lastLineHeight=0);this.lastItemY=h+this.itemY+k;this.lastLineHeight=Math.max(g,this.lastLineHeight);q.x=this.itemX;q.y=this.itemY;e?this.itemX+=a:(this.itemY+=h+g+k,this.lastLineHeight=g);this.offsetWidth=
    	this.widthOption||Math.max((e?this.itemX-c-(b.checkbox?0:l):a)+c,this.offsetWidth);}getAllItems(){let b=[];this.chart.series.forEach(function(a){const c=a&&a.options;a&&d(c.showInLegend,h(c.linkedTo)?!1:void 0,!0)&&(b=b.concat((a.legendItem||{}).labels||("point"===c.legendType?a.data:a)));});w(this,"afterGetAllItems",{allItems:b});return b}getAlignment(){const b=this.options;return this.proximate?b.align.charAt(0)+"tv":b.floating?"":b.align.charAt(0)+b.verticalAlign.charAt(0)+b.layout.charAt(0)}adjustMargins(b,
    	a){const c=this.chart,f=this.options,e=this.getAlignment();e&&[/(lth|ct|rth)/,/(rtv|rm|rbv)/,/(rbh|cb|lbh)/,/(lbv|lm|ltv)/].forEach(function(g,k){g.test(e)&&!h(b[k])&&(c[v[k]]=Math.max(c[v[k]],c.legend[(k+1)%2?"legendHeight":"legendWidth"]+[1,-1,-1,1][k]*f[k%2?"x":"y"]+d(f.margin,12)+a[k]+(c.titleOffset[k]||0)));});}proximatePositions(){const b=this.chart,a=[],c="left"===this.options.align;this.allItems.forEach(function(d){var f;var g=c;let k;d.yAxis&&(d.xAxis.options.reversed&&(g=!g),d.points&&(f=
    	e(g?d.points:d.points.slice(0).reverse(),function(b){return E(b.plotY)})),g=this.itemMarginTop+d.legendItem.label.getBBox().height+this.itemMarginBottom,k=d.yAxis.top-b.plotTop,d.visible?(f=f?f.plotY:d.yAxis.height,f+=k-.3*g):f=k+d.yAxis.height,a.push({target:f,size:g,item:d}));},this);let d;for(const c of l(a,b.plotHeight))d=c.item.legendItem||{},E(c.pos)&&(d.y=b.plotTop-b.spacing[0]+c.pos);}render(){const b=this.chart,a=b.renderer,c=this.options,d=this.padding;var e=this.getAllItems();let g,h=this.group,
    	l=this.box;this.itemX=d;this.itemY=this.initialItemY;this.lastItemY=this.offsetWidth=0;this.widthOption=k(c.width,b.spacingBox.width-d);var m=b.spacingBox.width-2*d-c.x;-1<["rm","lm"].indexOf(this.getAlignment().substring(0,2))&&(m/=2);this.maxLegendWidth=this.widthOption||m;h||(this.group=h=a.g("legend").addClass(c.className||"").attr({zIndex:7}).add(),this.contentGroup=a.g().attr({zIndex:1}).add(h),this.scrollGroup=a.g().add(this.contentGroup));this.renderTitle();r(e,(b,a)=>(b.options&&b.options.legendIndex||
    	0)-(a.options&&a.options.legendIndex||0));c.reversed&&e.reverse();this.allItems=e;this.display=m=!!e.length;this.itemHeight=this.totalItemWidth=this.maxItemWidth=this.lastLineHeight=0;e.forEach(this.renderItem,this);e.forEach(this.layoutItem,this);e=(this.widthOption||this.offsetWidth)+d;g=this.lastItemY+this.lastLineHeight+this.titleHeight;g=this.handleOverflow(g);g+=d;l||(this.box=l=a.rect().addClass("highcharts-legend-box").attr({r:c.borderRadius}).add(h));b.styledMode||l.attr({stroke:c.borderColor,
    	"stroke-width":c.borderWidth||0,fill:c.backgroundColor||"none"}).shadow(c.shadow);if(0<e&&0<g)l[l.placed?"animate":"attr"](l.crisp.call({},{x:0,y:0,width:e,height:g},l.strokeWidth()));h[m?"show":"hide"]();b.styledMode&&"none"===h.getStyle("display")&&(e=g=0);this.legendWidth=e;this.legendHeight=g;m&&this.align();this.proximate||this.positionItems();w(this,"afterRender");}align(b=this.chart.spacingBox){const a=this.chart,c=this.options;let d=b.y;/(lth|ct|rth)/.test(this.getAlignment())&&0<a.titleOffset[0]?
    	d+=a.titleOffset[0]:/(lbh|cb|rbh)/.test(this.getAlignment())&&0<a.titleOffset[2]&&(d-=a.titleOffset[2]);d!==b.y&&(b=F(b,{y:d}));a.hasRendered||(this.group.placed=!1);this.group.align(F(c,{width:this.legendWidth,height:this.legendHeight,verticalAlign:this.proximate?"top":c.verticalAlign}),!0,b);}handleOverflow(b){const a=this,c=this.chart,e=c.renderer,g=this.options;var k=g.y;const h="top"===g.verticalAlign,l=this.padding,m=g.maxHeight,q=g.navigation,r=d(q.animation,!0),p=q.arrowSize||12,t=this.pages,
    	w=this.allItems,v=function(b){"number"===typeof b?E.attr({height:b}):E&&(a.clipRect=E.destroy(),a.contentGroup.clip());a.contentGroup.div&&(a.contentGroup.div.style.clip=b?"rect("+l+"px,9999px,"+(l+b)+"px,0)":"auto");},u=function(b){a[b]=e.circle(0,0,1.3*p).translate(p/2,p/2).add(O);c.styledMode||a[b].attr("fill","rgba(0,0,0,0.0001)");return a[b]};let x,J,N;k=c.spacingBox.height+(h?-k:k)-l;let O=this.nav,E=this.clipRect;"horizontal"!==g.layout||"middle"===g.verticalAlign||g.floating||(k/=2);m&&(k=
    	Math.min(k,m));t.length=0;b&&0<k&&b>k&&!1!==q.enabled?(this.clipHeight=x=Math.max(k-20-this.titleHeight-l,0),this.currentPage=d(this.currentPage,1),this.fullHeight=b,w.forEach((b,a)=>{N=b.legendItem||{};b=N.y||0;const c=Math.round(N.label.getBBox().height);let d=t.length;if(!d||b-t[d-1]>x&&(J||b)!==t[d-1])t.push(J||b),d++;N.pageIx=d-1;J&&((w[a-1].legendItem||{}).pageIx=d-1);a===w.length-1&&b+c-t[d-1]>x&&b>t[d-1]&&(t.push(b),N.pageIx=d);b!==J&&(J=b);}),E||(E=a.clipRect=e.clipRect(0,l-2,9999,0),a.contentGroup.clip(E)),
    	v(x),O||(this.nav=O=e.g().attr({zIndex:1}).add(this.group),this.up=e.symbol("triangle",0,0,p,p).add(O),u("upTracker").on("click",function(){a.scroll(-1,r);}),this.pager=e.text("",15,10).addClass("highcharts-legend-navigation"),!c.styledMode&&q.style&&this.pager.css(q.style),this.pager.add(O),this.down=e.symbol("triangle-down",0,0,p,p).add(O),u("downTracker").on("click",function(){a.scroll(1,r);})),a.scroll(0),b=k):O&&(v(),this.nav=O.destroy(),this.scrollGroup.attr({translateY:1}),this.clipHeight=0);
    	return b}scroll(b,a){const c=this.chart,f=this.pages,e=f.length,g=this.clipHeight,k=this.options.navigation,h=this.pager,l=this.padding;let m=this.currentPage+b;m>e&&(m=e);0<m&&("undefined"!==typeof a&&B(a,c),this.nav.attr({translateX:l,translateY:g+this.padding+7+this.titleHeight,visibility:"inherit"}),[this.up,this.upTracker].forEach(function(b){b.attr({"class":1===m?"highcharts-legend-nav-inactive":"highcharts-legend-nav-active"});}),h.attr({text:m+"/"+e}),[this.down,this.downTracker].forEach(function(b){b.attr({x:18+
    	this.pager.getBBox().width,"class":m===e?"highcharts-legend-nav-inactive":"highcharts-legend-nav-active"});},this),c.styledMode||(this.up.attr({fill:1===m?k.inactiveColor:k.activeColor}),this.upTracker.css({cursor:1===m?"default":"pointer"}),this.down.attr({fill:m===e?k.inactiveColor:k.activeColor}),this.downTracker.css({cursor:m===e?"default":"pointer"})),this.scrollOffset=-f[m-1]+this.initialItemY,this.scrollGroup.animate({translateY:this.scrollOffset}),this.currentPage=m,this.positionCheckboxes(),
    	b=x(d(a,c.renderer.globalAnimation,!0)),q(()=>{w(this,"afterScroll",{currentPage:m});},b.duration));}setItemEvents(b,a,c){const d=this,f=b.legendItem||{},e=d.chart.renderer.boxWrapper,g=b instanceof L,k="highcharts-legend-"+(g?"point":"series")+"-active",h=d.chart.styledMode;c=c?[a,f.symbol]:[f.group];const l=a=>{d.allItems.forEach(c=>{b!==c&&[c].concat(c.linkedSeries||[]).forEach(b=>{b.setState(a,!g);});});};for(const f of c)if(f)f.on("mouseover",function(){b.visible&&l("inactive");b.setState("hover");
    	b.visible&&e.addClass(k);h||a.css(d.options.itemHoverStyle);}).on("mouseout",function(){d.chart.styledMode||a.css(F(b.visible?d.itemStyle:d.itemHiddenStyle));l("");e.removeClass(k);b.setState();}).on("click",function(a){const c=function(){b.setVisible&&b.setVisible();l(b.visible?"inactive":"");};e.removeClass(k);a={browserEvent:a};b.firePointEvent?b.firePointEvent("legendItemClick",a,c):w(b,"legendItemClick",a,c);});}createCheckboxForItem(b){b.checkbox=t("input",{type:"checkbox",className:"highcharts-legend-checkbox",
    	checked:b.selected,defaultChecked:b.selected},this.options.itemCheckboxStyle,this.chart.container);p(b.checkbox,"click",function(a){w(b.series||b,"checkboxClick",{checked:a.target.checked,item:b},function(){b.select();});});}}(function(b){const a=[];b.compose=function(c){z.pushUnique(a,c)&&p(c,"beforeMargins",function(){this.legend=new b(this,this.options.legend);});};})(G||(G={}));return G});M(a,"Core/Legend/LegendSymbol.js",[a["Core/Utilities.js"]],function(a){const {extend:x,merge:I,pick:L}=a;var C;
    	(function(a){a.lineMarker=function(a,B){B=this.legendItem=this.legendItem||{};var u=this.options;const v=a.symbolWidth,l=a.symbolHeight,p=l/2,t=this.chart.renderer,m=B.group;a=a.baseline-Math.round(.3*a.fontMetrics.b);let h={},g=u.marker,e=0;this.chart.styledMode||(h={"stroke-width":Math.min(u.lineWidth||0,24)},u.dashStyle?h.dashstyle=u.dashStyle:"square"!==u.linecap&&(h["stroke-linecap"]="round"));B.line=t.path().addClass("highcharts-graph").attr(h).add(m);h["stroke-linecap"]&&(e=Math.min(B.line.strokeWidth(),
    	v)/2);v&&B.line.attr({d:[["M",e,a],["L",v-e,a]]});g&&!1!==g.enabled&&v&&(u=Math.min(L(g.radius,p),p),0===this.symbol.indexOf("url")&&(g=I(g,{width:l,height:l}),u=0),B.symbol=B=t.symbol(this.symbol,v/2-u,a-u,2*u,2*u,x({context:"legend"},g)).addClass("highcharts-point").add(m),B.isMarker=!0);};a.rectangle=function(a,x){x=x.legendItem||{};const u=a.symbolHeight,v=a.options.squareSymbol;x.symbol=this.chart.renderer.rect(v?(a.symbolWidth-u)/2:0,a.baseline-u+1,v?u:a.symbolWidth,u,L(a.options.symbolRadius,
    	u/2)).addClass("highcharts-point").attr({zIndex:3}).add(x.group);};})(C||(C={}));return C});M(a,"Core/Series/SeriesDefaults.js",[],function(){return {lineWidth:1,allowPointSelect:!1,crisp:!0,showCheckbox:!1,animation:{duration:1E3},enableMouseTracking:!0,events:{},marker:{enabledThreshold:2,lineColor:"#ffffff",lineWidth:0,radius:4,states:{normal:{animation:!0},hover:{animation:{duration:150},enabled:!0,radiusPlus:2,lineWidthPlus:1},select:{fillColor:"#cccccc",lineColor:"#000000",lineWidth:2}}},point:{events:{}},
    	dataLabels:{animation:{},align:"center",borderWidth:0,defer:!0,formatter:function(){const {numberFormatter:a}=this.series.chart;return "number"!==typeof this.y?"":a(this.y,-1)},padding:5,style:{fontSize:"0.7em",fontWeight:"bold",color:"contrast",textOutline:"1px contrast"},verticalAlign:"bottom",x:0,y:0},cropThreshold:300,opacity:1,pointRange:0,softThreshold:!0,states:{normal:{animation:!0},hover:{animation:{duration:150},lineWidthPlus:1,marker:{},halo:{size:10,opacity:.25}},select:{animation:{duration:0}},
    	inactive:{animation:{duration:150},opacity:.2}},stickyTracking:!0,turboThreshold:1E3,findNearestPointBy:"x"}});M(a,"Core/Series/SeriesRegistry.js",[a["Core/Globals.js"],a["Core/Defaults.js"],a["Core/Series/Point.js"],a["Core/Utilities.js"]],function(a,y,I,L){const {defaultOptions:x}=y,{extendClass:z,merge:H}=L;var B;(function(u){function v(a,p){const l=x.plotOptions||{},m=p.defaultOptions,h=p.prototype;h.type=a;h.pointClass||(h.pointClass=I);m&&(l[a]=m);u.seriesTypes[a]=p;}u.seriesTypes=a.seriesTypes;
    	u.registerSeriesType=v;u.seriesType=function(a,p,t,m,h){const g=x.plotOptions||{};p=p||"";g[a]=H(g[p],t);v(a,z(u.seriesTypes[p]||function(){},m));u.seriesTypes[a].prototype.type=a;h&&(u.seriesTypes[a].prototype.pointClass=z(I,h));return u.seriesTypes[a]};})(B||(B={}));return B});M(a,"Core/Series/Series.js",[a["Core/Animation/AnimationUtilities.js"],a["Core/Defaults.js"],a["Core/Foundation.js"],a["Core/Globals.js"],a["Core/Legend/LegendSymbol.js"],a["Core/Series/Point.js"],a["Core/Series/SeriesDefaults.js"],
    	a["Core/Series/SeriesRegistry.js"],a["Core/Renderer/SVG/SVGElement.js"],a["Core/Utilities.js"]],function(a,y,I,L,C,z,H,B,u,v){const {animObject:l,setAnimation:p}=a,{defaultOptions:t}=y,{registerEventOptions:m}=I,{hasTouch:h,svg:g,win:e}=L,{seriesTypes:w}=B,{arrayMax:x,arrayMin:F,clamp:d,correctFloat:k,defined:r,diffObjects:q,erase:G,error:b,extend:f,find:c,fireEvent:n,getClosestDistance:P,getNestedProperty:D,insertItem:K,isArray:X,isNumber:T,isString:Z,merge:V,objectEach:Y,pick:A,removeEvent:M,splat:ia,
    	syncTimeout:ba}=v;class aa{constructor(){this.zones=this.yAxis=this.xAxis=this.userOptions=this.tooltipOptions=this.processedYData=this.processedXData=this.points=this.options=this.linkedSeries=this.index=this.eventsToUnbind=this.eventOptions=this.data=this.chart=this._i=void 0;}init(b,a){n(this,"init",{options:a});const c=this,d=b.series;this.eventsToUnbind=[];c.chart=b;c.options=c.setOptions(a);a=c.options;c.linkedSeries=[];c.bindAxes();f(c,{name:a.name,state:"",visible:!1!==a.visible,selected:!0===
    	a.selected});m(this,a);const e=a.events;if(e&&e.click||a.point&&a.point.events&&a.point.events.click||a.allowPointSelect)b.runTrackerClick=!0;c.getColor();c.getSymbol();c.parallelArrays.forEach(function(b){c[b+"Data"]||(c[b+"Data"]=[]);});c.isCartesian&&(b.hasCartesianSeries=!0);let g;d.length&&(g=d[d.length-1]);c._i=A(g&&g._i,-1)+1;c.opacity=c.options.opacity;b.orderItems("series",K(this,d));a.dataSorting&&a.dataSorting.enabled?c.setDataSortingOptions():c.points||c.data||c.setData(a.data,!1);n(this,
    	"afterInit");}is(b){return w[b]&&this instanceof w[b]}bindAxes(){const a=this,c=a.options,d=a.chart;let f;n(this,"bindAxes",null,function(){(a.axisTypes||[]).forEach(function(e){d[e].forEach(function(b){f=b.options;if(A(c[e],0)===b.index||"undefined"!==typeof c[e]&&c[e]===f.id)K(a,b.series),a[e]=b,b.isDirty=!0;});a[e]||a.optionalAxis===e||b(18,!0,d);});});n(this,"afterBindAxes");}updateParallelArrays(b,a,c){const d=b.series,f=T(a)?function(c){const f="y"===c&&d.toYData?d.toYData(b):b[c];d[c+"Data"][a]=
    	f;}:function(b){Array.prototype[a].apply(d[b+"Data"],c);};d.parallelArrays.forEach(f);}hasData(){return this.visible&&"undefined"!==typeof this.dataMax&&"undefined"!==typeof this.dataMin||this.visible&&this.yData&&0<this.yData.length}autoIncrement(b){var a=this.options;const c=a.pointIntervalUnit,d=a.relativeXValue,f=this.chart.time;let e=this.xIncrement,g;e=A(e,a.pointStart,0);this.pointInterval=g=A(this.pointInterval,a.pointInterval,1);d&&T(b)&&(g*=b);c&&(a=new f.Date(e),"day"===c?f.set("Date",a,f.get("Date",
    	a)+g):"month"===c?f.set("Month",a,f.get("Month",a)+g):"year"===c&&f.set("FullYear",a,f.get("FullYear",a)+g),g=a.getTime()-e);if(d&&T(b))return e+g;this.xIncrement=e+g;return e}setDataSortingOptions(){const b=this.options;f(this,{requireSorting:!1,sorted:!1,enabledDataSorting:!0,allowDG:!1});r(b.pointRange)||(b.pointRange=1);}setOptions(b){var a,c;const d=this.chart;var f=d.options.plotOptions,e=d.userOptions||{};const g=V(b);b=d.styledMode;const k={plotOptions:f,userOptions:g};n(this,"setOptions",
    	k);const h=k.plotOptions[this.type];e=e.plotOptions||{};const l=e.series||{},m=t.plotOptions[this.type]||{},q=e[this.type]||{};this.userOptions=k.userOptions;f=V(h,f.series,q,g);this.tooltipOptions=V(t.tooltip,null===(a=t.plotOptions.series)||void 0===a?void 0:a.tooltip,null===m||void 0===m?void 0:m.tooltip,d.userOptions.tooltip,null===(c=e.series)||void 0===c?void 0:c.tooltip,q.tooltip,g.tooltip);this.stickyTracking=A(g.stickyTracking,q.stickyTracking,l.stickyTracking,this.tooltipOptions.shared&&
    	!this.noSharedTooltip?!0:f.stickyTracking);null===h.marker&&delete f.marker;this.zoneAxis=f.zoneAxis;c=this.zones=(f.zones||[]).slice();!f.negativeColor&&!f.negativeFillColor||f.zones||(a={value:f[this.zoneAxis+"Threshold"]||f.threshold||0,className:"highcharts-negative"},b||(a.color=f.negativeColor,a.fillColor=f.negativeFillColor),c.push(a));c.length&&r(c[c.length-1].value)&&c.push(b?{}:{color:this.color,fillColor:this.fillColor});n(this,"afterSetOptions",{options:f});return f}getName(){return A(this.options.name,
    	"Series "+(this.index+1))}getCyclic(b,a,c){const d=this.chart,f=`${b}Index`,e=`${b}Counter`,g=(null===c||void 0===c?void 0:c.length)||d.options.chart.colorCount;if(!a){var k=A("color"===b?this.options.colorIndex:void 0,this[f]);r(k)||(d.series.length||(d[e]=0),k=d[e]%g,d[e]+=1);c&&(a=c[k]);}"undefined"!==typeof k&&(this[f]=k);this[b]=a;}getColor(){this.chart.styledMode?this.getCyclic("color"):this.options.colorByPoint?this.color="#cccccc":this.getCyclic("color",this.options.color||t.plotOptions[this.type].color,
    	this.chart.options.colors);}getPointsCollection(){return (this.hasGroupedData?this.points:this.data)||[]}getSymbol(){this.getCyclic("symbol",this.options.marker.symbol,this.chart.options.symbols);}findPointIndex(b,a){const d=b.id,f=b.x,e=this.points;var g=this.options.dataSorting,k;let h,n;if(d)g=this.chart.get(d),g instanceof z&&(k=g);else if(this.linkedParent||this.enabledDataSorting||this.options.relativeXValue)if(k=a=>!a.touched&&a.index===b.index,g&&g.matchByName?k=a=>!a.touched&&a.name===b.name:
    	this.options.relativeXValue&&(k=a=>!a.touched&&a.options.x===b.x),k=c(e,k),!k)return;k&&(n=k&&k.index,"undefined"!==typeof n&&(h=!0));"undefined"===typeof n&&T(f)&&(n=this.xData.indexOf(f,a));-1!==n&&"undefined"!==typeof n&&this.cropped&&(n=n>=this.cropStart?n-this.cropStart:n);!h&&T(n)&&e[n]&&e[n].touched&&(n=void 0);return n}updateData(b,a){const c=this.options,d=c.dataSorting,f=this.points,e=[],g=this.requireSorting,k=b.length===f.length;let n,h,l,m=!0;this.xIncrement=null;b.forEach(function(b,
    	a){var h=r(b)&&this.pointClass.prototype.optionsToObject.call({series:this},b)||{};const m=h.x;if(h.id||T(m)){if(h=this.findPointIndex(h,l),-1===h||"undefined"===typeof h?e.push(b):f[h]&&b!==c.data[h]?(f[h].update(b,!1,null,!1),f[h].touched=!0,g&&(l=h+1)):f[h]&&(f[h].touched=!0),!k||a!==h||d&&d.enabled||this.hasDerivedData)n=!0;}else e.push(b);},this);if(n)for(b=f.length;b--;)(h=f[b])&&!h.touched&&h.remove&&h.remove(!1,a);else !k||d&&d.enabled?m=!1:(b.forEach(function(b,a){b===f[a].y||f[a].destroyed||
    	f[a].update(b,!1,null,!1);}),e.length=0);f.forEach(function(b){b&&(b.touched=!1);});if(!m)return !1;e.forEach(function(b){this.addPoint(b,!1,null,null,!1);},this);null===this.xIncrement&&this.xData&&this.xData.length&&(this.xIncrement=x(this.xData),this.autoIncrement());return !0}setData(a,c=!0,d,f){var e;const g=this,k=g.points,h=k&&k.length||0,n=g.options,l=g.chart,m=n.dataSorting,q=g.xAxis,p=n.turboThreshold,r=this.xData,t=this.yData;var w=g.pointArrayMap;w=w&&w.length;const J=n.keys;let v,u=0,O=1,
    	x=null;if(!l.options.chart.allowMutatingData){n.data&&delete g.options.data;g.userOptions.data&&delete g.userOptions.data;var N=V(!0,a);}a=N||a||[];N=a.length;m&&m.enabled&&(a=this.sortData(a));l.options.chart.allowMutatingData&&!1!==f&&N&&h&&!g.cropped&&!g.hasGroupedData&&g.visible&&!g.boosted&&(v=this.updateData(a,d));if(!v){g.xIncrement=null;g.colorCounter=0;this.parallelArrays.forEach(function(b){g[b+"Data"].length=0;});if(p&&N>p)if(x=g.getFirstValidPoint(a),T(x))for(d=0;d<N;d++)r[d]=this.autoIncrement(),
    	t[d]=a[d];else if(X(x))if(w)if(x.length===w)for(d=0;d<N;d++)r[d]=this.autoIncrement(),t[d]=a[d];else for(d=0;d<N;d++)f=a[d],r[d]=f[0],t[d]=f.slice(1,w+1);else if(J&&(u=J.indexOf("x"),O=J.indexOf("y"),u=0<=u?u:0,O=0<=O?O:1),1===x.length&&(O=0),u===O)for(d=0;d<N;d++)r[d]=this.autoIncrement(),t[d]=a[d][O];else for(d=0;d<N;d++)f=a[d],r[d]=f[u],t[d]=f[O];else b(12,!1,l);else for(d=0;d<N;d++)f={series:g},g.pointClass.prototype.applyOptions.apply(f,[a[d]]),g.updateParallelArrays(f,d);t&&Z(t[0])&&b(14,!0,
    	l);g.data=[];g.options.data=g.userOptions.data=a;for(d=h;d--;)null===(e=k[d])||void 0===e?void 0:e.destroy();q&&(q.minRange=q.userMinRange);g.isDirty=l.isDirtyBox=!0;g.isDirtyData=!!k;d=!1;}"point"===n.legendType&&(this.processData(),this.generatePoints());c&&l.redraw(d);}sortData(b){const a=this,c=a.options.dataSorting.sortKey||"y",d=function(b,a){return r(a)&&b.pointClass.prototype.optionsToObject.call({series:b},a)||{}};b.forEach(function(c,f){b[f]=d(a,c);b[f].index=f;},this);b.concat().sort((b,a)=>
    	{b=D(c,b);a=D(c,a);return a<b?-1:a>b?1:0}).forEach(function(b,a){b.x=a;},this);a.linkedSeries&&a.linkedSeries.forEach(function(a){const c=a.options,f=c.data;c.dataSorting&&c.dataSorting.enabled||!f||(f.forEach(function(c,e){f[e]=d(a,c);b[e]&&(f[e].x=b[e].x,f[e].index=e);}),a.setData(f,!1));});return b}getProcessedData(a){const c=this;var d=c.xAxis,f=c.options;const e=f.cropThreshold,g=a||c.getExtremesFromAll||f.getExtremesFromAll,k=null===d||void 0===d?void 0:d.logarithmic,h=c.isCartesian;let n=0;let l;
    	a=c.xData;f=c.yData;let m=!1;const q=a.length;if(d){var r=d.getExtremes();l=r.min;r=r.max;m=!(!d.categories||d.names.length);}if(h&&c.sorted&&!g&&(!e||q>e||c.forceCrop))if(a[q-1]<l||a[0]>r)a=[],f=[];else if(c.yData&&(a[0]<l||a[q-1]>r)){var p=this.cropData(c.xData,c.yData,l,r);a=p.xData;f=p.yData;n=p.start;p=!0;}d=P([k?a.map(k.log2lin):a],()=>c.requireSorting&&!m&&b(15,!1,c.chart));return {xData:a,yData:f,cropped:p,cropStart:n,closestPointRange:d}}processData(b){const a=this.xAxis;if(this.isCartesian&&
    	!this.isDirty&&!a.isDirty&&!this.yAxis.isDirty&&!b)return !1;b=this.getProcessedData();this.cropped=b.cropped;this.cropStart=b.cropStart;this.processedXData=b.xData;this.processedYData=b.yData;this.closestPointRange=this.basePointRange=b.closestPointRange;n(this,"afterProcessData");}cropData(b,a,c,d,f){const e=b.length;let g,k=0,h=e;f=A(f,this.cropShoulder);for(g=0;g<e;g++)if(b[g]>=c){k=Math.max(0,g-f);break}for(c=g;c<e;c++)if(b[c]>d){h=c+f;break}return {xData:b.slice(k,h),yData:a.slice(k,h),start:k,
    	end:h}}generatePoints(){var b=this.options;const a=this.processedData||b.data,c=this.processedXData,d=this.processedYData,e=this.pointClass,g=c.length,k=this.cropStart||0,h=this.hasGroupedData,l=b.keys,m=[];b=b.dataGrouping&&b.dataGrouping.groupAll?k:0;let q;let r,p,t=this.data;if(!t&&!h){var w=[];w.length=a.length;t=this.data=w;}l&&h&&(this.options.keys=!1);for(p=0;p<g;p++)w=k+p,h?(r=(new e).init(this,[c[p]].concat(ia(d[p]))),r.dataGroup=this.groupMap[b+p],r.dataGroup.options&&(r.options=r.dataGroup.options,
    	f(r,r.dataGroup.options),delete r.dataLabels)):(r=t[w])||"undefined"===typeof a[w]||(t[w]=r=(new e).init(this,a[w],c[p])),r&&(r.index=h?b+p:w,m[p]=r);this.options.keys=l;if(t&&(g!==(q=t.length)||h))for(p=0;p<q;p++)p!==k||h||(p+=g),t[p]&&(t[p].destroyElements(),t[p].plotX=void 0);this.data=t;this.points=m;n(this,"afterGeneratePoints");}getXExtremes(b){return {min:F(b),max:x(b)}}getExtremes(b,a){const c=this.xAxis;var d=this.yAxis;const f=this.processedXData||this.xData,e=[],g=this.requireSorting?this.cropShoulder:
    	0;d=d?d.positiveValuesOnly:!1;let k,h=0,l=0,m=0;b=b||this.stackedYData||this.processedYData||[];const q=b.length;if(c){var p=c.getExtremes();h=p.min;l=p.max;}for(k=0;k<q;k++){var r=f[k];p=b[k];var t=(T(p)||X(p))&&(p.length||0<p||!d);r=a||this.getExtremesFromAll||this.options.getExtremesFromAll||this.cropped||!c||(f[k+g]||r)>=h&&(f[k-g]||r)<=l;if(t&&r)if(t=p.length)for(;t--;)T(p[t])&&(e[m++]=p[t]);else e[m++]=p;}b={activeYData:e,dataMin:F(e),dataMax:x(e)};n(this,"afterGetExtremes",{dataExtremes:b});
    	return b}applyExtremes(){const b=this.getExtremes();this.dataMin=b.dataMin;this.dataMax=b.dataMax;return b}getFirstValidPoint(b){const a=b.length;let c=0,d=null;for(;null===d&&c<a;)d=b[c],c++;return d}translate(){var b;this.processedXData||this.processData();this.generatePoints();var a=this.options;const c=a.stacking,f=this.xAxis,e=f.categories,g=this.enabledDataSorting,h=this.yAxis,l=this.points,m=l.length,q=this.pointPlacementToXValue(),p=!!q,t=a.threshold;a=a.startFromThreshold?t:0;let w,v,u,x,
    	D=Number.MAX_VALUE;for(w=0;w<m;w++){const n=l[w],m=n.x;let J,Q,R=n.y,O=n.low;const E=c&&(null===(b=h.stacking)||void 0===b?void 0:b.stacks[(this.negStacks&&R<(a?0:t)?"-":"")+this.stackKey]);v=f.translate(m,!1,!1,!1,!0,q);n.plotX=T(v)?k(d(v,-1E5,1E5)):void 0;c&&this.visible&&E&&E[m]&&(x=this.getStackIndicator(x,m,this.index),!n.isNull&&x.key&&(J=E[m],Q=J.points[x.key]),J&&X(Q)&&(O=Q[0],R=Q[1],O===a&&x.key===E[m].base&&(O=A(T(t)?t:h.min)),h.positiveValuesOnly&&r(O)&&0>=O&&(O=void 0),n.total=n.stackTotal=
    	A(J.total),n.percentage=r(n.y)&&J.total?n.y/J.total*100:void 0,n.stackY=R,this.irregularWidths||J.setOffset(this.pointXOffset||0,this.barW||0,void 0,void 0,void 0,this.xAxis)));n.yBottom=r(O)?d(h.translate(O,!1,!0,!1,!0),-1E5,1E5):void 0;this.dataModify&&(R=this.dataModify.modifyValue(R,w));let N;T(R)&&void 0!==n.plotX&&(N=h.translate(R,!1,!0,!1,!0),N=T(N)?d(N,-1E5,1E5):void 0);n.plotY=N;n.isInside=this.isPointInside(n);n.clientX=p?k(f.translate(m,!1,!1,!1,!0,q)):v;n.negative=(n.y||0)<(t||0);n.category=
    	A(e&&e[n.x],n.x);n.isNull||!1===n.visible||("undefined"!==typeof u&&(D=Math.min(D,Math.abs(v-u))),u=v);n.zone=this.zones.length?n.getZone():void 0;!n.graphic&&this.group&&g&&(n.isNew=!0);}this.closestPointRangePx=D;n(this,"afterTranslate");}getValidPoints(b,a,c){const d=this.chart;return (b||this.points||[]).filter(function(b){const {plotX:f,plotY:e}=b;return !c&&(b.isNull||!T(e))||a&&!d.isInsidePlot(f,e,{inverted:d.inverted})?!1:!1!==b.visible})}getClipBox(){const {chart:b,xAxis:a,yAxis:c}=this,d=V(b.clipBox);
    	a&&a.len!==b.plotSizeX&&(d.width=a.len);c&&c.len!==b.plotSizeY&&(d.height=c.len);return d}getSharedClipKey(){return this.sharedClipKey=(this.options.xAxis||0)+","+(this.options.yAxis||0)}setClip(){const {chart:b,group:a,markerGroup:c}=this,d=b.sharedClips,f=b.renderer,e=this.getClipBox(),g=this.getSharedClipKey();let k=d[g];k?k.animate(e):d[g]=k=f.clipRect(e);a&&a.clip(!1===this.options.clip?void 0:k);c&&c.clip();}animate(b){const {chart:a,group:c,markerGroup:d}=this,f=a.inverted;var e=l(this.options.animation),
    	g=[this.getSharedClipKey(),e.duration,e.easing,e.defer].join();let k=a.sharedClips[g],n=a.sharedClips[g+"m"];if(b&&c)e=this.getClipBox(),k?k.attr("height",e.height):(e.width=0,f&&(e.x=a.plotHeight),k=a.renderer.clipRect(e),a.sharedClips[g]=k,n=a.renderer.clipRect({x:-99,y:-99,width:f?a.plotWidth+199:99,height:f?99:a.plotHeight+199}),a.sharedClips[g+"m"]=n),c.clip(k),d&&d.clip(n);else if(k&&!k.hasClass("highcharts-animating")){g=this.getClipBox();const b=e.step;d&&d.element.childNodes.length&&(e.step=
    	function(a,c){b&&b.apply(c,arguments);"width"===c.prop&&n&&n.element&&n.attr(f?"height":"width",a+99);});k.addClass("highcharts-animating").animate(g,e);}}afterAnimate(){this.setClip();Y(this.chart.sharedClips,(b,a,c)=>{b&&!this.chart.container.querySelector(`[clip-path="url(#${b.id})"]`)&&(b.destroy(),delete c[a]);});this.finishedAnimating=!0;n(this,"afterAnimate");}drawPoints(b=this.points){const a=this.chart,c=a.styledMode,{colorAxis:d,options:f}=this,e=f.marker,g=this[this.specialGroup||"markerGroup"],
    	k=this.xAxis,n=A(e.enabled,!k||k.isRadial?!0:null,this.closestPointRangePx>=e.enabledThreshold*e.radius);let h,l,m,q;let p,r;if(!1!==e.enabled||this._hasPointMarkers)for(h=0;h<b.length;h++){l=b[h];q=(m=l.graphic)?"animate":"attr";var t=l.marker||{};p=!!l.marker;if((n&&"undefined"===typeof t.enabled||t.enabled)&&!l.isNull&&!1!==l.visible){const b=A(t.symbol,this.symbol,"rect");r=this.markerAttribs(l,l.selected&&"select");this.enabledDataSorting&&(l.startXPos=k.reversed?-(r.width||0):k.width);const f=
    	!1!==l.isInside;!m&&f&&(0<(r.width||0)||l.hasImage)&&(l.graphic=m=a.renderer.symbol(b,r.x,r.y,r.width,r.height,p?t:e).add(g),this.enabledDataSorting&&a.hasRendered&&(m.attr({x:l.startXPos}),q="animate"));m&&"animate"===q&&m[f?"show":"hide"](f).animate(r);if(m)if(t=this.pointAttribs(l,c||!l.selected?void 0:"select"),c)d&&m.css({fill:t.fill});else m[q](t);m&&m.addClass(l.getClassName(),!0);}else m&&(l.graphic=m.destroy());}}markerAttribs(b,a){const c=this.options;var d=c.marker;const f=b.marker||{},e=
    	f.symbol||d.symbol,g={};let k=A(f.radius,d&&d.radius);a&&(d=d.states[a],a=f.states&&f.states[a],k=A(a&&a.radius,d&&d.radius,k&&k+(d&&d.radiusPlus||0)));b.hasImage=e&&0===e.indexOf("url");b.hasImage&&(k=0);b=b.pos();T(k)&&b&&(g.x=b[0]-k,g.y=b[1]-k,c.crisp&&(g.x=Math.floor(g.x)));k&&(g.width=g.height=2*k);return g}pointAttribs(b,a){var c=this.options.marker,d=b&&b.options;const f=d&&d.marker||{};var e=d&&d.color,g=b&&b.color;const k=b&&b.zone&&b.zone.color;let n=this.color;b=A(f.lineWidth,c.lineWidth);
    	d=1;n=e||k||g||n;e=f.fillColor||c.fillColor||n;g=f.lineColor||c.lineColor||n;a=a||"normal";c=c.states[a]||{};a=f.states&&f.states[a]||{};b=A(a.lineWidth,c.lineWidth,b+A(a.lineWidthPlus,c.lineWidthPlus,0));e=a.fillColor||c.fillColor||e;g=a.lineColor||c.lineColor||g;d=A(a.opacity,c.opacity,d);return {stroke:g,"stroke-width":b,fill:e,opacity:d}}destroy(b){const a=this,c=a.chart,d=/AppleWebKit\/533/.test(e.navigator.userAgent),f=a.data||[];let g,k,h,l;n(a,"destroy",{keepEventsForUpdate:b});this.removeEvents(b);
    	(a.axisTypes||[]).forEach(function(b){(l=a[b])&&l.series&&(G(l.series,a),l.isDirty=l.forceRedraw=!0);});a.legendItem&&a.chart.legend.destroyItem(a);for(k=f.length;k--;)(h=f[k])&&h.destroy&&h.destroy();a.clips&&a.clips.forEach(b=>b.destroy());v.clearTimeout(a.animationTimeout);Y(a,function(b,a){b instanceof u&&!b.survive&&(g=d&&"group"===a?"hide":"destroy",b[g]());});c.hoverSeries===a&&(c.hoverSeries=void 0);G(c.series,a);c.orderItems("series");Y(a,function(c,d){b&&"hcEvents"===d||delete a[d];});}applyZones(){const b=
    	this,a=this.chart,c=a.renderer,f=this.zones,e=this.clips||[],g=this.graph,k=this.area,n=Math.max(a.plotWidth,a.plotHeight),h=this[(this.zoneAxis||"y")+"Axis"],l=a.inverted;let m,q,p,r,t,w,v,u,x,D,E,G=!1;f.length&&(g||k)&&h&&"undefined"!==typeof h.min?(t=h.reversed,w=h.horiz,g&&!this.showLine&&g.hide(),k&&k.hide(),r=h.getExtremes(),f.forEach(function(f,Q){m=t?w?a.plotWidth:0:w?0:h.toPixels(r.min)||0;m=d(A(q,m),0,n);q=d(Math.round(h.toPixels(A(f.value,r.max),!0)||0),0,n);G&&(m=q=h.toPixels(r.max));
    	v=Math.abs(m-q);u=Math.min(m,q);x=Math.max(m,q);h.isXAxis?(p={x:l?x:u,y:0,width:v,height:n},w||(p.x=a.plotHeight-p.x)):(p={x:0,y:l?x:u,width:n,height:v},w&&(p.y=a.plotWidth-p.y));e[Q]?e[Q].animate(p):e[Q]=c.clipRect(p);D=b["zone-area-"+Q];E=b["zone-graph-"+Q];g&&E&&E.clip(e[Q]);k&&D&&D.clip(e[Q]);G=f.value>r.max;b.resetZones&&0===q&&(q=void 0);}),this.clips=e):b.visible&&(g&&g.show(),k&&k.show());}plotGroup(b,a,c,d,f){let e=this[b];const g=!e;c={visibility:c,zIndex:d||.1};"undefined"===typeof this.opacity||
    	this.chart.styledMode||"inactive"===this.state||(c.opacity=this.opacity);g&&(this[b]=e=this.chart.renderer.g().add(f));e.addClass("highcharts-"+a+" highcharts-series-"+this.index+" highcharts-"+this.type+"-series "+(r(this.colorIndex)?"highcharts-color-"+this.colorIndex+" ":"")+(this.options.className||"")+(e.hasClass("highcharts-tracker")?" highcharts-tracker":""),!0);e.attr(c)[g?"attr":"animate"](this.getPlotBox(a));return e}getPlotBox(b){let a=this.xAxis,c=this.yAxis;const d=this.chart;b=d.inverted&&
    	!d.polar&&a&&!1!==this.invertible&&"series"===b;d.inverted&&(a=c,c=this.xAxis);return {translateX:a?a.left:d.plotLeft,translateY:c?c.top:d.plotTop,rotation:b?90:0,rotationOriginX:b?(a.len-c.len)/2:0,rotationOriginY:b?(a.len+c.len)/2:0,scaleX:b?-1:1,scaleY:1}}removeEvents(b){b||M(this);this.eventsToUnbind.length&&(this.eventsToUnbind.forEach(function(b){b();}),this.eventsToUnbind.length=0);}render(){const b=this;var a=b.chart;const c=b.options,d=l(c.animation),f=b.visible?"inherit":"hidden",e=c.zIndex,
    	g=b.hasRendered;a=a.seriesGroup;let k=b.finishedAnimating?0:d.duration;n(this,"render");b.plotGroup("group","series",f,e,a);b.markerGroup=b.plotGroup("markerGroup","markers",f,e,a);!1!==c.clip&&b.setClip();b.animate&&k&&b.animate(!0);b.drawGraph&&(b.drawGraph(),b.applyZones());b.visible&&b.drawPoints();b.drawDataLabels&&b.drawDataLabels();b.redrawPoints&&b.redrawPoints();b.drawTracker&&c.enableMouseTracking&&b.drawTracker();b.animate&&k&&b.animate();g||(k&&d.defer&&(k+=d.defer),b.animationTimeout=
    	ba(function(){b.afterAnimate();},k||0));b.isDirty=!1;b.hasRendered=!0;n(b,"afterRender");}redraw(){const b=this.isDirty||this.isDirtyData;this.translate();this.render();b&&delete this.kdTree;}searchPoint(b,a){const c=this.xAxis,d=this.yAxis,f=this.chart.inverted;return this.searchKDTree({clientX:f?c.len-b.chartY+c.pos:b.chartX-c.pos,plotY:f?d.len-b.chartX+d.pos:b.chartY-d.pos},a,b)}buildKDTree(b){function a(b,d,f){var e=b&&b.length;let g;if(e)return g=c.kdAxisArray[d%f],b.sort(function(b,a){return b[g]-
    	a[g]}),e=Math.floor(e/2),{point:b[e],left:a(b.slice(0,e),d+1,f),right:a(b.slice(e+1),d+1,f)}}this.buildingKdTree=!0;const c=this,d=-1<c.options.findNearestPointBy.indexOf("y")?2:1;delete c.kdTree;ba(function(){c.kdTree=a(c.getValidPoints(null,!c.directTouch),d,d);c.buildingKdTree=!1;},c.options.kdNow||b&&"touchstart"===b.type?0:1);}searchKDTree(b,a,c){function d(b,a,c,n){const h=a.point;var l=f.kdAxisArray[c%n];let m=h;var q=r(b[e])&&r(h[e])?Math.pow(b[e]-h[e],2):null;var p=r(b[g])&&r(h[g])?Math.pow(b[g]-
    	h[g],2):null;p=(q||0)+(p||0);h.dist=r(p)?Math.sqrt(p):Number.MAX_VALUE;h.distX=r(q)?Math.sqrt(q):Number.MAX_VALUE;l=b[l]-h[l];p=0>l?"left":"right";q=0>l?"right":"left";a[p]&&(p=d(b,a[p],c+1,n),m=p[k]<m[k]?p:h);a[q]&&Math.sqrt(l*l)<m[k]&&(b=d(b,a[q],c+1,n),m=b[k]<m[k]?b:m);return m}const f=this,e=this.kdAxisArray[0],g=this.kdAxisArray[1],k=a?"distX":"dist";a=-1<f.options.findNearestPointBy.indexOf("y")?2:1;this.kdTree||this.buildingKdTree||this.buildKDTree(c);if(this.kdTree)return d(b,this.kdTree,
    	a,a)}pointPlacementToXValue(){const {options:{pointPlacement:b,pointRange:a},xAxis:c}=this;let d=b;"between"===d&&(d=c.reversed?-.5:.5);return T(d)?d*(a||c.pointRange):0}isPointInside(b){const {chart:a,xAxis:c,yAxis:d}=this;return "undefined"!==typeof b.plotY&&"undefined"!==typeof b.plotX&&0<=b.plotY&&b.plotY<=(d?d.len:a.plotHeight)&&0<=b.plotX&&b.plotX<=(c?c.len:a.plotWidth)}drawTracker(){const b=this,a=b.options,c=a.trackByArea,d=[].concat(c?b.areaPath:b.graphPath),f=b.chart,e=f.pointer,k=f.renderer,
    	l=f.options.tooltip.snap,m=b.tracker,q=function(c){if(a.enableMouseTracking&&f.hoverSeries!==b)b.onMouseOver();},p="rgba(192,192,192,"+(g?.0001:.002)+")";m?m.attr({d}):b.graph&&(b.tracker=k.path(d).attr({visibility:b.visible?"inherit":"hidden",zIndex:2}).addClass(c?"highcharts-tracker-area":"highcharts-tracker-line").add(b.group),f.styledMode||b.tracker.attr({"stroke-linecap":"round","stroke-linejoin":"round",stroke:p,fill:c?p:"none","stroke-width":b.graph.strokeWidth()+(c?0:2*l)}),[b.tracker,b.markerGroup,
    	b.dataLabelsGroup].forEach(function(b){if(b&&(b.addClass("highcharts-tracker").on("mouseover",q).on("mouseout",function(b){e.onTrackerMouseOut(b);}),a.cursor&&!f.styledMode&&b.css({cursor:a.cursor}),h))b.on("touchstart",q);}));n(this,"afterDrawTracker");}addPoint(b,a,c,d,f){const e=this.options,g=this.data,k=this.chart;var h=this.xAxis;h=h&&h.hasNames&&h.names;const l=e.data,m=this.xData;let q,p;a=A(a,!0);const r={series:this};this.pointClass.prototype.applyOptions.apply(r,[b]);const t=r.x;p=m.length;
    	if(this.requireSorting&&t<m[p-1])for(q=!0;p&&m[p-1]>t;)p--;this.updateParallelArrays(r,"splice",[p,0,0]);this.updateParallelArrays(r,p);h&&r.name&&(h[t]=r.name);l.splice(p,0,b);if(q||this.processedData)this.data.splice(p,0,null),this.processData();"point"===e.legendType&&this.generatePoints();c&&(g[0]&&g[0].remove?g[0].remove(!1):(g.shift(),this.updateParallelArrays(r,"shift"),l.shift()));!1!==f&&n(this,"addPoint",{point:r});this.isDirtyData=this.isDirty=!0;a&&k.redraw(d);}removePoint(b,a,c){const d=
    	this,f=d.data,e=f[b],g=d.points,k=d.chart,h=function(){g&&g.length===f.length&&g.splice(b,1);f.splice(b,1);d.options.data.splice(b,1);d.updateParallelArrays(e||{series:d},"splice",[b,1]);e&&e.destroy();d.isDirty=!0;d.isDirtyData=!0;a&&k.redraw();};p(c,k);a=A(a,!0);e?e.firePointEvent("remove",null,h):h();}remove(b,a,c,d){function f(){e.destroy(d);g.isDirtyLegend=g.isDirtyBox=!0;g.linkSeries(d);A(b,!0)&&g.redraw(a);}const e=this,g=e.chart;!1!==c?n(e,"remove",null,f):f();}update(a,c){a=q(a,this.userOptions);
    	n(this,"update",{options:a});const d=this,e=d.chart;var g=d.userOptions;const k=d.initialType||d.type;var h=e.options.plotOptions;const l=w[k].prototype;var m=d.finishedAnimating&&{animation:!1};const p={};let r,t=["colorIndex","eventOptions","navigatorSeries","symbolIndex","baseSeries"],v=a.type||g.type||e.options.chart.type;const u=!(this.hasDerivedData||v&&v!==this.type||"undefined"!==typeof a.pointStart||"undefined"!==typeof a.pointInterval||"undefined"!==typeof a.relativeXValue||a.joinBy||a.mapData||
    	d.hasOptionChanged("dataGrouping")||d.hasOptionChanged("pointStart")||d.hasOptionChanged("pointInterval")||d.hasOptionChanged("pointIntervalUnit")||d.hasOptionChanged("keys"));v=v||k;u&&(t.push("data","isDirtyData","points","processedData","processedXData","processedYData","xIncrement","cropped","_hasPointMarkers","_hasPointLabels","clips","nodes","layout","level","mapMap","mapData","minY","maxY","minX","maxX"),!1!==a.visible&&t.push("area","graph"),d.parallelArrays.forEach(function(b){t.push(b+"Data");}),
    	a.data&&(a.dataSorting&&f(d.options.dataSorting,a.dataSorting),this.setData(a.data,!1)));a=V(g,m,{index:"undefined"===typeof g.index?d.index:g.index,pointStart:A(h&&h.series&&h.series.pointStart,g.pointStart,d.xData[0])},!u&&{data:d.options.data},a);u&&a.data&&(a.data=d.options.data);t=["group","markerGroup","dataLabelsGroup","transformGroup"].concat(t);t.forEach(function(b){t[b]=d[b];delete d[b];});h=!1;if(w[v]){if(h=v!==d.type,d.remove(!1,!1,!1,!0),h)if(Object.setPrototypeOf)Object.setPrototypeOf(d,
    	w[v].prototype);else {m=Object.hasOwnProperty.call(d,"hcEvents")&&d.hcEvents;for(r in l)d[r]=void 0;f(d,w[v].prototype);m?d.hcEvents=m:delete d.hcEvents;}}else b(17,!0,e,{missingModuleFor:v});t.forEach(function(b){d[b]=t[b];});d.init(e,a);if(u&&this.points){a=d.options;if(!1===a.visible)p.graphic=1,p.dataLabel=1;else if(!d._hasPointLabels){const {marker:b,dataLabels:c}=a;g=g.marker||{};!b||!1!==b.enabled&&g.symbol===b.symbol&&g.height===b.height&&g.width===b.width||(p.graphic=1);c&&!1===c.enabled&&(p.dataLabel=
    	1);}for(const b of this.points)b&&b.series&&(b.resolveColor(),Object.keys(p).length&&b.destroyElements(p),!1===a.showInLegend&&b.legendItem&&e.legend.destroyItem(b));}d.initialType=k;e.linkSeries();h&&d.linkedSeries.length&&(d.isDirtyData=!0);n(this,"afterUpdate");A(c,!0)&&e.redraw(u?void 0:!1);}setName(b){this.name=this.options.name=this.userOptions.name=b;this.chart.isDirtyLegend=!0;}hasOptionChanged(b){const a=this.options[b],c=this.chart.options.plotOptions,d=this.userOptions[b];return d?a!==d:a!==
    	A(c&&c[this.type]&&c[this.type][b],c&&c.series&&c.series[b],a)}onMouseOver(){const b=this.chart,a=b.hoverSeries;b.pointer.setHoverChartIndex();if(a&&a!==this)a.onMouseOut();this.options.events.mouseOver&&n(this,"mouseOver");this.setState("hover");b.hoverSeries=this;}onMouseOut(){const b=this.options,a=this.chart,c=a.tooltip,d=a.hoverPoint;a.hoverSeries=null;if(d)d.onMouseOut();this&&b.events.mouseOut&&n(this,"mouseOut");!c||this.stickyTracking||c.shared&&!this.noSharedTooltip||c.hide();a.series.forEach(function(b){b.setState("",
    	!0);});}setState(b,a){const c=this;var d=c.options;const f=c.graph,e=d.inactiveOtherPoints,g=d.states,k=A(g[b||"normal"]&&g[b||"normal"].animation,c.chart.options.chart.animation);let h=d.lineWidth,n=0,l=d.opacity;b=b||"";if(c.state!==b&&([c.group,c.markerGroup,c.dataLabelsGroup].forEach(function(a){a&&(c.state&&a.removeClass("highcharts-series-"+c.state),b&&a.addClass("highcharts-series-"+b));}),c.state=b,!c.chart.styledMode)){if(g[b]&&!1===g[b].enabled)return;b&&(h=g[b].lineWidth||h+(g[b].lineWidthPlus||
    	0),l=A(g[b].opacity,l));if(f&&!f.dashstyle&&T(h))for(d={"stroke-width":h},f.animate(d,k);c["zone-graph-"+n];)c["zone-graph-"+n].animate(d,k),n+=1;e||[c.group,c.markerGroup,c.dataLabelsGroup,c.labelBySeries].forEach(function(b){b&&b.animate({opacity:l},k);});}a&&e&&c.points&&c.setAllPointsToState(b||void 0);}setAllPointsToState(b){this.points.forEach(function(a){a.setState&&a.setState(b);});}setVisible(b,a){const c=this,d=c.chart,f=d.options.chart.ignoreHiddenSeries,e=c.visible,g=(c.visible=b=c.options.visible=
    	c.userOptions.visible="undefined"===typeof b?!e:b)?"show":"hide";["group","dataLabelsGroup","markerGroup","tracker","tt"].forEach(function(b){if(c[b])c[b][g]();});if(d.hoverSeries===c||(d.hoverPoint&&d.hoverPoint.series)===c)c.onMouseOut();c.legendItem&&d.legend.colorizeItem(c,b);c.isDirty=!0;c.options.stacking&&d.series.forEach(function(b){b.options.stacking&&b.visible&&(b.isDirty=!0);});c.linkedSeries.forEach(function(a){a.setVisible(b,!1);});f&&(d.isDirtyBox=!0);n(c,g);!1!==a&&d.redraw();}show(){this.setVisible(!0);}hide(){this.setVisible(!1);}select(b){this.selected=
    	b=this.options.selected="undefined"===typeof b?!this.selected:b;this.checkbox&&(this.checkbox.checked=b);n(this,b?"select":"unselect");}shouldShowTooltip(b,a,c={}){c.series=this;c.visiblePlotOnly=!0;return this.chart.isInsidePlot(b,a,c)}drawLegendSymbol(b,a){var c;null===(c=C[this.options.legendSymbol||"rectangle"])||void 0===c?void 0:c.call(this,b,a);}}aa.defaultOptions=H;aa.types=B.seriesTypes;aa.registerType=B.registerSeriesType;f(aa.prototype,{axisTypes:["xAxis","yAxis"],coll:"series",colorCounter:0,
    	cropShoulder:1,directTouch:!1,isCartesian:!0,kdAxisArray:["clientX","plotY"],parallelArrays:["x","y"],pointClass:z,requireSorting:!0,sorted:!0});B.series=aa;return aa});M(a,"Core/Chart/Chart.js",[a["Core/Animation/AnimationUtilities.js"],a["Core/Axis/Axis.js"],a["Core/Defaults.js"],a["Core/Templating.js"],a["Core/Foundation.js"],a["Core/Globals.js"],a["Core/Renderer/RendererRegistry.js"],a["Core/Series/Series.js"],a["Core/Series/SeriesRegistry.js"],a["Core/Renderer/SVG/SVGRenderer.js"],a["Core/Time.js"],
    	a["Core/Utilities.js"],a["Core/Renderer/HTML/AST.js"]],function(a,y,I,L,C,z,H,B,u,v,l,p,t){const {animate:m,animObject:h,setAnimation:g}=a,{defaultOptions:e,defaultTime:w}=I,{numberFormat:x}=L,{registerEventOptions:F}=C,{charts:d,doc:k,marginNames:r,svg:q,win:G}=z,{seriesTypes:b}=u,{addEvent:f,attr:c,createElement:n,css:P,defined:D,diffObjects:K,discardElement:X,erase:T,error:Z,extend:V,find:Y,fireEvent:A,getStyle:M,isArray:ia,isNumber:ba,isObject:aa,isString:J,merge:N,objectEach:O,pick:S,pInt:W,
    	relativeLength:ha,removeEvent:da,splat:fa,syncTimeout:ka,uniqueKey:ca}=p;class ea{static chart(b,a,c){return new ea(b,a,c)}constructor(b,a,c){this.series=this.renderTo=this.renderer=this.pointer=this.pointCount=this.plotWidth=this.plotTop=this.plotLeft=this.plotHeight=this.plotBox=this.options=this.numberFormatter=this.margin=this.labelCollectors=this.isResizing=this.index=this.eventOptions=this.container=this.colorCounter=this.clipBox=this.chartWidth=this.chartHeight=this.bounds=this.axisOffset=
    	this.axes=void 0;this.sharedClips={};this.zooming=this.yAxis=this.xAxis=this.userOptions=this.titleOffset=this.time=this.symbolCounter=this.spacingBox=this.spacing=void 0;this.getArgs(b,a,c);}getArgs(b,a,c){J(b)||b.nodeName?(this.renderTo=b,this.init(a,c)):this.init(b,a);}setZoomOptions(){const b=this.options.chart,a=b.zooming;this.zooming=Object.assign(Object.assign({},a),{type:S(b.zoomType,a.type),key:S(b.zoomKey,a.key),pinchType:S(b.pinchType,a.pinchType),singleTouch:S(b.zoomBySingleTouch,a.singleTouch,
    	!1),resetButton:N(a.resetButton,b.resetZoomButton)});}init(b,a){A(this,"init",{args:arguments},function(){const c=N(e,b),f=c.chart;this.userOptions=V({},b);this.margin=[];this.spacing=[];this.bounds={h:{},v:{}};this.labelCollectors=[];this.callback=a;this.isResizing=0;this.options=c;this.axes=[];this.series=[];this.time=b.time&&Object.keys(b.time).length?new l(b.time):z.time;this.numberFormatter=f.numberFormatter||x;this.styledMode=f.styledMode;this.hasCartesianSeries=f.showAxes;this.index=d.length;
    	d.push(this);z.chartCount++;F(this,f);this.xAxis=[];this.yAxis=[];this.pointCount=this.colorCounter=this.symbolCounter=0;this.setZoomOptions();A(this,"afterInit");this.firstRender();});}initSeries(a){var c=this.options.chart;c=a.type||c.type;const d=b[c];d||Z(17,!0,this,{missingModuleFor:c});c=new d;"function"===typeof c.init&&c.init(this,a);return c}setSeriesData(){this.getSeriesOrderByLinks().forEach(function(b){b.points||b.data||!b.enabledDataSorting||b.setData(b.options.data,!1);});}getSeriesOrderByLinks(){return this.series.concat().sort(function(b,
    	a){return b.linkedSeries.length||a.linkedSeries.length?a.linkedSeries.length-b.linkedSeries.length:0})}orderItems(b,a=0){const c=this[b],d=this.options[b]=fa(this.options[b]).slice();b=this.userOptions[b]=this.userOptions[b]?fa(this.userOptions[b]).slice():[];this.hasRendered&&(d.splice(a),b.splice(a));if(c)for(let f=a,e=c.length;f<e;++f)if(a=c[f])a.index=f,a instanceof B&&(a.name=a.getName()),a.options.isInternal||(d[f]=a.options,b[f]=a.userOptions);}isInsidePlot(b,a,c={}){const {inverted:d,plotBox:f,
    	plotLeft:e,plotTop:g,scrollablePlotBox:k}=this;var h=0;let n=0;c.visiblePlotOnly&&this.scrollingContainer&&({scrollLeft:h,scrollTop:n}=this.scrollingContainer);const l=c.series,m=c.visiblePlotOnly&&k||f;var q=c.inverted?a:b;a=c.inverted?b:a;b={x:q,y:a,isInsidePlot:!0,options:c};if(!c.ignoreX){const a=l&&(d&&!this.polar?l.yAxis:l.xAxis)||{pos:e,len:Infinity};q=c.paneCoordinates?a.pos+q:e+q;q>=Math.max(h+e,a.pos)&&q<=Math.min(h+e+m.width,a.pos+a.len)||(b.isInsidePlot=!1);}!c.ignoreY&&b.isInsidePlot&&
    	(h=!d&&c.axis&&!c.axis.isXAxis&&c.axis||l&&(d?l.xAxis:l.yAxis)||{pos:g,len:Infinity},c=c.paneCoordinates?h.pos+a:g+a,c>=Math.max(n+g,h.pos)&&c<=Math.min(n+g+m.height,h.pos+h.len)||(b.isInsidePlot=!1));A(this,"afterIsInsidePlot",b);return b.isInsidePlot}redraw(b){A(this,"beforeRedraw");const a=this.hasCartesianSeries?this.axes:this.colorAxis||[],c=this.series,d=this.pointer,f=this.legend,e=this.userOptions.legend,k=this.renderer,h=k.isHidden(),n=[];let l,m,q=this.isDirtyBox,p=this.isDirtyLegend,r;
    	k.rootFontSize=k.boxWrapper.getStyle("font-size");this.setResponsive&&this.setResponsive(!1);g(this.hasRendered?b:!1,this);h&&this.temporaryDisplay();this.layOutTitles(!1);for(b=c.length;b--;)if(r=c[b],r.options.stacking||r.options.centerInCategory)if(m=!0,r.isDirty){l=!0;break}if(l)for(b=c.length;b--;)r=c[b],r.options.stacking&&(r.isDirty=!0);c.forEach(function(b){b.isDirty&&("point"===b.options.legendType?("function"===typeof b.updateTotals&&b.updateTotals(),p=!0):e&&(e.labelFormatter||e.labelFormat)&&
    	(p=!0));b.isDirtyData&&A(b,"updatedData");});p&&f&&f.options.enabled&&(f.render(),this.isDirtyLegend=!1);m&&this.getStacks();a.forEach(function(b){b.updateNames();b.setScale();});this.getMargins();a.forEach(function(b){b.isDirty&&(q=!0);});a.forEach(function(b){const a=b.min+","+b.max;b.extKey!==a&&(b.extKey=a,n.push(function(){A(b,"afterSetExtremes",V(b.eventArgs,b.getExtremes()));delete b.eventArgs;}));(q||m)&&b.redraw();});q&&this.drawChartBox();A(this,"predraw");c.forEach(function(b){(q||b.isDirty)&&
    	b.visible&&b.redraw();b.isDirtyData=!1;});d&&d.reset(!0);k.draw();A(this,"redraw");A(this,"render");h&&this.temporaryDisplay(!0);n.forEach(function(b){b.call();});}get(b){function a(a){return a.id===b||a.options&&a.options.id===b}const c=this.series;let d=Y(this.axes,a)||Y(this.series,a);for(let b=0;!d&&b<c.length;b++)d=Y(c[b].points||[],a);return d}getAxes(){const b=this.options;A(this,"getAxes");for(const a of ["xAxis","yAxis"]){const c=b[a]=fa(b[a]||{});for(const b of c)new y(this,b,a);}A(this,"afterGetAxes");}getSelectedPoints(){return this.series.reduce((b,
    	a)=>{a.getPointsCollection().forEach(a=>{S(a.selectedStaging,a.selected)&&b.push(a);});return b},[])}getSelectedSeries(){return this.series.filter(function(b){return b.selected})}setTitle(b,a,c){this.applyDescription("title",b);this.applyDescription("subtitle",a);this.applyDescription("caption",void 0);this.layOutTitles(c);}applyDescription(b,a){const c=this,d=this.options[b]=N(this.options[b],a);let f=this[b];f&&a&&(this[b]=f=f.destroy());d&&!f&&(f=this.renderer.text(d.text,0,0,d.useHTML).attr({align:d.align,
    	"class":"highcharts-"+b,zIndex:d.zIndex||4}).add(),f.update=function(a,d){c.applyDescription(b,a);c.layOutTitles(d);},this.styledMode||f.css(V("title"===b?{fontSize:this.options.isStock?"1em":"1.2em"}:{},d.style)),this[b]=f);}layOutTitles(b=!0){const a=[0,0,0],c=this.renderer,d=this.spacingBox;["title","subtitle","caption"].forEach(function(b){const f=this[b],e=this.options[b],g=e.verticalAlign||"top";b="title"===b?"top"===g?-3:0:"top"===g?a[0]+2:0;if(f){f.css({width:(e.width||d.width+(e.widthAdjust||
    	0))+"px"});const k=c.fontMetrics(f).b,h=Math.round(f.getBBox(e.useHTML).height);f.align(V({y:"bottom"===g?k:b+k,height:h},e),!1,"spacingBox");e.floating||("top"===g?a[0]=Math.ceil(a[0]+h):"bottom"===g&&(a[2]=Math.ceil(a[2]+h)));}},this);a[0]&&"top"===(this.options.title.verticalAlign||"top")&&(a[0]+=this.options.title.margin);a[2]&&"bottom"===this.options.caption.verticalAlign&&(a[2]+=this.options.caption.margin);const f=!this.titleOffset||this.titleOffset.join(",")!==a.join(",");this.titleOffset=
    	a;A(this,"afterLayOutTitles");!this.isDirtyBox&&f&&(this.isDirtyBox=this.isDirtyLegend=f,this.hasRendered&&b&&this.isDirtyBox&&this.redraw());}getContainerBox(){return {width:M(this.renderTo,"width",!0)||0,height:M(this.renderTo,"height",!0)||0}}getChartSize(){var b=this.options.chart;const a=b.width;b=b.height;const c=this.getContainerBox();this.chartWidth=Math.max(0,a||c.width||600);this.chartHeight=Math.max(0,ha(b,this.chartWidth)||(1<c.height?c.height:400));this.containerBox=c;}temporaryDisplay(b){let a=
    	this.renderTo;if(b)for(;a&&a.style;)a.hcOrigStyle&&(P(a,a.hcOrigStyle),delete a.hcOrigStyle),a.hcOrigDetached&&(k.body.removeChild(a),a.hcOrigDetached=!1),a=a.parentNode;else for(;a&&a.style;){k.body.contains(a)||a.parentNode||(a.hcOrigDetached=!0,k.body.appendChild(a));if("none"===M(a,"display",!1)||a.hcOricDetached)a.hcOrigStyle={display:a.style.display,height:a.style.height,overflow:a.style.overflow},b={display:"block",overflow:"hidden"},a!==this.renderTo&&(b.height=0),P(a,b),a.offsetWidth||a.style.setProperty("display",
    	"block","important");a=a.parentNode;if(a===k.body)break}}setClassName(b){this.container.className="highcharts-container "+(b||"");}getContainer(){const b=this.options,a=b.chart;var f=ca();let e,h=this.renderTo;h||(this.renderTo=h=a.renderTo);J(h)&&(this.renderTo=h=k.getElementById(h));h||Z(13,!0,this);var l=W(c(h,"data-highcharts-chart"));ba(l)&&d[l]&&d[l].hasRendered&&d[l].destroy();c(h,"data-highcharts-chart",this.index);h.innerHTML=t.emptyHTML;a.skipClone||h.offsetWidth||this.temporaryDisplay();
    	this.getChartSize();l=this.chartWidth;const m=this.chartHeight;P(h,{overflow:"hidden"});this.styledMode||(e=V({position:"relative",overflow:"hidden",width:l+"px",height:m+"px",textAlign:"left",lineHeight:"normal",zIndex:0,"-webkit-tap-highlight-color":"rgba(0,0,0,0)",userSelect:"none","touch-action":"manipulation",outline:"none"},a.style||{}));this.container=f=n("div",{id:f},e,h);this._cursor=f.style.cursor;this.renderer=new (a.renderer||!q?H.getRendererType(a.renderer):v)(f,l,m,void 0,a.forExport,
    	b.exporting&&b.exporting.allowHTML,this.styledMode);this.containerBox=this.getContainerBox();g(void 0,this);this.setClassName(a.className);if(this.styledMode)for(const a in b.defs)this.renderer.definition(b.defs[a]);else this.renderer.setStyle(a.style);this.renderer.chartIndex=this.index;A(this,"afterGetContainer");}getMargins(b){const {spacing:a,margin:c,titleOffset:d}=this;this.resetMargins();d[0]&&!D(c[0])&&(this.plotTop=Math.max(this.plotTop,d[0]+a[0]));d[2]&&!D(c[2])&&(this.marginBottom=Math.max(this.marginBottom,
    	d[2]+a[2]));this.legend&&this.legend.display&&this.legend.adjustMargins(c,a);A(this,"getMargins");b||this.getAxisMargins();}getAxisMargins(){const b=this,a=b.axisOffset=[0,0,0,0],c=b.colorAxis,d=b.margin,f=function(b){b.forEach(function(b){b.visible&&b.getOffset();});};b.hasCartesianSeries?f(b.axes):c&&c.length&&f(c);r.forEach(function(c,f){D(d[f])||(b[c]+=a[f]);});b.setChartSize();}getOptions(){return K(this.userOptions,e)}reflow(b){const a=this;var c=a.options.chart;c=D(c.width)&&D(c.height);const d=
    	a.containerBox,f=a.getContainerBox();delete a.pointer.chartPosition;if(!c&&!a.isPrinting&&d&&f.width){if(f.width!==d.width||f.height!==d.height)p.clearTimeout(a.reflowTimeout),a.reflowTimeout=ka(function(){a.container&&a.setSize(void 0,void 0,!1);},b?100:0);a.containerBox=f;}}setReflow(){const b=this;var a=a=>{var c;(null===(c=b.options)||void 0===c?0:c.chart.reflow)&&b.hasLoaded&&b.reflow(a);};"function"===typeof ResizeObserver?(new ResizeObserver(a)).observe(b.renderTo):(a=f(G,"resize",a),f(this,"destroy",
    	a));}setSize(b,a,c){const d=this,f=d.renderer;d.isResizing+=1;g(c,d);c=f.globalAnimation;d.oldChartHeight=d.chartHeight;d.oldChartWidth=d.chartWidth;"undefined"!==typeof b&&(d.options.chart.width=b);"undefined"!==typeof a&&(d.options.chart.height=a);d.getChartSize();d.styledMode||(c?m:P)(d.container,{width:d.chartWidth+"px",height:d.chartHeight+"px"},c);d.setChartSize(!0);f.setSize(d.chartWidth,d.chartHeight,c);d.axes.forEach(function(b){b.isDirty=!0;b.setScale();});d.isDirtyLegend=!0;d.isDirtyBox=
    	!0;d.layOutTitles();d.getMargins();d.redraw(c);d.oldChartHeight=null;A(d,"resize");ka(function(){d&&A(d,"endResize",null,function(){--d.isResizing;});},h(c).duration);}setChartSize(b){var a=this.inverted;const c=this.renderer;var d=this.chartWidth,f=this.chartHeight;const e=this.options.chart,g=this.spacing,k=this.clipOffset;let h,n,l,m;this.plotLeft=h=Math.round(this.plotLeft);this.plotTop=n=Math.round(this.plotTop);this.plotWidth=l=Math.max(0,Math.round(d-h-this.marginRight));this.plotHeight=m=Math.max(0,
    	Math.round(f-n-this.marginBottom));this.plotSizeX=a?m:l;this.plotSizeY=a?l:m;this.plotBorderWidth=e.plotBorderWidth||0;this.spacingBox=c.spacingBox={x:g[3],y:g[0],width:d-g[3]-g[1],height:f-g[0]-g[2]};this.plotBox=c.plotBox={x:h,y:n,width:l,height:m};a=2*Math.floor(this.plotBorderWidth/2);d=Math.ceil(Math.max(a,k[3])/2);f=Math.ceil(Math.max(a,k[0])/2);this.clipBox={x:d,y:f,width:Math.floor(this.plotSizeX-Math.max(a,k[1])/2-d),height:Math.max(0,Math.floor(this.plotSizeY-Math.max(a,k[2])/2-f))};b||
    	(this.axes.forEach(function(b){b.setAxisSize();b.setAxisTranslation();}),c.alignElements());A(this,"afterSetChartSize",{skipAxes:b});}resetMargins(){A(this,"resetMargins");const b=this,a=b.options.chart;["margin","spacing"].forEach(function(c){const d=a[c],f=aa(d)?d:[d,d,d,d];["Top","Right","Bottom","Left"].forEach(function(d,e){b[c][e]=S(a[c+d],f[e]);});});r.forEach(function(a,c){b[a]=S(b.margin[c],b.spacing[c]);});b.axisOffset=[0,0,0,0];b.clipOffset=[0,0,0,0];}drawChartBox(){const b=this.options.chart,
    	a=this.renderer,c=this.chartWidth,d=this.chartHeight,f=this.styledMode,e=this.plotBGImage;var g=b.backgroundColor;const k=b.plotBackgroundColor,h=b.plotBackgroundImage,n=this.plotLeft,l=this.plotTop,m=this.plotWidth,q=this.plotHeight,p=this.plotBox,r=this.clipRect,t=this.clipBox;let w=this.chartBackground,v=this.plotBackground,u=this.plotBorder,x,D,E="animate";w||(this.chartBackground=w=a.rect().addClass("highcharts-background").add(),E="attr");if(f)x=D=w.strokeWidth();else {x=b.borderWidth||0;D=x+
    	(b.shadow?8:0);g={fill:g||"none"};if(x||w["stroke-width"])g.stroke=b.borderColor,g["stroke-width"]=x;w.attr(g).shadow(b.shadow);}w[E]({x:D/2,y:D/2,width:c-D-x%2,height:d-D-x%2,r:b.borderRadius});E="animate";v||(E="attr",this.plotBackground=v=a.rect().addClass("highcharts-plot-background").add());v[E](p);f||(v.attr({fill:k||"none"}).shadow(b.plotShadow),h&&(e?(h!==e.attr("href")&&e.attr("href",h),e.animate(p)):this.plotBGImage=a.image(h,n,l,m,q).add()));r?r.animate({width:t.width,height:t.height}):
    	this.clipRect=a.clipRect(t);E="animate";u||(E="attr",this.plotBorder=u=a.rect().addClass("highcharts-plot-border").attr({zIndex:1}).add());f||u.attr({stroke:b.plotBorderColor,"stroke-width":b.plotBorderWidth||0,fill:"none"});u[E](u.crisp({x:n,y:l,width:m,height:q},-u.strokeWidth()));this.isDirtyBox=!1;A(this,"afterDrawChartBox");}propFromSeries(){const a=this,c=a.options.chart,d=a.options.series;let f,e,g;["inverted","angular","polar"].forEach(function(k){e=b[c.type];g=c[k]||e&&e.prototype[k];for(f=
    	d&&d.length;!g&&f--;)(e=b[d[f].type])&&e.prototype[k]&&(g=!0);a[k]=g;});}linkSeries(b){const a=this,c=a.series;c.forEach(function(b){b.linkedSeries.length=0;});c.forEach(function(b){let c=b.options.linkedTo;J(c)&&(c=":previous"===c?a.series[b.index-1]:a.get(c))&&c.linkedParent!==b&&(c.linkedSeries.push(b),b.linkedParent=c,c.enabledDataSorting&&b.setDataSortingOptions(),b.visible=S(b.options.visible,c.options.visible,b.visible));});A(this,"afterLinkSeries",{isUpdating:b});}renderSeries(){this.series.forEach(function(b){b.translate();
    	b.render();});}render(){const b=this.axes,a=this.colorAxis,c=this.renderer,d=function(b){b.forEach(function(b){b.visible&&b.render();});};let f=0;this.setTitle();A(this,"beforeMargins");this.getStacks&&this.getStacks();this.getMargins(!0);this.setChartSize();const e=this.plotWidth;b.some(function(b){if(b.horiz&&b.visible&&b.options.labels.enabled&&b.series.length)return f=21,!0});const g=this.plotHeight=Math.max(this.plotHeight-f,0);b.forEach(function(b){b.setScale();});this.getAxisMargins();const k=1.1<
    	e/this.plotWidth,h=1.05<g/this.plotHeight;if(k||h)b.forEach(function(b){(b.horiz&&k||!b.horiz&&h)&&b.setTickInterval(!0);}),this.getMargins();this.drawChartBox();this.hasCartesianSeries?d(b):a&&a.length&&d(a);this.seriesGroup||(this.seriesGroup=c.g("series-group").attr({zIndex:3}).shadow(this.options.chart.seriesGroupShadow).add());this.renderSeries();this.addCredits();this.setResponsive&&this.setResponsive();this.hasRendered=!0;}addCredits(b){const a=this,c=N(!0,this.options.credits,b);c.enabled&&
    	!this.credits&&(this.credits=this.renderer.text(c.text+(this.mapCredits||""),0,0).addClass("highcharts-credits").on("click",function(){c.href&&(G.location.href=c.href);}).attr({align:c.position.align,zIndex:8}),a.styledMode||this.credits.css(c.style),this.credits.add().align(c.position),this.credits.update=function(b){a.credits=a.credits.destroy();a.addCredits(b);});}destroy(){const b=this,a=b.axes,c=b.series,f=b.container,e=f&&f.parentNode;let g;A(b,"destroy");b.renderer.forExport?T(d,b):d[b.index]=
    	void 0;z.chartCount--;b.renderTo.removeAttribute("data-highcharts-chart");da(b);for(g=a.length;g--;)a[g]=a[g].destroy();this.scroller&&this.scroller.destroy&&this.scroller.destroy();for(g=c.length;g--;)c[g]=c[g].destroy();"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function(a){const c=b[a];c&&c.destroy&&(b[a]=c.destroy());});f&&(f.innerHTML=t.emptyHTML,da(f),e&&X(f));
    	O(b,function(a,c){delete b[c];});}firstRender(){const b=this,a=b.options;b.getContainer();b.resetMargins();b.setChartSize();b.propFromSeries();b.getAxes();const c=ia(a.series)?a.series:[];a.series=[];c.forEach(function(a){b.initSeries(a);});b.linkSeries();b.setSeriesData();A(b,"beforeRender");b.render();b.pointer.getChartPosition();if(!b.renderer.imgCount&&!b.hasLoaded)b.onload();b.temporaryDisplay(!0);}onload(){this.callbacks.concat([this.callback]).forEach(function(b){b&&"undefined"!==typeof this.index&&
    	b.apply(this,[this]);},this);A(this,"load");A(this,"render");D(this.index)&&this.setReflow();this.warnIfA11yModuleNotLoaded();this.hasLoaded=!0;}warnIfA11yModuleNotLoaded(){const {options:b,title:a}=this;b&&!this.accessibility&&(this.renderer.boxWrapper.attr({role:"img","aria-label":(a&&a.element.textContent||"").replace(/</g,"&lt;")}),b.accessibility&&!1===b.accessibility.enabled||Z('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.',
    	!1,this));}addSeries(b,a,c){const d=this;let f;b&&(a=S(a,!0),A(d,"addSeries",{options:b},function(){f=d.initSeries(b);d.isDirtyLegend=!0;d.linkSeries();f.enabledDataSorting&&f.setData(b.data,!1);A(d,"afterAddSeries",{series:f});a&&d.redraw(c);}));return f}addAxis(b,a,c,d){return this.createAxis(a?"xAxis":"yAxis",{axis:b,redraw:c,animation:d})}addColorAxis(b,a,c){return this.createAxis("colorAxis",{axis:b,redraw:a,animation:c})}createAxis(b,a){b=new y(this,a.axis,b);S(a.redraw,!0)&&this.redraw(a.animation);
    	return b}showLoading(b){const a=this,c=a.options,d=c.loading,e=function(){g&&P(g,{left:a.plotLeft+"px",top:a.plotTop+"px",width:a.plotWidth+"px",height:a.plotHeight+"px"});};let g=a.loadingDiv,k=a.loadingSpan;g||(a.loadingDiv=g=n("div",{className:"highcharts-loading highcharts-loading-hidden"},null,a.container));k||(a.loadingSpan=k=n("span",{className:"highcharts-loading-inner"},null,g),f(a,"redraw",e));g.className="highcharts-loading";t.setElementHTML(k,S(b,c.lang.loading,""));a.styledMode||(P(g,
    	V(d.style,{zIndex:10})),P(k,d.labelStyle),a.loadingShown||(P(g,{opacity:0,display:""}),m(g,{opacity:d.style.opacity||.5},{duration:d.showDuration||0})));a.loadingShown=!0;e();}hideLoading(){const b=this.options,a=this.loadingDiv;a&&(a.className="highcharts-loading highcharts-loading-hidden",this.styledMode||m(a,{opacity:0},{duration:b.loading.hideDuration||100,complete:function(){P(a,{display:"none"});}}));this.loadingShown=!1;}update(b,a,c,d){const f=this,e={credits:"addCredits",title:"setTitle",subtitle:"setSubtitle",
    	caption:"setCaption"},g=b.isResponsiveOptions,k=[];let h,n;A(f,"update",{options:b});g||f.setResponsive(!1,!0);b=K(b,f.options);f.userOptions=N(f.userOptions,b);var m=b.chart;if(m){N(!0,f.options.chart,m);this.setZoomOptions();"className"in m&&f.setClassName(m.className);if("inverted"in m||"polar"in m||"type"in m){f.propFromSeries();var q=!0;}"alignTicks"in m&&(q=!0);"events"in m&&F(this,m);O(m,function(b,a){-1!==f.propsRequireUpdateSeries.indexOf("chart."+a)&&(h=!0);-1!==f.propsRequireDirtyBox.indexOf(a)&&
    	(f.isDirtyBox=!0);-1!==f.propsRequireReflow.indexOf(a)&&(g?f.isDirtyBox=!0:n=!0);});!f.styledMode&&m.style&&f.renderer.setStyle(f.options.chart.style||{});}!f.styledMode&&b.colors&&(this.options.colors=b.colors);b.time&&(this.time===w&&(this.time=new l(b.time)),N(!0,f.options.time,b.time));O(b,function(a,c){if(f[c]&&"function"===typeof f[c].update)f[c].update(a,!1);else if("function"===typeof f[e[c]])f[e[c]](a);else "colors"!==c&&-1===f.collectionsWithUpdate.indexOf(c)&&N(!0,f.options[c],b[c]);"chart"!==
    	c&&-1!==f.propsRequireUpdateSeries.indexOf(c)&&(h=!0);});this.collectionsWithUpdate.forEach(function(a){b[a]&&(fa(b[a]).forEach(function(b,d){const e=D(b.id);let g;e&&(g=f.get(b.id));!g&&f[a]&&(g=f[a][S(b.index,d)])&&(e&&D(g.options.id)||g.options.isInternal)&&(g=void 0);g&&g.coll===a&&(g.update(b,!1),c&&(g.touched=!0));!g&&c&&f.collectionsWithInit[a]&&(f.collectionsWithInit[a][0].apply(f,[b].concat(f.collectionsWithInit[a][1]||[]).concat([!1])).touched=!0);}),c&&f[a].forEach(function(b){b.touched||
    	b.options.isInternal?delete b.touched:k.push(b);}));});k.forEach(function(b){b.chart&&b.remove&&b.remove(!1);});q&&f.axes.forEach(function(b){b.update({},!1);});h&&f.getSeriesOrderByLinks().forEach(function(b){b.chart&&b.update({},!1);},this);q=m&&m.width;m=m&&(J(m.height)?ha(m.height,q||f.chartWidth):m.height);n||ba(q)&&q!==f.chartWidth||ba(m)&&m!==f.chartHeight?f.setSize(q,m,d):S(a,!0)&&f.redraw(d);A(f,"afterUpdate",{options:b,redraw:a,animation:d});}setSubtitle(b,a){this.applyDescription("subtitle",
    	b);this.layOutTitles(a);}setCaption(b,a){this.applyDescription("caption",b);this.layOutTitles(a);}showResetZoom(){function b(){a.zoomOut();}const a=this,c=e.lang,d=a.zooming.resetButton,f=d.theme,g="chart"===d.relativeTo||"spacingBox"===d.relativeTo?null:"scrollablePlotBox";A(this,"beforeShowResetZoom",null,function(){a.resetZoomButton=a.renderer.button(c.resetZoom,null,null,b,f).attr({align:d.position.align,title:c.resetZoomTitle}).addClass("highcharts-reset-zoom").add().align(d.position,!1,g);});A(this,
    	"afterShowResetZoom");}zoomOut(){A(this,"selection",{resetSelection:!0},this.zoom);}zoom(b){const a=this,c=a.pointer;let d=!1,f;!b||b.resetSelection?(a.axes.forEach(function(b){f=b.zoom();}),c.initiated=!1):b.xAxis.concat(b.yAxis).forEach(function(b){const e=b.axis;if(c[e.isXAxis?"zoomX":"zoomY"]&&D(c.mouseDownX)&&D(c.mouseDownY)&&a.isInsidePlot(c.mouseDownX-a.plotLeft,c.mouseDownY-a.plotTop,{axis:e})||!D(a.inverted?c.mouseDownX:c.mouseDownY))f=e.zoom(b.min,b.max),e.displayBtn&&(d=!0);});const e=a.resetZoomButton;
    	d&&!e?a.showResetZoom():!d&&aa(e)&&(a.resetZoomButton=e.destroy());f&&a.redraw(S(a.options.chart.animation,b&&b.animation,100>a.pointCount));}pan(b,a){const c=this,d=c.hoverPoints;a="object"===typeof a?a:{enabled:a,type:"x"};const f=c.options.chart;f&&f.panning&&(f.panning=a);const e=a.type;let g;A(this,"pan",{originalEvent:b},function(){d&&d.forEach(function(b){b.setState();});let a=c.xAxis;"xy"===e?a=a.concat(c.yAxis):"y"===e&&(a=c.yAxis);const f={};a.forEach(function(a){if(a.options.panningEnabled&&
    	!a.options.isInternal){var d=a.horiz,k=b[d?"chartX":"chartY"];d=d?"mouseDownX":"mouseDownY";var h=c[d],n=a.minPointOffset||0,l=a.reversed&&!c.inverted||!a.reversed&&c.inverted?-1:1,m=a.getExtremes(),q=a.toValue(h-k,!0)+n*l,p=a.toValue(h+a.len-k,!0)-(n*l||a.isXAxis&&a.pointRangePadding||0),r=p<q;l=a.hasVerticalPanning();h=r?p:q;q=r?q:p;var t=a.panningState;!l||a.isXAxis||t&&!t.isDirty||a.series.forEach(function(b){var a=b.getProcessedData(!0);a=b.getExtremes(a.yData,!0);t||(t={startMin:Number.MAX_VALUE,
    	startMax:-Number.MAX_VALUE});ba(a.dataMin)&&ba(a.dataMax)&&(t.startMin=Math.min(S(b.options.threshold,Infinity),a.dataMin,t.startMin),t.startMax=Math.max(S(b.options.threshold,-Infinity),a.dataMax,t.startMax));});l=Math.min(S(t&&t.startMin,m.dataMin),n?m.min:a.toValue(a.toPixels(m.min)-a.minPixelPadding));p=Math.max(S(t&&t.startMax,m.dataMax),n?m.max:a.toValue(a.toPixels(m.max)+a.minPixelPadding));a.panningState=t;a.isOrdinal||(n=l-h,0<n&&(q+=n,h=l),n=q-p,0<n&&(q=p,h-=n),a.series.length&&h!==m.min&&
    	q!==m.max&&h>=l&&q<=p&&(a.setExtremes(h,q,!1,!1,{trigger:"pan"}),!c.resetZoomButton&&h!==l&&q!==p&&e.match("y")&&(c.showResetZoom(),a.displayBtn=!1),g=!0),f[d]=k);}});O(f,(b,a)=>{c[a]=b;});g&&c.redraw(!1);P(c.container,{cursor:"move"});});}}V(ea.prototype,{callbacks:[],collectionsWithInit:{xAxis:[ea.prototype.addAxis,[!0]],yAxis:[ea.prototype.addAxis,[!1]],series:[ea.prototype.addSeries]},collectionsWithUpdate:["xAxis","yAxis","series"],propsRequireDirtyBox:"backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
    	propsRequireReflow:"margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),propsRequireUpdateSeries:"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")});return ea});M(a,"Extensions/ScrollablePlotArea.js",[a["Core/Animation/AnimationUtilities.js"],a["Core/Axis/Axis.js"],a["Core/Chart/Chart.js"],a["Core/Series/Series.js"],a["Core/Renderer/RendererRegistry.js"],a["Core/Utilities.js"]],
    	function(a,y,I,L,C,z){const {stop:x}=a,{addEvent:B,createElement:u,defined:v,merge:l,pick:p}=z;B(I,"afterSetChartSize",function(a){var m=this.options.chart.scrollablePlotArea,h=m&&m.minWidth;m=m&&m.minHeight;let g;if(!this.renderer.forExport){if(h){if(this.scrollablePixelsX=h=Math.max(0,h-this.chartWidth))this.scrollablePlotBox=this.renderer.scrollablePlotBox=l(this.plotBox),this.plotBox.width=this.plotWidth+=h,this.inverted?this.clipBox.height+=h:this.clipBox.width+=h,g={1:{name:"right",value:h}};}else m&&
    	(this.scrollablePixelsY=h=Math.max(0,m-this.chartHeight),v(h)&&(this.scrollablePlotBox=this.renderer.scrollablePlotBox=l(this.plotBox),this.plotBox.height=this.plotHeight+=h,this.inverted?this.clipBox.width+=h:this.clipBox.height+=h,g={2:{name:"bottom",value:h}}));g&&!a.skipAxes&&this.axes.forEach(function(a){g[a.side]?a.getPlotLinePath=function(){let e=g[a.side].name,h=this[e],l;this[e]=h-g[a.side].value;l=y.prototype.getPlotLinePath.apply(this,arguments);this[e]=h;return l}:(a.setAxisSize(),a.setAxisTranslation());});}});
    	B(I,"render",function(){this.scrollablePixelsX||this.scrollablePixelsY?(this.setUpScrolling&&this.setUpScrolling(),this.applyFixed()):this.fixedDiv&&this.applyFixed();});I.prototype.setUpScrolling=function(){const a={WebkitOverflowScrolling:"touch",overflowX:"hidden",overflowY:"hidden"};this.scrollablePixelsX&&(a.overflowX="auto");this.scrollablePixelsY&&(a.overflowY="auto");this.scrollingParent=u("div",{className:"highcharts-scrolling-parent"},{position:"relative"},this.renderTo);this.scrollingContainer=
    	u("div",{className:"highcharts-scrolling"},a,this.scrollingParent);let l;B(this.scrollingContainer,"scroll",()=>{this.pointer&&(delete this.pointer.chartPosition,this.hoverPoint&&(l=this.hoverPoint),this.pointer.runPointActions(void 0,l,!0));});this.innerContainer=u("div",{className:"highcharts-inner-container"},null,this.scrollingContainer);this.innerContainer.appendChild(this.container);this.setUpScrolling=null;};I.prototype.moveFixedElements=function(){let a=this.container,l=this.fixedRenderer,h=
    	".highcharts-breadcrumbs-group .highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "),g;this.scrollablePixelsX&&!this.inverted?g=".highcharts-yaxis":this.scrollablePixelsX&&this.inverted?g=".highcharts-xaxis":this.scrollablePixelsY&&
    	!this.inverted?g=".highcharts-xaxis":this.scrollablePixelsY&&this.inverted&&(g=".highcharts-yaxis");g&&h.push(`${g}:not(.highcharts-radial-axis)`,`${g}-labels:not(.highcharts-radial-axis-labels)`);h.forEach(function(e){[].forEach.call(a.querySelectorAll(e),function(a){(a.namespaceURI===l.SVG_NS?l.box:l.box.parentNode).appendChild(a);a.style.pointerEvents="auto";});});};I.prototype.applyFixed=function(){var a=!this.fixedDiv,l=this.options.chart,h=l.scrollablePlotArea,g=C.getRendererType();a?(this.fixedDiv=
    	u("div",{className:"highcharts-fixed"},{position:"absolute",overflow:"hidden",pointerEvents:"none",zIndex:(l.style&&l.style.zIndex||0)+2,top:0},null,!0),this.scrollingContainer&&this.scrollingContainer.parentNode.insertBefore(this.fixedDiv,this.scrollingContainer),this.renderTo.style.overflow="visible",this.fixedRenderer=l=new g(this.fixedDiv,this.chartWidth,this.chartHeight,this.options.chart.style),this.scrollableMask=l.path().attr({fill:this.options.chart.backgroundColor||"#fff","fill-opacity":p(h.opacity,
    	.85),zIndex:-1}).addClass("highcharts-scrollable-mask").add(),B(this,"afterShowResetZoom",this.moveFixedElements),B(this,"afterApplyDrilldown",this.moveFixedElements),B(this,"afterLayOutTitles",this.moveFixedElements)):this.fixedRenderer.setSize(this.chartWidth,this.chartHeight);if(this.scrollableDirty||a)this.scrollableDirty=!1,this.moveFixedElements();l=this.chartWidth+(this.scrollablePixelsX||0);g=this.chartHeight+(this.scrollablePixelsY||0);x(this.container);this.container.style.width=l+"px";
    	this.container.style.height=g+"px";this.renderer.boxWrapper.attr({width:l,height:g,viewBox:[0,0,l,g].join(" ")});this.chartBackground.attr({width:l,height:g});this.scrollingContainer.style.height=this.chartHeight+"px";a&&(h.scrollPositionX&&(this.scrollingContainer.scrollLeft=this.scrollablePixelsX*h.scrollPositionX),h.scrollPositionY&&(this.scrollingContainer.scrollTop=this.scrollablePixelsY*h.scrollPositionY));g=this.axisOffset;a=this.plotTop-g[0]-1;h=this.plotLeft-g[3]-1;l=this.plotTop+this.plotHeight+
    	g[2]+1;g=this.plotLeft+this.plotWidth+g[1]+1;let e=this.plotLeft+this.plotWidth-(this.scrollablePixelsX||0),w=this.plotTop+this.plotHeight-(this.scrollablePixelsY||0);a=this.scrollablePixelsX?[["M",0,a],["L",this.plotLeft-1,a],["L",this.plotLeft-1,l],["L",0,l],["Z"],["M",e,a],["L",this.chartWidth,a],["L",this.chartWidth,l],["L",e,l],["Z"]]:this.scrollablePixelsY?[["M",h,0],["L",h,this.plotTop-1],["L",g,this.plotTop-1],["L",g,0],["Z"],["M",h,w],["L",h,this.chartHeight],["L",g,this.chartHeight],["L",
    	g,w],["Z"]]:[["M",0,0]];"adjustHeight"!==this.redrawTrigger&&this.scrollableMask.attr({d:a});};B(y,"afterInit",function(){this.chart.scrollableDirty=!0;});B(L,"show",function(){this.chart.scrollableDirty=!0;});});M(a,"Core/Axis/Stacking/StackItem.js",[a["Core/Templating.js"],a["Core/Series/SeriesRegistry.js"],a["Core/Utilities.js"]],function(a,y,I){const {format:x}=a,{series:C}=y,{destroyObjectProperties:z,fireEvent:H,isNumber:B,pick:u}=I;class v{constructor(a,p,t,m,h){const g=a.chart.inverted,e=a.reversed;
    	this.axis=a;a=this.isNegative=!!t!==!!e;this.options=p=p||{};this.x=m;this.cumulative=this.total=null;this.points={};this.hasValidPoints=!1;this.stack=h;this.rightCliff=this.leftCliff=0;this.alignOptions={align:p.align||(g?a?"left":"right":"center"),verticalAlign:p.verticalAlign||(g?"middle":a?"bottom":"top"),y:p.y,x:p.x};this.textAlign=p.textAlign||(g?a?"right":"left":"center");}destroy(){z(this,this.axis);}render(a){const l=this.axis.chart,t=this.options;var m=t.format;m=m?x(m,this,l):t.formatter.call(this);
    	this.label?this.label.attr({text:m,visibility:"hidden"}):(this.label=l.renderer.label(m,null,void 0,t.shape,void 0,void 0,t.useHTML,!1,"stack-labels"),m={r:t.borderRadius||0,text:m,padding:u(t.padding,5),visibility:"hidden"},l.styledMode||(m.fill=t.backgroundColor,m.stroke=t.borderColor,m["stroke-width"]=t.borderWidth,this.label.css(t.style||{})),this.label.attr(m),this.label.added||this.label.add(a));this.label.labelrank=l.plotSizeY;H(this,"afterRender");}setOffset(a,p,t,m,h,g){const {alignOptions:e,
    	axis:l,label:v,options:x,textAlign:d}=this,k=l.chart;t=this.getStackBox({xOffset:a,width:p,boxBottom:t,boxTop:m,defaultX:h,xAxis:g});var {verticalAlign:r}=e;if(v&&t){m=v.getBBox();h=v.padding;g="justify"===u(x.overflow,"justify");e.x=x.x||0;e.y=x.y||0;const {x:a,y:p}=this.adjustStackPosition({labelBox:m,verticalAlign:r,textAlign:d});t.x-=a;t.y-=p;v.align(e,!1,t);(r=k.isInsidePlot(v.alignAttr.x+e.x+a,v.alignAttr.y+e.y+p))||(g=!1);g&&C.prototype.justifyDataLabel.call(l,v,e,v.alignAttr,m,t);v.attr({x:v.alignAttr.x,
    	y:v.alignAttr.y,rotation:x.rotation,rotationOriginX:m.width/2,rotationOriginY:m.height/2});u(!g&&x.crop,!0)&&(r=B(v.x)&&B(v.y)&&k.isInsidePlot(v.x-h+v.width,v.y)&&k.isInsidePlot(v.x+h,v.y));v[r?"show":"hide"]();}H(this,"afterSetOffset",{xOffset:a,width:p});}adjustStackPosition({labelBox:a,verticalAlign:p,textAlign:t}){const l={bottom:0,middle:1,top:2,right:1,center:0,left:-1};return {x:a.width/2+a.width/2*l[t],y:a.height/2*l[p]}}getStackBox(a){var l=this.axis;const t=l.chart,{boxTop:m,defaultX:h,xOffset:g,
    	width:e,boxBottom:w}=a;var v=l.stacking.usePercentage?100:u(m,this.total,0);v=l.toPixels(v);a=a.xAxis||t.xAxis[0];const x=u(h,a.translate(this.x))+g;l=l.toPixels(w||B(l.min)&&l.logarithmic&&l.logarithmic.lin2log(l.min)||0);l=Math.abs(v-l);const d=this.isNegative;return t.inverted?{x:(d?v:v-l)-t.plotLeft,y:a.height-x-e,width:l,height:e}:{x:x+a.transB-t.plotLeft,y:(d?v-l:v)-t.plotTop,width:e,height:l}}}return v});M(a,"Core/Axis/Stacking/StackingAxis.js",[a["Core/Animation/AnimationUtilities.js"],
    	a["Core/Axis/Axis.js"],a["Core/Series/SeriesRegistry.js"],a["Core/Axis/Stacking/StackItem.js"],a["Core/Utilities.js"]],function(a,y,I,L,C){function x(){const b=this,a=b.inverted;b.yAxis.forEach(b=>{b.stacking&&b.stacking.stacks&&b.hasVisibleSeries&&(b.stacking.oldStacks=b.stacking.stacks);});b.series.forEach(c=>{const d=c.xAxis&&c.xAxis.options||{};!c.options.stacking||!0!==c.visible&&!1!==b.options.chart.ignoreHiddenSeries||(c.stackKey=[c.type,q(c.options.stack,""),a?d.top:d.left,a?d.height:d.width].join());});}
    	function H(){const b=this.stacking;if(b){var a=b.stacks;r(a,function(b,c){E(b);a[c]=null;});b&&b.stackTotalGroup&&b.stackTotalGroup.destroy();}}function B(){"yAxis"!==this.coll||this.stacking||(this.stacking=new G(this));}function u(b,a,d,e){!w(b)||b.x!==a||e&&b.stackKey!==e?b={x:a,index:0,key:e,stackKey:e}:b.index++;b.key=[d,a,b.index].join();return b}function v(){const b=this,a=b.stackKey,d=b.yAxis.stacking.stacks,e=b.processedXData,g=b[b.options.stacking+"Stacker"];let k;g&&[a,"-"+a].forEach(a=>{let c=
    	e.length;let f;for(;c--;){var h=e[c];k=b.getStackIndicator(k,h,b.index,a);(f=(h=d[a]&&d[a][h])&&h.points[k.key])&&g.call(b,f,h,c);}});}function l(b,a,d){a=a.total?100/a.total:0;b[0]=e(b[0]*a);b[1]=e(b[1]*a);this.stackedYData[d]=b[1];}function p(){const b=this.yAxis.stacking;this.options.centerInCategory&&(this.is("column")||this.is("columnrange"))&&!this.options.stacking&&1<this.chart.series.length?h.setStackedPoints.call(this,"group"):b&&r(b.stacks,(a,d)=>{"group"===d.slice(-5)&&(r(a,b=>b.destroy()),
    	delete b.stacks[d]);});}function t(b){var a=this.chart;const f=b||this.options.stacking;if(f&&(!0===this.visible||!1===a.options.chart.ignoreHiddenSeries)){var g=this.processedXData,k=this.processedYData,h=[],l=k.length,m=this.options,p=m.threshold,r=q(m.startFromThreshold&&p,0);m=m.stack;b=b?`${this.type},${f}`:this.stackKey;var t="-"+b,v=this.negStacks;a="group"===f?a.yAxis[0]:this.yAxis;var u=a.stacking.stacks,x=a.stacking.oldStacks,E,G;a.stacking.stacksTouched+=1;for(G=0;G<l;G++){var F=g[G];var B=
    	k[G];var y=this.getStackIndicator(y,F,this.index);var C=y.key;var z=(E=v&&B<(r?0:p))?t:b;u[z]||(u[z]={});u[z][F]||(x[z]&&x[z][F]?(u[z][F]=x[z][F],u[z][F].total=null):u[z][F]=new L(a,a.options.stackLabels,!!E,F,m));z=u[z][F];null!==B?(z.points[C]=z.points[this.index]=[q(z.cumulative,r)],w(z.cumulative)||(z.base=C),z.touched=a.stacking.stacksTouched,0<y.index&&!1===this.singleStacks&&(z.points[C][0]=z.points[this.index+","+F+",0"][0])):z.points[C]=z.points[this.index]=null;"percent"===f?(E=E?b:t,v&&
    	u[E]&&u[E][F]?(E=u[E][F],z.total=E.total=Math.max(E.total,z.total)+Math.abs(B)||0):z.total=e(z.total+(Math.abs(B)||0))):"group"===f?(d(B)&&(B=B[0]),null!==B&&(z.total=(z.total||0)+1)):z.total=e(z.total+(B||0));z.cumulative="group"===f?(z.total||1)-1:e(q(z.cumulative,r)+(B||0));null!==B&&(z.points[C].push(z.cumulative),h[G]=z.cumulative,z.hasValidPoints=!0);}"percent"===f&&(a.stacking.usePercentage=!0);"group"!==f&&(this.stackedYData=h);a.stacking.oldStacks={};}}const {getDeferredAnimation:m}=a,{series:{prototype:h}}=
    	I,{addEvent:g,correctFloat:e,defined:w,destroyObjectProperties:E,fireEvent:F,isArray:d,isNumber:k,objectEach:r,pick:q}=C;class G{constructor(b){this.oldStacks={};this.stacks={};this.stacksTouched=0;this.axis=b;}buildStacks(){const b=this.axis,a=b.series,d=b.options.reversedStacks,e=a.length;let g,k;this.usePercentage=!1;for(k=e;k--;)g=a[d?k:e-k-1],g.setStackedPoints(),g.setGroupedPoints();for(k=0;k<e;k++)a[k].modifyStacks();F(b,"afterBuildStacks");}cleanStacks(){let b;this.oldStacks&&(b=this.stacks=
    	this.oldStacks);r(b,function(b){r(b,function(b){b.cumulative=b.total;});});}resetStacks(){r(this.stacks,b=>{r(b,(a,d)=>{k(a.touched)&&a.touched<this.stacksTouched?(a.destroy(),delete b[d]):(a.total=null,a.cumulative=null);});});}renderStackTotals(){var b=this.axis;const a=b.chart,d=a.renderer,e=this.stacks;b=m(a,b.options.stackLabels&&b.options.stackLabels.animation||!1);const g=this.stackTotalGroup=this.stackTotalGroup||d.g("stack-labels").attr({zIndex:6,opacity:0}).add();g.translate(a.plotLeft,a.plotTop);
    	r(e,function(b){r(b,function(b){b.render(g);});});g.animate({opacity:1},b);}}var b;(function(b){const a=[];b.compose=function(b,c,d){C.pushUnique(a,b)&&(g(b,"init",B),g(b,"destroy",H));C.pushUnique(a,c)&&(c.prototype.getStacks=x);C.pushUnique(a,d)&&(b=d.prototype,b.getStackIndicator=u,b.modifyStacks=v,b.percentStacker=l,b.setGroupedPoints=p,b.setStackedPoints=t);};})(b||(b={}));return b});M(a,"Series/Line/LineSeries.js",[a["Core/Series/Series.js"],a["Core/Series/SeriesRegistry.js"],a["Core/Utilities.js"]],
    	function(a,y,I){const {defined:x,merge:C}=I;class z extends a{constructor(){super(...arguments);this.points=this.options=this.data=void 0;}drawGraph(){const a=this,x=this.options,u=(this.gappedPath||this.getGraphPath).call(this),v=this.chart.styledMode;let l=[["graph","highcharts-graph"]];v||l[0].push(x.lineColor||this.color||"#cccccc",x.dashStyle);l=a.getZonesGraphs(l);l.forEach(function(l,t){var m=l[0];let h=a[m];const g=h?"animate":"attr";h?(h.endX=a.preventGraphAnimation?null:u.xMap,h.animate({d:u})):
    	u.length&&(a[m]=h=a.chart.renderer.path(u).addClass(l[1]).attr({zIndex:1}).add(a.group));h&&!v&&(m={stroke:l[2],"stroke-width":x.lineWidth||0,fill:a.fillGraph&&a.color||"none"},l[3]?m.dashstyle=l[3]:"square"!==x.linecap&&(m["stroke-linecap"]=m["stroke-linejoin"]="round"),h[g](m).shadow(2>t&&x.shadow));h&&(h.startX=u.xMap,h.isArea=u.isArea);});}getGraphPath(a,B,u){const v=this,l=v.options,p=[],t=[];let m,h=l.step;a=a||v.points;const g=a.reversed;g&&a.reverse();(h={right:1,center:2}[h]||h&&3)&&g&&(h=
    	4-h);a=this.getValidPoints(a,!1,!(l.connectNulls&&!B&&!u));a.forEach(function(e,g){const w=e.plotX,F=e.plotY,d=a[g-1],k=e.isNull||"number"!==typeof F;(e.leftCliff||d&&d.rightCliff)&&!u&&(m=!0);k&&!x(B)&&0<g?m=!l.connectNulls:k&&!B?m=!0:(0===g||m?g=[["M",e.plotX,e.plotY]]:v.getPointSpline?g=[v.getPointSpline(a,e,g)]:h?(g=1===h?[["L",d.plotX,F]]:2===h?[["L",(d.plotX+w)/2,d.plotY],["L",(d.plotX+w)/2,F]]:[["L",w,d.plotY]],g.push(["L",w,F])):g=[["L",w,F]],t.push(e.x),h&&(t.push(e.x),2===h&&t.push(e.x)),
    	p.push.apply(p,g),m=!1);});p.xMap=t;return v.graphPath=p}getZonesGraphs(a){this.zones.forEach(function(x,u){u=["zone-graph-"+u,"highcharts-graph highcharts-zone-graph-"+u+" "+(x.className||"")];this.chart.styledMode||u.push(x.color||this.color,x.dashStyle||this.options.dashStyle);a.push(u);},this);return a}}z.defaultOptions=C(a.defaultOptions,{legendSymbol:"lineMarker"});y.registerSeriesType("line",z);return z});M(a,"Series/Area/AreaSeries.js",[a["Core/Color/Color.js"],a["Core/Series/SeriesRegistry.js"],
    	a["Core/Utilities.js"]],function(a,y,I){const {seriesTypes:{line:x}}=y,{extend:C,merge:z,objectEach:H,pick:B}=I;class u extends x{constructor(){super(...arguments);this.points=this.options=this.data=void 0;}drawGraph(){this.areaPath=[];super.drawGraph.apply(this);const a=this,l=this.areaPath,p=this.options,t=[["area","highcharts-area",this.color,p.fillColor]];this.zones.forEach(function(l,h){t.push(["zone-area-"+h,"highcharts-area highcharts-zone-area-"+h+" "+l.className,l.color||a.color,l.fillColor||
    	p.fillColor]);});t.forEach(function(m){const h=m[0],g={};let e=a[h];const t=e?"animate":"attr";e?(e.endX=a.preventGraphAnimation?null:l.xMap,e.animate({d:l})):(g.zIndex=0,e=a[h]=a.chart.renderer.path(l).addClass(m[1]).add(a.group),e.isArea=!0);a.chart.styledMode||(m[3]?g.fill=m[3]:(g.fill=m[2],g["fill-opacity"]=B(p.fillOpacity,.75)));e[t](g);e.startX=l.xMap;e.shiftUnit=p.step?2:1;});}getGraphPath(a){var l=x.prototype.getGraphPath,p=this.options;const t=p.stacking,m=this.yAxis,h=[],g=[],e=this.index,
    	w=m.stacking.stacks[this.stackKey],v=p.threshold,u=Math.round(m.getThreshold(p.threshold));p=B(p.connectNulls,"percent"===t);var d=function(d,b,f){var c=a[d];d=t&&w[c.x].points[e];const n=c[f+"Null"]||0;f=c[f+"Cliff"]||0;let l,q;c=!0;f||n?(l=(n?d[0]:d[1])+f,q=d[0]+f,c=!!n):!t&&a[b]&&a[b].isNull&&(l=q=v);"undefined"!==typeof l&&(g.push({plotX:k,plotY:null===l?u:m.getThreshold(l),isNull:c,isCliff:!0}),h.push({plotX:k,plotY:null===q?u:m.getThreshold(q),doCurve:!1}));};let k;a=a||this.points;t&&(a=this.getStackPoints(a));
    	for(let e=0,b=a.length;e<b;++e){t||(a[e].leftCliff=a[e].rightCliff=a[e].leftNull=a[e].rightNull=void 0);var r=a[e].isNull;k=B(a[e].rectPlotX,a[e].plotX);var q=t?B(a[e].yBottom,u):u;if(!r||p)p||d(e,e-1,"left"),r&&!t&&p||(g.push(a[e]),h.push({x:e,plotX:k,plotY:q})),p||d(e,e+1,"right");}d=l.call(this,g,!0,!0);h.reversed=!0;r=l.call(this,h,!0,!0);(q=r[0])&&"M"===q[0]&&(r[0]=["L",q[1],q[2]]);r=d.concat(r);r.length&&r.push(["Z"]);l=l.call(this,g,!1,p);r.xMap=d.xMap;this.areaPath=r;return l}getStackPoints(a){const l=
    	this,p=[],t=[],m=this.xAxis,h=this.yAxis,g=h.stacking.stacks[this.stackKey],e={},w=h.series,v=w.length,u=h.options.reversedStacks?1:-1,d=w.indexOf(l);a=a||this.points;if(this.options.stacking){for(let d=0;d<a.length;d++)a[d].leftNull=a[d].rightNull=void 0,e[a[d].x]=a[d];H(g,function(a,d){null!==a.total&&t.push(d);});t.sort(function(a,d){return a-d});const k=w.map(a=>a.visible);t.forEach(function(a,q){let r=0,b,f;if(e[a]&&!e[a].isNull)p.push(e[a]),[-1,1].forEach(function(c){const h=1===c?"rightNull":
    	"leftNull",m=g[t[q+c]];let p=0;if(m){let c=d;for(;0<=c&&c<v;){const d=w[c].index;b=m.points[d];b||(d===l.index?e[a][h]=!0:k[c]&&(f=g[a].points[d])&&(p-=f[1]-f[0]));c+=u;}}e[a][1===c?"rightCliff":"leftCliff"]=p;});else {let c=d;for(;0<=c&&c<v;){if(b=g[a].points[w[c].index]){r=b[1];break}c+=u;}r=B(r,0);r=h.translate(r,0,1,0,1);p.push({isNull:!0,plotX:m.translate(a,0,0,0,1),x:a,plotY:r,yBottom:r});}});}return p}}u.defaultOptions=z(x.defaultOptions,{threshold:0,legendSymbol:"rectangle"});C(u.prototype,{singleStacks:!1});
    	y.registerSeriesType("area",u);return u});M(a,"Series/Spline/SplineSeries.js",[a["Core/Series/SeriesRegistry.js"],a["Core/Utilities.js"]],function(a,y){const {line:x}=a.seriesTypes,{merge:L,pick:C}=y;class z extends x{constructor(){super(...arguments);this.points=this.options=this.data=void 0;}getPointSpline(a,x,u){const v=x.plotX||0,l=x.plotY||0,p=a[u-1];u=a[u+1];let t,m;let h;if(p&&!p.isNull&&!1!==p.doCurve&&!x.isCliff&&u&&!u.isNull&&!1!==u.doCurve&&!x.isCliff){a=p.plotY||0;var g=u.plotX||0;u=
    	u.plotY||0;let e=0;t=(1.5*v+(p.plotX||0))/2.5;m=(1.5*l+a)/2.5;g=(1.5*v+g)/2.5;h=(1.5*l+u)/2.5;g!==t&&(e=(h-m)*(g-v)/(g-t)+l-h);m+=e;h+=e;m>a&&m>l?(m=Math.max(a,l),h=2*l-m):m<a&&m<l&&(m=Math.min(a,l),h=2*l-m);h>u&&h>l?(h=Math.max(u,l),m=2*l-h):h<u&&h<l&&(h=Math.min(u,l),m=2*l-h);x.rightContX=g;x.rightContY=h;}x=["C",C(p.rightContX,p.plotX,0),C(p.rightContY,p.plotY,0),C(t,v,0),C(m,l,0),v,l];p.rightContX=p.rightContY=void 0;return x}}z.defaultOptions=L(x.defaultOptions);a.registerSeriesType("spline",
    	z);return z});M(a,"Series/AreaSpline/AreaSplineSeries.js",[a["Series/Spline/SplineSeries.js"],a["Core/Series/SeriesRegistry.js"],a["Core/Utilities.js"]],function(a,y,I){const {area:x,area:{prototype:C}}=y.seriesTypes,{extend:z,merge:H}=I;class B extends a{constructor(){super(...arguments);this.options=this.points=this.data=void 0;}}B.defaultOptions=H(a.defaultOptions,x.defaultOptions);z(B.prototype,{getGraphPath:C.getGraphPath,getStackPoints:C.getStackPoints,drawGraph:C.drawGraph});y.registerSeriesType("areaspline",
    	B);return B});M(a,"Series/Column/ColumnSeriesDefaults.js",[],function(){return {borderRadius:3,centerInCategory:!1,groupPadding:.2,marker:null,pointPadding:.1,minPointLength:0,cropThreshold:50,pointRange:null,states:{hover:{halo:!1,brightness:.1},select:{color:"#cccccc",borderColor:"#000000"}},dataLabels:{align:void 0,verticalAlign:void 0,y:void 0},startFromThreshold:!0,stickyTracking:!1,tooltip:{distance:6},threshold:0,borderColor:"#ffffff"}});M(a,"Series/Column/ColumnSeries.js",[a["Core/Animation/AnimationUtilities.js"],
    	a["Core/Color/Color.js"],a["Series/Column/ColumnSeriesDefaults.js"],a["Core/Globals.js"],a["Core/Series/Series.js"],a["Core/Series/SeriesRegistry.js"],a["Core/Utilities.js"]],function(a,y,I,L,C,z,H){const {animObject:x}=a,{parse:u}=y,{hasTouch:v,noop:l}=L,{clamp:p,defined:t,extend:m,fireEvent:h,isArray:g,isNumber:e,merge:w,pick:E,objectEach:F}=H;class d extends C{constructor(){super(...arguments);this.points=this.options=this.group=this.data=this.borderWidth=void 0;}animate(a){const d=this,e=this.yAxis,
    	g=e.pos,b=d.options,f=this.chart.inverted,c={},k=f?"translateX":"translateY";let h;a?(c.scaleY=.001,a=p(e.toPixels(b.threshold),g,g+e.len),f?c.translateX=a-e.len:c.translateY=a,d.clipBox&&d.setClip(),d.group.attr(c)):(h=Number(d.group.attr(k)),d.group.animate({scaleY:1},m(x(d.options.animation),{step:function(b,a){d.group&&(c[k]=h+a.pos*(g-h),d.group.attr(c));}})));}init(a,d){super.init.apply(this,arguments);const e=this;a=e.chart;a.hasRendered&&a.series.forEach(function(a){a.type===e.type&&(a.isDirty=
    	!0);});}getColumnMetrics(){const a=this;var d=a.options;const e=a.xAxis,g=a.yAxis;var b=e.options.reversedStacks;b=e.reversed&&!b||!e.reversed&&b;const f={};let c,h=0;!1===d.grouping?h=1:a.chart.series.forEach(function(b){const d=b.yAxis,e=b.options;let k;b.type!==a.type||!b.visible&&a.chart.options.chart.ignoreHiddenSeries||g.len!==d.len||g.pos!==d.pos||(e.stacking&&"group"!==e.stacking?(c=b.stackKey,"undefined"===typeof f[c]&&(f[c]=h++),k=f[c]):!1!==e.grouping&&(k=h++),b.columnIndex=k);});const l=
    	Math.min(Math.abs(e.transA)*(e.ordinal&&e.ordinal.slope||d.pointRange||e.closestPointRange||e.tickInterval||1),e.len),m=l*d.groupPadding,p=(l-2*m)/(h||1);d=Math.min(d.maxPointWidth||e.len,E(d.pointWidth,p*(1-2*d.pointPadding)));a.columnMetrics={width:d,offset:(p-d)/2+(m+((a.columnIndex||0)+(b?1:0))*p-l/2)*(b?-1:1),paddedWidth:p,columnCount:h};return a.columnMetrics}crispCol(a,d,e,g){var b=this.borderWidth,f=-(b%2?.5:0);b=b%2?.5:1;this.options.crisp&&(e=Math.round(a+e)+f,a=Math.round(a)+f,e-=a);g=
    	Math.round(d+g)+b;f=.5>=Math.abs(d)&&.5<g;d=Math.round(d)+b;g-=d;f&&g&&(--d,g+=1);return {x:a,y:d,width:e,height:g}}adjustForMissingColumns(a,d,e,h){const b=this.options.stacking;if(!e.isNull&&1<h.columnCount){const f=this.yAxis.options.reversedStacks;let c=0,k=f?0:-h.columnCount;F(this.yAxis.stacking&&this.yAxis.stacking.stacks,a=>{if("number"===typeof e.x){const d=a[e.x.toString()];d&&(a=d.points[this.index],b?(a&&(c=k),d.hasValidPoints&&(f?k++:k--)):g(a)&&(a=Object.keys(d.points).filter(b=>!b.match(",")&&
    	d.points[b]&&1<d.points[b].length).map(parseFloat).sort((b,a)=>a-b),c=a.indexOf(this.index),k=a.length));}});a=(e.plotX||0)+((k-1)*h.paddedWidth+d)/2-d-c*h.paddedWidth;}return a}translate(){const a=this,d=a.chart,g=a.options;var l=a.dense=2>a.closestPointRange*a.xAxis.transA;l=a.borderWidth=E(g.borderWidth,l?0:1);const b=a.xAxis,f=a.yAxis,c=g.threshold,n=E(g.minPointLength,5),m=a.getColumnMetrics(),w=m.width,v=a.pointXOffset=m.offset,u=a.dataMin,x=a.dataMax;let F=a.barW=Math.max(w,1+2*l),y=a.translatedThreshold=
    	f.getThreshold(c);d.inverted&&(y-=.5);g.pointPadding&&(F=Math.ceil(F));C.prototype.translate.apply(a);a.points.forEach(function(k){const h=E(k.yBottom,y);var l=999+Math.abs(h),q=k.plotX||0;l=p(k.plotY,-l,f.len+l);let r=Math.min(l,h),D=Math.max(l,h)-r,z=w,B=q+v,G=F;n&&Math.abs(D)<n&&(D=n,q=!f.reversed&&!k.negative||f.reversed&&k.negative,e(c)&&e(x)&&k.y===c&&x<=c&&(f.min||0)<c&&(u!==x||(f.max||0)<=c)&&(q=!q,k.negative=!k.negative),r=Math.abs(r-y)>n?h-n:y-(q?n:0));t(k.options.pointWidth)&&(z=G=Math.ceil(k.options.pointWidth),
    	B-=Math.round((z-w)/2));g.centerInCategory&&(B=a.adjustForMissingColumns(B,z,k,m));k.barX=B;k.pointWidth=z;k.tooltipPos=d.inverted?[p(f.len+f.pos-d.plotLeft-l,f.pos-d.plotLeft,f.len+f.pos-d.plotLeft),b.len+b.pos-d.plotTop-B-G/2,D]:[b.left-d.plotLeft+B+G/2,p(l+f.pos-d.plotTop,f.pos-d.plotTop,f.len+f.pos-d.plotTop),D];k.shapeType=a.pointClass.prototype.shapeType||"roundedRect";k.shapeArgs=a.crispCol(B,k.isNull?y:r,G,k.isNull?0:D);});h(this,"afterColumnTranslate");}drawGraph(){this.group[this.dense?"addClass":
    	"removeClass"]("highcharts-dense-data");}pointAttribs(a,d){const e=this.options;var g=this.pointAttrToOptions||{},b=g.stroke||"borderColor";const f=g["stroke-width"]||"borderWidth";let c,k=a&&a.color||this.color,h=a&&a[b]||e[b]||k;g=a&&a.options.dashStyle||e.dashStyle;let l=a&&a[f]||e[f]||this[f]||0,m=E(a&&a.opacity,e.opacity,1);a&&this.zones.length&&(c=a.getZone(),k=a.options.color||c&&(c.color||a.nonZonedColor)||this.color,c&&(h=c.borderColor||h,g=c.dashStyle||g,l=c.borderWidth||l));d&&a&&(a=w(e.states[d],
    	a.options.states&&a.options.states[d]||{}),d=a.brightness,k=a.color||"undefined"!==typeof d&&u(k).brighten(a.brightness).get()||k,h=a[b]||h,l=a[f]||l,g=a.dashStyle||g,m=E(a.opacity,m));b={fill:k,stroke:h,"stroke-width":l,opacity:m};g&&(b.dashstyle=g);return b}drawPoints(a=this.points){const d=this,g=this.chart,k=d.options,b=g.renderer,f=k.animationLimit||250;let c;a.forEach(function(a){let h=a.graphic,l=!!h,n=h&&g.pointCount<f?"animate":"attr";if(e(a.plotY)&&null!==a.y){c=a.shapeArgs;h&&a.hasNewShapeType()&&
    	(h=h.destroy());d.enabledDataSorting&&(a.startXPos=d.xAxis.reversed?-(c?c.width||0:0):d.xAxis.width);h||(a.graphic=h=b[a.shapeType](c).add(a.group||d.group))&&d.enabledDataSorting&&g.hasRendered&&g.pointCount<f&&(h.attr({x:a.startXPos}),l=!0,n="animate");if(h&&l)h[n](w(c));g.styledMode||h[n](d.pointAttribs(a,a.selected&&"select")).shadow(!1!==a.allowShadow&&k.shadow);h&&(h.addClass(a.getClassName(),!0),h.attr({visibility:a.visible?"inherit":"hidden"}));}else h&&(a.graphic=h.destroy());});}drawTracker(a=
    	this.points){const d=this,e=d.chart,k=e.pointer,b=function(a){const b=k.getPointFromEvent(a);"undefined"!==typeof b&&d.options.enableMouseTracking&&(k.isDirectTouch=!0,b.onMouseOver(a));};let f;a.forEach(function(a){f=g(a.dataLabels)?a.dataLabels:a.dataLabel?[a.dataLabel]:[];a.graphic&&(a.graphic.element.point=a);f.forEach(function(b){b.div?b.div.point=a:b.element.point=a;});});d._hasTracking||(d.trackerGroups.forEach(function(a){if(d[a]){d[a].addClass("highcharts-tracker").on("mouseover",b).on("mouseout",
    	function(a){k.onTrackerMouseOut(a);});if(v)d[a].on("touchstart",b);!e.styledMode&&d.options.cursor&&d[a].css({cursor:d.options.cursor});}}),d._hasTracking=!0);h(this,"afterDrawTracker");}remove(){const a=this,d=a.chart;d.hasRendered&&d.series.forEach(function(d){d.type===a.type&&(d.isDirty=!0);});C.prototype.remove.apply(a,arguments);}}d.defaultOptions=w(C.defaultOptions,I);m(d.prototype,{cropShoulder:0,directTouch:!0,getSymbol:l,negStacks:!0,trackerGroups:["group","dataLabelsGroup"]});z.registerSeriesType("column",
    	d);return d});M(a,"Core/Series/DataLabel.js",[a["Core/Animation/AnimationUtilities.js"],a["Core/Templating.js"],a["Core/Utilities.js"]],function(a,y,I){const {getDeferredAnimation:x}=a,{format:C}=y,{defined:z,extend:H,fireEvent:B,isArray:u,isString:v,merge:l,objectEach:p,pick:t,splat:m}=I;var h;(function(a){function e(a,d,c,e,g){const b=this.chart;var f=this.isCartesian&&b.inverted;const k=this.enabledDataSorting;var h=a.plotX,l=a.plotY;const n=c.rotation;var m=c.align;l=z(h)&&z(l)&&b.isInsidePlot(h,
    	Math.round(l),{inverted:f,paneCoordinates:!0,series:this});let p="justify"===t(c.overflow,k?"none":"justify");f=this.visible&&!1!==a.visible&&z(h)&&(a.series.forceDL||k&&!p||l||t(c.inside,!!this.options.stacking)&&e&&b.isInsidePlot(h,f?e.x+1:e.y+e.height-1,{inverted:f,paneCoordinates:!0,series:this}));h=a.pos();if(f&&h){n&&d.attr({align:m});m=d.getBBox(!0);var q=[0,0];var r=b.renderer.fontMetrics(d).b;e=H({x:h[0],y:Math.round(h[1]),width:0,height:0},e);H(c,{width:m.width,height:m.height});n?(p=!1,
    	q=b.renderer.rotCorr(r,n),r={x:e.x+(c.x||0)+e.width/2+q.x,y:e.y+(c.y||0)+{top:0,middle:.5,bottom:1}[c.verticalAlign]*e.height},q=[m.x-Number(d.attr("x")),m.y-Number(d.attr("y"))],k&&this.xAxis&&!p&&this.setDataLabelStartPos(a,d,g,l,r),d[g?"attr":"animate"](r)):(k&&this.xAxis&&!p&&this.setDataLabelStartPos(a,d,g,l,e),d.align(c,void 0,e),r=d.alignAttr);if(p&&0<=e.height)this.justifyDataLabel(d,c,r,m,e,g);else if(t(c.crop,!0)){let {x:a,y:c}=r;a+=q[0];c+=q[1];f=b.isInsidePlot(a,c,{paneCoordinates:!0,
    	series:this})&&b.isInsidePlot(a+m.width,c+m.height,{paneCoordinates:!0,series:this});}if(c.shape&&!n)d[g?"attr":"animate"]({anchorX:h[0],anchorY:h[1]});}g&&k&&(d.placed=!1);f||k&&!p?d.show():(d.hide(),d.placed=!1);}function g(a,d){var b=d.filter;return b?(d=b.operator,a=a[b.property],b=b.value,">"===d&&a>b||"<"===d&&a<b||">="===d&&a>=b||"<="===d&&a<=b||"=="===d&&a==b||"==="===d&&a===b?!0:!1):!0}function h(){return this.plotGroup("dataLabelsGroup","data-labels",this.hasRendered?"inherit":"hidden",this.options.dataLabels.zIndex||
    	6)}function F(a){const b=this.hasRendered||0,c=this.initDataLabelsGroup().attr({opacity:+b});!b&&c&&(this.visible&&c.show(),this.options.animation?c.animate({opacity:1},a):c.attr({opacity:1}));return c}function d(a=this.points){var b,c;const d=this,e=d.chart,k=d.options,h=e.renderer,{backgroundColor:l,plotBackgroundColor:q}=e.options.chart,w=e.options.plotOptions,E=h.getContrast(v(q)&&q||v(l)&&l||"#000000");let F=k.dataLabels,A,y;var G=m(F)[0];const H=G.animation;G=G.defer?x(e,H,d):{defer:0,duration:0};
    	F=r(r(null===(b=null===w||void 0===w?void 0:w.series)||void 0===b?void 0:b.dataLabels,null===(c=null===w||void 0===w?void 0:w[d.type])||void 0===c?void 0:c.dataLabels),F);B(this,"drawDataLabels");if(u(F)||F.enabled||d._hasPointLabels)y=this.initDataLabels(G),a.forEach(a=>{var b;const c=a.dataLabels||[];A=m(r(F,a.dlOptions||(null===(b=a.options)||void 0===b?void 0:b.dataLabels)));A.forEach((b,f)=>{var l,m=b.enabled&&(!a.isNull||a.dataLabelOnNull)&&g(a,b);const n=a.connectors?a.connectors[f]:a.connector,
    	q=b.style||{};let r={},w=c[f],u=!w;const x=t(b.distance,a.labelDistance);if(m){var A=t(b[a.formatPrefix+"Format"],b.format);var F=a.getLabelConfig();F=z(A)?C(A,F,e):(b[a.formatPrefix+"Formatter"]||b.formatter).call(F,b);A=b.rotation;e.styledMode||(q.color=t(b.color,q.color,v(d.color)?d.color:void 0,"#000000"),"contrast"===q.color?(a.contrastColor=h.getContrast(a.color||d.color),q.color=!z(x)&&b.inside||0>(x||0)||k.stacking?a.contrastColor:E):delete a.contrastColor,k.cursor&&(q.cursor=k.cursor));r=
    	{r:b.borderRadius||0,rotation:A,padding:b.padding,zIndex:1};if(!e.styledMode){const {backgroundColor:c,borderColor:d}=b;r.fill="auto"===c?a.color:c;r.stroke="auto"===d?a.color:d;r["stroke-width"]=b.borderWidth;}p(r,(a,b)=>{"undefined"===typeof a&&delete r[b];});}!w||m&&z(F)&&!!w.div===!!b.useHTML&&(w.rotation&&b.rotation||w.rotation===b.rotation)||(w=void 0,u=!0,n&&a.connector&&(a.connector=a.connector.destroy(),a.connectors&&(1===a.connectors.length?delete a.connectors:delete a.connectors[f])));m&&
    	z(F)&&(w?r.text=F:(w=A?h.text(F,0,0,b.useHTML).addClass("highcharts-data-label"):h.label(F,0,0,b.shape,void 0,void 0,b.useHTML,void 0,"data-label"))&&w.addClass(" highcharts-data-label-color-"+a.colorIndex+" "+(b.className||"")+(b.useHTML?" highcharts-tracker":"")),w&&(w.options=b,w.attr(r),e.styledMode||w.css(q).shadow(b.shadow),(m=b[a.formatPrefix+"TextPath"]||b.textPath)&&!b.useHTML&&(w.setTextPath((null===(l=a.getDataLabelPath)||void 0===l?void 0:l.call(a,w))||a.graphic,m),a.dataLabelPath&&!m.enabled&&
    	(a.dataLabelPath=a.dataLabelPath.destroy())),w.added||w.add(y),d.alignDataLabel(a,w,b,void 0,u),w.isActive=!0,c[f]&&c[f]!==w&&c[f].destroy(),c[f]=w));});for(b=c.length;b--;)c[b].isActive?c[b].isActive=!1:(c[b].destroy(),c.splice(b,1));a.dataLabel=c[0];a.dataLabels=c;});B(this,"afterDrawDataLabels");}function k(a,d,c,e,g,k){const b=this.chart,f=d.align,h=d.verticalAlign,l=a.box?0:a.padding||0;let {x:m=0,y:n=0}=d,p,q;p=(c.x||0)+l;0>p&&("right"===f&&0<=m?(d.align="left",d.inside=!0):m-=p,q=!0);p=(c.x||
    	0)+e.width-l;p>b.plotWidth&&("left"===f&&0>=m?(d.align="right",d.inside=!0):m+=b.plotWidth-p,q=!0);p=c.y+l;0>p&&("bottom"===h&&0<=n?(d.verticalAlign="top",d.inside=!0):n-=p,q=!0);p=(c.y||0)+e.height-l;p>b.plotHeight&&("top"===h&&0>=n?(d.verticalAlign="bottom",d.inside=!0):n+=b.plotHeight-p,q=!0);q&&(d.x=m,d.y=n,a.placed=!k,a.align(d,void 0,g));return q}function r(a,d){let b=[],f;if(u(a)&&!u(d))b=a.map(function(a){return l(a,d)});else if(u(d)&&!u(a))b=d.map(function(b){return l(a,b)});else if(!u(a)&&
    	!u(d))b=l(a,d);else if(u(a)&&u(d))for(f=Math.max(a.length,d.length);f--;)b[f]=l(a[f],d[f]);return b}function q(a,d,c,e,g){const b=this.chart,f=b.inverted,k=this.xAxis,h=k.reversed,l=f?d.height/2:d.width/2;a=(a=a.pointWidth)?a/2:0;d.startXPos=f?g.x:h?-l-a:k.width-l+a;d.startYPos=f?h?this.yAxis.height-l+a:-l-a:g.y;e?"hidden"===d.visibility&&(d.show(),d.attr({opacity:0}).animate({opacity:1})):d.attr({opacity:1}).animate({opacity:0},void 0,d.hide);b.hasRendered&&(c&&d.attr({x:d.startXPos,y:d.startYPos}),
    	d.placed=!0);}const y=[];a.compose=function(a){I.pushUnique(y,a)&&(a=a.prototype,a.initDataLabelsGroup=h,a.initDataLabels=F,a.alignDataLabel=e,a.drawDataLabels=d,a.justifyDataLabel=k,a.setDataLabelStartPos=q);};})(h||(h={}));return h});M(a,"Series/Column/ColumnDataLabel.js",[a["Core/Series/DataLabel.js"],a["Core/Series/SeriesRegistry.js"],a["Core/Utilities.js"]],function(a,y,I){const {series:x}=y,{merge:C,pick:z}=I;var H;(function(y){function u(a,p,t,m,h){let g=this.chart.inverted;var e=a.series;
    	let l=(e.xAxis?e.xAxis.len:this.chart.plotSizeX)||0;e=(e.yAxis?e.yAxis.len:this.chart.plotSizeY)||0;var v=a.dlBox||a.shapeArgs;let u=z(a.below,a.plotY>z(this.translatedThreshold,e)),d=z(t.inside,!!this.options.stacking);v&&(m=C(v),0>m.y&&(m.height+=m.y,m.y=0),v=m.y+m.height-e,0<v&&v<m.height&&(m.height-=v),g&&(m={x:e-m.y-m.height,y:l-m.x-m.width,width:m.height,height:m.width}),d||(g?(m.x+=u?0:m.width,m.width=0):(m.y+=u?m.height:0,m.height=0)));t.align=z(t.align,!g||d?"center":u?"right":"left");t.verticalAlign=
    	z(t.verticalAlign,g||d?"middle":u?"top":"bottom");x.prototype.alignDataLabel.call(this,a,p,t,m,h);t.inside&&a.contrastColor&&p.css({color:a.contrastColor});}const v=[];y.compose=function(l){a.compose(x);I.pushUnique(v,l)&&(l.prototype.alignDataLabel=u);};})(H||(H={}));return H});M(a,"Series/Bar/BarSeries.js",[a["Series/Column/ColumnSeries.js"],a["Core/Series/SeriesRegistry.js"],a["Core/Utilities.js"]],function(a,y,I){const {extend:x,merge:C}=I;class z extends a{constructor(){super(...arguments);this.points=
    	this.options=this.data=void 0;}}z.defaultOptions=C(a.defaultOptions,{});x(z.prototype,{inverted:!0});y.registerSeriesType("bar",z);return z});M(a,"Series/Scatter/ScatterSeriesDefaults.js",[],function(){return {lineWidth:0,findNearestPointBy:"xy",jitter:{x:0,y:0},marker:{enabled:!0},tooltip:{headerFormat:'<span style="color:{point.color}">\u25cf</span> <span style="font-size: 0.8em"> {series.name}</span><br/>',pointFormat:"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"}}});M(a,"Series/Scatter/ScatterSeries.js",
    	[a["Series/Scatter/ScatterSeriesDefaults.js"],a["Core/Series/SeriesRegistry.js"],a["Core/Utilities.js"]],function(a,y,I){const {column:x,line:C}=y.seriesTypes,{addEvent:z,extend:H,merge:B}=I;class u extends C{constructor(){super(...arguments);this.points=this.options=this.data=void 0;}applyJitter(){const a=this,l=this.options.jitter,p=this.points.length;l&&this.points.forEach(function(t,m){["x","y"].forEach(function(h,g){let e="plot"+h.toUpperCase(),w,v;if(l[h]&&!t.isNull){var u=a[h+"Axis"];v=l[h]*
    	u.transA;u&&!u.isLog&&(w=Math.max(0,t[e]-v),u=Math.min(u.len,t[e]+v),g=1E4*Math.sin(m+g*p),g-=Math.floor(g),t[e]=w+(u-w)*g,"x"===h&&(t.clientX=t.plotX));}});});}drawGraph(){this.options.lineWidth?super.drawGraph():this.graph&&(this.graph=this.graph.destroy());}}u.defaultOptions=B(C.defaultOptions,a);H(u.prototype,{drawTracker:x.prototype.drawTracker,sorted:!1,requireSorting:!1,noSharedTooltip:!0,trackerGroups:["group","markerGroup","dataLabelsGroup"],takeOrdinalPosition:!1});z(u,"afterTranslate",function(){this.applyJitter();});
    	y.registerSeriesType("scatter",u);return u});M(a,"Series/CenteredUtilities.js",[a["Core/Globals.js"],a["Core/Series/Series.js"],a["Core/Utilities.js"]],function(a,y,I){const {deg2rad:x}=a,{fireEvent:C,isNumber:z,pick:H,relativeLength:B}=I;var u;(function(a){a.getCenter=function(){var a=this.options,p=this.chart;const t=2*(a.slicedOffset||0),m=p.plotWidth-2*t,h=p.plotHeight-2*t;var g=a.center;const e=Math.min(m,h),w=a.thickness;var v=a.size;let u=a.innerSize||0;"string"===typeof v&&(v=parseFloat(v));
    	"string"===typeof u&&(u=parseFloat(u));a=[H(g[0],"50%"),H(g[1],"50%"),H(v&&0>v?void 0:a.size,"100%"),H(u&&0>u?void 0:a.innerSize||0,"0%")];!p.angular||this instanceof y||(a[3]=0);for(g=0;4>g;++g)v=a[g],p=2>g||2===g&&/%$/.test(v),a[g]=B(v,[m,h,e,a[2]][g])+(p?t:0);a[3]>a[2]&&(a[3]=a[2]);z(w)&&2*w<a[2]&&0<w&&(a[3]=a[2]-2*w);C(this,"afterGetCenter",{positions:a});return a};a.getStartAndEndRadians=function(a,p){a=z(a)?a:0;p=z(p)&&p>a&&360>p-a?p:a+360;return {start:x*(a+-90),end:x*(p+-90)}};})(u||(u={}));
    return u});M(a,"Series/Pie/PiePoint.js",[a["Core/Animation/AnimationUtilities.js"],a["Core/Series/Point.js"],a["Core/Utilities.js"]],function(a,y,I){const {setAnimation:x}=a,{addEvent:C,defined:z,extend:H,isNumber:B,pick:u,relativeLength:v}=I;class l extends y{constructor(){super(...arguments);this.series=this.options=this.labelDistance=void 0;}getConnectorPath(){const a=this.labelPosition,l=this.series.options.dataLabels,m=this.connectorShapes;let h=l.connectorShape;m[h]&&(h=m[h]);return h.call(this,
    	{x:a.computed.x,y:a.computed.y,alignment:a.alignment},a.connectorPosition,l)}getTranslate(){return this.sliced?this.slicedTranslation:{translateX:0,translateY:0}}haloPath(a){const l=this.shapeArgs;return this.sliced||!this.visible?[]:this.series.chart.renderer.symbols.arc(l.x,l.y,l.r+a,l.r+a,{innerR:l.r-1,start:l.start,end:l.end,borderRadius:l.borderRadius})}init(){super.init.apply(this,arguments);this.name=u(this.name,"Slice");const a=a=>{this.slice("select"===a.type);};C(this,"select",a);C(this,
    	"unselect",a);return this}isValid(){return B(this.y)&&0<=this.y}setVisible(a,l){const m=this.series,h=m.chart,g=m.options.ignoreHiddenPoint;l=u(l,g);a!==this.visible&&(this.visible=this.options.visible=a="undefined"===typeof a?!this.visible:a,m.options.data[m.data.indexOf(this)]=this.options,["graphic","dataLabel","connector"].forEach(e=>{if(this[e])this[e][a?"show":"hide"](a);}),this.legendItem&&h.legend.colorizeItem(this,a),a||"hover"!==this.state||this.setState(""),g&&(m.isDirty=!0),l&&h.redraw());}slice(a,
    	l,m){const h=this.series;x(m,h.chart);u(l,!0);this.sliced=this.options.sliced=z(a)?a:!this.sliced;h.options.data[h.data.indexOf(this)]=this.options;this.graphic&&this.graphic.animate(this.getTranslate());}}H(l.prototype,{connectorShapes:{fixedOffset:function(a,l,m){const h=l.breakAt;l=l.touchingSliceAt;return [["M",a.x,a.y],m.softConnector?["C",a.x+("left"===a.alignment?-5:5),a.y,2*h.x-l.x,2*h.y-l.y,h.x,h.y]:["L",h.x,h.y],["L",l.x,l.y]]},straight:function(a,l){l=l.touchingSliceAt;return [["M",a.x,a.y],
    	["L",l.x,l.y]]},crookedLine:function(a,l,m){const {breakAt:h,touchingSliceAt:g}=l;({series:l}=this);const [e,p,t]=l.center,u=t/2,d=l.chart.plotWidth,k=l.chart.plotLeft;l="left"===a.alignment;const {x:r,y:q}=a;m.crookDistance?(a=v(m.crookDistance,1),a=l?e+u+(d+k-e-u)*(1-a):k+(e-u)*a):a=e+(p-q)*Math.tan((this.angle||0)-Math.PI/2);m=[["M",r,q]];(l?a<=r&&a>=h.x:a>=r&&a<=h.x)&&m.push(["L",a,q]);m.push(["L",h.x,h.y],["L",g.x,g.y]);return m}}});return l});M(a,"Series/Pie/PieSeriesDefaults.js",[],function(){	return {borderRadius:3,center:[null,null],clip:!1,colorByPoint:!0,dataLabels:{allowOverlap:!0,connectorPadding:5,connectorShape:"crookedLine",crookDistance:void 0,distance:30,enabled:!0,formatter:function(){return this.point.isNull?void 0:this.point.name},softConnector:!0,x:0},fillColor:void 0,ignoreHiddenPoint:!0,inactiveOtherPoints:!0,legendType:"point",marker:null,size:null,showInLegend:!1,slicedOffset:10,stickyTracking:!1,tooltip:{followPointer:!0},borderColor:"#ffffff",borderWidth:1,lineWidth:void 0,
    	states:{hover:{brightness:.1}}}});M(a,"Series/Pie/PieSeries.js",[a["Series/CenteredUtilities.js"],a["Series/Column/ColumnSeries.js"],a["Core/Globals.js"],a["Series/Pie/PiePoint.js"],a["Series/Pie/PieSeriesDefaults.js"],a["Core/Series/Series.js"],a["Core/Series/SeriesRegistry.js"],a["Core/Renderer/SVG/Symbols.js"],a["Core/Utilities.js"]],function(a,y,I,L,C,z,H,B,u){const {getStartAndEndRadians:v}=a;({noop:I}=I);const {clamp:l,extend:p,fireEvent:t,merge:m,pick:h,relativeLength:g}=u;class e extends z{constructor(){super(...arguments);
    	this.points=this.options=this.maxLabelDistance=this.data=this.center=void 0;}animate(a){const e=this,g=e.points,d=e.startAngleRad;a||g.forEach(function(a){const g=a.graphic,k=a.shapeArgs;g&&k&&(g.attr({r:h(a.startR,e.center&&e.center[3]/2),start:d,end:d}),g.animate({r:k.r,start:k.start,end:k.end},e.options.animation));});}drawEmpty(){const a=this.startAngleRad,e=this.endAngleRad,g=this.options;let d,k;0===this.total&&this.center?(d=this.center[0],k=this.center[1],this.graph||(this.graph=this.chart.renderer.arc(d,
    	k,this.center[1]/2,0,a,e).addClass("highcharts-empty-series").add(this.group)),this.graph.attr({d:B.arc(d,k,this.center[2]/2,0,{start:a,end:e,innerR:this.center[3]/2})}),this.chart.styledMode||this.graph.attr({"stroke-width":g.borderWidth,fill:g.fillColor||"none",stroke:g.color||"#cccccc"})):this.graph&&(this.graph=this.graph.destroy());}drawPoints(){const a=this.chart.renderer;this.points.forEach(function(e){e.graphic&&e.hasNewShapeType()&&(e.graphic=e.graphic.destroy());e.graphic||(e.graphic=a[e.shapeType](e.shapeArgs).add(e.series.group),
    	e.delayedRendering=!0);});}generatePoints(){super.generatePoints();this.updateTotals();}getX(a,e,g){const d=this.center,k=this.radii?this.radii[g.index]||0:d[2]/2;a=Math.asin(l((a-d[1])/(k+g.labelDistance),-1,1));return d[0]+(e?-1:1)*Math.cos(a)*(k+g.labelDistance)+(0<g.labelDistance?(e?-1:1)*this.options.dataLabels.padding:0)}hasData(){return !!this.processedXData.length}redrawPoints(){const a=this,e=a.chart;let g,d,k,h;this.drawEmpty();a.group&&!e.styledMode&&a.group.shadow(a.options.shadow);a.points.forEach(function(l){const q=
    	{};d=l.graphic;!l.isNull&&d?(h=l.shapeArgs,g=l.getTranslate(),e.styledMode||(k=a.pointAttribs(l,l.selected&&"select")),l.delayedRendering?(d.setRadialReference(a.center).attr(h).attr(g),e.styledMode||d.attr(k).attr({"stroke-linejoin":"round"}),l.delayedRendering=!1):(d.setRadialReference(a.center),e.styledMode||m(!0,q,k),m(!0,q,h,g),d.animate(q)),d.attr({visibility:l.visible?"inherit":"hidden"}),d.addClass(l.getClassName(),!0)):d&&(l.graphic=d.destroy());});}sortByAngle(a,e){a.sort(function(a,d){return "undefined"!==
    	typeof a.angle&&(d.angle-a.angle)*e});}translate(a){t(this,"translate");this.generatePoints();var e=this.options;const l=e.slicedOffset,d=l+(e.borderWidth||0);var k=v(e.startAngle,e.endAngle);const m=this.startAngleRad=k.start;k=(this.endAngleRad=k.end)-m;const q=this.points,p=e.dataLabels.distance;e=e.ignoreHiddenPoint;const b=q.length;let f,c,n,w=0;a||(this.center=a=this.getCenter());for(c=0;c<b;c++){n=q[c];var u=m+w*k;!n.isValid()||e&&!n.visible||(w+=n.percentage/100);var x=m+w*k;var y={x:a[0],
    	y:a[1],r:a[2]/2,innerR:a[3]/2,start:Math.round(1E3*u)/1E3,end:Math.round(1E3*x)/1E3};n.shapeType="arc";n.shapeArgs=y;n.labelDistance=h(n.options.dataLabels&&n.options.dataLabels.distance,p);n.labelDistance=g(n.labelDistance,y.r);this.maxLabelDistance=Math.max(this.maxLabelDistance||0,n.labelDistance);x=(x+u)/2;x>1.5*Math.PI?x-=2*Math.PI:x<-Math.PI/2&&(x+=2*Math.PI);n.slicedTranslation={translateX:Math.round(Math.cos(x)*l),translateY:Math.round(Math.sin(x)*l)};y=Math.cos(x)*a[2]/2;f=Math.sin(x)*a[2]/
    	2;n.tooltipPos=[a[0]+.7*y,a[1]+.7*f];n.half=x<-Math.PI/2||x>Math.PI/2?1:0;n.angle=x;u=Math.min(d,n.labelDistance/5);n.labelPosition={natural:{x:a[0]+y+Math.cos(x)*n.labelDistance,y:a[1]+f+Math.sin(x)*n.labelDistance},computed:{},alignment:0>n.labelDistance?"center":n.half?"right":"left",connectorPosition:{breakAt:{x:a[0]+y+Math.cos(x)*u,y:a[1]+f+Math.sin(x)*u},touchingSliceAt:{x:a[0]+y,y:a[1]+f}}};}t(this,"afterTranslate");}updateTotals(){const a=this.points,e=a.length,g=this.options.ignoreHiddenPoint;
    	let d,k,h=0;for(d=0;d<e;d++)k=a[d],!k.isValid()||g&&!k.visible||(h+=k.y);this.total=h;for(d=0;d<e;d++)k=a[d],k.percentage=0<h&&(k.visible||!g)?k.y/h*100:0,k.total=h;}}e.defaultOptions=m(z.defaultOptions,C);p(e.prototype,{axisTypes:[],directTouch:!0,drawGraph:void 0,drawTracker:y.prototype.drawTracker,getCenter:a.getCenter,getSymbol:I,isCartesian:!1,noSharedTooltip:!0,pointAttribs:y.prototype.pointAttribs,pointClass:L,requireSorting:!1,searchPoint:I,trackerGroups:["group","dataLabelsGroup"]});H.registerSeriesType("pie",
    	e);return e});M(a,"Series/Pie/PieDataLabel.js",[a["Core/Series/DataLabel.js"],a["Core/Globals.js"],a["Core/Renderer/RendererUtilities.js"],a["Core/Series/SeriesRegistry.js"],a["Core/Utilities.js"]],function(a,y,I,L,C){const {noop:x}=y,{distribute:H}=I,{series:B}=L,{arrayMax:u,clamp:v,defined:l,merge:p,pick:t,relativeLength:m}=C;var h;(function(g){function e(){const a=this,d=a.data,e=a.chart,g=a.options.dataLabels||{},b=g.connectorPadding,f=e.plotWidth,c=e.plotHeight,h=e.plotLeft,m=Math.round(e.chartWidth/
    	3),w=a.center,v=w[2]/2,x=w[1],y=[[],[]],z=[0,0,0,0],F=a.dataLabelPositioners;let C,A,E,I,L,M,J,N,O,S,W,U;a.visible&&(g.enabled||a._hasPointLabels)&&(d.forEach(function(a){a.dataLabel&&a.visible&&a.dataLabel.shortened&&(a.dataLabel.attr({width:"auto"}).css({width:"auto",textOverflow:"clip"}),a.dataLabel.shortened=!1);}),B.prototype.drawDataLabels.apply(a),d.forEach(function(a){a.dataLabel&&(a.visible?(y[a.half].push(a),a.dataLabel._pos=null,!l(g.style.width)&&!l(a.options.dataLabels&&a.options.dataLabels.style&&
    	a.options.dataLabels.style.width)&&a.dataLabel.getBBox().width>m&&(a.dataLabel.css({width:Math.round(.7*m)+"px"}),a.dataLabel.shortened=!0)):(a.dataLabel=a.dataLabel.destroy(),a.dataLabels&&1===a.dataLabels.length&&delete a.dataLabels));}),y.forEach((d,k)=>{const m=d.length,n=[];let q,p=0;if(m){a.sortByAngle(d,k-.5);if(0<a.maxLabelDistance){var r=Math.max(0,x-v-a.maxLabelDistance);q=Math.min(x+v+a.maxLabelDistance,e.plotHeight);d.forEach(function(a){0<a.labelDistance&&a.dataLabel&&(a.top=Math.max(0,
    	x-v-a.labelDistance),a.bottom=Math.min(x+v+a.labelDistance,e.plotHeight),p=a.dataLabel.getBBox().height||21,a.distributeBox={target:a.labelPosition.natural.y-a.top+p/2,size:p,rank:a.y},n.push(a.distributeBox));});r=q+p-r;H(n,r,r/5);}for(W=0;W<m;W++){C=d[W];M=C.labelPosition;I=C.dataLabel;S=!1===C.visible?"hidden":"inherit";O=r=M.natural.y;n&&l(C.distributeBox)&&("undefined"===typeof C.distributeBox.pos?S="hidden":(J=C.distributeBox.size,O=F.radialDistributionY(C)));delete C.positionIndex;if(g.justify)N=
    	F.justify(C,v,w);else switch(g.alignTo){case "connectors":N=F.alignToConnectors(d,k,f,h);break;case "plotEdges":N=F.alignToPlotEdges(I,k,f,h);break;default:N=F.radialDistributionX(a,C,O,r);}I._attr={visibility:S,align:M.alignment};U=C.options.dataLabels||{};I._pos={x:N+t(U.x,g.x)+({left:b,right:-b}[M.alignment]||0),y:O+t(U.y,g.y)-I.getBBox().height/2};M&&(M.computed.x=N,M.computed.y=O);t(g.crop,!0)&&(L=I.getBBox().width,r=null,N-L<b&&1===k?(r=Math.round(L-N+b),z[3]=Math.max(r,z[3])):N+L>f-b&&0===k&&
    	(r=Math.round(N+L-f+b),z[1]=Math.max(r,z[1])),0>O-J/2?z[0]=Math.max(Math.round(-O+J/2),z[0]):O+J/2>c&&(z[2]=Math.max(Math.round(O+J/2-c),z[2])),I.sideOverflow=r);}}}),0===u(z)||this.verifyDataLabelOverflow(z))&&(this.placeDataLabels(),this.points.forEach(function(b){U=p(g,b.options.dataLabels);if(A=t(U.connectorWidth,1)){let c;E=b.connector;if((I=b.dataLabel)&&I._pos&&b.visible&&0<b.labelDistance){S=I._attr.visibility;if(c=!E)b.connector=E=e.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-"+
    	b.colorIndex+(b.className?" "+b.className:"")).add(a.dataLabelsGroup),e.styledMode||E.attr({"stroke-width":A,stroke:U.connectorColor||b.color||"#666666"});E[c?"attr":"animate"]({d:b.getConnectorPath()});E.attr("visibility",S);}else E&&(b.connector=E.destroy());}}));}function h(){this.points.forEach(function(a){let d=a.dataLabel,e;d&&a.visible&&((e=d._pos)?(d.sideOverflow&&(d._attr.width=Math.max(d.getBBox().width-d.sideOverflow,0),d.css({width:d._attr.width+"px",textOverflow:(this.options.dataLabels.style||
    	{}).textOverflow||"ellipsis"}),d.shortened=!0),d.attr(d._attr),d[d.moved?"animate":"attr"](e),d.moved=!0):d&&d.attr({y:-9999}));delete a.distributeBox;},this);}function y(a){let d=this.center,e=this.options,g=e.center,b=e.minSize||80,f,c=null!==e.size;c||(null!==g[0]?f=Math.max(d[2]-Math.max(a[1],a[3]),b):(f=Math.max(d[2]-a[1]-a[3],b),d[0]+=(a[3]-a[1])/2),null!==g[1]?f=v(f,b,d[2]-Math.max(a[0],a[2])):(f=v(f,b,d[2]-a[0]-a[2]),d[1]+=(a[0]-a[2])/2),f<d[2]?(d[2]=f,d[3]=Math.min(e.thickness?Math.max(0,f-
    	2*e.thickness):Math.max(0,m(e.innerSize||0,f)),f),this.translate(d),this.drawDataLabels&&this.drawDataLabels()):c=!0);return c}const z=[],d={radialDistributionY:function(a){return a.top+a.distributeBox.pos},radialDistributionX:function(a,d,e,g){return a.getX(e<d.top+2||e>d.bottom-2?g:e,d.half,d)},justify:function(a,d,e){return e[0]+(a.half?-1:1)*(d+a.labelDistance)},alignToPlotEdges:function(a,d,e,g){a=a.getBBox().width;return d?a+g:e-a-g},alignToConnectors:function(a,d,e,g){let b=0,f;a.forEach(function(a){f=
    	a.dataLabel.getBBox().width;f>b&&(b=f);});return d?b+g:e-b-g}};g.compose=function(g){a.compose(B);C.pushUnique(z,g)&&(g=g.prototype,g.dataLabelPositioners=d,g.alignDataLabel=x,g.drawDataLabels=e,g.placeDataLabels=h,g.verifyDataLabelOverflow=y);};})(h||(h={}));return h});M(a,"Extensions/OverlappingDataLabels.js",[a["Core/Chart/Chart.js"],a["Core/Utilities.js"]],function(a,y){function x(a,l){let p,t=!1;a&&(p=a.newOpacity,a.oldOpacity!==p&&(a.alignAttr&&a.placed?(a[p?"removeClass":"addClass"]("highcharts-data-label-hidden"),
    	t=!0,a.alignAttr.opacity=p,a[a.isOld?"animate":"attr"](a.alignAttr,null,function(){l.styledMode||a.css({pointerEvents:p?"auto":"none"});}),C(l,"afterHideOverlappingLabel")):a.attr({opacity:p})),a.isOld=!0);return t}const {addEvent:L,fireEvent:C,isArray:z,isNumber:H,objectEach:B,pick:u}=y;L(a,"render",function(){let a=this,l=[];(this.labelCollectors||[]).forEach(function(a){l=l.concat(a());});(this.yAxis||[]).forEach(function(a){a.stacking&&a.options.stackLabels&&!a.options.stackLabels.allowOverlap&&
    	B(a.stacking.stacks,function(a){B(a,function(a){a.label&&l.push(a.label);});});});(this.series||[]).forEach(function(p){var t=p.options.dataLabels;p.visible&&(!1!==t.enabled||p._hasPointLabels)&&(t=m=>m.forEach(h=>{h.visible&&(z(h.dataLabels)?h.dataLabels:h.dataLabel?[h.dataLabel]:[]).forEach(function(g){const e=g.options;g.labelrank=u(e.labelrank,h.labelrank,h.shapeArgs&&h.shapeArgs.height);e.allowOverlap?(g.oldOpacity=g.opacity,g.newOpacity=1,x(g,a)):l.push(g);});}),t(p.nodes||[]),t(p.points));});this.hideOverlappingLabels(l);});
    	a.prototype.hideOverlappingLabels=function(a){let l=this,p=a.length,t=l.renderer;var m;let h;let g,e,w,u=!1;var v=function(a){let d,e;var g;let h=a.box?0:a.padding||0,b=g=0,f,c;if(a&&(!a.alignAttr||a.placed))return d=a.alignAttr||{x:a.attr("x"),y:a.attr("y")},e=a.parentGroup,a.width||(g=a.getBBox(),a.width=g.width,a.height=g.height,g=t.fontMetrics(a.element).h),f=a.width-2*h,(c={left:"0",center:"0.5",right:"1"}[a.alignValue])?b=+c*f:H(a.x)&&Math.round(a.x)!==a.translateX&&(b=a.x-a.translateX),{x:d.x+
    	(e.translateX||0)+h-(b||0),y:d.y+(e.translateY||0)+h-g,width:a.width-2*h,height:a.height-2*h}};for(h=0;h<p;h++)if(m=a[h])m.oldOpacity=m.opacity,m.newOpacity=1,m.absoluteBox=v(m);a.sort(function(a,e){return (e.labelrank||0)-(a.labelrank||0)});for(h=0;h<p;h++)for(e=(v=a[h])&&v.absoluteBox,m=h+1;m<p;++m)w=(g=a[m])&&g.absoluteBox,!e||!w||v===g||0===v.newOpacity||0===g.newOpacity||"hidden"===v.visibility||"hidden"===g.visibility||w.x>=e.x+e.width||w.x+w.width<=e.x||w.y>=e.y+e.height||w.y+w.height<=e.y||
    	((v.labelrank<g.labelrank?v:g).newOpacity=0);a.forEach(function(a){x(a,l)&&(u=!0);});u&&C(l,"afterHideAllOverlappingLabels");};});M(a,"Extensions/BorderRadius.js",[a["Core/Defaults.js"],a["Core/Series/Series.js"],a["Core/Series/SeriesRegistry.js"],a["Core/Renderer/SVG/SVGElement.js"],a["Core/Renderer/SVG/SVGRenderer.js"],a["Core/Utilities.js"]],function(a,y,I,L,C,z){const {defaultOptions:x}=a;({seriesTypes:a}=I);const {addEvent:B,extend:u,isObject:v,merge:l,relativeLength:p}=z,t={radius:0,scope:"stack",
    	where:void 0},m=(a,g)=>{v(a)||(a={radius:a||0});return l(t,g,a)};if(-1===L.symbolCustomAttribs.indexOf("borderRadius")){L.symbolCustomAttribs.push("borderRadius","brBoxHeight","brBoxY");const h=C.prototype.symbols.arc;C.prototype.symbols.arc=function(a,g,l,m,d={}){a=h(a,g,l,m,d);const {innerR:e=0,r=l,start:q=0,end:t=0}=d;if(d.open||!d.borderRadius)return a;l=t-q;g=Math.sin(l/2);d=Math.max(Math.min(p(d.borderRadius||0,r-e),(r-e)/2,r*g/(1+g)),0);l=Math.min(d,l/Math.PI*2*e);for(g=a.length-1;g--;){{let e=
    	void 0,h=void 0,k=void 0;m=a;var b=g,f=1<g?l:d,c=m[b],n=m[b+1];"Z"===n[0]&&(n=m[0]);"M"!==c[0]&&"L"!==c[0]||"A"!==n[0]?"A"!==c[0]||"M"!==n[0]&&"L"!==n[0]||(k=n,h=c):(k=c,h=n,e=!0);if(k&&h&&h.params){c=h[1];var w=h[5];n=h.params;const {start:a,end:d,cx:g,cy:l}=n;var u=w?c-f:c+f;const p=u?Math.asin(f/u):0;w=w?p:-p;u*=Math.cos(p);e?(n.start=a+w,k[1]=g+u*Math.cos(a),k[2]=l+u*Math.sin(a),m.splice(b+1,0,["A",f,f,0,0,1,g+c*Math.cos(n.start),l+c*Math.sin(n.start)])):(n.end=d-w,h[6]=g+c*Math.cos(n.end),h[7]=
    	l+c*Math.sin(n.end),m.splice(b+1,0,["A",f,f,0,0,1,g+u*Math.cos(d),l+u*Math.sin(d)]));h[4]=Math.abs(n.end-n.start)<Math.PI?0:1;}}}return a};const g=C.prototype.symbols.roundedRect;C.prototype.symbols.roundedRect=function(a,h,l,m,d={}){const e=g(a,h,l,m,d),{r:p=0,brBoxHeight:q=m,brBoxY:t=h}=d;var b=h-t,f=t+q-(h+m);d=-.1<b-p?0:p;const c=-.1<f-p?0:p;var n=Math.max(d&&b,0);const u=Math.max(c&&f,0);f=[a+d,h];b=[a+l-d,h];const w=[a+l,h+d],v=[a+l,h+m-c],x=[a+l-c,h+m],y=[a+c,h+m],z=[a,h+m-c],B=[a,h+d];if(n){const a=
    	Math.sqrt(Math.pow(d,2)-Math.pow(d-n,2));f[0]-=a;b[0]+=a;w[1]=B[1]=h+d-n;}m<d-n&&(n=Math.sqrt(Math.pow(d,2)-Math.pow(d-n-m,2)),w[0]=v[0]=a+l-d+n,x[0]=Math.min(w[0],x[0]),y[0]=Math.max(v[0],y[0]),z[0]=B[0]=a+d-n,w[1]=B[1]=h+m);u&&(n=Math.sqrt(Math.pow(c,2)-Math.pow(c-u,2)),x[0]+=n,y[0]-=n,v[1]=z[1]=h+m-c+u);m<c-u&&(m=Math.sqrt(Math.pow(c,2)-Math.pow(c-u-m,2)),w[0]=v[0]=a+l-c+m,b[0]=Math.min(w[0],b[0]),f[0]=Math.max(v[0],f[0]),z[0]=B[0]=a+c-m,v[1]=z[1]=h);e.length=0;e.push(["M",...f],["L",...b],["A",
    	d,d,0,0,1,...w],["L",...v],["A",c,c,0,0,1,...x],["L",...y],["A",c,c,0,0,1,...z],["L",...B],["A",d,d,0,0,1,...f],["Z"]);return e};B(a.pie,"afterTranslate",function(){const a=m(this.options.borderRadius);for(const e of this.points){const g=e.shapeArgs;g&&(g.borderRadius=p(a.radius,(g.r||0)-(g.innerR||0)));}});B(y,"afterColumnTranslate",function(){var a,g;if(this.options.borderRadius&&(!this.chart.is3d||!this.chart.is3d())){const {options:e,yAxis:r}=this,q="percent"===e.stacking;var h=null===(g=null===
    	(a=x.plotOptions)||void 0===a?void 0:a[this.type])||void 0===g?void 0:g.borderRadius;a=m(e.borderRadius,v(h)?h:{});g=r.options.reversed;for(const k of this.points)if({shapeArgs:h}=k,"roundedRect"===k.shapeType&&h){const {width:b=0,height:f=0,y:c=0}=h;var l=c,d=f;"stack"===a.scope&&k.stackTotal&&(l=r.translate(q?100:k.stackTotal,!1,!0,!1,!0),d=r.translate(e.threshold||0,!1,!0,!1,!0),d=this.crispCol(0,Math.min(l,d),0,Math.abs(l-d)),l=d.y,d=d.height);const m=-1===(k.negative?-1:1)*(g?-1:1);let t=a.where;
    	!t&&this.is("waterfall")&&Math.abs((k.yBottom||0)-(this.translatedThreshold||0))>this.borderWidth&&(t="all");t||(t="end");const v=Math.min(p(a.radius,b),b/2,"all"===t?f/2:Infinity)||0;"end"===t&&(m&&(l-=v),d+=v);u(h,{brBoxHeight:d,brBoxY:l,r:v});}}},{order:9});}y={optionsToObject:m};return y});M(a,"Core/Responsive.js",[a["Core/Utilities.js"]],function(a){const {diffObjects:x,extend:I,find:L,merge:C,pick:z,uniqueKey:H}=a;var B;(function(u){function v(a,l){const h=a.condition;(h.callback||function(){return this.chartWidth<=
    	z(h.maxWidth,Number.MAX_VALUE)&&this.chartHeight<=z(h.maxHeight,Number.MAX_VALUE)&&this.chartWidth>=z(h.minWidth,0)&&this.chartHeight>=z(h.minHeight,0)}).call(this)&&l.push(a._id);}function l(a,l){const h=this.options.responsive;var g=this.currentResponsive;let e=[];!l&&h&&h.rules&&h.rules.forEach(a=>{"undefined"===typeof a._id&&(a._id=H());this.matchResponsiveRule(a,e);},this);l=C(...e.map(a=>L((h||{}).rules||[],e=>e._id===a)).map(a=>a&&a.chartOptions));l.isResponsiveOptions=!0;e=e.toString()||void 0;
    	e!==(g&&g.ruleIds)&&(g&&this.update(g.undoOptions,a,!0),e?(g=x(l,this.options,!0,this.collectionsWithUpdate),g.isResponsiveOptions=!0,this.currentResponsive={ruleIds:e,mergedOptions:l,undoOptions:g},this.update(l,a,!0)):this.currentResponsive=void 0);}const p=[];u.compose=function(t){a.pushUnique(p,t)&&I(t.prototype,{matchResponsiveRule:v,setResponsive:l});return t};})(B||(B={}));return B});M(a,"masters/highcharts.src.js",[a["Core/Globals.js"],a["Core/Utilities.js"],a["Core/Defaults.js"],a["Core/Animation/Fx.js"],
    	a["Core/Animation/AnimationUtilities.js"],a["Core/Renderer/HTML/AST.js"],a["Core/Templating.js"],a["Core/Renderer/RendererUtilities.js"],a["Core/Renderer/SVG/SVGElement.js"],a["Core/Renderer/SVG/SVGRenderer.js"],a["Core/Renderer/HTML/HTMLElement.js"],a["Core/Renderer/HTML/HTMLRenderer.js"],a["Core/Axis/Axis.js"],a["Core/Axis/DateTimeAxis.js"],a["Core/Axis/LogarithmicAxis.js"],a["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"],a["Core/Axis/Tick.js"],a["Core/Tooltip.js"],a["Core/Series/Point.js"],a["Core/Pointer.js"],
    	a["Core/Legend/Legend.js"],a["Core/Chart/Chart.js"],a["Core/Axis/Stacking/StackingAxis.js"],a["Core/Axis/Stacking/StackItem.js"],a["Core/Series/Series.js"],a["Core/Series/SeriesRegistry.js"],a["Series/Column/ColumnSeries.js"],a["Series/Column/ColumnDataLabel.js"],a["Series/Pie/PieSeries.js"],a["Series/Pie/PieDataLabel.js"],a["Core/Series/DataLabel.js"],a["Core/Responsive.js"],a["Core/Color/Color.js"],a["Core/Time.js"]],function(a,y,I,L,C,z,H,B,u,v,l,p,t,m,h,g,e,w,E,F,d,k,r,q,G,b,f,c,n,M,D,K,U,T){a.animate=
    	C.animate;a.animObject=C.animObject;a.getDeferredAnimation=C.getDeferredAnimation;a.setAnimation=C.setAnimation;a.stop=C.stop;a.timers=L.timers;a.AST=z;a.Axis=t;a.Chart=k;a.chart=k.chart;a.Fx=L;a.Legend=d;a.PlotLineOrBand=g;a.Point=E;a.Pointer=F;a.Series=G;a.StackItem=q;a.SVGElement=u;a.SVGRenderer=v;a.Templating=H;a.Tick=e;a.Time=T;a.Tooltip=w;a.Color=U;a.color=U.parse;p.compose(v);l.compose(u);F.compose(k);d.compose(k);a.defaultOptions=I.defaultOptions;a.getOptions=I.getOptions;a.time=I.defaultTime;
    	a.setOptions=I.setOptions;a.dateFormat=H.dateFormat;a.format=H.format;a.numberFormat=H.numberFormat;a.addEvent=y.addEvent;a.arrayMax=y.arrayMax;a.arrayMin=y.arrayMin;a.attr=y.attr;a.clearTimeout=y.clearTimeout;a.correctFloat=y.correctFloat;a.createElement=y.createElement;a.css=y.css;a.defined=y.defined;a.destroyObjectProperties=y.destroyObjectProperties;a.discardElement=y.discardElement;a.distribute=B.distribute;a.erase=y.erase;a.error=y.error;a.extend=y.extend;a.extendClass=y.extendClass;a.find=
    	y.find;a.fireEvent=y.fireEvent;a.getMagnitude=y.getMagnitude;a.getStyle=y.getStyle;a.inArray=y.inArray;a.isArray=y.isArray;a.isClass=y.isClass;a.isDOMElement=y.isDOMElement;a.isFunction=y.isFunction;a.isNumber=y.isNumber;a.isObject=y.isObject;a.isString=y.isString;a.keys=y.keys;a.merge=y.merge;a.normalizeTickInterval=y.normalizeTickInterval;a.objectEach=y.objectEach;a.offset=y.offset;a.pad=y.pad;a.pick=y.pick;a.pInt=y.pInt;a.relativeLength=y.relativeLength;a.removeEvent=y.removeEvent;a.seriesType=
    	b.seriesType;a.splat=y.splat;a.stableSort=y.stableSort;a.syncTimeout=y.syncTimeout;a.timeUnits=y.timeUnits;a.uniqueKey=y.uniqueKey;a.useSerialIds=y.useSerialIds;a.wrap=y.wrap;c.compose(f);D.compose(G);m.compose(t);h.compose(t);M.compose(n);g.compose(t);K.compose(k);r.compose(t,k,G);w.compose(F);return a});a["masters/highcharts.src.js"]._modules=a;return a["masters/highcharts.src.js"]});
    	
    } (highcharts));

    let chart;
    let currentChannel;

    window.addEventListener('load', function() {
      chart = highchartsExports.chart('container', {
          chart: {
            type: 'column',
            events: {
              load: requestData
            }
          },
          title: {
            text: 'Monthly Sales Data'
          },
          yAxis: {
            minPadding: 0.2,
            maxPadding: 0.2,
            title: {
              text: 'Value',
              margin: 80,
            }
          },
          xAxis: {
            categories: ['Jan','Feb','March','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],
          },
          series: [{
            name: 'Buy',
            data: [] 
          }, {
            name: 'Sell',
            data: []
          }]
      });
    });

    async function requestData() {
      (async () => {
        currentChannel = await window.fdc3.getCurrentChannel();
      
        if(!currentChannel) {
          await window.fdc3.joinUserChannel("default");
        }

        await window.fdc3.addContextListener('fdc3.instrument', (context, metadata) => {
          if(context.id) {
            chart.setTitle({ text: "Monthly sales for " + context.id.ticker });
            chart.series[0].setData([]);
            chart.series[1].setData([]);

            context.id.buyData.forEach(function (p) {
              chart.series[0].addPoint(p, false);
            });
          
            context.id.sellData.forEach(function (p) {
              chart.series[1].addPoint(p, false);
            });

            chart.redraw();
          }
        });
      })();
    }

})();
